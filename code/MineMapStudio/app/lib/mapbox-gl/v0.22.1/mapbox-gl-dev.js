(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.mapboxgl = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var util = require('../util/util');

module.exports = ArrayGroup;

/**
 * A class that manages vertex and element arrays for a range of features. It handles initialization,
 * serialization for transfer to the main thread, and certain intervening mutations.
 *
 * Array elements are broken into array groups based on inherent limits of WebGL. Within a group is:
 *
 * * A "layout" vertex array, with fixed layout, containing values calculated from layout properties.
 * * Zero, one, or two element arrays, with fixed layout, typically for eventual use in
 *   `gl.drawElements(gl.TRIANGLES, ...)`.
 * * Zero or more "paint" vertex arrays keyed by layer ID, each with a dynamic layout which depends
 *   on which paint properties of that layer use data-driven-functions (property functions or
 *   property-and-zoom functions). Values are calculated by evaluating those functions.
 *
 * @private
 */
function ArrayGroup(arrayTypes) {
    var LayoutVertexArrayType = arrayTypes.layoutVertexArrayType;
    this.layoutVertexArray = new LayoutVertexArrayType();

    var ElementArrayType = arrayTypes.elementArrayType;
    if (ElementArrayType) this.elementArray = new ElementArrayType();

    var ElementArrayType2 = arrayTypes.elementArrayType2;
    if (ElementArrayType2) this.elementArray2 = new ElementArrayType2();

    this.paintVertexArrays = util.mapObject(arrayTypes.paintVertexArrayTypes, function (PaintVertexArrayType) {
        return new PaintVertexArrayType();
    });
}

/**
 * The maximum size of a vertex array. This limit is imposed by WebGL's 16 bit
 * addressing of vertex buffers.
 * @private
 * @readonly
 */
ArrayGroup.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1;

ArrayGroup.prototype.hasCapacityFor = function(numVertices) {
    return this.layoutVertexArray.length + numVertices <= ArrayGroup.MAX_VERTEX_ARRAY_LENGTH;
};

ArrayGroup.prototype.isEmpty = function() {
    return this.layoutVertexArray.length === 0;
};

ArrayGroup.prototype.trim = function() {
    this.layoutVertexArray.trim();

    if (this.elementArray) {
        this.elementArray.trim();
    }

    if (this.elementArray2) {
        this.elementArray2.trim();
    }

    for (var layerName in this.paintVertexArrays) {
        this.paintVertexArrays[layerName].trim();
    }
};

ArrayGroup.prototype.serialize = function() {
    return {
        layoutVertexArray: this.layoutVertexArray.serialize(),
        elementArray: this.elementArray && this.elementArray.serialize(),
        elementArray2: this.elementArray2 && this.elementArray2.serialize(),
        paintVertexArrays: util.mapObject(this.paintVertexArrays, function(array) {
            return array.serialize();
        })
    };
};

ArrayGroup.prototype.getTransferables = function(transferables) {
    transferables.push(this.layoutVertexArray.arrayBuffer);

    if (this.elementArray) {
        transferables.push(this.elementArray.arrayBuffer);
    }

    if (this.elementArray2) {
        transferables.push(this.elementArray2.arrayBuffer);
    }

    for (var layerName in this.paintVertexArrays) {
        transferables.push(this.paintVertexArrays[layerName].arrayBuffer);
    }
};

},{"../util/util":120}],2:[function(require,module,exports){
'use strict';

var featureFilter = require('feature-filter');
var ArrayGroup = require('./array_group');
var BufferGroup = require('./buffer_group');
var util = require('../util/util');
var StructArrayType = require('../util/struct_array');
var assert = require('assert');

module.exports = Bucket;

/**
 * Instantiate the appropriate subclass of `Bucket` for `options`.
 * @private
 * @param options See `Bucket` constructor options
 * @returns {Bucket}
 */
Bucket.create = function(options) {
    var Classes = {
        fill: require('./bucket/fill_bucket'),
        line: require('./bucket/line_bucket'),
        circle: require('./bucket/circle_bucket'),
        symbol: require('./bucket/symbol_bucket'),
        extrusion: require('./bucket/extrusion_bucket')
    };
    return new Classes[options.layer.type](options);
};


/**
 * The maximum extent of a feature that can be safely stored in the buffer.
 * In practice, all features are converted to this extent before being added.
 *
 * Positions are stored as signed 16bit integers.
 * One bit is lost for signedness to support featuers extending past the left edge of the tile.
 * One bit is lost because the line vertex buffer packs 1 bit of other data into the int.
 * One bit is lost to support features extending past the extent on the right edge of the tile.
 * This leaves us with 2^13 = 8192
 *
 * @private
 * @readonly
 */
Bucket.EXTENT = 8192;

/**
 * The `Bucket` class is the single point of knowledge about turning vector
 * tiles into WebGL buffers.
 *
 * `Bucket` is an abstract class. A subclass exists for each Mapbox GL
 * style spec layer type. Because `Bucket` is an abstract class,
 * instances should be created via the `Bucket.create` method.
 *
 * @class Bucket
 * @private
 * @param options
 * @param {number} options.zoom Zoom level of the buffers being built. May be
 *     a fractional zoom level.
 * @param options.layer A Mapbox style layer object
 * @param {Object.<string, Buffer>} options.buffers The set of `Buffer`s being
 *     built for this tile. This object facilitates sharing of `Buffer`s be
       between `Bucket`s.
 */
function Bucket(options) {
    this.zoom = options.zoom;
    this.overscaling = options.overscaling;
    this.layer = options.layer;
    this.childLayers = options.childLayers;

    this.type = this.layer.type;
    this.features = [];
    this.id = this.layer.id;
    this.index = options.index;
    this.sourceLayer = this.layer.sourceLayer;
    this.sourceLayerIndex = options.sourceLayerIndex;
    this.minZoom = this.layer.minzoom;
    this.maxZoom = this.layer.maxzoom;

    this.paintAttributes = createPaintAttributes(this);

    if (options.arrays) {
        var programInterfaces = this.programInterfaces;
        this.bufferGroups = util.mapObject(options.arrays, function(programArrayGroups, programName) {
            var programInterface = programInterfaces[programName];
            var paintVertexArrayTypes = options.paintVertexArrayTypes[programName];
            return programArrayGroups.map(function(arrayGroup) {
                return new BufferGroup(arrayGroup, {
                    layoutVertexArrayType: programInterface.layoutVertexArrayType.serialize(),
                    elementArrayType: programInterface.elementArrayType && programInterface.elementArrayType.serialize(),
                    elementArrayType2: programInterface.elementArrayType2 && programInterface.elementArrayType2.serialize(),
                    paintVertexArrayTypes: paintVertexArrayTypes
                });
            });
        });
    }
}

/**
 * Build the arrays! Features are set directly to the `features` property.
 * @private
 */
Bucket.prototype.populateArrays = function() {
    this.createArrays();
    this.recalculateStyleLayers();

    for (var i = 0; i < this.features.length; i++) {
        this.addFeature(this.features[i]);
    }

    this.trimArrays();
};

/**
 * Check if there is enough space available in the current array group for
 * `vertexLength` vertices. If not, append a new array group. Should be called
 * by `populateArrays` and its callees.
 *
 * Array groups are added to this.arrayGroups[programName].
 *
 * @private
 * @param {string} programName the name of the program associated with the buffer that will receive the vertices
 * @param {number} vertexLength The number of vertices that will be inserted to the buffer.
 * @returns The current array group
 */
Bucket.prototype.prepareArrayGroup = function(programName, numVertices) {
    var groups = this.arrayGroups[programName];
    var currentGroup = groups.length && groups[groups.length - 1];

    if (!currentGroup || !currentGroup.hasCapacityFor(numVertices)) {
        currentGroup = new ArrayGroup({
            layoutVertexArrayType: this.programInterfaces[programName].layoutVertexArrayType,
            elementArrayType: this.programInterfaces[programName].elementArrayType,
            elementArrayType2: this.programInterfaces[programName].elementArrayType2,
            paintVertexArrayTypes: this.paintVertexArrayTypes[programName]
        });

        currentGroup.index = groups.length;

        groups.push(currentGroup);
    }

    return currentGroup;
};

/**
 * Sets up `this.paintVertexArrayTypes` as { [programName]: { [layerName]: PaintArrayType, ... }, ... }
 *
 * And `this.arrayGroups` as { [programName]: [], ... }; these get populated
 * with array group structure over in `prepareArrayGroup`.
 *
 * @private
 */
Bucket.prototype.createArrays = function() {
    this.arrayGroups = {};
    this.paintVertexArrayTypes = {};

    for (var programName in this.programInterfaces) {
        this.arrayGroups[programName] = [];

        var paintVertexArrayTypes = this.paintVertexArrayTypes[programName] = {};
        var layerPaintAttributes = this.paintAttributes[programName];

        for (var layerName in layerPaintAttributes) {
            paintVertexArrayTypes[layerName] = new Bucket.VertexArrayType(layerPaintAttributes[layerName].attributes);
        }
    }
};

Bucket.prototype.destroy = function(gl) {
    for (var programName in this.bufferGroups) {
        var programBufferGroups = this.bufferGroups[programName];
        for (var i = 0; i < programBufferGroups.length; i++) {
            programBufferGroups[i].destroy(gl);
        }
    }
};

Bucket.prototype.trimArrays = function() {
    for (var programName in this.arrayGroups) {
        var arrayGroups = this.arrayGroups[programName];
        for (var i = 0; i < arrayGroups.length; i++) {
            arrayGroups[i].trim();
        }
    }
};

Bucket.prototype.isEmpty = function() {
    for (var programName in this.arrayGroups) {
        var arrayGroups = this.arrayGroups[programName];
        for (var i = 0; i < arrayGroups.length; i++) {
            if (!arrayGroups[i].isEmpty()) {
                return false;
            }
        }
    }
    return true;
};

Bucket.prototype.getTransferables = function(transferables) {
    for (var programName in this.arrayGroups) {
        var arrayGroups = this.arrayGroups[programName];
        for (var i = 0; i < arrayGroups.length; i++) {
            arrayGroups[i].getTransferables(transferables);
        }
    }
};

Bucket.prototype.setUniforms = function(gl, programName, program, layer, globalProperties) {
    var uniforms = this.paintAttributes[programName][layer.id].uniforms;
    for (var i = 0; i < uniforms.length; i++) {
        var uniform = uniforms[i];
        var uniformLocation = program[uniform.name];
        gl['uniform' + uniform.components + 'fv'](uniformLocation, uniform.getValue(layer, globalProperties));
    }
};

Bucket.prototype.serialize = function() {
    return {
        layerId: this.layer.id,
        zoom: this.zoom,
        arrays: util.mapObject(this.arrayGroups, function(programArrayGroups) {
            return programArrayGroups.map(function(arrayGroup) {
                return arrayGroup.serialize();
            });
        }),
        paintVertexArrayTypes: util.mapObject(this.paintVertexArrayTypes, function(arrayTypes) {
            return util.mapObject(arrayTypes, function(arrayType) {
                return arrayType.serialize();
            });
        }),

        childLayerIds: this.childLayers.map(function(layer) {
            return layer.id;
        })
    };
};

Bucket.prototype.createFilter = function() {
    if (!this.filter) {
        this.filter = featureFilter(this.layer.filter);
    }
};

var FAKE_ZOOM_HISTORY = { lastIntegerZoom: Infinity, lastIntegerZoomTime: 0, lastZoom: 0 };
Bucket.prototype.recalculateStyleLayers = function() {
    for (var i = 0; i < this.childLayers.length; i++) {
        this.childLayers[i].recalculate(this.zoom, FAKE_ZOOM_HISTORY);
    }
};

Bucket.prototype.populatePaintArrays = function(interfaceName, globalProperties, featureProperties, startGroup, startIndex) {
    for (var l = 0; l < this.childLayers.length; l++) {
        var layer = this.childLayers[l];
        var groups = this.arrayGroups[interfaceName];
        for (var g = startGroup.index; g < groups.length; g++) {
            var group = groups[g];
            var length = group.layoutVertexArray.length;
            var paintArray = group.paintVertexArrays[layer.id];
            paintArray.resize(length);

            var attributes = this.paintAttributes[interfaceName][layer.id].attributes;
            for (var m = 0; m < attributes.length; m++) {
                var attribute = attributes[m];

                var value = attribute.getValue(layer, globalProperties, featureProperties);

                var multiplier = attribute.multiplier || 1;
                var components = attribute.components || 1;

                var start = g === startGroup.index  ? startIndex : 0;
                for (var i = start; i < length; i++) {
                    var vertex = paintArray.get(i);
                    for (var c = 0; c < components; c++) {
                        var memberName = components > 1 ? (attribute.name + c) : attribute.name;
                        vertex[memberName] = value[c] * multiplier;
                    }
                }
            }
        }
    }
};

/**
 * A vertex array stores data for each vertex in a geometry. Elements are aligned to 4 byte
 * boundaries for best performance in WebGL.
 * @private
 */
Bucket.VertexArrayType = function (members) {
    return new StructArrayType({
        members: members,
        alignment: 4
    });
};

/**
 * An element array stores Uint16 indicies of vertexes in a corresponding vertex array. With no
 * arguments, it defaults to three components per element, forming triangles.
 * @private
 */
Bucket.ElementArrayType = function (components) {
    return new StructArrayType({
        members: [{
            type: 'Uint16',
            name: 'vertices',
            components: components || 3
        }]
    });
};

function createPaintAttributes(bucket) {
    var attributes = {};
    for (var interfaceName in bucket.programInterfaces) {
        var layerPaintAttributes = attributes[interfaceName] = {};

        for (var c = 0; c < bucket.childLayers.length; c++) {
            var childLayer = bucket.childLayers[c];

            layerPaintAttributes[childLayer.id] = {
                attributes: [],
                uniforms: [],
                defines: [],
                vertexPragmas: { define: {}, initialize: {} },
                fragmentPragmas: { define: {}, initialize: {} }
            };
        }

        var interface_ = bucket.programInterfaces[interfaceName];
        if (!interface_.paintAttributes) continue;

        // These tokens are replaced by arguments to the pragma
        // https://github.com/mapbox/mapbox-gl-shaders#pragmas
        var attributePrecision = '{precision}';
        var attributeType = '{type}';

        for (var i = 0; i < interface_.paintAttributes.length; i++) {
            var attribute = interface_.paintAttributes[i];
            attribute.multiplier = attribute.multiplier || 1;

            for (var j = 0; j < bucket.childLayers.length; j++) {
                var layer = bucket.childLayers[j];
                var paintAttributes = layerPaintAttributes[layer.id];

                var attributeInputName = attribute.name;
                assert(attribute.name.slice(0, 2) === 'a_');
                var attributeInnerName = attribute.name.slice(2);
                var attributeVaryingDefinition;

                paintAttributes.fragmentPragmas.initialize[attributeInnerName] = '';

                if (layer.isPaintValueFeatureConstant(attribute.paintProperty)) {
                    paintAttributes.uniforms.push(attribute);

                    paintAttributes.fragmentPragmas.define[attributeInnerName] = paintAttributes.vertexPragmas.define[attributeInnerName] = [
                        'uniform',
                        attributePrecision,
                        attributeType,
                        attributeInputName
                    ].join(' ') + ';';

                    paintAttributes.fragmentPragmas.initialize[attributeInnerName] = paintAttributes.vertexPragmas.initialize[attributeInnerName] = [
                        attributePrecision,
                        attributeType,
                        attributeInnerName,
                        '=',
                        attributeInputName
                    ].join(' ') + ';\n';

                } else if (layer.isPaintValueZoomConstant(attribute.paintProperty)) {
                    paintAttributes.attributes.push(util.extend({}, attribute, {
                        name: attributeInputName
                    }));

                    attributeVaryingDefinition = [
                        'varying',
                        attributePrecision,
                        attributeType,
                        attributeInnerName
                    ].join(' ') + ';\n';

                    var attributeAttributeDefinition = [
                        paintAttributes.fragmentPragmas.define[attributeInnerName],
                        'attribute',
                        attributePrecision,
                        attributeType,
                        attributeInputName
                    ].join(' ') + ';\n';

                    paintAttributes.fragmentPragmas.define[attributeInnerName] = attributeVaryingDefinition;

                    paintAttributes.vertexPragmas.define[attributeInnerName] = attributeVaryingDefinition + attributeAttributeDefinition;

                    paintAttributes.vertexPragmas.initialize[attributeInnerName] = [
                        attributeInnerName,
                        '=',
                        attributeInputName,
                        '/',
                        attribute.multiplier.toFixed(1)
                    ].join(' ') + ';\n';

                } else {

                    var tName = 'u_' + attributeInputName.slice(2) + '_t';
                    var zoomLevels = layer.getPaintValueStopZoomLevels(attribute.paintProperty);

                    // Pick the index of the first offset to add to the buffers.
                    // Find the four closest stops, ideally with two on each side of the zoom level.
                    var numStops = 0;
                    while (numStops < zoomLevels.length && zoomLevels[numStops] < bucket.zoom) numStops++;
                    var stopOffset = Math.max(0, Math.min(zoomLevels.length - 4, numStops - 2));

                    var fourZoomLevels = [];
                    for (var s = 0; s < 4; s++) {
                        fourZoomLevels.push(zoomLevels[Math.min(stopOffset + s, zoomLevels.length - 1)]);
                    }

                    attributeVaryingDefinition = [
                        'varying',
                        attributePrecision,
                        attributeType,
                        attributeInnerName
                    ].join(' ') + ';\n';

                    paintAttributes.vertexPragmas.define[attributeInnerName] = attributeVaryingDefinition + [
                        'uniform',
                        'lowp',
                        'float',
                        tName
                    ].join(' ') + ';\n';
                    paintAttributes.fragmentPragmas.define[attributeInnerName] = attributeVaryingDefinition;

                    paintAttributes.uniforms.push(util.extend({}, attribute, {
                        name: tName,
                        getValue: createGetUniform(attribute, stopOffset),
                        components: 1
                    }));

                    var components = attribute.components;
                    if (components === 1) {

                        paintAttributes.attributes.push(util.extend({}, attribute, {
                            getValue: createFunctionGetValue(attribute, fourZoomLevels),
                            isFunction: true,
                            components: components * 4
                        }));

                        paintAttributes.vertexPragmas.define[attributeInnerName] += [
                            'attribute',
                            attributePrecision,
                            'vec4',
                            attributeInputName
                        ].join(' ') + ';\n';

                        paintAttributes.vertexPragmas.initialize[attributeInnerName] = [
                            attributeInnerName,
                            '=',
                            'evaluate_zoom_function_1(' + attributeInputName + ', ' + tName + ')',
                            '/',
                            attribute.multiplier.toFixed(1)
                        ].join(' ') + ';\n';

                    } else {

                        var attributeInputNames = [];
                        for (var k = 0; k < 4; k++) {
                            attributeInputNames.push(attributeInputName + k);
                            paintAttributes.attributes.push(util.extend({}, attribute, {
                                getValue: createFunctionGetValue(attribute, [fourZoomLevels[k]]),
                                isFunction: true,
                                name: attributeInputName + k
                            }));
                            paintAttributes.vertexPragmas.define[attributeInnerName] += [
                                'attribute',
                                attributePrecision,
                                attributeType,
                                attributeInputName + k
                            ].join(' ') + ';\n';
                        }
                        paintAttributes.vertexPragmas.initialize[attributeInnerName] = [
                            attributeInnerName,
                            ' = ',
                            'evaluate_zoom_function_4(' + attributeInputNames.join(', ') + ', ' + tName + ')',
                            '/',
                            attribute.multiplier.toFixed(1)
                        ].join(' ') + ';\n';
                    }
                }
            }
        }
    }
    return attributes;
}

function createFunctionGetValue(attribute, stopZoomLevels) {
    return function(layer, globalProperties, featureProperties) {
        if (stopZoomLevels.length === 1) {
            // return one multi-component value like color0
            return attribute.getValue(layer, util.extend({}, globalProperties, { zoom: stopZoomLevels[0] }), featureProperties);
        } else {
            // pack multiple single-component values into a four component attribute
            var values = [];
            for (var z = 0; z < stopZoomLevels.length; z++) {
                var stopZoomLevel = stopZoomLevels[z];
                values.push(attribute.getValue(layer, util.extend({}, globalProperties, { zoom: stopZoomLevel }), featureProperties)[0]);
            }
            return values;
        }
    };
}

function createGetUniform(attribute, stopOffset) {
    return function(layer, globalProperties) {
        // stopInterp indicates which stops need to be interpolated.
        // If stopInterp is 3.5 then interpolate half way between stops 3 and 4.
        var stopInterp = layer.getPaintInterpolationT(attribute.paintProperty, globalProperties.zoom);
        // We can only store four stop values in the buffers. stopOffset is the number of stops that come
        // before the stops that were added to the buffers.
        return [Math.max(0, Math.min(4, stopInterp - stopOffset))];
    };
}

},{"../util/struct_array":118,"../util/util":120,"./array_group":1,"./bucket/circle_bucket":3,"./bucket/extrusion_bucket":4,"./bucket/fill_bucket":5,"./bucket/line_bucket":6,"./bucket/symbol_bucket":7,"./buffer_group":9,"assert":122,"feature-filter":136}],3:[function(require,module,exports){
'use strict';

var Bucket = require('../bucket');
var util = require('../../util/util');
var loadGeometry = require('../load_geometry');
var EXTENT = Bucket.EXTENT;

module.exports = CircleBucket;

/**
 * Circles are represented by two triangles.
 *
 * Each corner has a pos that is the center of the circle and an extrusion
 * vector that is where it points.
 * @private
 */
function CircleBucket() {
    Bucket.apply(this, arguments);
}

CircleBucket.prototype = util.inherit(Bucket, {});

CircleBucket.prototype.addCircleVertex = function(layoutVertexArray, x, y, extrudeX, extrudeY) {
    return layoutVertexArray.emplaceBack(
            (x * 2) + ((extrudeX + 1) / 2),
            (y * 2) + ((extrudeY + 1) / 2));
};

CircleBucket.prototype.programInterfaces = {
    circle: {
        layoutVertexArrayType: new Bucket.VertexArrayType([{
            name: 'a_pos',
            components: 2,
            type: 'Int16'
        }]),
        elementArrayType: new Bucket.ElementArrayType(),

        paintAttributes: [{
            name: 'a_color',
            components: 4,
            type: 'Uint8',
            getValue: function(layer, globalProperties, featureProperties) {
                return layer.getPaintValue("circle-color", globalProperties, featureProperties);
            },
            multiplier: 255,
            paintProperty: 'circle-color'
        }, {
            name: 'a_radius',
            components: 1,
            type: 'Uint16',
            isLayerConstant: false,
            getValue: function(layer, globalProperties, featureProperties) {
                return [layer.getPaintValue("circle-radius", globalProperties, featureProperties)];
            },
            multiplier: 10,
            paintProperty: 'circle-radius'
        }, {
            name: 'a_blur',
            components: 1,
            type: 'Uint16',
            isLayerConstant: false,
            getValue: function(layer, globalProperties, featureProperties) {
                return [layer.getPaintValue("circle-blur", globalProperties, featureProperties)];
            },
            multiplier: 10,
            paintProperty: 'circle-blur'
        }, {
            name: 'a_opacity',
            components: 1,
            type: 'Uint16',
            isLayerConstant: false,
            getValue: function(layer, globalProperties, featureProperties) {
                return [layer.getPaintValue("circle-opacity", globalProperties, featureProperties)];
            },
            multiplier: 255,
            paintProperty: 'circle-opacity'
        }]
    }
};

CircleBucket.prototype.addFeature = function(feature) {
    var globalProperties = {zoom: this.zoom};
    var geometries = loadGeometry(feature);

    var startGroup = this.prepareArrayGroup('circle', 0);
    var startIndex = startGroup.layoutVertexArray.length;

    for (var j = 0; j < geometries.length; j++) {
        for (var k = 0; k < geometries[j].length; k++) {

            var x = geometries[j][k].x;
            var y = geometries[j][k].y;

            // Do not include points that are outside the tile boundaries.
            if (x < 0 || x >= EXTENT || y < 0 || y >= EXTENT) continue;

            // this geometry will be of the Point type, and we'll derive
            // two triangles from it.
            //
            // ┌─────────┐
            // │ 3     2 │
            // │         │
            // │ 0     1 │
            // └─────────┘

            var group = this.prepareArrayGroup('circle', 4);
            var layoutVertexArray = group.layoutVertexArray;

            var index = this.addCircleVertex(layoutVertexArray, x, y, -1, -1);
            this.addCircleVertex(layoutVertexArray, x, y, 1, -1);
            this.addCircleVertex(layoutVertexArray, x, y, 1, 1);
            this.addCircleVertex(layoutVertexArray, x, y, -1, 1);

            group.elementArray.emplaceBack(index, index + 1, index + 2);
            group.elementArray.emplaceBack(index, index + 3, index + 2);
        }
    }

    this.populatePaintArrays('circle', globalProperties, feature.properties, startGroup, startIndex);
};

},{"../../util/util":120,"../bucket":2,"../load_geometry":11}],4:[function(require,module,exports){
'use strict';

var Bucket = require('../bucket');
var util = require('../../util/util');
var loadGeometry = require('../load_geometry');
var earcut = require('earcut');
var classifyRings = require('../../util/classify_rings');
var Point = require('point-geometry');
var EARCUT_MAX_RINGS = 500;

module.exports = ExtrusionBucket;

function ExtrusionBucket() {
    Bucket.apply(this, arguments);
}

ExtrusionBucket.prototype = util.inherit(Bucket, {});


ExtrusionBucket.prototype.addExtrusionVertex = function(vertexBuffer, x, y,h, nx, ny, nz, t, e) {
    var factor = Math.pow(2, 13);

    return vertexBuffer.emplaceBack(
            // a_pos
            x,
            y,
            h,
            // a_normal
            Math.floor(nx * factor) * 2 + t,
            ny * factor * 2,
            nz * factor * 2,

            // a_edgedistance
            e
            );
};

ExtrusionBucket.prototype.programInterfaces = {
    extrusion: {
        layoutVertexArrayType: new Bucket.VertexArrayType([{
            name: 'a_pos',
            components: 3,
            type: 'Int16'
        }, {
            name: 'a_normal',
            components: 3,
            type: 'Int16'
        }, {
            name: 'a_edgedistance',
            components: 1,
            type: 'Int16'
        }]),
        elementArrayType: new Bucket.ElementArrayType(3),
        elementArrayType2: new Bucket.ElementArrayType(2),

        paintAttributes: [{
            name: 'a_minH',
            components: 1,
            type: 'Uint16',
            isLayerConstant: false, // what is this
            getValue: function(layer, globalProperties, featureProperties) {
                return [layer.getPaintValue("extrusion-min-height", globalProperties, featureProperties)];
            },
            multiplier: 1,
            paintProperty: 'extrusion-min-height'
        }, {
            name: 'a_maxH',
            components: 1,
            type: 'Uint16',
            isLayerConstant: false, // what is this
            getValue: function(layer, globalProperties, featureProperties) {
                return [layer.getPaintValue("extrusion-height", globalProperties, featureProperties)];
            },
            multiplier: 1,
            paintProperty: 'extrusion-height'
        }, {
            name: 'a_color',
            components: 4,
            type: 'Uint8',
            getValue: function(layer, globalProperties, featureProperties) {
                return layer.getPaintValue("extrusion-color", globalProperties, featureProperties);
            },
            multiplier: 255,
            paintProperty: 'extrusion-color'
        }]
    }
};

ExtrusionBucket.prototype.addFeature = function(feature) {
    var lines = loadGeometry(feature);
    var polygons = convertCoords(classifyRings(lines, EARCUT_MAX_RINGS));
    for (var i = 0; i < polygons.length; i++) {
        this.addPolygon(polygons[i], feature);
    }
};

ExtrusionBucket.prototype.addPolygon = function(polygon, feature) {
    var numVertices = 0;
    for (var k = 0; k < polygon.length; k++) {
        numVertices += polygon[k].length;
    }

    var group = this.prepareArrayGroup('extrusion', numVertices);
    var flattened = [];
    var holeIndices = [];
    var startIndex = group.layoutVertexArray.length;

    var h = feature.properties.levels?feature.properties.levels*3:-1.0;

    var indices = [];

    for (var r = 0; r < polygon.length; r++) {
        var ring = polygon[r];

        if (r > 0) holeIndices.push(flattened.length / 2);

        // add vertices from the roof
        for (var v = 0; v < ring.length; v++) {
            var vertex = ring[v];

            var topIndex = this.addExtrusionVertex(group.layoutVertexArray, vertex[0], vertex[1], h, 0, 0, 1, 1, 0);
            indices.push(topIndex);

            if (v >= 1) {
                group.elementArray2.emplaceBack(topIndex-1, topIndex);
            }

            // convert to format used by earcut
            flattened.push(vertex[0]);
            flattened.push(vertex[1]);
        }

        var edgeDistance = 0;

        for (var s = 0; s < ring.length - 1; s++) {
            var v1 = ring[s];
            var v2 = ring[s + 1];
            var perp = Point.convert(v2)._sub(Point.convert(v1))._perp()._unit();

            var vertexArray = group.layoutVertexArray;
            var wIndex = this.addExtrusionVertex(vertexArray, v1[0], v1[1], 0, perp.x, perp.y, 0, 0, edgeDistance);
            this.addExtrusionVertex(vertexArray, v1[0], v1[1], h, perp.x, perp.y, 0, 1, edgeDistance);

            edgeDistance += Point.convert(v2).dist(Point.convert(v1));

            this.addExtrusionVertex(vertexArray, v2[0], v2[1], 0, perp.x, perp.y, 0, 0, edgeDistance);
            this.addExtrusionVertex(vertexArray, v2[0], v2[1], h, perp.x, perp.y, 0, 1, edgeDistance);

            group.elementArray.emplaceBack(wIndex, wIndex + 1, wIndex + 2);
            group.elementArray.emplaceBack(wIndex + 1, wIndex + 2, wIndex + 3);

            group.elementArray2.emplaceBack(wIndex, wIndex + 1);
            group.elementArray2.emplaceBack(wIndex + 2, wIndex + 3);
            group.elementArray2.emplaceBack(wIndex, wIndex + 2);
            group.elementArray2.emplaceBack(wIndex + 1, wIndex + 3);
        }
    }

    var triangleIndices = earcut(flattened, holeIndices);

    for (var i = 0; i < triangleIndices.length - 2; i += 3) {
        group.elementArray.emplaceBack(indices[triangleIndices[i]],
            indices[triangleIndices[i+1]],
            indices[triangleIndices[i+2]]);
    }

    this.populatePaintArrays('extrusion', {zoom: this.zoom}, feature.properties, group, startIndex);
};

function convertCoords(rings) {
    if (rings instanceof Point) return [rings.x, rings.y];
    return rings.map(convertCoords);
}

function isBoundaryEdge(v1, v2) {
    return v1.some(function(a, i) { return (a === 0 - 64 || a === Bucket.EXTENT + 64) && v2[i] === a; });
}

},{"../../util/classify_rings":107,"../../util/util":120,"../bucket":2,"../load_geometry":11,"earcut":135,"point-geometry":187}],5:[function(require,module,exports){
'use strict';

var Bucket = require('../bucket');
var util = require('../../util/util');
var loadGeometry = require('../load_geometry');
var earcut = require('earcut');
var classifyRings = require('../../util/classify_rings');
var EARCUT_MAX_RINGS = 500;

module.exports = FillBucket;

function FillBucket() {
    Bucket.apply(this, arguments);
}

FillBucket.prototype = util.inherit(Bucket, {});

FillBucket.prototype.programInterfaces = {
    fill: {
        layoutVertexArrayType: new Bucket.VertexArrayType([{
            name: 'a_pos',
            components: 2,
            type: 'Int16'
        }]),
        elementArrayType: new Bucket.ElementArrayType(1),
        elementArrayType2: new Bucket.ElementArrayType(2),

        paintAttributes: [{
            name: 'a_color',
            components: 4,
            type: 'Uint8',
            getValue: function(layer, globalProperties, featureProperties) {
                return layer.getPaintValue("fill-color", globalProperties, featureProperties);
            },
            multiplier: 255,
            paintProperty: 'fill-color'
        }, {
            name: 'a_outline_color',
            components: 4,
            type: 'Uint8',
            getValue: function(layer, globalProperties, featureProperties) {
                return layer.getPaintValue("fill-outline-color", globalProperties, featureProperties);
            },
            multiplier: 255,
            paintProperty: 'fill-outline-color'
        }, {
            name: 'a_opacity',
            components: 1,
            type: 'Uint8',
            getValue: function(layer, globalProperties, featureProperties) {
                return [layer.getPaintValue("fill-opacity", globalProperties, featureProperties)];
            },
            multiplier: 255,
            paintProperty: 'fill-opacity'
        }]
    }
};

FillBucket.prototype.addFeature = function(feature) {
    var lines = loadGeometry(feature);
    var polygons = classifyRings(lines, EARCUT_MAX_RINGS);

    var startGroup = this.prepareArrayGroup('fill', 0);
    var startIndex = startGroup.layoutVertexArray.length;

    for (var i = 0; i < polygons.length; i++) {
        this.addPolygon(polygons[i]);
    }

    this.populatePaintArrays('fill', {zoom: this.zoom}, feature.properties, startGroup, startIndex);
};

FillBucket.prototype.addPolygon = function(polygon) {
    var numVertices = 0;
    for (var k = 0; k < polygon.length; k++) {
        numVertices += polygon[k].length;
    }

    var group = this.prepareArrayGroup('fill', numVertices);
    var flattened = [];
    var holeIndices = [];
    var startIndex = group.layoutVertexArray.length;

    for (var r = 0; r < polygon.length; r++) {
        var ring = polygon[r];

        if (r > 0) holeIndices.push(flattened.length / 2);

        for (var v = 0; v < ring.length; v++) {
            var vertex = ring[v];

            var index = group.layoutVertexArray.emplaceBack(vertex.x, vertex.y);

            if (v >= 1) {
                group.elementArray2.emplaceBack(index - 1, index);
            }

            // convert to format used by earcut
            flattened.push(vertex.x);
            flattened.push(vertex.y);
        }
    }

    var triangleIndices = earcut(flattened, holeIndices);

    for (var i = 0; i < triangleIndices.length; i++) {
        group.elementArray.emplaceBack(triangleIndices[i] + startIndex);
    }
};

},{"../../util/classify_rings":107,"../../util/util":120,"../bucket":2,"../load_geometry":11,"earcut":135}],6:[function(require,module,exports){
'use strict';

var Bucket = require('../bucket');
var util = require('../../util/util');
var loadGeometry = require('../load_geometry');
var EXTENT = Bucket.EXTENT;

// NOTE ON EXTRUDE SCALE:
// scale the extrusion vector so that the normal length is this value.
// contains the "texture" normals (-1..1). this is distinct from the extrude
// normals for line joins, because the x-value remains 0 for the texture
// normal array, while the extrude normal actually moves the vertex to create
// the acute/bevelled line join.
var EXTRUDE_SCALE = 63;

/*
 * Sharp corners cause dashed lines to tilt because the distance along the line
 * is the same at both the inner and outer corners. To improve the appearance of
 * dashed lines we add extra points near sharp corners so that a smaller part
 * of the line is tilted.
 *
 * COS_HALF_SHARP_CORNER controls how sharp a corner has to be for us to add an
 * extra vertex. The default is 75 degrees.
 *
 * The newly created vertices are placed SHARP_CORNER_OFFSET pixels from the corner.
 */
var COS_HALF_SHARP_CORNER = Math.cos(75 / 2 * (Math.PI / 180));
var SHARP_CORNER_OFFSET = 15;

// The number of bits that is used to store the line distance in the buffer.
var LINE_DISTANCE_BUFFER_BITS = 15;

// We don't have enough bits for the line distance as we'd like to have, so
// use this value to scale the line distance (in tile units) down to a smaller
// value. This lets us store longer distances while sacrificing precision.
var LINE_DISTANCE_SCALE = 1 / 2;

// The maximum line distance, in tile units, that fits in the buffer.
var MAX_LINE_DISTANCE = Math.pow(2, LINE_DISTANCE_BUFFER_BITS - 1) / LINE_DISTANCE_SCALE;


module.exports = LineBucket;

/**
 * @private
 */
function LineBucket() {
    Bucket.apply(this, arguments);
}

LineBucket.prototype = util.inherit(Bucket, {});

LineBucket.prototype.addLineVertex = function(layoutVertexBuffer, point, extrude, tx, ty, dir, linesofar) {
    return layoutVertexBuffer.emplaceBack(
            // a_pos
            (point.x << 1) | tx,
            (point.y << 1) | ty,
            // a_data
            // add 128 to store an byte in an unsigned byte
            Math.round(EXTRUDE_SCALE * extrude.x) + 128,
            Math.round(EXTRUDE_SCALE * extrude.y) + 128,
            // Encode the -1/0/1 direction value into the first two bits of .z of a_data.
            // Combine it with the lower 6 bits of `linesofar` (shifted by 2 bites to make
            // room for the direction value). The upper 8 bits of `linesofar` are placed in
            // the `w` component. `linesofar` is scaled down by `LINE_DISTANCE_SCALE` so that
            // we can store longer distances while sacrificing precision.
            ((dir === 0 ? 0 : (dir < 0 ? -1 : 1)) + 1) | (((linesofar * LINE_DISTANCE_SCALE) & 0x3F) << 2),
            (linesofar * LINE_DISTANCE_SCALE) >> 6);
};

LineBucket.prototype.programInterfaces = {
    line: {
        layoutVertexArrayType: new Bucket.VertexArrayType([{
            name: 'a_pos',
            components: 2,
            type: 'Int16'
        }, {
            name: 'a_data',
            components: 4,
            type: 'Uint8'
        }]),
        paintAttributes: [{
            name: 'a_color',
            components: 4,
            type: 'Uint8',
            getValue: function(layer, globalProperties, featureProperties) {
                return layer.getPaintValue("line-color", globalProperties, featureProperties);
            },
            multiplier: 255,
            paintProperty: 'line-color'
        }],
        elementArrayType: new Bucket.ElementArrayType()
    }
};

LineBucket.prototype.addFeature = function(feature) {
    var lines = loadGeometry(feature, LINE_DISTANCE_BUFFER_BITS);
    for (var i = 0; i < lines.length; i++) {
        this.addLine(
            lines[i],
            feature.properties,
            this.layer.layout['line-join'],
            this.layer.layout['line-cap'],
            this.layer.layout['line-miter-limit'],
            this.layer.layout['line-round-limit']
        );
    }
};

LineBucket.prototype.addLine = function(vertices, featureProperties, join, cap, miterLimit, roundLimit) {

    var len = vertices.length;
    // If the line has duplicate vertices at the end, adjust length to remove them.
    while (len > 2 && vertices[len - 1].equals(vertices[len - 2])) {
        len--;
    }

    // a line must have at least two vertices
    if (vertices.length < 2) return;

    if (join === 'bevel') miterLimit = 1.05;

    var sharpCornerOffset = SHARP_CORNER_OFFSET * (EXTENT / (512 * this.overscaling));

    var firstVertex = vertices[0],
        lastVertex = vertices[len - 1],
        closed = firstVertex.equals(lastVertex);

    // we could be more precise, but it would only save a negligible amount of space
    var group = this.prepareArrayGroup('line', len * 10);
    var startIndex = group.layoutVertexArray.length;

    // a line may not have coincident points
    if (len === 2 && closed) return;

    this.distance = 0;

    var beginCap = cap,
        endCap = closed ? 'butt' : cap,
        startOfLine = true,
        currentVertex, prevVertex, nextVertex, prevNormal, nextNormal, offsetA, offsetB;

    // the last three vertices added
    this.e1 = this.e2 = this.e3 = -1;

    if (closed) {
        currentVertex = vertices[len - 2];
        nextNormal = firstVertex.sub(currentVertex)._unit()._perp();
    }

    for (var i = 0; i < len; i++) {

        nextVertex = closed && i === len - 1 ?
            vertices[1] : // if the line is closed, we treat the last vertex like the first
            vertices[i + 1]; // just the next vertex

        // if two consecutive vertices exist, skip the current one
        if (nextVertex && vertices[i].equals(nextVertex)) continue;

        if (nextNormal) prevNormal = nextNormal;
        if (currentVertex) prevVertex = currentVertex;

        currentVertex = vertices[i];

        // Calculate the normal towards the next vertex in this line. In case
        // there is no next vertex, pretend that the line is continuing straight,
        // meaning that we are just using the previous normal.
        nextNormal = nextVertex ? nextVertex.sub(currentVertex)._unit()._perp() : prevNormal;

        // If we still don't have a previous normal, this is the beginning of a
        // non-closed line, so we're doing a straight "join".
        prevNormal = prevNormal || nextNormal;

        // Determine the normal of the join extrusion. It is the angle bisector
        // of the segments between the previous line and the next line.
        var joinNormal = prevNormal.add(nextNormal)._unit();

        /*  joinNormal     prevNormal
         *             ↖      ↑
         *                .________. prevVertex
         *                |
         * nextNormal  ←  |  currentVertex
         *                |
         *     nextVertex !
         *
         */

        // Calculate the length of the miter (the ratio of the miter to the width).
        // Find the cosine of the angle between the next and join normals
        // using dot product. The inverse of that is the miter length.
        var cosHalfAngle = joinNormal.x * nextNormal.x + joinNormal.y * nextNormal.y;
        var miterLength = 1 / cosHalfAngle;

        var isSharpCorner = cosHalfAngle < COS_HALF_SHARP_CORNER && prevVertex && nextVertex;

        if (isSharpCorner && i > 0) {
            var prevSegmentLength = currentVertex.dist(prevVertex);
            if (prevSegmentLength > 2 * sharpCornerOffset) {
                var newPrevVertex = currentVertex.sub(currentVertex.sub(prevVertex)._mult(sharpCornerOffset / prevSegmentLength)._round());
                this.distance += newPrevVertex.dist(prevVertex);
                this.addCurrentVertex(newPrevVertex, this.distance, prevNormal.mult(1), 0, 0, false);
                prevVertex = newPrevVertex;
            }
        }

        // The join if a middle vertex, otherwise the cap.
        var middleVertex = prevVertex && nextVertex;
        var currentJoin = middleVertex ? join : nextVertex ? beginCap : endCap;

        if (middleVertex && currentJoin === 'round') {
            if (miterLength < roundLimit) {
                currentJoin = 'miter';
            } else if (miterLength <= 2) {
                currentJoin = 'fakeround';
            }
        }

        if (currentJoin === 'miter' && miterLength > miterLimit) {
            currentJoin = 'bevel';
        }

        if (currentJoin === 'bevel') {
            // The maximum extrude length is 128 / 63 = 2 times the width of the line
            // so if miterLength >= 2 we need to draw a different type of bevel where.
            if (miterLength > 2) currentJoin = 'flipbevel';

            // If the miterLength is really small and the line bevel wouldn't be visible,
            // just draw a miter join to save a triangle.
            if (miterLength < miterLimit) currentJoin = 'miter';
        }

        // Calculate how far along the line the currentVertex is
        if (prevVertex) this.distance += currentVertex.dist(prevVertex);

        if (currentJoin === 'miter') {

            joinNormal._mult(miterLength);
            this.addCurrentVertex(currentVertex, this.distance, joinNormal, 0, 0, false);

        } else if (currentJoin === 'flipbevel') {
            // miter is too big, flip the direction to make a beveled join

            if (miterLength > 100) {
                // Almost parallel lines
                joinNormal = nextNormal.clone();

            } else {
                var direction = prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x > 0 ? -1 : 1;
                var bevelLength = miterLength * prevNormal.add(nextNormal).mag() / prevNormal.sub(nextNormal).mag();
                joinNormal._perp()._mult(bevelLength * direction);
            }
            this.addCurrentVertex(currentVertex, this.distance, joinNormal, 0, 0, false);
            this.addCurrentVertex(currentVertex, this.distance, joinNormal.mult(-1), 0, 0, false);

        } else if (currentJoin === 'bevel' || currentJoin === 'fakeround') {
            var lineTurnsLeft = (prevNormal.x * nextNormal.y - prevNormal.y * nextNormal.x) > 0;
            var offset = -Math.sqrt(miterLength * miterLength - 1);
            if (lineTurnsLeft) {
                offsetB = 0;
                offsetA = offset;
            } else {
                offsetA = 0;
                offsetB = offset;
            }

            // Close previous segment with a bevel
            if (!startOfLine) {
                this.addCurrentVertex(currentVertex, this.distance, prevNormal, offsetA, offsetB, false);
            }

            if (currentJoin === 'fakeround') {
                // The join angle is sharp enough that a round join would be visible.
                // Bevel joins fill the gap between segments with a single pie slice triangle.
                // Create a round join by adding multiple pie slices. The join isn't actually round, but
                // it looks like it is at the sizes we render lines at.

                // Add more triangles for sharper angles.
                // This math is just a good enough approximation. It isn't "correct".
                var n = Math.floor((0.5 - (cosHalfAngle - 0.5)) * 8);
                var approxFractionalJoinNormal;

                for (var m = 0; m < n; m++) {
                    approxFractionalJoinNormal = nextNormal.mult((m + 1) / (n + 1))._add(prevNormal)._unit();
                    this.addPieSliceVertex(currentVertex, this.distance, approxFractionalJoinNormal, lineTurnsLeft);
                }

                this.addPieSliceVertex(currentVertex, this.distance, joinNormal, lineTurnsLeft);

                for (var k = n - 1; k >= 0; k--) {
                    approxFractionalJoinNormal = prevNormal.mult((k + 1) / (n + 1))._add(nextNormal)._unit();
                    this.addPieSliceVertex(currentVertex, this.distance, approxFractionalJoinNormal, lineTurnsLeft);
                }
            }

            // Start next segment
            if (nextVertex) {
                this.addCurrentVertex(currentVertex, this.distance, nextNormal, -offsetA, -offsetB, false);
            }

        } else if (currentJoin === 'butt') {
            if (!startOfLine) {
                // Close previous segment with a butt
                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 0, 0, false);
            }

            // Start next segment with a butt
            if (nextVertex) {
                this.addCurrentVertex(currentVertex, this.distance, nextNormal, 0, 0, false);
            }

        } else if (currentJoin === 'square') {

            if (!startOfLine) {
                // Close previous segment with a square cap
                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 1, 1, false);

                // The segment is done. Unset vertices to disconnect segments.
                this.e1 = this.e2 = -1;
            }

            // Start next segment
            if (nextVertex) {
                this.addCurrentVertex(currentVertex, this.distance, nextNormal, -1, -1, false);
            }

        } else if (currentJoin === 'round') {

            if (!startOfLine) {
                // Close previous segment with butt
                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 0, 0, false);

                // Add round cap or linejoin at end of segment
                this.addCurrentVertex(currentVertex, this.distance, prevNormal, 1, 1, true);

                // The segment is done. Unset vertices to disconnect segments.
                this.e1 = this.e2 = -1;
            }


            // Start next segment with a butt
            if (nextVertex) {
                // Add round cap before first segment
                this.addCurrentVertex(currentVertex, this.distance, nextNormal, -1, -1, true);

                this.addCurrentVertex(currentVertex, this.distance, nextNormal, 0, 0, false);
            }
        }

        if (isSharpCorner && i < len - 1) {
            var nextSegmentLength = currentVertex.dist(nextVertex);
            if (nextSegmentLength > 2 * sharpCornerOffset) {
                var newCurrentVertex = currentVertex.add(nextVertex.sub(currentVertex)._mult(sharpCornerOffset / nextSegmentLength)._round());
                this.distance += newCurrentVertex.dist(currentVertex);
                this.addCurrentVertex(newCurrentVertex, this.distance, nextNormal.mult(1), 0, 0, false);
                currentVertex = newCurrentVertex;
            }
        }

        startOfLine = false;
    }

    this.populatePaintArrays(
        'line', {zoom: this.zoom},
        featureProperties,
        group,
        startIndex
    );
};

/**
 * Add two vertices to the buffers.
 *
 * @param {Object} currentVertex the line vertex to add buffer vertices for
 * @param {number} distance the distance from the beginning of the line to the vertex
 * @param {number} endLeft extrude to shift the left vertex along the line
 * @param {number} endRight extrude to shift the left vertex along the line
 * @param {boolean} round whether this is a round cap
 * @private
 */
LineBucket.prototype.addCurrentVertex = function(currentVertex, distance, normal, endLeft, endRight, round) {
    var tx = round ? 1 : 0;
    var extrude;
    var arrayGroup = this.arrayGroups.line[this.arrayGroups.line.length - 1];
    var layoutVertexArray = arrayGroup.layoutVertexArray;
    var elementArray = arrayGroup.elementArray;

    extrude = normal.clone();
    if (endLeft) extrude._sub(normal.perp()._mult(endLeft));
    this.e3 = this.addLineVertex(layoutVertexArray, currentVertex, extrude, tx, 0, endLeft, distance);
    if (this.e1 >= 0 && this.e2 >= 0) {
        elementArray.emplaceBack(this.e1, this.e2, this.e3);
    }
    this.e1 = this.e2;
    this.e2 = this.e3;

    extrude = normal.mult(-1);
    if (endRight) extrude._sub(normal.perp()._mult(endRight));
    this.e3 = this.addLineVertex(layoutVertexArray, currentVertex, extrude, tx, 1, -endRight, distance);
    if (this.e1 >= 0 && this.e2 >= 0) {
        elementArray.emplaceBack(this.e1, this.e2, this.e3);
    }
    this.e1 = this.e2;
    this.e2 = this.e3;

    // There is a maximum "distance along the line" that we can store in the buffers.
    // When we get close to the distance, reset it to zero and add the vertex again with
    // a distance of zero. The max distance is determined by the number of bits we allocate
    // to `linesofar`.
    if (distance > MAX_LINE_DISTANCE / 2) {
        this.distance = 0;
        this.addCurrentVertex(currentVertex, this.distance, normal, endLeft, endRight, round);
    }
};

/**
 * Add a single new vertex and a triangle using two previous vertices.
 * This adds a pie slice triangle near a join to simulate round joins
 *
 * @param {Object} currentVertex the line vertex to add buffer vertices for
 * @param {number} distance the distance from the beggining of the line to the vertex
 * @param {Object} extrude the offset of the new vertex from the currentVertex
 * @param {boolean} whether the line is turning left or right at this angle
 * @private
 */
LineBucket.prototype.addPieSliceVertex = function(currentVertex, distance, extrude, lineTurnsLeft) {
    var ty = lineTurnsLeft ? 1 : 0;
    extrude = extrude.mult(lineTurnsLeft ? -1 : 1);
    var arrayGroup = this.arrayGroups.line[this.arrayGroups.line.length - 1];
    var layoutVertexArray = arrayGroup.layoutVertexArray;
    var elementArray = arrayGroup.elementArray;

    this.e3 = this.addLineVertex(layoutVertexArray, currentVertex, extrude, 0, ty, 0, distance);

    if (this.e1 >= 0 && this.e2 >= 0) {
        elementArray.emplaceBack(this.e1, this.e2, this.e3);
    }

    if (lineTurnsLeft) {
        this.e2 = this.e3;
    } else {
        this.e1 = this.e3;
    }
};

},{"../../util/util":120,"../bucket":2,"../load_geometry":11}],7:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

var Bucket = require('../bucket');
var Anchor = require('../../symbol/anchor');
var getAnchors = require('../../symbol/get_anchors');
var resolveTokens = require('../../util/token');
var Quads = require('../../symbol/quads');
var Shaping = require('../../symbol/shaping');
var resolveText = require('../../symbol/resolve_text');
var mergeLines = require('../../symbol/mergelines');
var clipLine = require('../../symbol/clip_line');
var util = require('../../util/util');
var loadGeometry = require('../load_geometry');
var CollisionFeature = require('../../symbol/collision_feature');
var findPoleOfInaccessibility = require('../../util/find_pole_of_inaccessibility');
var classifyRings = require('../../util/classify_rings');

var shapeText = Shaping.shapeText;
var shapeIcon = Shaping.shapeIcon;
var getGlyphQuads = Quads.getGlyphQuads;
var getIconQuads = Quads.getIconQuads;

var EXTENT = Bucket.EXTENT;

module.exports = SymbolBucket;

function SymbolBucket(options) {
    Bucket.apply(this, arguments);
    this.showCollisionBoxes = options.showCollisionBoxes;
    this.overscaling = options.overscaling;
    this.collisionBoxArray = options.collisionBoxArray;
    this.symbolQuadsArray = options.symbolQuadsArray;
    this.symbolInstancesArray = options.symbolInstancesArray;

    this.sdfIcons = options.sdfIcons;
    this.iconsNeedLinear = options.iconsNeedLinear;
    this.adjustedTextSize = options.adjustedTextSize;
    this.adjustedIconSize = options.adjustedIconSize;
    this.fontstack = options.fontstack;
}

// this constant is based on the size of the glyphQuadEndIndex and iconQuadEndIndex
// in the symbol_instances StructArrayType
// eg the max valid UInt16 is 65,535
SymbolBucket.MAX_QUADS = 65535;

SymbolBucket.prototype = util.inherit(Bucket, {});

SymbolBucket.prototype.serialize = function() {
    var serialized = Bucket.prototype.serialize.apply(this);
    serialized.sdfIcons = this.sdfIcons;
    serialized.iconsNeedLinear = this.iconsNeedLinear;
    serialized.adjustedTextSize = this.adjustedTextSize;
    serialized.adjustedIconSize = this.adjustedIconSize;
    serialized.fontstack = this.fontstack;
    return serialized;
};

var layoutVertexArrayType = new Bucket.VertexArrayType([{
    name: 'a_pos',
    components: 2,
    type: 'Int16'
}, {
    name: 'a_offset',
    components: 2,
    type: 'Int16'
}, {
    name: 'a_texture_pos',
    components: 2,
    type: 'Uint16'
}, {
    name: 'a_data',
    components: 4,
    type: 'Uint8'
}]);

var elementArrayType = new Bucket.ElementArrayType();

function addVertex(array, x, y, ox, oy, tx, ty, minzoom, maxzoom, labelminzoom, labelangle) {
    return array.emplaceBack(
            // a_pos
            x,
            y,

            // a_offset
            Math.round(ox * 64),
            Math.round(oy * 64),

            // a_texture_pos
            tx / 4, // x coordinate of symbol on glyph atlas texture
            ty / 4, // y coordinate of symbol on glyph atlas texture

            // a_data
            (labelminzoom || 0) * 10, // labelminzoom
            labelangle, // labelangle
            (minzoom || 0) * 10, // minzoom
            Math.min(maxzoom || 25, 25) * 10); // maxzoom
}

SymbolBucket.prototype.addCollisionBoxVertex = function(layoutVertexArray, point, extrude, maxZoom, placementZoom) {
    return layoutVertexArray.emplaceBack(
            // pos
            point.x,
            point.y,
            // extrude
            Math.round(extrude.x),
            Math.round(extrude.y),
            // data
            maxZoom * 10,
            placementZoom * 10);
};

SymbolBucket.prototype.programInterfaces = {

    glyph: {
        layoutVertexArrayType: layoutVertexArrayType,
        elementArrayType: elementArrayType
    },

    icon: {
        layoutVertexArrayType: layoutVertexArrayType,
        elementArrayType: elementArrayType
    },

    collisionBox: {
        layoutVertexArrayType: new Bucket.VertexArrayType([{
            name: 'a_pos',
            components: 2,
            type: 'Int16'
        }, {
            name: 'a_extrude',
            components: 2,
            type: 'Int16'
        }, {
            name: 'a_data',
            components: 2,
            type: 'Uint8'
        }])
    }
};

SymbolBucket.prototype.populateArrays = function(collisionTile, stacks, icons) {

    // To reduce the number of labels that jump around when zooming we need
    // to use a text-size value that is the same for all zoom levels.
    // This calculates text-size at a high zoom level so that all tiles can
    // use the same value when calculating anchor positions.
    var zoomHistory = { lastIntegerZoom: Infinity, lastIntegerZoomTime: 0, lastZoom: 0 };
    this.adjustedTextMaxSize = this.layer.getLayoutValue('text-size', {zoom: 18, zoomHistory: zoomHistory});
    this.adjustedTextSize = this.layer.getLayoutValue('text-size', {zoom: this.zoom + 1, zoomHistory: zoomHistory});
    this.adjustedIconMaxSize = this.layer.getLayoutValue('icon-size', {zoom: 18, zoomHistory: zoomHistory});
    this.adjustedIconSize = this.layer.getLayoutValue('icon-size', {zoom: this.zoom + 1, zoomHistory: zoomHistory});

    var tileSize = 512 * this.overscaling;
    this.tilePixelRatio = EXTENT / tileSize;
    this.compareText = {};
    this.iconsNeedLinear = false;
    this.symbolInstancesStartIndex = this.symbolInstancesArray.length;

    var layout = this.layer.layout;
    var features = this.features;
    var textFeatures = this.textFeatures;

    var horizontalAlign = 0.5,
        verticalAlign = 0.5;

    switch (layout['text-anchor']) {
    case 'right':
    case 'top-right':
    case 'bottom-right':
        horizontalAlign = 1;
        break;
    case 'left':
    case 'top-left':
    case 'bottom-left':
        horizontalAlign = 0;
        break;
    }

    switch (layout['text-anchor']) {
    case 'bottom':
    case 'bottom-right':
    case 'bottom-left':
        verticalAlign = 1;
        break;
    case 'top':
    case 'top-right':
    case 'top-left':
        verticalAlign = 0;
        break;
    }

    var justify = layout['text-justify'] === 'right' ? 1 :
        layout['text-justify'] === 'left' ? 0 :
        0.5;

    var oneEm = 24;
    var lineHeight = layout['text-line-height'] * oneEm;
    var maxWidth = layout['symbol-placement'] !== 'line' ? layout['text-max-width'] * oneEm : 0;
    var spacing = layout['text-letter-spacing'] * oneEm;
    var textOffset = [layout['text-offset'][0] * oneEm, layout['text-offset'][1] * oneEm];
    var fontstack = this.fontstack = layout['text-font'].join(',');

    var geometries = [];
    for (var g = 0; g < features.length; g++) {
        geometries.push(loadGeometry(features[g]));
    }

    if (layout['symbol-placement'] === 'line') {
        // Merge adjacent lines with the same text to improve labelling.
        // It's better to place labels on one long line than on many short segments.
        var merged = mergeLines(features, textFeatures, geometries);

        geometries = merged.geometries;
        features = merged.features;
        textFeatures = merged.textFeatures;
    }

    var shapedText, shapedIcon;

    for (var k = 0; k < features.length; k++) {
        if (!geometries[k]) continue;

        if (textFeatures[k]) {
            shapedText = shapeText(textFeatures[k], stacks[fontstack], maxWidth,
                    lineHeight, horizontalAlign, verticalAlign, justify, spacing, textOffset);
        } else {
            shapedText = null;
        }

        if (layout['icon-image']) {
            var iconName = resolveTokens(features[k].properties, layout['icon-image']);
            var image = icons[iconName];
            shapedIcon = shapeIcon(image, layout);

            if (image) {
                if (this.sdfIcons === undefined) {
                    this.sdfIcons = image.sdf;
                } else if (this.sdfIcons !== image.sdf) {
                    util.warnOnce('Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer');
                }
                if (image.pixelRatio !== 1) {
                    this.iconsNeedLinear = true;
                } else if (layout['icon-rotate'] !== 0 || !this.layer.isLayoutValueFeatureConstant('icon-rotate')) {
                    this.iconsNeedLinear = true;
                }
            }
        } else {
            shapedIcon = null;
        }

        if (shapedText || shapedIcon) {
            this.addFeature(geometries[k], shapedText, shapedIcon, features[k]);
        }
    }
    this.symbolInstancesEndIndex = this.symbolInstancesArray.length;
    this.placeFeatures(collisionTile, this.showCollisionBoxes);

    this.trimArrays();
};

SymbolBucket.prototype.addFeature = function(lines, shapedText, shapedIcon, feature) {
    var layout = this.layer.layout;

    var glyphSize = 24;

    var fontScale = this.adjustedTextSize / glyphSize,
        textMaxSize = this.adjustedTextMaxSize !== undefined ? this.adjustedTextMaxSize : this.adjustedTextSize,
        textBoxScale = this.tilePixelRatio * fontScale,
        textMaxBoxScale = this.tilePixelRatio * textMaxSize / glyphSize,
        iconBoxScale = this.tilePixelRatio * this.adjustedIconSize,
        symbolMinDistance = this.tilePixelRatio * layout['symbol-spacing'],
        avoidEdges = layout['symbol-avoid-edges'],
        textPadding = layout['text-padding'] * this.tilePixelRatio,
        iconPadding = layout['icon-padding'] * this.tilePixelRatio,
        textMaxAngle = layout['text-max-angle'] / 180 * Math.PI,
        textAlongLine = layout['text-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line',
        iconAlongLine = layout['icon-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line',
        mayOverlap = layout['text-allow-overlap'] || layout['icon-allow-overlap'] ||
            layout['text-ignore-placement'] || layout['icon-ignore-placement'],
        symbolPlacement = layout['symbol-placement'],
        isLine = symbolPlacement === 'line',
        textRepeatDistance = symbolMinDistance / 2;

    var list = null;
    if (isLine) {
        list = clipLine(lines, 0, 0, EXTENT, EXTENT);
    } else {
        // Only care about looping through the outer rings
        list = classifyRings(lines, 0);
    }

    for (var i = 0; i < list.length; i++) {
        var anchors = null;
        // At this point it is a list of points for a line or a list of polygon rings
        var pointsOrRings = list[i];
        var line = null;

        // Calculate the anchor points around which you want to place labels
        if (isLine) {
            line = pointsOrRings;
            anchors = getAnchors(
                line,
                symbolMinDistance,
                textMaxAngle,
                shapedText,
                shapedIcon,
                glyphSize,
                textMaxBoxScale,
                this.overscaling,
                EXTENT
            );
        } else {
            line = pointsOrRings[0];
            anchors = this.findPolygonAnchors(pointsOrRings);
        }


        // Here line is a list of points that is either the outer ring of a polygon or just a line

        // For each potential label, create the placement features used to check for collisions, and the quads use for rendering.
        for (var j = 0, len = anchors.length; j < len; j++) {
            var anchor = anchors[j];

            if (shapedText && isLine) {
                if (this.anchorIsTooClose(shapedText.text, textRepeatDistance, anchor)) {
                    continue;
                }
            }

            var inside = !(anchor.x < 0 || anchor.x > EXTENT || anchor.y < 0 || anchor.y > EXTENT);

            if (avoidEdges && !inside) continue;

            // Normally symbol layers are drawn across tile boundaries. Only symbols
            // with their anchors within the tile boundaries are added to the buffers
            // to prevent symbols from being drawn twice.
            //
            // Symbols in layers with overlap are sorted in the y direction so that
            // symbols lower on the canvas are drawn on top of symbols near the top.
            // To preserve this order across tile boundaries these symbols can't
            // be drawn across tile boundaries. Instead they need to be included in
            // the buffers for both tiles and clipped to tile boundaries at draw time.
            var addToBuffers = inside || mayOverlap;
            this.addSymbolInstance(anchor, line, shapedText, shapedIcon, this.layer,
                addToBuffers, this.symbolInstancesArray.length, this.collisionBoxArray, feature.index, this.sourceLayerIndex, this.index,
                textBoxScale, textPadding, textAlongLine,
                iconBoxScale, iconPadding, iconAlongLine, {zoom: this.zoom}, feature.properties);
        }
    }
};

SymbolBucket.prototype.findPolygonAnchors = function(polygonRings) {

    var outerRing = polygonRings[0];
    if (outerRing.length === 0) {
        return [];
    } else if (outerRing.length < 3 || !util.isClosedPolygon(outerRing)) {
        return [ new Anchor(outerRing[0].x, outerRing[0].y, 0) ];
    }

    var anchors = null;
    // 16 here represents 2 pixels
    var poi = findPoleOfInaccessibility(polygonRings, 16);
    anchors = [ new Anchor(poi.x, poi.y, 0) ];

    return anchors;
};

SymbolBucket.prototype.anchorIsTooClose = function(text, repeatDistance, anchor) {
    var compareText = this.compareText;
    if (!(text in compareText)) {
        compareText[text] = [];
    } else {
        var otherAnchors = compareText[text];
        for (var k = otherAnchors.length - 1; k >= 0; k--) {
            if (anchor.dist(otherAnchors[k]) < repeatDistance) {
                // If it's within repeatDistance of one anchor, stop looking
                return true;
            }
        }
    }
    // If anchor is not within repeatDistance of any other anchor, add to array
    compareText[text].push(anchor);
    return false;
};

SymbolBucket.prototype.placeFeatures = function(collisionTile, showCollisionBoxes) {
    this.recalculateStyleLayers();

    // Calculate which labels can be shown and when they can be shown and
    // create the bufers used for rendering.

    this.createArrays();

    var layout = this.layer.layout;

    var maxScale = collisionTile.maxScale;

    var textAlongLine = layout['text-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line';
    var iconAlongLine = layout['icon-rotation-alignment'] === 'map' && layout['symbol-placement'] === 'line';

    var mayOverlap = layout['text-allow-overlap'] || layout['icon-allow-overlap'] ||
        layout['text-ignore-placement'] || layout['icon-ignore-placement'];

    // Sort symbols by their y position on the canvas so that the lower symbols
    // are drawn on top of higher symbols.
    // Don't sort symbols that won't overlap because it isn't necessary and
    // because it causes more labels to pop in and out when rotating.
    if (mayOverlap) {
        // Only need the symbol instances from the current tile to sort, so convert those instances into an array
        // of `StructType`s to enable sorting
        var symbolInstancesStructTypeArray = this.symbolInstancesArray.toArray(this.symbolInstancesStartIndex, this.symbolInstancesEndIndex);

        var angle = collisionTile.angle;

        var sin = Math.sin(angle),
            cos = Math.cos(angle);

        this.sortedSymbolInstances = symbolInstancesStructTypeArray.sort(function(a, b) {
            var aRotated = (sin * a.anchorPointX + cos * a.anchorPointY) | 0;
            var bRotated = (sin * b.anchorPointX + cos * b.anchorPointY) | 0;
            return (aRotated - bRotated) || (b.index - a.index);
        });
    }

    for (var p = this.symbolInstancesStartIndex; p < this.symbolInstancesEndIndex; p++) {
        var symbolInstance = this.sortedSymbolInstances ? this.sortedSymbolInstances[p - this.symbolInstancesStartIndex] : this.symbolInstancesArray.get(p);
        var textCollisionFeature = {
            boxStartIndex: symbolInstance.textBoxStartIndex,
            boxEndIndex: symbolInstance.textBoxEndIndex
        };
        var iconCollisionFeature = {
            boxStartIndex: symbolInstance.iconBoxStartIndex,
            boxEndIndex: symbolInstance.iconBoxEndIndex
        };

        var hasText = !(symbolInstance.textBoxStartIndex === symbolInstance.textBoxEndIndex);
        var hasIcon = !(symbolInstance.iconBoxStartIndex === symbolInstance.iconBoxEndIndex);

        var iconWithoutText = layout['text-optional'] || !hasText,
            textWithoutIcon = layout['icon-optional'] || !hasIcon;


        // Calculate the scales at which the text and icon can be placed without collision.

        var glyphScale = hasText ?
            collisionTile.placeCollisionFeature(textCollisionFeature,
					layout['text-allow-overlap'], layout['symbol-avoid-edges']) :
            collisionTile.minScale;

        var iconScale = hasIcon ?
            collisionTile.placeCollisionFeature(iconCollisionFeature,
                    layout['icon-allow-overlap'], layout['symbol-avoid-edges']) :
            collisionTile.minScale;


        // Combine the scales for icons and text.

        if (!iconWithoutText && !textWithoutIcon) {
            iconScale = glyphScale = Math.max(iconScale, glyphScale);
        } else if (!textWithoutIcon && glyphScale) {
            glyphScale = Math.max(iconScale, glyphScale);
        } else if (!iconWithoutText && iconScale) {
            iconScale = Math.max(iconScale, glyphScale);
        }


        // Insert final placement into collision tree and add glyphs/icons to buffers

        if (hasText) {
            collisionTile.insertCollisionFeature(textCollisionFeature, glyphScale, layout['text-ignore-placement']);
            if (glyphScale <= maxScale) {
                this.addSymbols('glyph', symbolInstance.glyphQuadStartIndex, symbolInstance.glyphQuadEndIndex, glyphScale, layout['text-keep-upright'], textAlongLine, collisionTile.angle);
            }
        }

        if (hasIcon) {
            collisionTile.insertCollisionFeature(iconCollisionFeature, iconScale, layout['icon-ignore-placement']);
            if (iconScale <= maxScale) {
                this.addSymbols('icon', symbolInstance.iconQuadStartIndex, symbolInstance.iconQuadEndIndex, iconScale, layout['icon-keep-upright'], iconAlongLine, collisionTile.angle);
            }
        }

    }

    if (showCollisionBoxes) this.addToDebugBuffers(collisionTile);
};

SymbolBucket.prototype.addSymbols = function(programName, quadsStart, quadsEnd, scale, keepUpright, alongLine, placementAngle) {

    var group = this.prepareArrayGroup(programName, 4 * (quadsEnd - quadsStart));

    var elementArray = group.elementArray;
    var layoutVertexArray = group.layoutVertexArray;

    var zoom = this.zoom;
    var placementZoom = Math.max(Math.log(scale) / Math.LN2 + zoom, 0);

    for (var k = quadsStart; k < quadsEnd; k++) {

        var symbol = this.symbolQuadsArray.get(k).SymbolQuad;

        // drop upside down versions of glyphs
        var a = (symbol.anchorAngle + placementAngle + Math.PI) % (Math.PI * 2);
        if (keepUpright && alongLine && (a <= Math.PI / 2 || a > Math.PI * 3 / 2)) continue;

        var tl = symbol.tl,
            tr = symbol.tr,
            bl = symbol.bl,
            br = symbol.br,
            tex = symbol.tex,
            anchorPoint = symbol.anchorPoint,

            minZoom = Math.max(zoom + Math.log(symbol.minScale) / Math.LN2, placementZoom),
            maxZoom = Math.min(zoom + Math.log(symbol.maxScale) / Math.LN2, 25);

        if (maxZoom <= minZoom) continue;

        // Lower min zoom so that while fading out the label it can be shown outside of collision-free zoom levels
        if (minZoom === placementZoom) minZoom = 0;

        // Encode angle of glyph
        var glyphAngle = Math.round((symbol.glyphAngle / (Math.PI * 2)) * 256);

        var index = addVertex(layoutVertexArray, anchorPoint.x, anchorPoint.y, tl.x, tl.y, tex.x, tex.y, minZoom, maxZoom, placementZoom, glyphAngle);
        addVertex(layoutVertexArray, anchorPoint.x, anchorPoint.y, tr.x, tr.y, tex.x + tex.w, tex.y, minZoom, maxZoom, placementZoom, glyphAngle);
        addVertex(layoutVertexArray, anchorPoint.x, anchorPoint.y, bl.x, bl.y, tex.x, tex.y + tex.h, minZoom, maxZoom, placementZoom, glyphAngle);
        addVertex(layoutVertexArray, anchorPoint.x, anchorPoint.y, br.x, br.y, tex.x + tex.w, tex.y + tex.h, minZoom, maxZoom, placementZoom, glyphAngle);

        elementArray.emplaceBack(index, index + 1, index + 2);
        elementArray.emplaceBack(index + 1, index + 2, index + 3);
    }

};

SymbolBucket.prototype.updateIcons = function(icons) {
    this.recalculateStyleLayers();
    var iconValue = this.layer.layout['icon-image'];
    if (!iconValue) return;

    for (var i = 0; i < this.features.length; i++) {
        var iconName = resolveTokens(this.features[i].properties, iconValue);
        if (iconName)
            icons[iconName] = true;
    }
};

SymbolBucket.prototype.updateFont = function(stacks) {
    this.recalculateStyleLayers();
    var fontName = this.layer.layout['text-font'],
        stack = stacks[fontName] = stacks[fontName] || {};

    this.textFeatures = resolveText(this.features, this.layer.layout, stack);
};

SymbolBucket.prototype.addToDebugBuffers = function(collisionTile) {
    var group = this.prepareArrayGroup('collisionBox', 0);
    var layoutVertexArray = group.layoutVertexArray;
    var angle = -collisionTile.angle;
    var yStretch = collisionTile.yStretch;

    for (var j = this.symbolInstancesStartIndex; j < this.symbolInstancesEndIndex; j++) {
        var symbolInstance = this.symbolInstancesArray.get(j);
        symbolInstance.textCollisionFeature = {boxStartIndex: symbolInstance.textBoxStartIndex, boxEndIndex: symbolInstance.textBoxEndIndex};
        symbolInstance.iconCollisionFeature = {boxStartIndex: symbolInstance.iconBoxStartIndex, boxEndIndex: symbolInstance.iconBoxEndIndex};

        for (var i = 0; i < 2; i++) {
            var feature = symbolInstance[i === 0 ? 'textCollisionFeature' : 'iconCollisionFeature'];
            if (!feature) continue;

            for (var b = feature.boxStartIndex; b < feature.boxEndIndex; b++) {
                var box = this.collisionBoxArray.get(b);
                var anchorPoint = box.anchorPoint;

                var tl = new Point(box.x1, box.y1 * yStretch)._rotate(angle);
                var tr = new Point(box.x2, box.y1 * yStretch)._rotate(angle);
                var bl = new Point(box.x1, box.y2 * yStretch)._rotate(angle);
                var br = new Point(box.x2, box.y2 * yStretch)._rotate(angle);

                var maxZoom = Math.max(0, Math.min(25, this.zoom + Math.log(box.maxScale) / Math.LN2));
                var placementZoom = Math.max(0, Math.min(25, this.zoom + Math.log(box.placementScale) / Math.LN2));

                this.addCollisionBoxVertex(layoutVertexArray, anchorPoint, tl, maxZoom, placementZoom);
                this.addCollisionBoxVertex(layoutVertexArray, anchorPoint, tr, maxZoom, placementZoom);
                this.addCollisionBoxVertex(layoutVertexArray, anchorPoint, tr, maxZoom, placementZoom);
                this.addCollisionBoxVertex(layoutVertexArray, anchorPoint, br, maxZoom, placementZoom);
                this.addCollisionBoxVertex(layoutVertexArray, anchorPoint, br, maxZoom, placementZoom);
                this.addCollisionBoxVertex(layoutVertexArray, anchorPoint, bl, maxZoom, placementZoom);
                this.addCollisionBoxVertex(layoutVertexArray, anchorPoint, bl, maxZoom, placementZoom);
                this.addCollisionBoxVertex(layoutVertexArray, anchorPoint, tl, maxZoom, placementZoom);
            }
        }
    }
};

SymbolBucket.prototype.addSymbolInstance = function(anchor, line, shapedText, shapedIcon, layer, addToBuffers, index, collisionBoxArray, featureIndex, sourceLayerIndex, bucketIndex,
    textBoxScale, textPadding, textAlongLine,
    iconBoxScale, iconPadding, iconAlongLine, globalProperties, featureProperties) {

    var glyphQuadStartIndex, glyphQuadEndIndex, iconQuadStartIndex, iconQuadEndIndex, textCollisionFeature, iconCollisionFeature, glyphQuads, iconQuads;
    if (shapedText) {
        glyphQuads = addToBuffers ? getGlyphQuads(anchor, shapedText, textBoxScale, line, layer, textAlongLine) : [];
        textCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex, shapedText, textBoxScale, textPadding, textAlongLine, false);
    }

    glyphQuadStartIndex = this.symbolQuadsArray.length;
    if (glyphQuads && glyphQuads.length) {
        for (var i = 0; i < glyphQuads.length; i++) {
            this.addSymbolQuad(glyphQuads[i]);
        }
    }
    glyphQuadEndIndex = this.symbolQuadsArray.length;

    var textBoxStartIndex = textCollisionFeature ? textCollisionFeature.boxStartIndex : this.collisionBoxArray.length;
    var textBoxEndIndex = textCollisionFeature ? textCollisionFeature.boxEndIndex : this.collisionBoxArray.length;

    if (shapedIcon) {
        iconQuads = addToBuffers ? getIconQuads(anchor, shapedIcon, iconBoxScale, line, layer, iconAlongLine, shapedText, globalProperties, featureProperties) : [];
        iconCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex, shapedIcon, iconBoxScale, iconPadding, iconAlongLine, true);
    }

    iconQuadStartIndex = this.symbolQuadsArray.length;
    if (iconQuads && iconQuads.length === 1) {
        this.addSymbolQuad(iconQuads[0]);
    }
    iconQuadEndIndex = this.symbolQuadsArray.length;

    var iconBoxStartIndex = iconCollisionFeature ? iconCollisionFeature.boxStartIndex : this.collisionBoxArray.length;
    var iconBoxEndIndex = iconCollisionFeature ? iconCollisionFeature.boxEndIndex : this.collisionBoxArray.length;
    if (iconQuadEndIndex > SymbolBucket.MAX_QUADS) util.warnOnce("Too many symbols being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907");
    if (glyphQuadEndIndex > SymbolBucket.MAX_QUADS) util.warnOnce("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907");

    return this.symbolInstancesArray.emplaceBack(
        textBoxStartIndex,
        textBoxEndIndex,
        iconBoxStartIndex,
        iconBoxEndIndex,
        glyphQuadStartIndex,
        glyphQuadEndIndex,
        iconQuadStartIndex,
        iconQuadEndIndex,
        anchor.x,
        anchor.y,
        index);
};

SymbolBucket.prototype.addSymbolQuad = function(symbolQuad) {
    return this.symbolQuadsArray.emplaceBack(
        // anchorPoints
        symbolQuad.anchorPoint.x,
        symbolQuad.anchorPoint.y,
        // corners
        symbolQuad.tl.x,
        symbolQuad.tl.y,
        symbolQuad.tr.x,
        symbolQuad.tr.y,
        symbolQuad.bl.x,
        symbolQuad.bl.y,
        symbolQuad.br.x,
        symbolQuad.br.y,
        // texture
        symbolQuad.tex.h,
        symbolQuad.tex.w,
        symbolQuad.tex.x,
        symbolQuad.tex.y,
        //angle
        symbolQuad.anchorAngle,
        symbolQuad.glyphAngle,
        // scales
        symbolQuad.maxScale,
        symbolQuad.minScale);
};

},{"../../symbol/anchor":67,"../../symbol/clip_line":69,"../../symbol/collision_feature":71,"../../symbol/get_anchors":73,"../../symbol/mergelines":76,"../../symbol/quads":77,"../../symbol/resolve_text":78,"../../symbol/shaping":79,"../../util/classify_rings":107,"../../util/find_pole_of_inaccessibility":112,"../../util/token":119,"../../util/util":120,"../bucket":2,"../load_geometry":11,"point-geometry":187}],8:[function(require,module,exports){
'use strict';

module.exports = Buffer;

/**
 * The `Buffer` class turns a `StructArray` into a WebGL buffer. Each member of the StructArray's
 * Struct type is converted to a WebGL atribute.
 *
 * @class Buffer
 * @private
 * @param {object} array A serialized StructArray.
 * @param {object} arrayType A serialized StructArrayType.
 * @param {BufferType} type
 */
function Buffer(array, arrayType, type) {
    this.arrayBuffer = array.arrayBuffer;
    this.length = array.length;
    this.attributes = arrayType.members;
    this.itemSize = arrayType.bytesPerElement;
    this.type = type;
    this.arrayType = arrayType;
}

/**
 * Bind this buffer to a WebGL context.
 * @private
 * @param gl The WebGL context
 */
Buffer.prototype.bind = function(gl) {
    var type = gl[this.type];

    if (!this.buffer) {
        this.buffer = gl.createBuffer();
        gl.bindBuffer(type, this.buffer);
        gl.bufferData(type, this.arrayBuffer, gl.STATIC_DRAW);

        // dump array buffer once it's bound to gl
        this.arrayBuffer = null;
    } else {
        gl.bindBuffer(type, this.buffer);
    }
};

/**
 * @enum {string} AttributeType
 * @private
 * @readonly
 */
var AttributeType = {
    Int8:   'BYTE',
    Uint8:  'UNSIGNED_BYTE',
    Int16:  'SHORT',
    Uint16: 'UNSIGNED_SHORT'
};

/**
 * Set the attribute pointers in a WebGL context
 * @private
 * @param gl The WebGL context
 * @param program The active WebGL program
 */
Buffer.prototype.setVertexAttribPointers = function(gl, program) {
    for (var j = 0; j < this.attributes.length; j++) {
        var member = this.attributes[j];
        var attribIndex = program[member.name];

        if (attribIndex !== undefined) {
            gl.vertexAttribPointer(
                attribIndex,
                member.components,
                gl[AttributeType[member.type]],
                false,
                this.arrayType.bytesPerElement,
                member.offset
            );
        }
    }
};

/**
 * Destroy the GL buffer bound to the given WebGL context
 * @private
 * @param gl The WebGL context
 */
Buffer.prototype.destroy = function(gl) {
    if (this.buffer) {
        gl.deleteBuffer(this.buffer);
    }
};

/**
 * @enum {string} BufferType
 * @private
 * @readonly
 */
Buffer.BufferType = {
    VERTEX: 'ARRAY_BUFFER',
    ELEMENT: 'ELEMENT_ARRAY_BUFFER'
};

},{}],9:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var Buffer = require('./buffer');
var VertexArrayObject = require('../render/vertex_array_object');

module.exports = BufferGroup;

function BufferGroup(arrayGroup, arrayTypes) {
    this.layoutVertexBuffer = new Buffer(arrayGroup.layoutVertexArray,
        arrayTypes.layoutVertexArrayType, Buffer.BufferType.VERTEX);

    if (arrayGroup.elementArray) {
        this.elementBuffer = new Buffer(arrayGroup.elementArray,
            arrayTypes.elementArrayType, Buffer.BufferType.ELEMENT);
    }

    var vaos = this.vaos = {};
    var secondVaos;

    if (arrayGroup.elementArray2) {
        this.elementBuffer2 = new Buffer(arrayGroup.elementArray2,
            arrayTypes.elementArrayType2, Buffer.BufferType.ELEMENT);
        secondVaos = this.secondVaos = {};
    }

    this.paintVertexBuffers = util.mapObject(arrayGroup.paintVertexArrays, function(array, name) {
        vaos[name] = new VertexArrayObject();
        if (arrayGroup.elementArray2) {
            secondVaos[name] = new VertexArrayObject();
        }
        return new Buffer(array, arrayTypes.paintVertexArrayTypes[name], Buffer.BufferType.VERTEX);
    });
}

BufferGroup.prototype.destroy = function(gl) {
    this.layoutVertexBuffer.destroy(gl);
    if (this.elementBuffer) {
        this.elementBuffer.destroy(gl);
    }
    if (this.elementBuffer2) {
        this.elementBuffer2.destroy(gl);
    }
    for (var n in this.paintVertexBuffers) {
        this.paintVertexBuffers[n].destroy(gl);
    }
    for (var j in this.vaos) {
        this.vaos[j].destroy(gl);
    }
    for (var k in this.secondVaos) {
        this.secondVaos[k].destroy(gl);
    }
};

},{"../render/vertex_array_object":32,"../util/util":120,"./buffer":8}],10:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');
var loadGeometry = require('./load_geometry');
var EXTENT = require('./bucket').EXTENT;
var featureFilter = require('feature-filter');
var StructArrayType = require('../util/struct_array');
var Grid = require('grid-index');
var DictionaryCoder = require('../util/dictionary_coder');
var vt = require('vector-tile');
var Protobuf = require('pbf');
var GeoJSONFeature = require('../util/vectortile_to_geojson');
var arraysIntersect = require('../util/util').arraysIntersect;

var intersection = require('../util/intersection_tests');
var multiPolygonIntersectsBufferedMultiPoint = intersection.multiPolygonIntersectsBufferedMultiPoint;
var multiPolygonIntersectsMultiPolygon = intersection.multiPolygonIntersectsMultiPolygon;
var multiPolygonIntersectsBufferedMultiLine = intersection.multiPolygonIntersectsBufferedMultiLine;


var FeatureIndexArray = new StructArrayType({
    members: [
        // the index of the feature in the original vectortile
        { type: 'Uint32', name: 'featureIndex' },
        // the source layer the feature appears in
        { type: 'Uint16', name: 'sourceLayerIndex' },
        // the bucket the feature appears in
        { type: 'Uint16', name: 'bucketIndex' }
    ]});

module.exports = FeatureIndex;

function FeatureIndex(coord, overscaling, collisionTile) {
    if (coord.grid) {
        var serialized = coord;
        var rawTileData = overscaling;
        coord = serialized.coord;
        overscaling = serialized.overscaling;
        this.grid = new Grid(serialized.grid);
        this.featureIndexArray = new FeatureIndexArray(serialized.featureIndexArray);
        this.rawTileData = rawTileData;
        this.bucketLayerIDs = serialized.bucketLayerIDs;
    } else {
        this.grid = new Grid(EXTENT, 16, 0);
        this.featureIndexArray = new FeatureIndexArray();
    }
    this.coord = coord;
    this.overscaling = overscaling;
    this.x = coord.x;
    this.y = coord.y;
    this.z = coord.z - Math.log(overscaling) / Math.LN2;
    this.setCollisionTile(collisionTile);
}

FeatureIndex.prototype.insert = function(feature, featureIndex, sourceLayerIndex, bucketIndex) {
    var key = this.featureIndexArray.length;
    this.featureIndexArray.emplaceBack(featureIndex, sourceLayerIndex, bucketIndex);
    var geometry = loadGeometry(feature);

    for (var r = 0; r < geometry.length; r++) {
        var ring = geometry[r];

        var bbox = [Infinity, Infinity, -Infinity, -Infinity];
        for (var i = 0; i < ring.length; i++) {
            var p = ring[i];
            bbox[0] = Math.min(bbox[0], p.x);
            bbox[1] = Math.min(bbox[1], p.y);
            bbox[2] = Math.max(bbox[2], p.x);
            bbox[3] = Math.max(bbox[3], p.y);
        }

        this.grid.insert(key, bbox[0], bbox[1], bbox[2], bbox[3]);
    }
};

FeatureIndex.prototype.setCollisionTile = function(collisionTile) {
    this.collisionTile = collisionTile;
};

FeatureIndex.prototype.serialize = function() {
    var data = {
        coord: this.coord,
        overscaling: this.overscaling,
        grid: this.grid.toArrayBuffer(),
        featureIndexArray: this.featureIndexArray.serialize(),
        bucketLayerIDs: this.bucketLayerIDs
    };
    return {
        data: data,
        transferables: [data.grid, data.featureIndexArray.arrayBuffer]
    };
};

function translateDistance(translate) {
    return Math.sqrt(translate[0] * translate[0] + translate[1] * translate[1]);
}

// Finds features in this tile at a particular position.
FeatureIndex.prototype.query = function(args, styleLayers) {
    if (!this.vtLayers) {
        this.vtLayers = new vt.VectorTile(new Protobuf(new Uint8Array(this.rawTileData))).layers;
        this.sourceLayerCoder = new DictionaryCoder(this.vtLayers ? Object.keys(this.vtLayers).sort() : ['_geojsonTileLayer']);
    }

    var result = {};

    var params = args.params || {},
        pixelsToTileUnits = EXTENT / args.tileSize / args.scale,
        filter = featureFilter(params.filter);

    // Features are indexed their original geometries. The rendered geometries may
    // be buffered, translated or offset. Figure out how much the search radius needs to be
    // expanded by to include these features.
    var additionalRadius = 0;
    for (var id in styleLayers) {
        var styleLayer = styleLayers[id];
        var paint = styleLayer.paint;

        var styleLayerDistance = 0;
        if (styleLayer.type === 'line') {
            styleLayerDistance = getLineWidth(paint) / 2 + Math.abs(paint['line-offset']) + translateDistance(paint['line-translate']);
        } else if (styleLayer.type === 'fill') {
            styleLayerDistance = translateDistance(paint['fill-translate']);
        } else if (styleLayer.type === 'circle') {
            styleLayerDistance = paint['circle-radius'] + translateDistance(paint['circle-translate']);
        } else if (styleLayer.type === 'extrusion') {
            styleLayerDistance = translateDistance(paint['extrusion-translate']);
        }
        additionalRadius = Math.max(additionalRadius, styleLayerDistance * pixelsToTileUnits);
    }

    var queryGeometry = args.queryGeometry.map(function(q) {
        return q.map(function(p) {
            return new Point(p.x, p.y);
        });
    });

    var minX = Infinity;
    var minY = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    for (var i = 0; i < queryGeometry.length; i++) {
        var ring = queryGeometry[i];
        for (var k = 0; k < ring.length; k++) {
            var p = ring[k];
            minX = Math.min(minX, p.x);
            minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x);
            maxY = Math.max(maxY, p.y);
        }
    }

    var matching = this.grid.query(minX - additionalRadius, minY - additionalRadius, maxX + additionalRadius, maxY + additionalRadius);
    matching.sort(topDownFeatureComparator);
    this.filterMatching(result, matching, this.featureIndexArray, queryGeometry, filter, params.layers, styleLayers, args.bearing, pixelsToTileUnits);

    var matchingSymbols = this.collisionTile.queryRenderedSymbols(minX, minY, maxX, maxY, args.scale);
    matchingSymbols.sort();
    this.filterMatching(result, matchingSymbols, this.collisionTile.collisionBoxArray, queryGeometry, filter, params.layers, styleLayers, args.bearing, pixelsToTileUnits);

    return result;
};

function topDownFeatureComparator(a, b) {
    return b - a;
}

function getLineWidth(paint) {
    if (paint['line-gap-width'] > 0) {
        return paint['line-gap-width'] + 2 * paint['line-width'];
    } else {
        return paint['line-width'];
    }
}

FeatureIndex.prototype.filterMatching = function(result, matching, array, queryGeometry, filter, filterLayerIDs, styleLayers, bearing, pixelsToTileUnits) {
    var previousIndex;
    for (var k = 0; k < matching.length; k++) {
        var index = matching[k];

        // don't check the same feature more than once
        if (index === previousIndex) continue;
        previousIndex = index;

        var match = array.get(index);

        var layerIDs = this.bucketLayerIDs[match.bucketIndex];
        if (filterLayerIDs && !arraysIntersect(filterLayerIDs, layerIDs)) continue;

        var sourceLayerName = this.sourceLayerCoder.decode(match.sourceLayerIndex);
        var sourceLayer = this.vtLayers[sourceLayerName];
        var feature = sourceLayer.feature(match.featureIndex);

        if (!filter(feature)) continue;

        var geometry = null;

        for (var l = 0; l < layerIDs.length; l++) {
            var layerID = layerIDs[l];

            if (filterLayerIDs && filterLayerIDs.indexOf(layerID) < 0) {
                continue;
            }

            var styleLayer = styleLayers[layerID];
            if (!styleLayer) continue;

            var translatedPolygon;
            if (styleLayer.type !== 'symbol') {
                // all symbols already match the style

                if (!geometry) geometry = loadGeometry(feature);

                var paint = styleLayer.paint;

                if (styleLayer.type === 'line') {
                    translatedPolygon = translate(queryGeometry,
                            paint['line-translate'], paint['line-translate-anchor'],
                            bearing, pixelsToTileUnits);
                    var halfWidth = getLineWidth(paint) / 2 * pixelsToTileUnits;
                    if (paint['line-offset']) {
                        geometry = offsetLine(geometry, paint['line-offset'] * pixelsToTileUnits);
                    }
                    if (!multiPolygonIntersectsBufferedMultiLine(translatedPolygon, geometry, halfWidth)) continue;

                } else if (styleLayer.type === 'fill') {
                    translatedPolygon = translate(queryGeometry,
                            paint['fill-translate'], paint['fill-translate-anchor'],
                            bearing, pixelsToTileUnits);
                    if (!multiPolygonIntersectsMultiPolygon(translatedPolygon, geometry)) continue;

                } else if (styleLayer.type === 'circle') {
                    translatedPolygon = translate(queryGeometry,
                            paint['circle-translate'], paint['circle-translate-anchor'],
                            bearing, pixelsToTileUnits);
                    var circleRadius = paint['circle-radius'] * pixelsToTileUnits;
                    if (!multiPolygonIntersectsBufferedMultiPoint(translatedPolygon, geometry, circleRadius)) continue;
                } else if (styleLayer.type === 'extrusion') {
                    // TODO
                }
            }

            var geojsonFeature = new GeoJSONFeature(feature, this.z, this.x, this.y);
            geojsonFeature.layer = styleLayer.serialize({
                includeRefProperties: true
            });
            var layerResult = result[layerID];
            if (layerResult === undefined) {
                layerResult = result[layerID] = [];
            }
            layerResult.push(geojsonFeature);
        }
    }
};

function translate(queryGeometry, translate, translateAnchor, bearing, pixelsToTileUnits) {
    if (!translate[0] && !translate[1]) {
        return queryGeometry;
    }

    translate = Point.convert(translate);

    if (translateAnchor === "viewport") {
        translate._rotate(-bearing);
    }

    var translated = [];
    for (var i = 0; i < queryGeometry.length; i++) {
        var ring = queryGeometry[i];
        var translatedRing = [];
        for (var k = 0; k < ring.length; k++) {
            translatedRing.push(ring[k].sub(translate._mult(pixelsToTileUnits)));
        }
        translated.push(translatedRing);
    }
    return translated;
}

function offsetLine(rings, offset) {
    var newRings = [];
    var zero = new Point(0, 0);
    for (var k = 0; k < rings.length; k++) {
        var ring = rings[k];
        var newRing = [];
        for (var i = 0; i < ring.length; i++) {
            var a = ring[i - 1];
            var b = ring[i];
            var c = ring[i + 1];
            var aToB = i === 0 ? zero : b.sub(a)._unit()._perp();
            var bToC = i === ring.length - 1 ? zero : c.sub(b)._unit()._perp();
            var extrude = aToB._add(bToC)._unit();

            var cosHalfAngle = extrude.x * bToC.x + extrude.y * bToC.y;
            extrude._mult(1 / cosHalfAngle);

            newRing.push(extrude._mult(offset)._add(b));
        }
        newRings.push(newRing);
    }
    return newRings;
}

},{"../util/dictionary_coder":109,"../util/intersection_tests":115,"../util/struct_array":118,"../util/util":120,"../util/vectortile_to_geojson":121,"./bucket":2,"./load_geometry":11,"feature-filter":136,"grid-index":157,"pbf":185,"point-geometry":187,"vector-tile":198}],11:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var EXTENT = require('./bucket').EXTENT;
var assert = require('assert');


// These bounds define the minimum and maximum supported coordinate values.
// While visible coordinates are within [0, EXTENT], tiles may theoretically
// contain cordinates within [-Infinity, Infinity]. Our range is limited by the
// number of bits used to represent the coordinate.
function createBounds(bits) {
    return {
        min: -1 * Math.pow(2, bits - 1),
        max: Math.pow(2, bits - 1) - 1
    };
}

var boundsLookup = {
    15: createBounds(15),
    16: createBounds(16)
};

/**
 * Loads a geometry from a VectorTileFeature and scales it to the common extent
 * used internally.
 * @param {VectorTileFeature} feature
 * @param {number} [bits=16] The number of signed integer bits available to store
 *   each coordinate. A warning will be issued if any coordinate will not fits
 *   in the specified number of bits.
 * @private
 */
module.exports = function loadGeometry(feature, bits) {
    var bounds = boundsLookup[bits || 16];
    assert(bounds);

    var scale = EXTENT / feature.extent;
    var geometry = feature.loadGeometry();
    for (var r = 0; r < geometry.length; r++) {
        var ring = geometry[r];
        for (var p = 0; p < ring.length; p++) {
            var point = ring[p];
            // round here because mapbox-gl-native uses integers to represent
            // points and we need to do the same to avoid renering differences.
            point.x = Math.round(point.x * scale);
            point.y = Math.round(point.y * scale);

            if (point.x < bounds.min || point.x > bounds.max || point.y < bounds.min || point.y > bounds.max) {
                util.warnOnce('Geometry exceeds allowed extent, reduce your vector tile buffer size');
            }
        }
    }
    return geometry;
};

},{"../util/util":120,"./bucket":2,"assert":122}],12:[function(require,module,exports){
'use strict';

module.exports = Coordinate;

/**
 * A coordinate is a column, row, zoom combination, often used
 * as the data component of a tile.
 *
 * @param {number} column
 * @param {number} row
 * @param {number} zoom
 * @private
 */
function Coordinate(column, row, zoom) {
    this.column = column;
    this.row = row;
    this.zoom = zoom;
}

Coordinate.prototype = {

    /**
     * Create a clone of this coordinate that can be mutated without
     * changing the original coordinate
     *
     * @returns {Coordinate} clone
     * @private
     * var coord = new Coordinate(0, 0, 0);
     * var c2 = coord.clone();
     * // since coord is cloned, modifying a property of c2 does
     * // not modify it.
     * c2.zoom = 2;
     */
    clone: function() {
        return new Coordinate(this.column, this.row, this.zoom);
    },

    /**
     * Zoom this coordinate to a given zoom level. This returns a new
     * coordinate object, not mutating the old one.
     *
     * @param {number} zoom
     * @returns {Coordinate} zoomed coordinate
     * @private
     * @example
     * var coord = new Coordinate(0, 0, 0);
     * var c2 = coord.zoomTo(1);
     * c2 // equals new Coordinate(0, 0, 1);
     */
    zoomTo: function(zoom) { return this.clone()._zoomTo(zoom); },

    /**
     * Subtract the column and row values of this coordinate from those
     * of another coordinate. The other coordinat will be zoomed to the
     * same level as `this` before the subtraction occurs
     *
     * @param {Coordinate} c other coordinate
     * @returns {Coordinate} result
     * @private
     */
    sub: function(c) { return this.clone()._sub(c); },

    _zoomTo: function(zoom) {
        var scale = Math.pow(2, zoom - this.zoom);
        this.column *= scale;
        this.row *= scale;
        this.zoom = zoom;
        return this;
    },

    _sub: function(c) {
        c = c.zoomTo(this.zoom);
        this.column -= c.column;
        this.row -= c.row;
        return this;
    }
};

},{}],13:[function(require,module,exports){
'use strict';

module.exports = LngLat;

var wrap = require('../util/util').wrap;

/**
 * A `LngLat` object represents a given longitude and latitude coordinate, measured in degrees.
 *
 * Mapbox GL uses longitude, latitude coordinate order (as opposed to latitude, longitude) to match GeoJSON.
 *
 * Note that any Mapbox GL method that accepts a `LngLat` object as an argument or option
 * can also accept an `Array` of two numbers and will perform an implicit conversion.
 * This flexible type is documented as [`LngLatLike`](#LngLatLike).
 *
 * @class LngLat
 * @param {number} lng Longitude, measured in degrees.
 * @param {number} lat Latitude, measured in degrees.
 * @example
 * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);
 */
function LngLat(lng, lat) {
    if (isNaN(lng) || isNaN(lat)) {
        throw new Error('Invalid LngLat object: (' + lng + ', ' + lat + ')');
    }
    this.lng = +lng;
    this.lat = +lat;
    if (this.lat > 90 || this.lat < -90) {
        throw new Error('Invalid LngLat latitude value: must be between -90 and 90');
    }
}

/**
 * Returns a new `LngLat` object whose longitude is wrapped to the range (-180, 180).
 *
 * @returns {LngLat} The wrapped `LngLat` object.
 * @example
 * var ll = new mapboxgl.LngLat(286.0251, 40.7736);
 * var wrapped = ll.wrap();
 * wrapped.lng; // = -73.9749
 */
LngLat.prototype.wrap = function () {
    return new LngLat(wrap(this.lng, -180, 180), this.lat);
};

/**
 * Returns the coordinates represented as an array of two numbers.
 *
 * @returns {Array<number>} The coordinates represeted as an array of longitude and latitude.
 * @example
 * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);
 * ll.toArray(); // = [-73.9749, 40.7736]
 */
LngLat.prototype.toArray = function () {
    return [this.lng, this.lat];
};

/**
 * Returns the coordinates represent as a string.
 *
 * @returns {string} The coordinates represented as a string of the format `'LngLat(lng, lat)'`.
 * @example
 * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);
 * ll.toString(); // = "LngLat(-73.9749, 40.7736)"
 */
LngLat.prototype.toString = function () {
    return 'LngLat(' + this.lng + ', ' + this.lat + ')';
};

/**
 * Converts an array of two numbers to a `LngLat` object.
 *
 * If a `LngLat` object is passed in, the function returns it unchanged.
 *
 * @param {LngLatLike} input An array of two numbers to convert, or a `LngLat` object to return.
 * @returns {LngLat} A new `LngLat` object, if a conversion occurred, or the original `LngLat` object.
 * @example
 * var arr = [-73.9749, 40.7736];
 * var ll = mapboxgl.LngLat.convert(arr);
 * ll;   // = LngLat {lng: -73.9749, lat: 40.7736}
 */
LngLat.convert = function (input) {
    if (input instanceof LngLat) {
        return input;
    }
    if (Array.isArray(input)) {
        return new LngLat(input[0], input[1]);
    }
    return input;
};

},{"../util/util":120}],14:[function(require,module,exports){
'use strict';

module.exports = LngLatBounds;

var LngLat = require('./lng_lat');

/**
 * A `LngLatBounds` object represents a geographical bounding box,
 * defined by its southwest and northeast points in longitude and latitude.
 *
 * If no arguments are provided to the constructor, a `null` bounding box is created.
 *
 * Note that any Mapbox GL method that accepts a `LngLatBounds` object as an argument or option
 * can also accept an `Array` of two [`LngLatLike`](#LngLatLike) constructs and will perform an implicit conversion.
 * This flexible type is documented as [`LngLatBoundsLike`](#LngLatBoundsLike).
 *
 * @class LngLatBounds
 * @param {LngLatLike} sw The southwest corner of the bounding box.
 * @param {LngLatLike} ne The northeast corner of the bounding box.
 * @example
 * var sw = new mapboxgl.LngLat(-73.9876, 40.7661);
 * var ne = new mapboxgl.LngLat(-73.9397, 40.8002);
 * var llb = new mapboxgl.LngLatBounds(sw, ne);
 */
function LngLatBounds(sw, ne) {
    if (!sw) {
        return;
    } else if (ne) {
        this.extend(sw).extend(ne);
    } else if (sw.length === 4) {
        this.extend([sw[0], sw[1]]).extend([sw[2], sw[3]]);
    } else {
        this.extend(sw[0]).extend(sw[1]);
    }
}

LngLatBounds.prototype = {

    /**
     * Extends the bounding box to include an area represented by a `LngLat` or `LngLatBounds`.
     *
     * @param {LngLatLike|LngLatBoundsLike} obj The area that the bounding box will extend to include.
     * @returns {LngLatBounds} `this`
     */
    extend: function(obj) {
        var sw = this._sw,
            ne = this._ne,
            sw2, ne2;

        if (obj instanceof LngLat) {
            sw2 = obj;
            ne2 = obj;

        } else if (obj instanceof LngLatBounds) {
            sw2 = obj._sw;
            ne2 = obj._ne;

            if (!sw2 || !ne2) return this;

        } else {
            return obj ? this.extend(LngLat.convert(obj) || LngLatBounds.convert(obj)) : this;
        }

        if (!sw && !ne) {
            this._sw = new LngLat(sw2.lng, sw2.lat);
            this._ne = new LngLat(ne2.lng, ne2.lat);

        } else {
            sw.lng = Math.min(sw2.lng, sw.lng);
            sw.lat = Math.min(sw2.lat, sw.lat);
            ne.lng = Math.max(ne2.lng, ne.lng);
            ne.lat = Math.max(ne2.lat, ne.lat);
        }

        return this;
    },

    /**
     * Returns the geographical coordinate equidistant from the bounding box's corners.
     *
     * @returns {LngLat} The bounding box's center.
     * @example
     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
     * llb.getCenter(); // = LngLat {lng: -73.96365, lat: 40.78315}
     */
    getCenter: function() {
        return new LngLat((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
    },

    /**
     * Returns the southwest corner of the bounding box.
     *
     * @returns {LngLat} The southwest corner of the bounding box.
     */
    getSouthWest: function() { return this._sw; },

    /**
    * Returns the northeast corner of the bounding box.
    *
    * @returns {LngLat} The northeast corner of the bounding box.
     */
    getNorthEast: function() { return this._ne; },

    /**
    * Returns the northwest corner of the bounding box.
    *
    * @returns {LngLat} The northwest corner of the bounding box.
     */
    getNorthWest: function() { return new LngLat(this.getWest(), this.getNorth()); },

    /**
    * Returns the southeast corner of the bounding box.
    *
    * @returns {LngLat} The southeast corner of the bounding box.
     */
    getSouthEast: function() { return new LngLat(this.getEast(), this.getSouth()); },

    /**
    * Returns the west edge of the bounding box.
    *
    * @returns {LngLat} The west edge of the bounding box.
     */
    getWest:  function() { return this._sw.lng; },

    /**
    * Returns the south edge of the bounding box.
    *
    * @returns {LngLat} The south edge of the bounding box.
     */
    getSouth: function() { return this._sw.lat; },

    /**
    * Returns the east edge of the bounding box.
    *
    * @returns {LngLat} The east edge of the bounding box.
     */
    getEast:  function() { return this._ne.lng; },

    /**
    * Returns the north edge of the bounding box.
    *
    * @returns {LngLat} The north edge of the bounding box.
     */
    getNorth: function() { return this._ne.lat; },

    /**
     * Returns the bounding box represented as an array.
     *
     * @returns {Array<Array<number>>} The bounding box represented as an array, consisting of the
     *   southwest and northeast coordinates of the bounding represented as arrays of numbers.
     * @example
     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
     * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]
     */
    toArray: function () {
        return [this._sw.toArray(), this._ne.toArray()];
    },

    /**
     * Return the bounding box represented as a string.
     *
     * @returns {string} The bounding box represents as a string of the format
     *   `'LngLatBounds(LngLat(lng, lat), LngLat(lng, lat))'`.
     * @example
     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
     * llb.toString(); // = "LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))"
     */
    toString: function () {
        return 'LngLatBounds(' + this._sw.toString() + ', ' + this._ne.toString() + ')';
    }
};

/**
 * Converts an array to a `LngLatBounds` object.
 *
 * If a `LngLatBounds` object is passed in, the function returns it unchanged.
 *
 * Internally, the function calls `LngLat#convert` to convert arrays to `LngLat` values.
 *
 * @param {LngLatBoundsLike} input An array of two coordinates to convert, or a `LngLatBounds` object to return.
 * @returns {LngLatBounds} A new `LngLatBounds` object, if a conversion occurred, or the original `LngLatBounds` object.
 * @example
 * var arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];
 * var llb = mapboxgl.LngLatBounds.convert(arr);
 * llb;   // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}
 */
LngLatBounds.convert = function (input) {
    if (!input || input instanceof LngLatBounds) return input;
    return new LngLatBounds(input);
};

},{"./lng_lat":13}],15:[function(require,module,exports){
'use strict';

var LngLat = require('./lng_lat'),
    Point = require('point-geometry'),
    Coordinate = require('./coordinate'),
    wrap = require('../util/util').wrap,
    interp = require('../util/interpolate'),
    TileCoord = require('../source/tile_coord'),
    EXTENT = require('../data/bucket').EXTENT,
    glmatrix = require('gl-matrix');

var vec4 = glmatrix.vec4,
    mat4 = glmatrix.mat4,
    mat2 = glmatrix.mat2;

module.exports = Transform;

/**
 * A single transform, generally used for a single tile to be
 * scaled, rotated, and zoomed.
 *
 * @param {number} minZoom
 * @param {number} maxZoom
 * @private
 */
function Transform(minZoom, maxZoom) {
    this.tileSize = 512; // constant

    this._minZoom = minZoom || 0;
    this._maxZoom = maxZoom || 22;

    this.latRange = [-85.05113, 85.05113];

    this.width = 0;
    this.height = 0;
    this._center = new LngLat(0, 0);
    this.zoom = 0;
    this.angle = 0;
    this._altitude = 1.5;
    this._pitch = 0;
    this._unmodified = true;
}

Transform.prototype = {
    get minZoom() { return this._minZoom; },
    set minZoom(zoom) {
        if (this._minZoom === zoom) return;
        this._minZoom = zoom;
        this.zoom = Math.max(this.zoom, zoom);
    },

    get maxZoom() { return this._maxZoom; },
    set maxZoom(zoom) {
        if (this._maxZoom === zoom) return;
        this._maxZoom = zoom;
        this.zoom = Math.min(this.zoom, zoom);
    },

    get worldSize() {
        return this.tileSize * this.scale;
    },

    get centerPoint() {
        return this.size._div(2);
    },

    get size() {
        return new Point(this.width, this.height);
    },

    get bearing() {
        return -this.angle / Math.PI * 180;
    },
    set bearing(bearing) {
        var b = -wrap(bearing, -180, 180) * Math.PI / 180;
        if (this.angle === b) return;
        this._unmodified = false;
        this.angle = b;
        this._calcMatrices();

        // 2x2 matrix for rotating points
        this.rotationMatrix = mat2.create();
        mat2.rotate(this.rotationMatrix, this.rotationMatrix, this.angle);
    },

    get pitch() {
        return this._pitch / Math.PI * 180;
    },
    set pitch(pitch) {
        var p = Math.min(60, pitch) / 180 * Math.PI;
        if (this._pitch === p) return;
        this._unmodified = false;
        this._pitch = p;
        this._calcMatrices();
    },

    get altitude() {
        return this._altitude;
    },
    set altitude(altitude) {
        var a = Math.max(0.75, altitude);
        if (this._altitude === a) return;
        this._unmodified = false;
        this._altitude = a;
        this._calcMatrices();
    },

    get zoom() { return this._zoom; },
    set zoom(zoom) {
        var z = Math.min(Math.max(zoom, this.minZoom), this.maxZoom);
        if (this._zoom === z) return;
        this._unmodified = false;
        this._zoom = z;
        this.scale = this.zoomScale(z);
        this.tileZoom = Math.floor(z);
        this.zoomFraction = z - this.tileZoom;
        this._calcMatrices();
        this._constrain();
    },

    get center() { return this._center; },
    set center(center) {
        if (center.lat === this._center.lat && center.lng === this._center.lng) return;
        this._unmodified = false;
        this._center = center;
        this._calcMatrices();
        this._constrain();
    },

    /**
     * Return a zoom level that will cover all tiles the transform
     * @param {Object} options
     * @param {number} options.tileSize
     * @param {boolean} options.roundZoom
     * @returns {number} zoom level
     * @private
     */
    coveringZoomLevel: function(options) {
        return (options.roundZoom ? Math.round : Math.floor)(
            this.zoom + this.scaleZoom(this.tileSize / options.tileSize)
        );
    },

    /**
     * Return all coordinates that could cover this transform for a covering
     * zoom level.
     * @param {Object} options
     * @param {number} options.tileSize
     * @param {number} options.minzoom
     * @param {number} options.maxzoom
     * @param {boolean} options.roundZoom
     * @param {boolean} options.reparseOverscaled
     * @returns {Array<Tile>} tiles
     * @private
     */
    coveringTiles: function(options) {
        var z = this.coveringZoomLevel(options);
        var actualZ = z;

        if (z < options.minzoom) return [];
        if (z > options.maxzoom) z = options.maxzoom;

        var tr = this,
            tileCenter = tr.locationCoordinate(tr.center)._zoomTo(z),
            centerPoint = new Point(tileCenter.column - 0.5, tileCenter.row - 0.5);

        return TileCoord.cover(z, [
            tr.pointCoordinate(new Point(0, 0))._zoomTo(z),
            tr.pointCoordinate(new Point(tr.width, 0))._zoomTo(z),
            tr.pointCoordinate(new Point(tr.width, tr.height))._zoomTo(z),
            tr.pointCoordinate(new Point(0, tr.height))._zoomTo(z)
        ], options.reparseOverscaled ? actualZ : z).sort(function(a, b) {
            return centerPoint.dist(a) - centerPoint.dist(b);
        });
    },

    resize: function(width, height) {
        this.width = width;
        this.height = height;

        this.pixelsToGLUnits = [2 / width, -2 / height];
        this._calcMatrices();
        this._constrain();
    },

    get unmodified() { return this._unmodified; },

    zoomScale: function(zoom) { return Math.pow(2, zoom); },
    scaleZoom: function(scale) { return Math.log(scale) / Math.LN2; },

    project: function(lnglat, worldSize) {
        return new Point(
            this.lngX(lnglat.lng, worldSize),
            this.latY(lnglat.lat, worldSize));
    },

    unproject: function(point, worldSize) {
        return new LngLat(
            this.xLng(point.x, worldSize),
            this.yLat(point.y, worldSize));
    },

    get x() { return this.lngX(this.center.lng); },
    get y() { return this.latY(this.center.lat); },

    get point() { return new Point(this.x, this.y); },

    /**
     * latitude to absolute x coord
     * @param {number} lon
     * @param {number} [worldSize=this.worldSize]
     * @returns {number} pixel coordinate
     * @private
     */
    lngX: function(lng, worldSize) {
        return (180 + lng) * (worldSize || this.worldSize) / 360;
    },
    /**
     * latitude to absolute y coord
     * @param {number} lat
     * @param {number} [worldSize=this.worldSize]
     * @returns {number} pixel coordinate
     * @private
     */
    latY: function(lat, worldSize) {
        var y = 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360));
        return (180 - y) * (worldSize || this.worldSize) / 360;
    },

    xLng: function(x, worldSize) {
        return x * 360 / (worldSize || this.worldSize) - 180;
    },
    yLat: function(y, worldSize) {
        var y2 = 180 - y * 360 / (worldSize || this.worldSize);
        return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
    },

    panBy: function(offset) {
        var point = this.centerPoint._add(offset);
        this.center = this.pointLocation(point);
    },

    setLocationAtPoint: function(lnglat, point) {
        var c = this.locationCoordinate(lnglat);
        var coordAtPoint = this.pointCoordinate(point);
        var coordCenter = this.pointCoordinate(this.centerPoint);
        var translate = coordAtPoint._sub(c);
        this._unmodified = false;
        this.center = this.coordinateLocation(coordCenter._sub(translate));
    },

    /**
     * Given a location, return the screen point that corresponds to it
     * @param {LngLat} lnglat location
     * @returns {Point} screen point
     * @private
     */
    locationPoint: function(lnglat) {
        return this.coordinatePoint(this.locationCoordinate(lnglat));
    },

    /**
     * Given a point on screen, return its lnglat
     * @param {Point} p screen point
     * @returns {LngLat} lnglat location
     * @private
     */
    pointLocation: function(p) {
        return this.coordinateLocation(this.pointCoordinate(p));
    },

    /**
     * Given a geographical lnglat, return an unrounded
     * coordinate that represents it at this transform's zoom level and
     * worldsize.
     * @param {LngLat} lnglat
     * @returns {Coordinate}
     * @private
     */
    locationCoordinate: function(lnglat) {
        var k = this.zoomScale(this.tileZoom) / this.worldSize,
            ll = LngLat.convert(lnglat);

        return new Coordinate(
            this.lngX(ll.lng) * k,
            this.latY(ll.lat) * k,
            this.tileZoom);
    },

    /**
     * Given a Coordinate, return its geographical position.
     * @param {Coordinate} coord
     * @returns {LngLat} lnglat
     * @private
     */
    coordinateLocation: function(coord) {
        var worldSize = this.zoomScale(coord.zoom);
        return new LngLat(
            this.xLng(coord.column, worldSize),
            this.yLat(coord.row, worldSize));
    },

    pointCoordinate: function(p) {

        var targetZ = 0;
        // since we don't know the correct projected z value for the point,
        // unproject two points to get a line and then find the point on that
        // line with z=0

        var coord0 = [p.x, p.y, 0, 1];
        var coord1 = [p.x, p.y, 1, 1];

        vec4.transformMat4(coord0, coord0, this.pixelMatrixInverse);
        vec4.transformMat4(coord1, coord1, this.pixelMatrixInverse);

        var w0 = coord0[3];
        var w1 = coord1[3];
        var x0 = coord0[0] / w0;
        var x1 = coord1[0] / w1;
        var y0 = coord0[1] / w0;
        var y1 = coord1[1] / w1;
        var z0 = coord0[2] / w0;
        var z1 = coord1[2] / w1;


        var t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);
        var scale = this.worldSize / this.zoomScale(this.tileZoom);

        return new Coordinate(
            interp(x0, x1, t) / scale,
            interp(y0, y1, t) / scale,
            this.tileZoom);
    },

    /**
     * Given a coordinate, return the screen point that corresponds to it
     * @param {Coordinate} coord
     * @returns {Point} screen point
     * @private
     */
    coordinatePoint: function(coord) {
        var scale = this.worldSize / this.zoomScale(coord.zoom);
        var p = [coord.column * scale, coord.row * scale, 0, 1];
        vec4.transformMat4(p, p, this.pixelMatrix);
        return new Point(p[0] / p[3], p[1] / p[3]);
    },

    /**
     * Calculate the posMatrix that, given a tile coordinate, would be used to display the tile on a map.
     * @param {TileCoord|Coordinate} coord
     * @param {Number} maxZoom maximum source zoom to account for overscaling
     * @private
     */
    calculatePosMatrix: function(coord, maxZoom) {
        if (maxZoom === undefined) maxZoom = Infinity;
        if (coord instanceof TileCoord) coord = coord.toCoordinate(maxZoom);

        // Initialize model-view matrix that converts from the tile coordinates to screen coordinates.

        // if z > maxzoom then the tile is actually a overscaled maxzoom tile,
        // so calculate the matrix the maxzoom tile would use.
        var z = Math.min(coord.zoom, maxZoom);

        var scale = this.worldSize / Math.pow(2, z);
        var posMatrix = new Float64Array(16);

        mat4.identity(posMatrix);
        mat4.translate(posMatrix, posMatrix, [coord.column * scale, coord.row * scale, 0]);
        mat4.scale(posMatrix, posMatrix, [ scale / EXTENT, scale / EXTENT, 1 ]);
        mat4.multiply(posMatrix, this.projMatrix, posMatrix);

        return new Float32Array(posMatrix);
    },

    _constrain: function() {
        if (!this.center || !this.width || !this.height || this._constraining) return;

        this._constraining = true;

        var minY, maxY, minX, maxX, sy, sx, x2, y2,
            size = this.size,
            unmodified = this._unmodified;

        if (this.latRange) {
            minY = this.latY(this.latRange[1]);
            maxY = this.latY(this.latRange[0]);
            sy = maxY - minY < size.y ? size.y / (maxY - minY) : 0;
        }

        if (this.lngRange) {
            minX = this.lngX(this.lngRange[0]);
            maxX = this.lngX(this.lngRange[1]);
            sx = maxX - minX < size.x ? size.x / (maxX - minX) : 0;
        }

        // how much the map should scale to fit the screen into given latitude/longitude ranges
        var s = Math.max(sx || 0, sy || 0);

        if (s) {
            this.center = this.unproject(new Point(
                sx ? (maxX + minX) / 2 : this.x,
                sy ? (maxY + minY) / 2 : this.y));
            this.zoom += this.scaleZoom(s);
            this._unmodified = unmodified;
            this._constraining = false;
            return;
        }

        if (this.latRange) {
            var y = this.y,
                h2 = size.y / 2;

            if (y - h2 < minY) y2 = minY + h2;
            if (y + h2 > maxY) y2 = maxY - h2;
        }

        if (this.lngRange) {
            var x = this.x,
                w2 = size.x / 2;

            if (x - w2 < minX) x2 = minX + w2;
            if (x + w2 > maxX) x2 = maxX - w2;
        }

        // pan the map if the screen goes off the range
        if (x2 !== undefined || y2 !== undefined) {
            this.center = this.unproject(new Point(
                x2 !== undefined ? x2 : this.x,
                y2 !== undefined ? y2 : this.y));
        }

        this._unmodified = unmodified;
        this._constraining = false;
    },

    _calcMatrices: function() {
        if (!this.height) return;

        // Find the distance from the center point to the center top in altitude units using law of sines.
        var halfFov = Math.atan(0.5 / this.altitude);
        var topHalfSurfaceDistance = Math.sin(halfFov) * this.altitude / Math.sin(Math.PI / 2 - this._pitch - halfFov);

        // Calculate z value of the farthest fragment that should be rendered.
        var farZ = Math.cos(Math.PI / 2 - this._pitch) * topHalfSurfaceDistance + this.altitude;

        // matrix for conversion from location to GL coordinates (-1 .. 1)
        var m = new Float64Array(16);
        mat4.perspective(m, 2 * Math.atan((this.height / 2) / this.altitude), this.width / this.height, 0.1, farZ);
        mat4.translate(m, m, [0, 0, -this.altitude]);

        // After the rotateX, z values are in pixel units. Convert them to
        // altitude units. 1 altitude unit = the screen height.
        mat4.scale(m, m, [1, -1, 1 / this.height]);

        mat4.rotateX(m, m, this._pitch);
        mat4.rotateZ(m, m, this.angle);
        mat4.translate(m, m, [-this.x, -this.y, 0]);

        this.projMatrix = m;

        // matrix for conversion from location to screen coordinates
        m = mat4.create();
        mat4.scale(m, m, [this.width / 2, -this.height / 2, 1]);
        mat4.translate(m, m, [1, -1, 0]);
        this.pixelMatrix = mat4.multiply(new Float64Array(16), m, this.projMatrix);

        // inverse matrix for conversion from screen coordinaes to location
        m = mat4.invert(new Float64Array(16), this.pixelMatrix);
        if (!m) throw new Error("failed to invert matrix");
        this.pixelMatrixInverse = m;
    }
};

},{"../data/bucket":2,"../source/tile_coord":44,"../util/interpolate":114,"../util/util":120,"./coordinate":12,"./lng_lat":13,"gl-matrix":147,"point-geometry":187}],16:[function(require,module,exports){
'use strict';

// Font data From Hershey Simplex Font
// http://paulbourke.net/dataformats/hershey/
var simplexFont = {
    " ": [16, []],
    "!": [10, [5, 21, 5, 7, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
    "\"": [16, [4, 21, 4, 14, -1, -1, 12, 21, 12, 14]],
    "#": [21, [11, 25, 4, -7, -1, -1, 17, 25, 10, -7, -1, -1, 4, 12, 18, 12, -1, -1, 3, 6, 17, 6]],
    "$": [20, [8, 25, 8, -4, -1, -1, 12, 25, 12, -4, -1, -1, 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],
    "%": [24, [21, 21, 3, 0, -1, -1, 8, 21, 10, 19, 10, 17, 9, 15, 7, 14, 5, 14, 3, 16, 3, 18, 4, 20, 6, 21, 8, 21, 10, 20, 13, 19, 16, 19, 19, 20, 21, 21, -1, -1, 17, 7, 15, 6, 14, 4, 14, 2, 16, 0, 18, 0, 20, 1, 21, 3, 21, 5, 19, 7, 17, 7]],
    "&": [26, [23, 12, 23, 13, 22, 14, 21, 14, 20, 13, 19, 11, 17, 6, 15, 3, 13, 1, 11, 0, 7, 0, 5, 1, 4, 2, 3, 4, 3, 6, 4, 8, 5, 9, 12, 13, 13, 14, 14, 16, 14, 18, 13, 20, 11, 21, 9, 20, 8, 18, 8, 16, 9, 13, 11, 10, 16, 3, 18, 1, 20, 0, 22, 0, 23, 1, 23, 2]],
    "'": [10, [5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15]],
    "(": [14, [11, 25, 9, 23, 7, 20, 5, 16, 4, 11, 4, 7, 5, 2, 7, -2, 9, -5, 11, -7]],
    ")": [14, [3, 25, 5, 23, 7, 20, 9, 16, 10, 11, 10, 7, 9, 2, 7, -2, 5, -5, 3, -7]],
    "*": [16, [8, 21, 8, 9, -1, -1, 3, 18, 13, 12, -1, -1, 13, 18, 3, 12]],
    "+": [26, [13, 18, 13, 0, -1, -1, 4, 9, 22, 9]],
    ",": [10, [6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],
    "-": [26, [4, 9, 22, 9]],
    ".": [10, [5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
    "/": [22, [20, 25, 2, -7]],
    "0": [20, [9, 21, 6, 20, 4, 17, 3, 12, 3, 9, 4, 4, 6, 1, 9, 0, 11, 0, 14, 1, 16, 4, 17, 9, 17, 12, 16, 17, 14, 20, 11, 21, 9, 21]],
    "1": [20, [6, 17, 8, 18, 11, 21, 11, 0]],
    "2": [20, [4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10, 3, 0, 17, 0]],
    "3": [20, [5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],
    "4": [20, [13, 21, 3, 7, 18, 7, -1, -1, 13, 21, 13, 0]],
    "5": [20, [15, 21, 5, 21, 4, 12, 5, 13, 8, 14, 11, 14, 14, 13, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],
    "6": [20, [16, 18, 15, 20, 12, 21, 10, 21, 7, 20, 5, 17, 4, 12, 4, 7, 5, 3, 7, 1, 10, 0, 11, 0, 14, 1, 16, 3, 17, 6, 17, 7, 16, 10, 14, 12, 11, 13, 10, 13, 7, 12, 5, 10, 4, 7]],
    "7": [20, [17, 21, 7, 0, -1, -1, 3, 21, 17, 21]],
    "8": [20, [8, 21, 5, 20, 4, 18, 4, 16, 5, 14, 7, 13, 11, 12, 14, 11, 16, 9, 17, 7, 17, 4, 16, 2, 15, 1, 12, 0, 8, 0, 5, 1, 4, 2, 3, 4, 3, 7, 4, 9, 6, 11, 9, 12, 13, 13, 15, 14, 16, 16, 16, 18, 15, 20, 12, 21, 8, 21]],
    "9": [20, [16, 14, 15, 11, 13, 9, 10, 8, 9, 8, 6, 9, 4, 11, 3, 14, 3, 15, 4, 18, 6, 20, 9, 21, 10, 21, 13, 20, 15, 18, 16, 14, 16, 9, 15, 4, 13, 1, 10, 0, 8, 0, 5, 1, 4, 3]],
    ":": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],
    ";": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],
    "<": [24, [20, 18, 4, 9, 20, 0]],
    "=": [26, [4, 12, 22, 12, -1, -1, 4, 6, 22, 6]],
    ">": [24, [4, 18, 20, 9, 4, 0]],
    "?": [18, [3, 16, 3, 17, 4, 19, 5, 20, 7, 21, 11, 21, 13, 20, 14, 19, 15, 17, 15, 15, 14, 13, 13, 12, 9, 10, 9, 7, -1, -1, 9, 2, 8, 1, 9, 0, 10, 1, 9, 2]],
    "@": [27, [18, 13, 17, 15, 15, 16, 12, 16, 10, 15, 9, 14, 8, 11, 8, 8, 9, 6, 11, 5, 14, 5, 16, 6, 17, 8, -1, -1, 12, 16, 10, 14, 9, 11, 9, 8, 10, 6, 11, 5, -1, -1, 18, 16, 17, 8, 17, 6, 19, 5, 21, 5, 23, 7, 24, 10, 24, 12, 23, 15, 22, 17, 20, 19, 18, 20, 15, 21, 12, 21, 9, 20, 7, 19, 5, 17, 4, 15, 3, 12, 3, 9, 4, 6, 5, 4, 7, 2, 9, 1, 12, 0, 15, 0, 18, 1, 20, 2, 21, 3, -1, -1, 19, 16, 18, 8, 18, 6, 19, 5]],
    "A": [18, [9, 21, 1, 0, -1, -1, 9, 21, 17, 0, -1, -1, 4, 7, 14, 7]],
    "B": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, -1, -1, 4, 11, 13, 11, 16, 10, 17, 9, 18, 7, 18, 4, 17, 2, 16, 1, 13, 0, 4, 0]],
    "C": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5]],
    "D": [21, [4, 21, 4, 0, -1, -1, 4, 21, 11, 21, 14, 20, 16, 18, 17, 16, 18, 13, 18, 8, 17, 5, 16, 3, 14, 1, 11, 0, 4, 0]],
    "E": [19, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11, -1, -1, 4, 0, 17, 0]],
    "F": [18, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11]],
    "G": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 18, 8, -1, -1, 13, 8, 18, 8]],
    "H": [22, [4, 21, 4, 0, -1, -1, 18, 21, 18, 0, -1, -1, 4, 11, 18, 11]],
    "I": [8, [4, 21, 4, 0]],
    "J": [16, [12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7]],
    "K": [21, [4, 21, 4, 0, -1, -1, 18, 21, 4, 7, -1, -1, 9, 12, 18, 0]],
    "L": [17, [4, 21, 4, 0, -1, -1, 4, 0, 16, 0]],
    "M": [24, [4, 21, 4, 0, -1, -1, 4, 21, 12, 0, -1, -1, 20, 21, 12, 0, -1, -1, 20, 21, 20, 0]],
    "N": [22, [4, 21, 4, 0, -1, -1, 4, 21, 18, 0, -1, -1, 18, 21, 18, 0]],
    "O": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21]],
    "P": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 14, 17, 12, 16, 11, 13, 10, 4, 10]],
    "Q": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, -1, -1, 12, 4, 18, -2]],
    "R": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, 4, 11, -1, -1, 11, 11, 18, 0]],
    "S": [20, [17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],
    "T": [16, [8, 21, 8, 0, -1, -1, 1, 21, 15, 21]],
    "U": [22, [4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21]],
    "V": [18, [1, 21, 9, 0, -1, -1, 17, 21, 9, 0]],
    "W": [24, [2, 21, 7, 0, -1, -1, 12, 21, 7, 0, -1, -1, 12, 21, 17, 0, -1, -1, 22, 21, 17, 0]],
    "X": [20, [3, 21, 17, 0, -1, -1, 17, 21, 3, 0]],
    "Y": [18, [1, 21, 9, 11, 9, 0, -1, -1, 17, 21, 9, 11]],
    "Z": [20, [17, 21, 3, 0, -1, -1, 3, 21, 17, 21, -1, -1, 3, 0, 17, 0]],
    "[": [14, [4, 25, 4, -7, -1, -1, 5, 25, 5, -7, -1, -1, 4, 25, 11, 25, -1, -1, 4, -7, 11, -7]],
    "\\": [14, [0, 21, 14, -3]],
    "]": [14, [9, 25, 9, -7, -1, -1, 10, 25, 10, -7, -1, -1, 3, 25, 10, 25, -1, -1, 3, -7, 10, -7]],
    "^": [16, [6, 15, 8, 18, 10, 15, -1, -1, 3, 12, 8, 17, 13, 12, -1, -1, 8, 17, 8, 0]],
    "_": [16, [0, -2, 16, -2]],
    "`": [10, [6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17]],
    "a": [19, [15, 14, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "b": [19, [4, 21, 4, 0, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],
    "c": [18, [15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "d": [19, [15, 21, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "e": [18, [3, 8, 15, 8, 15, 10, 14, 12, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "f": [12, [10, 21, 8, 21, 6, 20, 5, 17, 5, 0, -1, -1, 2, 14, 9, 14]],
    "g": [19, [15, 14, 15, -2, 14, -5, 13, -6, 11, -7, 8, -7, 6, -6, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "h": [19, [4, 21, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
    "i": [8, [3, 21, 4, 20, 5, 21, 4, 22, 3, 21, -1, -1, 4, 14, 4, 0]],
    "j": [10, [5, 21, 6, 20, 7, 21, 6, 22, 5, 21, -1, -1, 6, 14, 6, -3, 5, -6, 3, -7, 1, -7]],
    "k": [17, [4, 21, 4, 0, -1, -1, 14, 14, 4, 4, -1, -1, 8, 8, 15, 0]],
    "l": [8, [4, 21, 4, 0]],
    "m": [30, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0, -1, -1, 15, 10, 18, 13, 20, 14, 23, 14, 25, 13, 26, 10, 26, 0]],
    "n": [19, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],
    "o": [19, [8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3, 16, 6, 16, 8, 15, 11, 13, 13, 11, 14, 8, 14]],
    "p": [19, [4, 14, 4, -7, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],
    "q": [19, [15, 14, 15, -7, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],
    "r": [13, [4, 14, 4, 0, -1, -1, 4, 8, 5, 11, 7, 13, 9, 14, 12, 14]],
    "s": [17, [14, 11, 13, 13, 10, 14, 7, 14, 4, 13, 3, 11, 4, 9, 6, 8, 11, 7, 13, 6, 14, 4, 14, 3, 13, 1, 10, 0, 7, 0, 4, 1, 3, 3]],
    "t": [12, [5, 21, 5, 4, 6, 1, 8, 0, 10, 0, -1, -1, 2, 14, 9, 14]],
    "u": [19, [4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, -1, -1, 15, 14, 15, 0]],
    "v": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0]],
    "w": [22, [3, 14, 7, 0, -1, -1, 11, 14, 7, 0, -1, -1, 11, 14, 15, 0, -1, -1, 19, 14, 15, 0]],
    "x": [17, [3, 14, 14, 0, -1, -1, 14, 14, 3, 0]],
    "y": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0, 6, -4, 4, -6, 2, -7, 1, -7]],
    "z": [17, [14, 14, 3, 0, -1, -1, 3, 14, 14, 14, -1, -1, 3, 0, 14, 0]],
    "{": [14, [9, 25, 7, 24, 6, 23, 5, 21, 5, 19, 6, 17, 7, 16, 8, 14, 8, 12, 6, 10, -1, -1, 7, 24, 6, 22, 6, 20, 7, 18, 8, 17, 9, 15, 9, 13, 8, 11, 4, 9, 8, 7, 9, 5, 9, 3, 8, 1, 7, 0, 6, -2, 6, -4, 7, -6, -1, -1, 6, 8, 8, 6, 8, 4, 7, 2, 6, 1, 5, -1, 5, -3, 6, -5, 7, -6, 9, -7]],
    "|": [8, [4, 25, 4, -7]],
    "}": [14, [5, 25, 7, 24, 8, 23, 9, 21, 9, 19, 8, 17, 7, 16, 6, 14, 6, 12, 8, 10, -1, -1, 7, 24, 8, 22, 8, 20, 7, 18, 6, 17, 5, 15, 5, 13, 6, 11, 10, 9, 6, 7, 5, 5, 5, 3, 6, 1, 7, 0, 8, -2, 8, -4, 7, -6, -1, -1, 8, 8, 6, 6, 6, 4, 7, 2, 8, 1, 9, -1, 9, -3, 8, -5, 7, -6, 5, -7]],
    "~": [24, [3, 6, 3, 8, 4, 11, 6, 12, 8, 12, 10, 11, 14, 8, 16, 7, 18, 7, 20, 8, 21, 10, -1, -1, 3, 8, 4, 10, 6, 11, 8, 11, 10, 10, 14, 7, 16, 6, 18, 6, 20, 7, 21, 10, 21, 12]]
};

module.exports = function textVertices(text, left, baseline, scale) {
    scale = scale || 1;

    var strokes = [],
        i, len, j, len2, glyph, x, y, prev;

    for (i = 0, len = text.length; i < len; i++) {
        glyph = simplexFont[text[i]];
        if (!glyph) continue;
        prev = null;

        for (j = 0, len2 = glyph[1].length; j < len2; j += 2) {
            if (glyph[1][j] === -1 && glyph[1][j + 1] === -1) {
                prev = null;

            } else {
                x = left + glyph[1][j] * scale;
                y = baseline - glyph[1][j + 1] * scale;
                if (prev) {
                    strokes.push(prev.x, prev.y, x, y);
                }
                prev = {x: x, y: y};
            }
        }
        left += glyph[0] * scale;
    }

    return strokes;
};

},{}],17:[function(require,module,exports){
'use strict';

// jshint -W079
var mapboxgl = module.exports = {};

mapboxgl.version = require('../package.json').version;

mapboxgl.Map = require('./ui/map');
mapboxgl.Control = require('./ui/control/control');
mapboxgl.Navigation = require('./ui/control/navigation');
mapboxgl.Geolocate = require('./ui/control/geolocate');
mapboxgl.Attribution = require('./ui/control/attribution');
mapboxgl.Scale = require('./ui/control/scale');
mapboxgl.Popup = require('./ui/popup');
mapboxgl.Marker = require('./ui/marker');

mapboxgl.Style = require('./style/style');

mapboxgl.LngLat = require('./geo/lng_lat');
mapboxgl.LngLatBounds = require('./geo/lng_lat_bounds');
mapboxgl.Point = require('point-geometry');

mapboxgl.Evented = require('./util/evented');
mapboxgl.util = require('./util/util');

mapboxgl.supported = require('./util/browser').supported;

var ajax = require('./util/ajax');
mapboxgl.util.getJSON = ajax.getJSON;
mapboxgl.util.getArrayBuffer = ajax.getArrayBuffer;

var config = require('./util/config');
mapboxgl.config = config;

Object.defineProperty(mapboxgl, 'accessToken', {
    get: function() { return config.ACCESS_TOKEN; },
    set: function(token) { config.ACCESS_TOKEN = token; }
});

/**
 * Gets and sets the map's [access token](https://www.mapbox.com/help/define-access-token/).
 *
 * @var {string} accessToken
 * @example
 * mapboxgl.accessToken = myAccessToken;
 */

/**
 * The version of Mapbox GL JS in use as specified in `package.json`,
 * `CHANGELOG.md`, and the GitHub release.
 *
 * @var {string} version
 */

/**
 * Returns a Boolean indicating whether the browser [supports Mapbox GL JS](https://www.mapbox.com/help/mapbox-browser-support/#mapbox-gl-js).
 *
 * @function supported
 * @param {Object} options
 * @param {boolean} [options.failIfMajorPerformanceCaveat=false] If `true`,
 *   the function will return `false` if the performance of Mapbox GL JS would
 *   be dramatically worse than expected (i.e. a software renderer would be used).
 * @return {boolean}
 * @example
 * mapboxgl.supported() // = true
 */

},{"../package.json":207,"./geo/lng_lat":13,"./geo/lng_lat_bounds":14,"./style/style":53,"./ui/control/attribution":85,"./ui/control/control":86,"./ui/control/geolocate":87,"./ui/control/navigation":88,"./ui/control/scale":89,"./ui/map":98,"./ui/marker":99,"./ui/popup":100,"./util/ajax":102,"./util/browser":103,"./util/config":108,"./util/evented":111,"./util/util":120,"point-geometry":187}],18:[function(require,module,exports){
'use strict';

var assert = require('assert');

module.exports = function(uniforms) {
    var pragmas = { define: {}, initialize: {} };

    for (var i = 0; i < uniforms.length; i++) {
        var uniform = uniforms[i];
        assert(uniform.name.slice(0, 2) === 'u_');

        var type = '{precision} ' + (uniform.components === 1 ? 'float' : 'vec' + uniform.components);
        pragmas.define[uniform.name.slice(2)] = 'uniform ' + type + ' ' + uniform.name + ';\n';
        pragmas.initialize[uniform.name.slice(2)] = type + ' ' + uniform.name.slice(2) + ' = ' + uniform.name + ';\n';
    }

    return pragmas;
};

},{"assert":122}],19:[function(require,module,exports){
'use strict';

var pixelsToTileUnits = require('../source/pixels_to_tile_units');
var createUniformPragmas = require('./create_uniform_pragmas');

var tileSize = 512;

module.exports = drawBackground;

function drawBackground(painter, source, layer) {
    var gl = painter.gl;
    var transform = painter.transform;
    var color = layer.paint['background-color'];
    var image = layer.paint['background-pattern'];
    var opacity = layer.paint['background-opacity'];
    var program;

    var imagePosA = image ? painter.spriteAtlas.getPosition(image.from, true) : null;
    var imagePosB = image ? painter.spriteAtlas.getPosition(image.to, true) : null;

    painter.setDepthSublayer(0);
    if (imagePosA && imagePosB) {

        if (painter.isOpaquePass) return;

        // Draw texture fill
        program = painter.useProgram('pattern');
        gl.uniform1i(program.u_image, 0);
        gl.uniform2fv(program.u_pattern_tl_a, imagePosA.tl);
        gl.uniform2fv(program.u_pattern_br_a, imagePosA.br);
        gl.uniform2fv(program.u_pattern_tl_b, imagePosB.tl);
        gl.uniform2fv(program.u_pattern_br_b, imagePosB.br);
        gl.uniform1f(program.u_opacity, opacity);

        gl.uniform1f(program.u_mix, image.t);

        gl.uniform2fv(program.u_pattern_size_a, imagePosA.size);
        gl.uniform2fv(program.u_pattern_size_b, imagePosB.size);
        gl.uniform1f(program.u_scale_a, image.fromScale);
        gl.uniform1f(program.u_scale_b, image.toScale);

        gl.activeTexture(gl.TEXTURE0);
        painter.spriteAtlas.bind(gl, true);

        painter.tileExtentPatternVAO.bind(gl, program, painter.tileExtentBuffer);
    } else {
        // Draw filling rectangle.
        if (painter.isOpaquePass !== (color[3] === 1)) return;

        var pragmas = createUniformPragmas([
            {name: 'u_color', components: 4},
            {name: 'u_opacity', components: 1}
        ]);
        program = painter.useProgram('fill', [], pragmas, pragmas);
        gl.uniform4fv(program.u_color, color);
        gl.uniform1f(program.u_opacity, opacity);
        painter.tileExtentVAO.bind(gl, program, painter.tileExtentBuffer);
    }

    gl.disable(gl.STENCIL_TEST);

    // We need to draw the background in tiles in order to use calculatePosMatrix
    // which applies the projection matrix (transform.projMatrix). Otherwise
    // the depth and stencil buffers get into a bad state.
    // This can be refactored into a single draw call once earcut lands and
    // we don't have so much going on in the stencil buffer.
    var coords = transform.coveringTiles({ tileSize: tileSize });
    for (var c = 0; c < coords.length; c++) {
        var coord = coords[c];
        // var pixelsToTileUnitsBound = pixelsToTileUnits.bind({coord:coord, tileSize: tileSize});
        if (imagePosA && imagePosB) {
            var tile = {coord:coord, tileSize: tileSize};

            gl.uniform1f(program.u_tile_units_to_pixels, 1 / pixelsToTileUnits(tile, 1, painter.transform.tileZoom));

            var tileSizeAtNearestZoom = tile.tileSize * Math.pow(2, painter.transform.tileZoom - tile.coord.z);

            var pixelX = tileSizeAtNearestZoom * (tile.coord.x + coord.w * Math.pow(2, tile.coord.z));
            var pixelY = tileSizeAtNearestZoom * tile.coord.y;
            // split the pixel coord into two pairs of 16 bit numbers. The glsl spec only guarantees 16 bits of precision.
            gl.uniform2f(program.u_pixel_coord_upper, pixelX >> 16, pixelY >> 16);
            gl.uniform2f(program.u_pixel_coord_lower, pixelX & 0xFFFF, pixelY & 0xFFFF);
        }

        gl.uniformMatrix4fv(program.u_matrix, false, painter.transform.calculatePosMatrix(coord));
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, painter.tileExtentBuffer.length);
    }

    gl.stencilMask(0x00);
    gl.stencilFunc(gl.EQUAL, 0x80, 0x80);
}

},{"../source/pixels_to_tile_units":38,"./create_uniform_pragmas":18}],20:[function(require,module,exports){
'use strict';

var browser = require('../util/browser');

module.exports = drawCircles;

function drawCircles(painter, source, layer, coords) {
    if (painter.isOpaquePass) return;

    var gl = painter.gl;

    painter.setDepthSublayer(0);
    painter.depthMask(false);

    // Allow circles to be drawn across boundaries, so that
    // large circles are not clipped to tiles
    gl.disable(gl.STENCIL_TEST);

    for (var i = 0; i < coords.length; i++) {
        var coord = coords[i];

        var tile = source.getTile(coord);
        var bucket = tile.getBucket(layer);
        if (!bucket) continue;
        var bufferGroups = bucket.bufferGroups.circle;
        if (!bufferGroups) continue;

        var programOptions = bucket.paintAttributes.circle[layer.id];
        var program = painter.useProgram(
            'circle',
            programOptions.defines,
            programOptions.vertexPragmas,
            programOptions.fragmentPragmas
        );

        if (layer.paint['circle-pitch-scale'] === 'map') {
            gl.uniform1i(program.u_scale_with_map, true);
            gl.uniform2f(program.u_extrude_scale,
                painter.transform.pixelsToGLUnits[0] * painter.transform.altitude,
                painter.transform.pixelsToGLUnits[1] * painter.transform.altitude);
        } else {
            gl.uniform1i(program.u_scale_with_map, false);
            gl.uniform2fv(program.u_extrude_scale, painter.transform.pixelsToGLUnits);
        }

        gl.uniform1f(program.u_devicepixelratio, browser.devicePixelRatio);

        gl.uniformMatrix4fv(program.u_matrix, false, painter.translatePosMatrix(
            coord.posMatrix,
            tile,
            layer.paint['circle-translate'],
            layer.paint['circle-translate-anchor']
        ));

        bucket.setUniforms(gl, 'circle', program, layer, {zoom: painter.transform.zoom});

        for (var k = 0; k < bufferGroups.length; k++) {
            var group = bufferGroups[k];
            group.vaos[layer.id].bind(gl, program, group.layoutVertexBuffer, group.elementBuffer, group.paintVertexBuffers[layer.id]);
            gl.drawElements(gl.TRIANGLES, group.elementBuffer.length * 3, gl.UNSIGNED_SHORT, 0);
        }
    }
}

},{"../util/browser":103}],21:[function(require,module,exports){
'use strict';

module.exports = drawCollisionDebug;

function drawCollisionDebug(painter, source, layer, coords) {
    var gl = painter.gl;
    gl.enable(gl.STENCIL_TEST);
    var program = painter.useProgram('collisionbox');

    for (var i = 0; i < coords.length; i++) {
        var coord = coords[i];
        var tile = source.getTile(coord);
        var bucket = tile.getBucket(layer);
        if (!bucket) continue;
        var bufferGroups = bucket.bufferGroups.collisionBox;

        if (!bufferGroups || !bufferGroups.length) continue;
        var group = bufferGroups[0];
        if (group.layoutVertexBuffer.length === 0) continue;

        gl.uniformMatrix4fv(program.u_matrix, false, coord.posMatrix);

        painter.enableTileClippingMask(coord);

        painter.lineWidth(1);
        gl.uniform1f(program.u_scale, Math.pow(2, painter.transform.zoom - tile.coord.z));
        gl.uniform1f(program.u_zoom, painter.transform.zoom * 10);
        gl.uniform1f(program.u_maxzoom, (tile.coord.z + 1) * 10);

        group.vaos[layer.id].bind(gl, program, group.layoutVertexBuffer);
        gl.drawArrays(gl.LINES, 0, group.layoutVertexBuffer.length);
    }
}

},{}],22:[function(require,module,exports){
'use strict';

var textVertices = require('../lib/debugtext');
var browser = require('../util/browser');
var mat4 = require('gl-matrix').mat4;
var EXTENT = require('../data/bucket').EXTENT;
var Buffer = require('../data/buffer');
var VertexArrayObject = require('./vertex_array_object');

module.exports = drawDebug;

function drawDebug(painter, source, coords) {
    if (painter.isOpaquePass) return;
    if (!painter.options.debug) return;

    for (var i = 0; i < coords.length; i++) {
        drawDebugTile(painter, source, coords[i]);
    }
}

function drawDebugTile(painter, source, coord) {
    var gl = painter.gl;

    gl.disable(gl.STENCIL_TEST);
    painter.lineWidth(1 * browser.devicePixelRatio);

    var posMatrix = coord.posMatrix;
    var program = painter.useProgram('debug');

    gl.uniformMatrix4fv(program.u_matrix, false, posMatrix);
    gl.uniform4f(program.u_color, 1, 0, 0, 1);
    painter.debugVAO.bind(gl, program, painter.debugBuffer);
    gl.drawArrays(gl.LINE_STRIP, 0, painter.debugBuffer.length);

    var vertices = textVertices(coord.toString(), 50, 200, 5);
    var debugTextArray = new painter.PosArray();
    for (var v = 0; v < vertices.length; v += 2) {
        debugTextArray.emplaceBack(vertices[v], vertices[v + 1]);
    }
    var debugTextBuffer = new Buffer(debugTextArray.serialize(), painter.PosArray.serialize(), Buffer.BufferType.VERTEX);
    var debugTextVAO = new VertexArrayObject();
    debugTextVAO.bind(gl, program, debugTextBuffer);
    gl.uniform4f(program.u_color, 1, 1, 1, 1);

    // Draw the halo with multiple 1px lines instead of one wider line because
    // the gl spec doesn't guarantee support for lines with width > 1.
    var tileSize = source.getTile(coord).tileSize;
    var onePixel = EXTENT / (Math.pow(2, painter.transform.zoom - coord.z) * tileSize);
    var translations = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
    for (var i = 0; i < translations.length; i++) {
        var translation = translations[i];
        gl.uniformMatrix4fv(program.u_matrix, false, mat4.translate([], posMatrix, [onePixel * translation[0], onePixel * translation[1], 0]));
        gl.drawArrays(gl.LINES, 0, debugTextBuffer.length);
    }

    gl.uniform4f(program.u_color, 0, 0, 0, 1);
    gl.uniformMatrix4fv(program.u_matrix, false, posMatrix);
    gl.drawArrays(gl.LINES, 0, debugTextBuffer.length);
}

},{"../data/bucket":2,"../data/buffer":8,"../lib/debugtext":16,"../util/browser":103,"./vertex_array_object":32,"gl-matrix":147}],23:[function(require,module,exports){
'use strict';

var mat3 = require('gl-matrix').mat3;
var mat4 = require('gl-matrix').mat4;
var vec3 = require('gl-matrix').vec3;
var pixelsToTileUnits = require('../source/pixels_to_tile_units');
var Buffer = require('../data/buffer');
var VertexArrayObject = require('./vertex_array_object');
var StructArrayType = require('../util/struct_array');

module.exports = draw;

function draw(painter, source, layer, coords) {
    if (layer.paint['extrusion-layer-opacity'] === 0) return;
    var gl = painter.gl;
    gl.disable(gl.STENCIL_TEST);
    painter.depthMask(true);

    // Create a new texture to which to render the extrusion layer. This approach
    // allows us to adjust opacity on a per-layer basis (eliminating the interior
    // walls per-feature opacity problem)
    var texture = new PrerenderedExtrusionLayer(gl, painter, layer);
    texture.bindFramebuffer();

    gl.clearStencil(0x80);
    gl.stencilMask(0xFF);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.stencilMask(0x00);

    for (var i = 0; i < coords.length; i++) {
        drawExtrusion(painter, source, layer, coords[i]);
    }

    if (!painter.isOpaquePass && layer.paint['extrusion-antialias']) {
        for (var j = 0; j < coords.length; j++) {
            drawExtrusionStroke(painter, source, layer, coords[j]);
        }
    }

    // Unbind the framebuffer as a render target and render it to the map
    texture.unbindFramebuffer();
    texture.renderToMap();
}

function PrerenderedExtrusionLayer(gl, painter, layer) {
    this.gl = gl;
    this.width = painter.width;
    this.height = painter.height;
    this.painter = painter;
    this.layer = layer;

    this.texture = null;
    this.fbo = null;
    this.fbos = this.painter.preFbos[this.width] && this.painter.preFbos[this.width][this.height];
}

PrerenderedExtrusionLayer.prototype.bindFramebuffer = function() {
    var gl = this.gl;

    this.texture = this.painter.getTexture(this.width, this.height);

    gl.activeTexture(gl.TEXTURE1);

    if (!this.texture) {
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        this.texture.width = this.width;
        this.texture.height = this.height;
    } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
    }

    if (!this.fbos) {
        this.fbo = gl.createFramebuffer();
        var stencil = gl.createRenderbuffer();
        var depthRenderBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
        gl.bindRenderbuffer(gl.RENDERBUFFER, depthRenderBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA4, this.width, this.height);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.width, this.height);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, stencil);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthRenderBuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
    } else {
        this.fbo = this.fbos.pop();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
    }
};

PrerenderedExtrusionLayer.prototype.unbindFramebuffer = function() {
    this.painter.bindDefaultFramebuffer();
    if (this.fbos) {
        this.fbos.push(this.fbo);
    } else {
        if (!this.painter.preFbos[this.width]) this.painter.preFbos[this.width] = {};
        this.painter.preFbos[this.width][this.height] = [this.fbo];
    }
    this.painter.saveTexture(this.texture);
};

PrerenderedExtrusionLayer.prototype.TextureBoundsArray = new StructArrayType({
    members: [
        { name: 'a_pos', type: 'Int16', components: 2 }
    ]
});

PrerenderedExtrusionLayer.prototype.renderToMap = function() {
    var gl = this.gl;
    var painter = this.painter;
    var program = painter.useProgram('extrusiontexture');

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);

    gl.uniform1f(program.u_opacity, this.layer.paint['extrusion-layer-opacity']);
    gl.uniform1i(program.u_texture, 1);

    gl.uniformMatrix4fv(program.u_matrix, false, mat4.ortho(
        mat4.create(),
        0,
        painter.width,
        painter.height,
        0,
        0,
        1)
    );

    gl.disable(gl.DEPTH_TEST);

    gl.uniform1i(program.u_xdim, painter.width);
    gl.uniform1i(program.u_ydim, painter.height);

    var array = new this.TextureBoundsArray();
    array.emplaceBack(0, 0);
    array.emplaceBack(painter.width, 0);
    array.emplaceBack(0, painter.height);
    array.emplaceBack(painter.width, painter.height);
    var buffer = new Buffer(array.serialize(), this.TextureBoundsArray.serialize(), Buffer.BufferType.VERTEX);

    var vao = new VertexArrayObject();
    vao.bind(gl, program, buffer);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    gl.enable(gl.DEPTH_TEST);
};

function drawExtrusion(painter, source, layer, coord) {
    var tile = source.getTile(coord);
    var bucket = tile.getBucket(layer);
    if (!bucket) return;
    var bufferGroups = bucket.bufferGroups.extrusion;
    if (!bufferGroups) return;

    if (painter.isOpaquePass) return;

    painter.setDepthSublayer(2);

    var gl = painter.gl;

    var image = layer.paint['extrusion-pattern'];

    var programOptions = bucket.paintAttributes.extrusion[layer.id];
    var program = painter.useProgram(
        image ? 'extrusionpattern' : 'extrusion',
        programOptions.defines,
        programOptions.vertexPragmas,
        programOptions.fragmentPragmas
    );

    if (image) {
        setPattern(image, tile, coord, painter, program);
    }

    setMatrix(program, painter, coord, tile, layer);
    setLighting(program, painter);

    bucket.setUniforms(gl, 'extrusion', program, layer, {zoom: painter.transform.zoom});

    for (var i = 0; i < bufferGroups.length; i++) {
        var group = bufferGroups[i];
        group.vaos[layer.id].bind(gl, program, group.layoutVertexBuffer, group.elementBuffer, group.paintVertexBuffers[layer.id]);
        gl.drawElements(gl.TRIANGLES, group.elementBuffer.length * 3, gl.UNSIGNED_SHORT, 0);
    }
}

function drawExtrusionStroke(painter, source, layer, coord) {
    var tile = source.getTile(coord);
    var bucket = tile.getBucket(layer);
    if (!bucket) return;

    var gl = painter.gl;
    var bufferGroups = bucket.bufferGroups.extrusion;

    painter.setDepthSublayer(1);
    painter.lineWidth(2);

    var outlineDefines = ['OUTLINE'];

    var image = layer.paint['extrusion-pattern'];
    var color = layer.paint['extrusion-outline-color'];
    if (!color) outlineDefines.push('DEFAULT_COLOR');

    var programOptions = bucket.paintAttributes.extrusion[layer.id];
    var outlineProgram = painter.useProgram(
        // TODO extrusion pattern with antialias & no color specified?
        (image && !color) ? 'extrusionpattern' : 'extrusion',
        programOptions.defines.concat(outlineDefines),
        programOptions.vertexPragmas,
        programOptions.fragmentPragmas
    );

    setLighting(outlineProgram, painter);
    setMatrix(outlineProgram, painter, coord, tile, layer);

    bucket.setUniforms(gl, 'extrusion', outlineProgram, layer, {zoom: painter.transform.zoom});

    if (color) gl.uniform4fv(outlineProgram.u_outline_color, color);

    painter.enableTileClippingMask(coord);

    for (var k = 0; k < bufferGroups.length; k++) {
        var group = bufferGroups[k];
        group.secondVaos[layer.id].bind(gl, outlineProgram, group.layoutVertexBuffer, group.elementBuffer2, group.paintVertexBuffers[layer.id]);
        gl.drawElements(gl.LINES, group.elementBuffer2.length * 2, gl.UNSIGNED_SHORT, 0);
    }
}

function setMatrix(program, painter, coord, tile, layer) {
    var zScale = Math.pow(2, painter.transform.zoom) / 50000;

    painter.gl.uniformMatrix4fv(program.u_matrix, false, mat4.scale(
        mat4.create(),
        painter.translatePosMatrix(
            coord.posMatrix,
            tile,
            layer.paint['extrusion-translate'],
            layer.paint['extrusion-translate-anchor']
        ),
        [1, 1, zScale, 1])
    );
}

function setLighting(program, painter) {
    var _ld = painter.light.lightDirection,
        lightdir = [_ld.x, _ld.y, _ld.z];
    var lightMat = mat3.create();
    if (painter.light.lightAnchor === 'viewport') mat3.fromRotation(lightMat, -painter.transform.angle);
    vec3.transformMat3(lightdir, lightdir, lightMat);
    painter.gl.uniform3fv(program.u_lightdir, lightdir);
}


function setPattern(image, tile, coord, painter, program) {
    var gl = painter.gl;

    var imagePosA = painter.spriteAtlas.getPosition(image.from, true);
    var imagePosB = painter.spriteAtlas.getPosition(image.to, true);
    if (!imagePosA || !imagePosB) return;

    gl.uniform1i(program.u_image, 0);
    gl.uniform2fv(program.u_pattern_tl_a, imagePosA.tl);
    gl.uniform2fv(program.u_pattern_br_a, imagePosA.br);
    gl.uniform2fv(program.u_pattern_tl_b, imagePosB.tl);
    gl.uniform2fv(program.u_pattern_br_b, imagePosB.br);
    gl.uniform1f(program.u_mix, image.t);

    gl.uniform1f(program.u_tile_units_to_pixels, 1 / pixelsToTileUnits(tile, 1, painter.transform.tileZoom));
    gl.uniform2fv(program.u_pattern_size_a, imagePosA.size);
    gl.uniform2fv(program.u_pattern_size_b, imagePosB.size);
    gl.uniform1f(program.u_scale_a, image.fromScale);
    gl.uniform1f(program.u_scale_b, image.toScale);

    var tileSizeAtNearestZoom = tile.tileSize * Math.pow(2, painter.transform.tileZoom - tile.coord.z);

    var pixelX = tileSizeAtNearestZoom * (tile.coord.x + coord.w * Math.pow(2, tile.coord.z));
    var pixelY = tileSizeAtNearestZoom * tile.coord.y;
    // split the pixel coord into two pairs of 16 bit numbers. The glsl spec only guarantees 16 bits of precision.
    gl.uniform2f(program.u_pixel_coord_upper, pixelX >> 16, pixelY >> 16);
    gl.uniform2f(program.u_pixel_coord_lower, pixelX & 0xFFFF, pixelY & 0xFFFF);

    gl.uniform1f(program.u_height_factor, -Math.pow(2, painter.transform.tileZoom) / tileSizeAtNearestZoom >> 3);

    gl.activeTexture(gl.TEXTURE0);
    painter.spriteAtlas.bind(gl, true);
}

},{"../data/buffer":8,"../source/pixels_to_tile_units":38,"../util/struct_array":118,"./vertex_array_object":32,"gl-matrix":147}],24:[function(require,module,exports){
'use strict';

var pixelsToTileUnits = require('../source/pixels_to_tile_units');

module.exports = draw;

function draw(painter, source, layer, coords) {
    var gl = painter.gl;
    gl.enable(gl.STENCIL_TEST);

    var isOpaque;
    if (layer.paint['fill-pattern']) {
        isOpaque = false;
    } else {
        isOpaque = (
            layer.isPaintValueFeatureConstant('fill-color') &&
            layer.isPaintValueFeatureConstant('fill-opacity') &&
            layer.paint['fill-color'][3] === 1 &&
            layer.paint['fill-opacity'] === 1
        );
    }

    // Draw fill
    if (painter.isOpaquePass === isOpaque) {
        // Once we switch to earcut drawing we can pull most of the WebGL setup
        // outside of this coords loop.
        painter.setDepthSublayer(1);
        for (var i = 0; i < coords.length; i++) {
            drawFill(painter, source, layer, coords[i]);
        }
    }

    if (!painter.isOpaquePass && layer.paint['fill-antialias']) {
        painter.lineWidth(2);
        painter.depthMask(false);

        var isOutlineColorDefined = layer.getPaintProperty('fill-outline-color');
        if (isOutlineColorDefined || !layer.paint['fill-pattern']) {
            if (isOutlineColorDefined) {
                // If we defined a different color for the fill outline, we are
                // going to ignore the bits in 0x07 and just care about the global
                // clipping mask.
                painter.setDepthSublayer(2);
            } else {
                // Otherwise, we only want to drawFill the antialiased parts that are
                // *outside* the current shape. This is important in case the fill
                // or stroke color is translucent. If we wouldn't clip to outside
                // the current shape, some pixels from the outline stroke overlapped
                // the (non-antialiased) fill.
                painter.setDepthSublayer(0);
            }
        } else {
            // Otherwise, we only want to drawFill the antialiased parts that are
            // *outside* the current shape. This is important in case the fill
            // or stroke color is translucent. If we wouldn't clip to outside
            // the current shape, some pixels from the outline stroke overlapped
            // the (non-antialiased) fill.
            painter.setDepthSublayer(0);
        }

        for (var j = 0; j < coords.length; j++) {
            drawStroke(painter, source, layer, coords[j]);
        }
    }
}

function drawFill(painter, source, layer, coord) {
    var tile = source.getTile(coord);
    var bucket = tile.getBucket(layer);
    if (!bucket) return;
    var bufferGroups = bucket.bufferGroups.fill;
    if (!bufferGroups) return;

    var gl = painter.gl;

    var image = layer.paint['fill-pattern'];
    var program;

    if (!image) {

        var programOptions = bucket.paintAttributes.fill[layer.id];
        program = painter.useProgram(
            'fill',
            programOptions.defines,
            programOptions.vertexPragmas,
            programOptions.fragmentPragmas
        );
        bucket.setUniforms(gl, 'fill', program, layer, {zoom: painter.transform.zoom});

    } else {
        // Draw texture fill
        program = painter.useProgram('pattern');
        setPattern(image, layer.paint['fill-opacity'], tile, coord, painter, program);

        gl.activeTexture(gl.TEXTURE0);
        painter.spriteAtlas.bind(gl, true);
    }

    gl.uniformMatrix4fv(program.u_matrix, false, painter.translatePosMatrix(
        coord.posMatrix,
        tile,
        layer.paint['fill-translate'],
        layer.paint['fill-translate-anchor']
    ));

    painter.enableTileClippingMask(coord);

    for (var i = 0; i < bufferGroups.length; i++) {
        var group = bufferGroups[i];
        group.vaos[layer.id].bind(gl, program, group.layoutVertexBuffer, group.elementBuffer, group.paintVertexBuffers[layer.id]);
        gl.drawElements(gl.TRIANGLES, group.elementBuffer.length, gl.UNSIGNED_SHORT, 0);
    }
}

function drawStroke(painter, source, layer, coord) {
    var tile = source.getTile(coord);
    var bucket = tile.getBucket(layer);
    if (!bucket) return;

    var gl = painter.gl;
    var bufferGroups = bucket.bufferGroups.fill;

    var image = layer.paint['fill-pattern'];
    var opacity = layer.paint['fill-opacity'];
    var isOutlineColorDefined = layer.getPaintProperty('fill-outline-color');

    var program;
    if (image && !isOutlineColorDefined) {
        program = painter.useProgram('outlinepattern');
        gl.uniform2f(program.u_world, gl.drawingBufferWidth, gl.drawingBufferHeight);

    } else {
        var programOptions = bucket.paintAttributes.fill[layer.id];
        program = painter.useProgram(
            'outline',
            programOptions.defines,
            programOptions.vertexPragmas,
            programOptions.fragmentPragmas
        );
        gl.uniform2f(program.u_world, gl.drawingBufferWidth, gl.drawingBufferHeight);
        gl.uniform1f(program.u_opacity, opacity);
        bucket.setUniforms(gl, 'fill', program, layer, {zoom: painter.transform.zoom});
    }

    gl.uniformMatrix4fv(program.u_matrix, false, painter.translatePosMatrix(
        coord.posMatrix,
        tile,
        layer.paint['fill-translate'],
        layer.paint['fill-translate-anchor']
    ));

    if (image) { setPattern(image, opacity, tile, coord, painter, program); }

    painter.enableTileClippingMask(coord);

    for (var k = 0; k < bufferGroups.length; k++) {
        var group = bufferGroups[k];
        group.secondVaos[layer.id].bind(gl, program, group.layoutVertexBuffer, group.elementBuffer2, group.paintVertexBuffers[layer.id]);
        gl.drawElements(gl.LINES, group.elementBuffer2.length * 2, gl.UNSIGNED_SHORT, 0);
    }
}


function setPattern(image, opacity, tile, coord, painter, program) {
    var gl = painter.gl;

    var imagePosA = painter.spriteAtlas.getPosition(image.from, true);
    var imagePosB = painter.spriteAtlas.getPosition(image.to, true);
    if (!imagePosA || !imagePosB) return;

    gl.uniform1i(program.u_image, 0);
    gl.uniform2fv(program.u_pattern_tl_a, imagePosA.tl);
    gl.uniform2fv(program.u_pattern_br_a, imagePosA.br);
    gl.uniform2fv(program.u_pattern_tl_b, imagePosB.tl);
    gl.uniform2fv(program.u_pattern_br_b, imagePosB.br);
    gl.uniform1f(program.u_opacity, opacity);
    gl.uniform1f(program.u_mix, image.t);

    gl.uniform1f(program.u_tile_units_to_pixels, 1 / pixelsToTileUnits(tile, 1, painter.transform.tileZoom));
    gl.uniform2fv(program.u_pattern_size_a, imagePosA.size);
    gl.uniform2fv(program.u_pattern_size_b, imagePosB.size);
    gl.uniform1f(program.u_scale_a, image.fromScale);
    gl.uniform1f(program.u_scale_b, image.toScale);

    var tileSizeAtNearestZoom = tile.tileSize * Math.pow(2, painter.transform.tileZoom - tile.coord.z);

    var pixelX = tileSizeAtNearestZoom * (tile.coord.x + coord.w * Math.pow(2, tile.coord.z));
    var pixelY = tileSizeAtNearestZoom * tile.coord.y;
    // split the pixel coord into two pairs of 16 bit numbers. The glsl spec only guarantees 16 bits of precision.
    gl.uniform2f(program.u_pixel_coord_upper, pixelX >> 16, pixelY >> 16);
    gl.uniform2f(program.u_pixel_coord_lower, pixelX & 0xFFFF, pixelY & 0xFFFF);

    gl.activeTexture(gl.TEXTURE0);
    painter.spriteAtlas.bind(gl, true);
}

},{"../source/pixels_to_tile_units":38}],25:[function(require,module,exports){
'use strict';

var browser = require('../util/browser');
var mat2 = require('gl-matrix').mat2;
var pixelsToTileUnits = require('../source/pixels_to_tile_units');

/**
 * Draw a line. Under the hood this will read elements from
 * a tile, dash textures from a lineAtlas, and style properties from a layer.
 * @param {Object} painter
 * @param {Object} layer
 * @param {Object} posMatrix
 * @param {Tile} tile
 * @returns {undefined} draws with the painter
 * @private
 */
module.exports = function drawLine(painter, source, layer, coords) {
    if (painter.isOpaquePass) return;
    painter.setDepthSublayer(0);
    painter.depthMask(false);

    var gl = painter.gl;
    gl.enable(gl.STENCIL_TEST);

    // don't draw zero-width lines
    if (layer.paint['line-width'] <= 0) return;

    for (var k = 0; k < coords.length; k++) {
        drawLineTile(painter, source, layer, coords[k]);
    }

};

function drawLineTile(painter, source, layer, coord) {
    var tile = source.getTile(coord);
    var bucket = tile.getBucket(layer);
    if (!bucket) return;
    var bufferGroups = bucket.bufferGroups.line;
    if (!bufferGroups) return;

    var gl = painter.gl;

    var programOptions = bucket.paintAttributes.line[layer.id];

    // the distance over which the line edge fades out.
    // Retina devices need a smaller distance to avoid aliasing.
    var antialiasing = 1 / browser.devicePixelRatio;

    var blur = layer.paint['line-blur'] + antialiasing;
    var color = layer.paint['line-color'];

    var tr = painter.transform;

    var antialiasingMatrix = mat2.create();
    mat2.scale(antialiasingMatrix, antialiasingMatrix, [1, Math.cos(tr._pitch)]);
    mat2.rotate(antialiasingMatrix, antialiasingMatrix, painter.transform.angle);

    // calculate how much longer the real world distance is at the top of the screen
    // than at the middle of the screen.
    var topedgelength = Math.sqrt(tr.height * tr.height / 4  * (1 + tr.altitude * tr.altitude));
    var x = tr.height / 2 * Math.tan(tr._pitch);
    var extra = (topedgelength + x) / topedgelength - 1;

    var dasharray = layer.paint['line-dasharray'];
    var image = layer.paint['line-pattern'];
    var program, posA, posB, imagePosA, imagePosB;

    if (dasharray) {
        program = painter.useProgram(
            'linesdfpattern',
            programOptions.defines,
            programOptions.vertexPragmas,
            programOptions.fragmentPragmas
        );

        gl.uniform1f(program.u_linewidth, layer.paint['line-width'] / 2);
        gl.uniform1f(program.u_gapwidth, layer.paint['line-gap-width'] / 2);
        gl.uniform1f(program.u_antialiasing, antialiasing / 2);
        gl.uniform1f(program.u_blur, blur);
        gl.uniform4fv(program.u_color, color);
        gl.uniform1f(program.u_opacity, layer.paint['line-opacity']);

        posA = painter.lineAtlas.getDash(dasharray.from, layer.layout['line-cap'] === 'round');
        posB = painter.lineAtlas.getDash(dasharray.to, layer.layout['line-cap'] === 'round');

        gl.uniform1i(program.u_image, 0);
        gl.activeTexture(gl.TEXTURE0);
        painter.lineAtlas.bind(gl);

        gl.uniform1f(program.u_tex_y_a, posA.y);
        gl.uniform1f(program.u_tex_y_b, posB.y);
        gl.uniform1f(program.u_mix, dasharray.t);
        gl.uniform1f(program.u_extra, extra);
        gl.uniform1f(program.u_offset, -layer.paint['line-offset']);
        gl.uniformMatrix2fv(program.u_antialiasingmatrix, false, antialiasingMatrix);

    } else if (image) {
        imagePosA = painter.spriteAtlas.getPosition(image.from, true);
        imagePosB = painter.spriteAtlas.getPosition(image.to, true);
        if (!imagePosA || !imagePosB) return;

        program = painter.useProgram(
            'linepattern',
            programOptions.defines,
            programOptions.vertexPragmas,
            programOptions.fragmentPragmas
        );

        gl.uniform1i(program.u_image, 0);
        gl.activeTexture(gl.TEXTURE0);
        painter.spriteAtlas.bind(gl, true);

        gl.uniform1f(program.u_linewidth, layer.paint['line-width'] / 2);
        gl.uniform1f(program.u_gapwidth, layer.paint['line-gap-width'] / 2);
        gl.uniform1f(program.u_antialiasing, antialiasing / 2);
        gl.uniform1f(program.u_blur, blur);
        gl.uniform2fv(program.u_pattern_tl_a, imagePosA.tl);
        gl.uniform2fv(program.u_pattern_br_a, imagePosA.br);
        gl.uniform2fv(program.u_pattern_tl_b, imagePosB.tl);
        gl.uniform2fv(program.u_pattern_br_b, imagePosB.br);
        gl.uniform1f(program.u_fade, image.t);
        gl.uniform1f(program.u_opacity, layer.paint['line-opacity']);
        gl.uniform1f(program.u_extra, extra);
        gl.uniform1f(program.u_offset, -layer.paint['line-offset']);
        gl.uniformMatrix2fv(program.u_antialiasingmatrix, false, antialiasingMatrix);

    } else {
        program = painter.useProgram(
            'line',
            programOptions.defines,
            programOptions.vertexPragmas,
            programOptions.fragmentPragmas
        );

        gl.uniform1f(program.u_linewidth, layer.paint['line-width'] / 2);
        gl.uniform1f(program.u_gapwidth, layer.paint['line-gap-width'] / 2);
        gl.uniform1f(program.u_antialiasing, antialiasing / 2);
        gl.uniform1f(program.u_blur, blur);
        gl.uniform1f(program.u_extra, extra);
        gl.uniform1f(program.u_offset, -layer.paint['line-offset']);
        gl.uniformMatrix2fv(program.u_antialiasingmatrix, false, antialiasingMatrix);
        gl.uniform4fv(program.u_color, color);
        gl.uniform1f(program.u_opacity, layer.paint['line-opacity']);
    }

    painter.enableTileClippingMask(coord);

    // set uniforms that are different for each tile
    var posMatrix = painter.translatePosMatrix(coord.posMatrix, tile, layer.paint['line-translate'], layer.paint['line-translate-anchor']);
    gl.uniformMatrix4fv(program.u_matrix, false, posMatrix);

    var ratio = 1 / pixelsToTileUnits(tile, 1, painter.transform.zoom);

    if (dasharray) {
        var widthA = posA.width * dasharray.fromScale;
        var widthB = posB.width * dasharray.toScale;
        var scaleA = [1 / pixelsToTileUnits(tile, widthA, painter.transform.tileZoom), -posA.height / 2];
        var scaleB = [1 / pixelsToTileUnits(tile, widthB, painter.transform.tileZoom), -posB.height / 2];
        var gamma = painter.lineAtlas.width / (Math.min(widthA, widthB) * 256 * browser.devicePixelRatio) / 2;
        gl.uniform1f(program.u_ratio, ratio);
        gl.uniform2fv(program.u_patternscale_a, scaleA);
        gl.uniform2fv(program.u_patternscale_b, scaleB);
        gl.uniform1f(program.u_sdfgamma, gamma);

    } else if (image) {
        gl.uniform1f(program.u_ratio, ratio);
        gl.uniform2fv(program.u_pattern_size_a, [
            pixelsToTileUnits(tile, imagePosA.size[0] * image.fromScale, painter.transform.tileZoom),
            imagePosB.size[1]
        ]);
        gl.uniform2fv(program.u_pattern_size_b, [
            pixelsToTileUnits(tile, imagePosB.size[0] * image.toScale, painter.transform.tileZoom),
            imagePosB.size[1]
        ]);

    } else {
        gl.uniform1f(program.u_ratio, ratio);
    }

    bucket.setUniforms(gl, 'line', program, layer, {zoom: painter.transform.zoom});

    for (var i = 0; i < bufferGroups.length; i++) {
        var group = bufferGroups[i];
        group.vaos[layer.id].bind(gl, program, group.layoutVertexBuffer, group.elementBuffer, group.paintVertexBuffers[layer.id]);
        gl.drawElements(gl.TRIANGLES, group.elementBuffer.length * 3, gl.UNSIGNED_SHORT, 0);
    }
}

},{"../source/pixels_to_tile_units":38,"../util/browser":103,"gl-matrix":147}],26:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var StructArrayType = require('../util/struct_array');

module.exports = drawRaster;

function drawRaster(painter, source, layer, coords) {
    if (painter.isOpaquePass) return;

    var gl = painter.gl;

    gl.enable(gl.DEPTH_TEST);
    painter.depthMask(true);

    // Change depth function to prevent double drawing in areas where tiles overlap.
    gl.depthFunc(gl.LESS);

    var minTileZ = coords.length && coords[0].z;

    for (var i = 0; i < coords.length; i++) {
        var coord = coords[i];
        // set the lower zoom level to sublayer 0, and higher zoom levels to higher sublayers
        painter.setDepthSublayer(coord.z - minTileZ);
        drawRasterTile(painter, source, layer, coord);
    }

    gl.depthFunc(gl.LEQUAL);
}

drawRaster.RasterBoundsArray = new StructArrayType({
    members: [
        { name: 'a_pos', type: 'Int16', components: 2 },
        { name: 'a_texture_pos', type: 'Int16', components: 2 }
    ]
});

function drawRasterTile(painter, source, layer, coord) {

    var gl = painter.gl;

    gl.disable(gl.STENCIL_TEST);

    var tile = source.getTile(coord);
    var posMatrix = painter.transform.calculatePosMatrix(coord, source.maxzoom);

    var program = painter.useProgram('raster');
    gl.uniformMatrix4fv(program.u_matrix, false, posMatrix);

    // color parameters
    gl.uniform1f(program.u_brightness_low, layer.paint['raster-brightness-min']);
    gl.uniform1f(program.u_brightness_high, layer.paint['raster-brightness-max']);
    gl.uniform1f(program.u_saturation_factor, saturationFactor(layer.paint['raster-saturation']));
    gl.uniform1f(program.u_contrast_factor, contrastFactor(layer.paint['raster-contrast']));
    gl.uniform3fv(program.u_spin_weights, spinWeights(layer.paint['raster-hue-rotate']));

    var parentTile = tile.source && tile.source.findLoadedParent(coord, 0, {}),
        opacities = getOpacities(tile, parentTile, layer, painter.transform);

    var parentScaleBy, parentTL;

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, tile.texture);

    gl.activeTexture(gl.TEXTURE1);

    if (parentTile) {
        gl.bindTexture(gl.TEXTURE_2D, parentTile.texture);
        parentScaleBy = Math.pow(2, parentTile.coord.z - tile.coord.z);
        parentTL = [tile.coord.x * parentScaleBy % 1, tile.coord.y * parentScaleBy % 1];

    } else {
        gl.bindTexture(gl.TEXTURE_2D, tile.texture);
        opacities[1] = 0;
    }

    // cross-fade parameters
    gl.uniform2fv(program.u_tl_parent, parentTL || [0, 0]);
    gl.uniform1f(program.u_scale_parent, parentScaleBy || 1);
    gl.uniform1f(program.u_buffer_scale, 1);
    gl.uniform1f(program.u_opacity0, opacities[0]);
    gl.uniform1f(program.u_opacity1, opacities[1]);
    gl.uniform1i(program.u_image0, 0);
    gl.uniform1i(program.u_image1, 1);

    var buffer = tile.boundsBuffer || painter.rasterBoundsBuffer;
    var vao = tile.boundsVAO || painter.rasterBoundsVAO;
    vao.bind(gl, program, buffer);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, buffer.length);
}

function spinWeights(angle) {
    angle *= Math.PI / 180;
    var s = Math.sin(angle);
    var c = Math.cos(angle);
    return [
        (2 * c + 1) / 3,
        (-Math.sqrt(3) * s - c + 1) / 3,
        (Math.sqrt(3) * s - c + 1) / 3
    ];
}

function contrastFactor(contrast) {
    return contrast > 0 ?
        1 / (1 - contrast) :
        1 + contrast;
}

function saturationFactor(saturation) {
    return saturation > 0 ?
        1 - 1 / (1.001 - saturation) :
        -saturation;
}

function getOpacities(tile, parentTile, layer, transform) {
    var opacity = [1, 0];
    var fadeDuration = layer.paint['raster-fade-duration'];

    if (tile.source && fadeDuration > 0) {
        var now = new Date().getTime();

        var sinceTile = (now - tile.timeAdded) / fadeDuration;
        var sinceParent = parentTile ? (now - parentTile.timeAdded) / fadeDuration : -1;

        var idealZ = transform.coveringZoomLevel(tile.source);
        var parentFurther = parentTile ? Math.abs(parentTile.coord.z - idealZ) > Math.abs(tile.coord.z - idealZ) : false;

        if (!parentTile || parentFurther) {
            // if no parent or parent is older
            opacity[0] = util.clamp(sinceTile, 0, 1);
            opacity[1] = 1 - opacity[0];
        } else {
            // parent is younger, zooming out
            opacity[0] = util.clamp(1 - sinceParent, 0, 1);
            opacity[1] = 1 - opacity[0];
        }
    }

    var op = layer.paint['raster-opacity'];
    opacity[0] *= op;
    opacity[1] *= op;

    return opacity;
}

},{"../util/struct_array":118,"../util/util":120}],27:[function(require,module,exports){
'use strict';

var browser = require('../util/browser');
var drawCollisionDebug = require('./draw_collision_debug');
var pixelsToTileUnits = require('../source/pixels_to_tile_units');


module.exports = drawSymbols;

function drawSymbols(painter, source, layer, coords) {
    if (painter.isOpaquePass) return;

    var drawAcrossEdges = !(layer.layout['text-allow-overlap'] || layer.layout['icon-allow-overlap'] ||
        layer.layout['text-ignore-placement'] || layer.layout['icon-ignore-placement']);

    var gl = painter.gl;

    // Disable the stencil test so that labels aren't clipped to tile boundaries.
    //
    // Layers with features that may be drawn overlapping aren't clipped. These
    // layers are sorted in the y direction, and to draw the correct ordering near
    // tile edges the icons are included in both tiles and clipped when drawing.
    if (drawAcrossEdges) {
        gl.disable(gl.STENCIL_TEST);
    } else {
        gl.enable(gl.STENCIL_TEST);
    }

    painter.setDepthSublayer(0);
    painter.depthMask(false);
    gl.disable(gl.DEPTH_TEST);

    drawLayerSymbols(painter, source, layer, coords, false,
            layer.paint['icon-translate'],
            layer.paint['icon-translate-anchor'],
            layer.layout['icon-rotation-alignment'],
            // icon-pitch-alignment is not yet implemented
            // and we simply inherit the rotation alignment
            layer.layout['icon-rotation-alignment'],
            layer.layout['icon-size'],
            layer.paint['icon-halo-width'],
            layer.paint['icon-halo-color'],
            layer.paint['icon-halo-blur'],
            layer.paint['icon-opacity'],
            layer.paint['icon-color']);

    drawLayerSymbols(painter, source, layer, coords, true,
            layer.paint['text-translate'],
            layer.paint['text-translate-anchor'],
            layer.layout['text-rotation-alignment'],
            layer.layout['text-pitch-alignment'],
            layer.layout['text-size'],
            layer.paint['text-halo-width'],
            layer.paint['text-halo-color'],
            layer.paint['text-halo-blur'],
            layer.paint['text-opacity'],
            layer.paint['text-color']);

    gl.enable(gl.DEPTH_TEST);

    if (source.map.showCollisionBoxes) {
        drawCollisionDebug(painter, source, layer, coords);
    }
}

function drawLayerSymbols(painter, source, layer, coords, isText,
        translate,
        translateAnchor,
        rotationAlignment,
        pitchAlignment,
        size,
        haloWidth,
        haloColor,
        haloBlur,
        opacity,
        color) {

    for (var j = 0; j < coords.length; j++) {
        var tile = source.getTile(coords[j]);
        var bucket = tile.getBucket(layer);
        if (!bucket) continue;
        var bothBufferGroups = bucket.bufferGroups;
        var bufferGroups = isText ? bothBufferGroups.glyph : bothBufferGroups.icon;
        if (!bufferGroups.length) continue;

        painter.enableTileClippingMask(coords[j]);
        drawSymbol(painter, layer, coords[j].posMatrix, tile, bucket, bufferGroups, isText,
                isText || bucket.sdfIcons, !isText && bucket.iconsNeedLinear,
                isText ? bucket.adjustedTextSize : bucket.adjustedIconSize, bucket.fontstack,
                translate,
                translateAnchor,
                rotationAlignment,
                pitchAlignment,
                size,
                haloWidth,
                haloColor,
                haloBlur,
                opacity,
                color);
    }
}

function drawSymbol(painter, layer, posMatrix, tile, bucket, bufferGroups, isText, sdf, iconsNeedLinear, adjustedSize, fontstack,
        translate,
        translateAnchor,
        rotationAlignment,
        pitchAlignment,
        size,
        haloWidth,
        haloColor,
        haloBlur,
        opacity,
        color) {

    var gl = painter.gl;
    var tr = painter.transform;
    var rotateWithMap = rotationAlignment === 'map';
    var pitchWithMap = pitchAlignment === 'map';

    var defaultSize = isText ? 24 : 1;
    var fontScale = size / defaultSize;

    var extrudeScale, s, gammaScale;
    if (pitchWithMap) {
        s = pixelsToTileUnits(tile, 1, painter.transform.zoom) * fontScale;
        gammaScale = 1 / Math.cos(tr._pitch);
        extrudeScale = [s, s];
    } else {
        s = painter.transform.altitude * fontScale;
        gammaScale = 1;
        extrudeScale = [ tr.pixelsToGLUnits[0] * s, tr.pixelsToGLUnits[1] * s];
    }

    if (!isText && !painter.style.sprite.loaded())
        return;

    var program = painter.useProgram(sdf ? 'sdf' : 'icon');
    gl.uniformMatrix4fv(program.u_matrix, false, painter.translatePosMatrix(posMatrix, tile, translate, translateAnchor));
    gl.uniform1i(program.u_rotate_with_map, rotateWithMap);
    gl.uniform1i(program.u_pitch_with_map, pitchWithMap);
    gl.uniform2fv(program.u_extrude_scale, extrudeScale);

    gl.activeTexture(gl.TEXTURE0);
    gl.uniform1i(program.u_texture, 0);

    if (isText) {
        // use the fonstack used when parsing the tile, not the fontstack
        // at the current zoom level (layout['text-font']).
        var glyphAtlas = fontstack && painter.glyphSource.getGlyphAtlas(fontstack);
        if (!glyphAtlas) return;

        glyphAtlas.updateTexture(gl);
        gl.uniform2f(program.u_texsize, glyphAtlas.width / 4, glyphAtlas.height / 4);
    } else {
        var mapMoving = painter.options.rotating || painter.options.zooming;
        var iconScaled = fontScale !== 1 || browser.devicePixelRatio !== painter.spriteAtlas.pixelRatio || iconsNeedLinear;
        var iconTransformed = pitchWithMap || painter.transform.pitch;
        painter.spriteAtlas.bind(gl, sdf || mapMoving || iconScaled || iconTransformed);
        gl.uniform2f(program.u_texsize, painter.spriteAtlas.width / 4, painter.spriteAtlas.height / 4);
    }

    // adjust min/max zooms for variable font sizes
    var zoomAdjust = Math.log(size / adjustedSize) / Math.LN2 || 0;
    gl.uniform1f(program.u_zoom, (painter.transform.zoom - zoomAdjust) * 10); // current zoom level

    gl.activeTexture(gl.TEXTURE1);
    painter.frameHistory.bind(gl);
    gl.uniform1i(program.u_fadetexture, 1);

    var group;

    if (sdf) {
        var sdfPx = 8;
        var blurOffset = 1.19;
        var haloOffset = 6;
        var gamma = 0.105 * defaultSize / size / browser.devicePixelRatio;

        if (haloWidth) {
            // Draw halo underneath the text.
            gl.uniform1f(program.u_gamma, (haloBlur * blurOffset / fontScale / sdfPx + gamma) * gammaScale);
            gl.uniform4fv(program.u_color, haloColor);
            gl.uniform1f(program.u_opacity, opacity);
            gl.uniform1f(program.u_buffer, (haloOffset - haloWidth / fontScale) / sdfPx);

            for (var j = 0; j < bufferGroups.length; j++) {
                group = bufferGroups[j];
                group.vaos[layer.id].bind(gl, program, group.layoutVertexBuffer, group.elementBuffer);
                gl.drawElements(gl.TRIANGLES, group.elementBuffer.length * 3, gl.UNSIGNED_SHORT, 0);
            }
        }

        gl.uniform1f(program.u_gamma, gamma * gammaScale);
        gl.uniform4fv(program.u_color, color);
        gl.uniform1f(program.u_opacity, opacity);
        gl.uniform1f(program.u_buffer, (256 - 64) / 256);
        gl.uniform1f(program.u_pitch, tr.pitch / 360 * 2 * Math.PI);
        gl.uniform1f(program.u_bearing, tr.bearing / 360 * 2 * Math.PI);
        gl.uniform1f(program.u_aspect_ratio, tr.width / tr.height);

        for (var i = 0; i < bufferGroups.length; i++) {
            group = bufferGroups[i];
            group.vaos[layer.id].bind(gl, program, group.layoutVertexBuffer, group.elementBuffer);
            gl.drawElements(gl.TRIANGLES, group.elementBuffer.length * 3, gl.UNSIGNED_SHORT, 0);
        }

    } else {
        gl.uniform1f(program.u_opacity, opacity);
        for (var k = 0; k < bufferGroups.length; k++) {
            group = bufferGroups[k];
            group.vaos[layer.id].bind(gl, program, group.layoutVertexBuffer, group.elementBuffer);
            gl.drawElements(gl.TRIANGLES, group.elementBuffer.length * 3, gl.UNSIGNED_SHORT, 0);
        }
    }
}

},{"../source/pixels_to_tile_units":38,"../util/browser":103,"./draw_collision_debug":21}],28:[function(require,module,exports){
'use strict';

module.exports = FrameHistory;

function FrameHistory() {
    this.changeTimes = new Float64Array(256);
    this.changeOpacities = new Uint8Array(256);
    this.opacities = new Uint8ClampedArray(256);
    this.array = new Uint8Array(this.opacities.buffer);

    this.fadeDuration = 300;
    this.previousZoom = 0;
    this.firstFrame = true;
}

FrameHistory.prototype.record = function(zoom) {
    var now = Date.now();

    if (this.firstFrame) {
        now = 0;
        this.firstFrame = false;
    }

    zoom = Math.floor(zoom * 10);

    var z;
    if (zoom < this.previousZoom) {
        for (z = zoom + 1; z <= this.previousZoom; z++) {
            this.changeTimes[z] = now;
            this.changeOpacities[z] = this.opacities[z];
        }
    } else {
        for (z = zoom; z > this.previousZoom; z--) {
            this.changeTimes[z] = now;
            this.changeOpacities[z] = this.opacities[z];
        }
    }

    for (z = 0; z < 256; z++) {
        var timeSince = now - this.changeTimes[z];
        var opacityChange = timeSince / this.fadeDuration * 255;
        if (z <= zoom) {
            this.opacities[z] = this.changeOpacities[z] + opacityChange;
        } else {
            this.opacities[z] = this.changeOpacities[z] - opacityChange;
        }
    }

    this.changed = true;
    this.previousZoom = zoom;
};

FrameHistory.prototype.bind = function(gl) {
    if (!this.texture) {
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, 256, 1, 0, gl.ALPHA, gl.UNSIGNED_BYTE, this.array);

    } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        if (this.changed) {
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 256, 1, gl.ALPHA, gl.UNSIGNED_BYTE, this.array);
            this.changed = false;
        }
    }
};

},{}],29:[function(require,module,exports){
'use strict';

var util = require('../util/util');

module.exports = LineAtlas;

/**
 * A LineAtlas lets us reuse rendered dashed lines
 * by writing many of them to a texture and then fetching their positions
 * using .getDash.
 *
 * @param {number} width
 * @param {number} height
 * @private
 */
function LineAtlas(width, height) {
    this.width = width;
    this.height = height;
    this.nextRow = 0;

    this.bytes = 4;
    this.data = new Uint8Array(this.width * this.height * this.bytes);

    this.positions = {};
}

LineAtlas.prototype.setSprite = function(sprite) {
    this.sprite = sprite;
};

/**
 * Get or create a dash line pattern.
 *
 * @param {Array<number>} dasharray
 * @param {boolean} round whether to add circle caps in between dash segments
 * @returns {Object} position of dash texture in { y, height, width }
 * @private
 */
LineAtlas.prototype.getDash = function(dasharray, round) {
    var key = dasharray.join(",") + round;

    if (!this.positions[key]) {
        this.positions[key] = this.addDash(dasharray, round);
    }
    return this.positions[key];
};

LineAtlas.prototype.addDash = function(dasharray, round) {

    var n = round ? 7 : 0;
    var height = 2 * n + 1;
    var offset = 128;

    if (this.nextRow + height > this.height) {
        util.warnOnce('LineAtlas out of space');
        return null;
    }

    var length = 0;
    for (var i = 0; i < dasharray.length; i++) {
        length += dasharray[i];
    }

    var stretch = this.width / length;
    var halfWidth = stretch / 2;

    // If dasharray has an odd length, both the first and last parts
    // are dashes and should be joined seamlessly.
    var oddLength = dasharray.length % 2 === 1;

    for (var y = -n; y <= n; y++) {
        var row = this.nextRow + n + y;
        var index = this.width * row;

        var left = oddLength ? -dasharray[dasharray.length - 1] : 0;
        var right = dasharray[0];
        var partIndex = 1;

        for (var x = 0; x < this.width; x++) {

            while (right < x / stretch) {
                left = right;
                right = right + dasharray[partIndex];

                if (oddLength && partIndex === dasharray.length - 1) {
                    right += dasharray[0];
                }

                partIndex++;
            }

            var distLeft = Math.abs(x - left * stretch);
            var distRight = Math.abs(x - right * stretch);
            var dist = Math.min(distLeft, distRight);
            var inside = (partIndex % 2) === 1;
            var signedDistance;

            if (round) {
                // Add circle caps
                var distMiddle = n ? y / n * (halfWidth + 1) : 0;
                if (inside) {
                    var distEdge = halfWidth - Math.abs(distMiddle);
                    signedDistance = Math.sqrt(dist * dist + distEdge * distEdge);
                } else {
                    signedDistance = halfWidth - Math.sqrt(dist * dist + distMiddle * distMiddle);
                }
            } else {
                signedDistance = (inside ? 1 : -1) * dist;
            }

            this.data[3 + (index + x) * 4] = Math.max(0, Math.min(255, signedDistance + offset));
        }
    }

    var pos = {
        y: (this.nextRow + n + 0.5) / this.height,
        height: 2 * n / this.height,
        width: length
    };

    this.nextRow += height;
    this.dirty = true;

    return pos;
};

LineAtlas.prototype.bind = function(gl) {
    if (!this.texture) {
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.data);

    } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);

        if (this.dirty) {
            this.dirty = false;
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, this.data);
        }
    }
};

},{"../util/util":120}],30:[function(require,module,exports){
'use strict';

var browser = require('../util/browser');
var mat4 = require('gl-matrix').mat4;
var FrameHistory = require('./frame_history');
var SourceCache = require('../source/source_cache');
var EXTENT = require('../data/bucket').EXTENT;
var pixelsToTileUnits = require('../source/pixels_to_tile_units');
var util = require('../util/util');
var StructArrayType = require('../util/struct_array');
var Buffer = require('../data/buffer');
var VertexArrayObject = require('./vertex_array_object');
var RasterBoundsArray = require('./draw_raster').RasterBoundsArray;
var createUniformPragmas = require('./create_uniform_pragmas');

module.exports = Painter;

/**
 * Initialize a new painter object.
 *
 * @param {Canvas} gl an experimental-webgl drawing context
 * @private
 */
function Painter(gl, transform) {
    this.gl = gl;
    this.transform = transform;

    this.reusableTextures = {};
    this.preFbos = {};

    this.frameHistory = new FrameHistory();
    this.light = {};

    this.setup();

    // Within each layer there are multiple distinct z-planes that can be drawn to.
    // This is implemented using the WebGL depth buffer.
    this.numSublayers = SourceCache.maxUnderzooming + SourceCache.maxOverzooming + 1;
    this.depthEpsilon = 1 / Math.pow(2, 16);

    this.lineWidthRange = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE);
}

util.extend(Painter.prototype, require('./painter/use_program'));

/*
 * Update the GL viewport, projection matrix, and transforms to compensate
 * for a new width and height value.
 */
Painter.prototype.resize = function(width, height) {
    var gl = this.gl;

    this.width = width * browser.devicePixelRatio;
    this.height = height * browser.devicePixelRatio;
    gl.viewport(0, 0, this.width, this.height);

};

Painter.prototype.setup = function() {
    var gl = this.gl;

    gl.verbose = true;

    // We are blending the new pixels *behind* the existing pixels. That way we can
    // draw front-to-back and use then stencil buffer to cull opaque pixels early.
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

    gl.enable(gl.STENCIL_TEST);

    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);

    this._depthMask = false;
    gl.depthMask(false);

    var PosArray = this.PosArray = new StructArrayType({
        members: [{ name: 'a_pos', type: 'Int16', components: 2 }]
    });

    var tileExtentArray = new PosArray();
    tileExtentArray.emplaceBack(0, 0);
    tileExtentArray.emplaceBack(EXTENT, 0);
    tileExtentArray.emplaceBack(0, EXTENT);
    tileExtentArray.emplaceBack(EXTENT, EXTENT);
    this.tileExtentBuffer = new Buffer(tileExtentArray.serialize(), PosArray.serialize(), Buffer.BufferType.VERTEX);
    this.tileExtentVAO = new VertexArrayObject();
    this.tileExtentPatternVAO = new VertexArrayObject();

    var debugArray = new PosArray();
    debugArray.emplaceBack(0, 0);
    debugArray.emplaceBack(EXTENT, 0);
    debugArray.emplaceBack(EXTENT, EXTENT);
    debugArray.emplaceBack(0, EXTENT);
    debugArray.emplaceBack(0, 0);
    this.debugBuffer = new Buffer(debugArray.serialize(), PosArray.serialize(), Buffer.BufferType.VERTEX);
    this.debugVAO = new VertexArrayObject();

    var rasterBoundsArray = new RasterBoundsArray();
    rasterBoundsArray.emplaceBack(0, 0, 0, 0);
    rasterBoundsArray.emplaceBack(EXTENT, 0, 32767, 0);
    rasterBoundsArray.emplaceBack(0, EXTENT, 0, 32767);
    rasterBoundsArray.emplaceBack(EXTENT, EXTENT, 32767, 32767);
    this.rasterBoundsBuffer = new Buffer(rasterBoundsArray.serialize(), RasterBoundsArray.serialize(), Buffer.BufferType.VERTEX);
    this.rasterBoundsVAO = new VertexArrayObject();
};

/*
 * Set the lighting properties (used for extrusions).
 */
Painter.prototype.setLighting = function(lightOptions) {
    for (var key in lightOptions) {
        this.light[key] = lightOptions[key];
    }
};

/*
 * Reset the color buffers of the drawing canvas.
 */
Painter.prototype.clearColor = function() {
    var gl = this.gl;
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
};

/*
 * Reset the drawing canvas by clearing the stencil buffer so that we can draw
 * new tiles at the same location, while retaining previously drawn pixels.
 */
Painter.prototype.clearStencil = function() {
    var gl = this.gl;
    gl.clearStencil(0x0);
    gl.stencilMask(0xFF);
    gl.clear(gl.STENCIL_BUFFER_BIT);
};

Painter.prototype.clearDepth = function() {
    var gl = this.gl;
    gl.clearDepth(1);
    this.depthMask(true);
    gl.clear(gl.DEPTH_BUFFER_BIT);
};

Painter.prototype._renderTileClippingMasks = function(coords) {
    var gl = this.gl;
    gl.colorMask(false, false, false, false);
    this.depthMask(false);
    gl.disable(gl.DEPTH_TEST);
    gl.enable(gl.STENCIL_TEST);

    // Only write clipping IDs to the last 5 bits. The first three are used for drawing fills.
    gl.stencilMask(0xF8);
    // Tests will always pass, and ref value will be written to stencil buffer.
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);

    var idNext = 1;
    this._tileClippingMaskIDs = {};
    for (var i = 0; i < coords.length; i++) {
        var coord = coords[i];
        var id = this._tileClippingMaskIDs[coord.id] = (idNext++) << 3;

        gl.stencilFunc(gl.ALWAYS, id, 0xF8);

        var pragmas = createUniformPragmas([
            {name: 'u_color', components: 4},
            {name: 'u_opacity', components: 1}
        ]);
        var program = this.useProgram('fill', [], pragmas, pragmas);
        gl.uniformMatrix4fv(program.u_matrix, false, coord.posMatrix);

        // Draw the clipping mask
        this.tileExtentVAO.bind(gl, program, this.tileExtentBuffer);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.tileExtentBuffer.length);
    }

    gl.stencilMask(0x00);
    gl.colorMask(true, true, true, true);
    this.depthMask(true);
    gl.enable(gl.DEPTH_TEST);
};

Painter.prototype.enableTileClippingMask = function(coord) {
    var gl = this.gl;
    gl.stencilFunc(gl.EQUAL, this._tileClippingMaskIDs[coord.id], 0xF8);
};

// Overridden by headless tests.
Painter.prototype.prepareBuffers = function() {};
Painter.prototype.bindDefaultFramebuffer = function() {
    var gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};

var draw = {
    symbol: require('./draw_symbol'),
    circle: require('./draw_circle'),
    line: require('./draw_line'),
    fill: require('./draw_fill'),
    extrusion: require('./draw_extrusion'),
    raster: require('./draw_raster'),
    background: require('./draw_background'),
    debug: require('./draw_debug')
};

Painter.prototype.render = function(style, options) {
    this.style = style;
    this.options = options;

    this.lineAtlas = style.lineAtlas;

    this.spriteAtlas = style.spriteAtlas;
    this.spriteAtlas.setSprite(style.sprite);

    this.glyphSource = style.glyphSource;

    this.frameHistory.record(this.transform.zoom);

    this.prepareBuffers();
    this.clearColor();
    this.clearDepth();

    this.showOverdrawInspector(options.showOverdrawInspector);

    this.depthRange = (style._order.length + 2) * this.numSublayers * this.depthEpsilon;

    this.renderPass({isOpaquePass: true});
    this.renderPass({isOpaquePass: false});
};

Painter.prototype.renderPass = function(options) {
    var groups = this.style._groups;
    var isOpaquePass = options.isOpaquePass;
    this.currentLayer = isOpaquePass ? this.style._order.length : -1;

    for (var i = 0; i < groups.length; i++) {
        var group = groups[isOpaquePass ? groups.length - 1 - i : i];
        var source = this.style.sources[group.source];

        var j;
        var coords = [];
        if (source) {
            coords = source.getVisibleCoordinates();
            for (j = 0; j < coords.length; j++) {
                coords[j].posMatrix = this.transform.calculatePosMatrix(coords[j], source.maxzoom);
            }
            this.clearStencil();
            if (source.prepare) source.prepare();
            if (source.isTileClipped) {
                this._renderTileClippingMasks(coords);
            }
        }

        if (isOpaquePass) {
            if (!this._showOverdrawInspector) {
                this.gl.disable(this.gl.BLEND);
            }
            this.isOpaquePass = true;
        } else {
            this.gl.enable(this.gl.BLEND);
            this.isOpaquePass = false;
            coords.reverse();
        }

        for (j = 0; j < group.length; j++) {
            var layer = group[isOpaquePass ? group.length - 1 - j : j];
            this.currentLayer += isOpaquePass ? -1 : 1;
            this.renderLayer(this, source, layer, coords);
        }

        if (source) {
            draw.debug(this, source, coords);
        }
    }
};

Painter.prototype.depthMask = function(mask) {
    if (mask !== this._depthMask) {
        this._depthMask = mask;
        this.gl.depthMask(mask);
    }
};

Painter.prototype.renderLayer = function(painter, source, layer, coords) {
    if (layer.isHidden(this.transform.zoom)) return;
    if (layer.type !== 'background' && !coords.length) return;
    this.id = layer.id;
    draw[layer.type](painter, source, layer, coords);
};

Painter.prototype.setDepthSublayer = function(n) {
    var farDepth = 1 - ((1 + this.currentLayer) * this.numSublayers + n) * this.depthEpsilon;
    var nearDepth = farDepth - 1 + this.depthRange;
    this.gl.depthRange(nearDepth, farDepth);
};

Painter.prototype.translatePosMatrix = function(matrix, tile, translate, anchor) {
    if (!translate[0] && !translate[1]) return matrix;

    if (anchor === 'viewport') {
        var sinA = Math.sin(-this.transform.angle);
        var cosA = Math.cos(-this.transform.angle);
        translate = [
            translate[0] * cosA - translate[1] * sinA,
            translate[0] * sinA + translate[1] * cosA
        ];
    }

    var translation = [
        pixelsToTileUnits(tile, translate[0], this.transform.zoom),
        pixelsToTileUnits(tile, translate[1], this.transform.zoom),
        0
    ];

    var translatedMatrix = new Float32Array(16);
    mat4.translate(translatedMatrix, matrix, translation);
    return translatedMatrix;
};

Painter.prototype.saveTexture = function(texture) {
    var width = texture.width ? texture.width : texture.size,
        height = texture.height ? texture.height : texture.size;
    var widthTextures = this.reusableTextures[width];
    if (!widthTextures) {
        this.reusableTextures[width] = {};
        this.reusableTextures[width][height] = [texture];
    } else {
        var textures = widthTextures[height];
        if (!textures) {
            widthTextures[height] = [texture];
        } else {
            textures.push(texture);
        }
    }
};

Painter.prototype.getTexture = function(width, height) {
    var widthTextures = this.reusableTextures[width];
    if (widthTextures) {
        var textures = widthTextures[height || width];
        return textures && textures.length > 0 ? textures.pop() : null;
    }
};

Painter.prototype.lineWidth = function(width) {
    this.gl.lineWidth(util.clamp(width, this.lineWidthRange[0], this.lineWidthRange[1]));
};

Painter.prototype.showOverdrawInspector = function(enabled) {
    if (!enabled && !this._showOverdrawInspector) return;
    this._showOverdrawInspector = enabled;

    var gl = this.gl;
    if (enabled) {
        gl.blendFunc(gl.CONSTANT_COLOR, gl.ONE);
        var numOverdrawSteps = 8;
        var a = 1 / numOverdrawSteps;
        gl.blendColor(a, a, a, 0);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
    } else {
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    }
};

},{"../data/bucket":2,"../data/buffer":8,"../source/pixels_to_tile_units":38,"../source/source_cache":42,"../util/browser":103,"../util/struct_array":118,"../util/util":120,"./create_uniform_pragmas":18,"./draw_background":19,"./draw_circle":20,"./draw_debug":22,"./draw_extrusion":23,"./draw_fill":24,"./draw_line":25,"./draw_raster":26,"./draw_symbol":27,"./frame_history":28,"./painter/use_program":31,"./vertex_array_object":32,"gl-matrix":147}],31:[function(require,module,exports){
'use strict';

var assert = require('assert');
var util = require('../../util/util');
var shaders = require('mapbox-gl-shaders');

var utilSource = shaders.util;

module.exports._createProgram = function(name, defines, vertexPragmas, fragmentPragmas) {
    var gl = this.gl;
    var program = gl.createProgram();
    var definition = shaders[name];

    var definesSource = '#define MAPBOX_GL_JS;\n';
    for (var j = 0; j < defines.length; j++) {
        definesSource += '#define ' + defines[j] + ';\n';
    }

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, applyPragmas(definesSource + definition.fragmentSource, fragmentPragmas));
    gl.compileShader(fragmentShader);
    assert(gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS), gl.getShaderInfoLog(fragmentShader));
    gl.attachShader(program, fragmentShader);

    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, applyPragmas(definesSource + utilSource + definition.vertexSource, vertexPragmas));
    gl.compileShader(vertexShader);
    assert(gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS), gl.getShaderInfoLog(vertexShader));
    gl.attachShader(program, vertexShader);

    gl.linkProgram(program);
    assert(gl.getProgramParameter(program, gl.LINK_STATUS), gl.getProgramInfoLog(program));

    var attributes = {};
    var numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (var i = 0; i < numAttributes; i++) {
        var attribute = gl.getActiveAttrib(program, i);
        attributes[attribute.name] = gl.getAttribLocation(program, attribute.name);
    }

    var uniforms = {};
    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (var ui = 0; ui < numUniforms; ui++) {
        var uniform = gl.getActiveUniform(program, ui);
        uniforms[uniform.name] = gl.getUniformLocation(program, uniform.name);
    }

    return util.extend({
        program: program,
        definition: definition,
        attributes: attributes,
        numAttributes: numAttributes
    }, attributes, uniforms);
};

module.exports._createProgramCached = function(name, defines, vertexPragmas, fragmentPragmas) {
    this.cache = this.cache || {};

    var key = JSON.stringify({
        name: name,
        defines: defines,
        vertexPragmas: vertexPragmas,
        fragmentPragmas: fragmentPragmas
    });

    if (!this.cache[key]) {
        this.cache[key] = this._createProgram(name, defines, vertexPragmas, fragmentPragmas);
    }
    return this.cache[key];
};

module.exports.useProgram = function (nextProgramName, defines, vertexPragmas, fragmentPragmas) {
    var gl = this.gl;

    defines = defines || [];
    if (this._showOverdrawInspector) {
        defines = defines.concat('OVERDRAW_INSPECTOR');
    }

    var nextProgram = this._createProgramCached(nextProgramName, defines, vertexPragmas, fragmentPragmas);
    var previousProgram = this.currentProgram;

    if (previousProgram !== nextProgram) {
        gl.useProgram(nextProgram.program);
        this.currentProgram = nextProgram;
    }

    return nextProgram;
};

function applyPragmas(source, pragmas) {
    return source.replace(/#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, function(match, operation, precision, type, name) {
        return pragmas[operation][name].replace(/{type}/g, type).replace(/{precision}/g, precision);
    });
}

},{"../../util/util":120,"assert":122,"mapbox-gl-shaders":159}],32:[function(require,module,exports){
'use strict';

var assert = require('assert');

module.exports = VertexArrayObject;

function VertexArrayObject() {
    this.boundProgram = null;
    this.boundVertexBuffer = null;
    this.boundVertexBuffer2 = null;
    this.boundElementBuffer = null;
    this.vao = null;
}

VertexArrayObject.prototype.bind = function(gl, program, layoutVertexBuffer, elementBuffer, vertexBuffer2) {

    if (gl.extVertexArrayObject === undefined) {
        gl.extVertexArrayObject = gl.getExtension("OES_vertex_array_object");
    }

    var isFreshBindRequired = (
        !this.vao ||
        this.boundProgram !== program ||
        this.boundVertexBuffer !== layoutVertexBuffer ||
        this.boundVertexBuffer2 !== vertexBuffer2 ||
        this.boundElementBuffer !== elementBuffer
    );

    if (!gl.extVertexArrayObject || isFreshBindRequired) {
        this.freshBind(gl, program, layoutVertexBuffer, elementBuffer, vertexBuffer2);
    } else {
        gl.extVertexArrayObject.bindVertexArrayOES(this.vao);
    }
};

VertexArrayObject.prototype.freshBind = function(gl, program, layoutVertexBuffer, elementBuffer, vertexBuffer2) {
    var numPrevAttributes;
    var numNextAttributes = program.numAttributes;

    if (gl.extVertexArrayObject) {
        if (this.vao) this.destroy(gl);
        this.vao = gl.extVertexArrayObject.createVertexArrayOES();
        gl.extVertexArrayObject.bindVertexArrayOES(this.vao);
        numPrevAttributes = 0;

        // store the arguments so that we can verify them when the vao is bound again
        this.boundProgram = program;
        this.boundVertexBuffer = layoutVertexBuffer;
        this.boundVertexBuffer2 = vertexBuffer2;
        this.boundElementBuffer = elementBuffer;

    } else {
        numPrevAttributes = gl.currentNumAttributes || 0;

        // Disable all attributes from the previous program that aren't used in
        // the new program. Note: attribute indices are *not* program specific!
        for (var i = numNextAttributes; i < numPrevAttributes; i++) {
            // WebGL breaks if you disable attribute 0.
            // http://stackoverflow.com/questions/20305231
            assert(i !== 0);
            gl.disableVertexAttribArray(i);
        }
    }

    // Enable all attributes for the new program.
    for (var j = numPrevAttributes; j < numNextAttributes; j++) {
        gl.enableVertexAttribArray(j);
    }

    layoutVertexBuffer.bind(gl);
    layoutVertexBuffer.setVertexAttribPointers(gl, program);
    if (vertexBuffer2) {
        vertexBuffer2.bind(gl);
        vertexBuffer2.setVertexAttribPointers(gl, program);
    }
    if (elementBuffer) {
        elementBuffer.bind(gl);
    }

    gl.currentNumAttributes = numNextAttributes;
};

VertexArrayObject.prototype.unbind = function(gl) {
    var ext = gl.extVertexArrayObject;
    if (ext) {
        ext.bindVertexArrayOES(null);
    }
};

VertexArrayObject.prototype.destroy = function(gl) {
    var ext = gl.extVertexArrayObject;
    if (ext && this.vao) {
        ext.deleteVertexArrayOES(this.vao);
        this.vao = null;
    }
};

},{"assert":122}],33:[function(require,module,exports){
'use strict';

var Evented = require('../util/evented');
var util = require('../util/util');
var urlResolve = require('resolve-url');
var EXTENT = require('../data/bucket').EXTENT;

module.exports = GeoJSONSource;

/**
 * A source containing GeoJSON.
 *
 * @class GeoJSONSource
 * @param {Object} [options]
 * @param {Object|string} [options.data] A GeoJSON data object or a URL to one. The latter is preferable in the case of large GeoJSON objects.
 * @param {number} [options.maxzoom=18] The maximum zoom level at which to preserve detail (1-20).
 * @param {number} [options.buffer=128] The tile buffer, measured in pixels. The buffer extends each
 *   tile's data just past its visible edges, helping to ensure seamless rendering across tile boundaries.
 *   The default value, 128, is a safe value for label layers, preventing text clipping at boundaries.
 *   You can read more about buffers and clipping in the
 *   [Mapbox Vector Tile Specification](https://www.mapbox.com/vector-tiles/specification/#clipping).
 * @param {number} [options.tolerance=0.375] The simplification tolerance, measured in pixels.
 *   This value is passed into a modified [Ramer–Douglas–Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)
 *   to simplify (i.e. reduce the number of points) in curves. Higher values result in greater simplification.
 * @param {boolean} [options.cluster] If `true`, a collection of point features will be clustered into groups,
 *   according to `options.clusterRadius`.
 * @param {number} [options.clusterRadius=50] The radius of each cluster when clustering points, measured in pixels.
 * @param {number} [options.clusterMaxZoom] The maximum zoom level to cluster points in. By default, this value is
 *   one zoom level less than the map's `maxzoom`, so that at the highest zoom level features are not clustered.
 *
 * @example
 * map.addSource('some id', {
 *     data: 'https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_10m_ports.geojson'
 * });
 *
 * @example
 * map.addSource('some id', {
 *    type: 'geojson',
 *    data: {
 *        "type": "FeatureCollection",
 *        "features": [{
 *            "type": "Feature",
 *            "geometry": {
 *                "type": "Point",
 *                "coordinates": [
 *                    -76.53063297271729,
 *                    39.18174077994108
 *                ]
 *            }
 *        }]
 *    }
 * });
 *
 * @example
 * map.getSource('some id').setData({
 *     data: {
 *        "type": "FeatureCollection",
 *        "features": [{
 *            "type": "Feature",
 *            "properties": { "name": "Null Island" },
 *            "geometry": {
 *                "type": "Point",
 *                "coordinates": [ 0, 0 ]
 *            }
 *        }]
 *     }
 * });
 */
function GeoJSONSource(id, options, dispatcher) {
    options = options || {};
    this.id = id;
    this.dispatcher = dispatcher;

    this._data = options.data;

    if (options.maxzoom !== undefined) this.maxzoom = options.maxzoom;
    if (options.type) this.type = options.type;

    var scale = EXTENT / this.tileSize;

    // sent to the worker, along with `url: ...` or `data: literal geojson`,
    // so that it can load/parse/index the geojson data
    // extending with `options.workerOptions` helps to make it easy for
    // third-party sources to hack/reuse GeoJSONSource.
    this.workerOptions = util.extend({
        source: this.id,
        cluster: options.cluster || false,
        geojsonVtOptions: {
            buffer: (options.buffer !== undefined ? options.buffer : 128) * scale,
            tolerance: (options.tolerance !== undefined ? options.tolerance : 0.375) * scale,
            extent: EXTENT,
            maxZoom: this.maxzoom
        },
        superclusterOptions: {
            maxZoom: Math.min(options.clusterMaxZoom, this.maxzoom - 1) || (this.maxzoom - 1),
            extent: EXTENT,
            radius: (options.clusterRadius || 50) * scale,
            log: false
        }
    }, options.workerOptions);

    this._updateWorkerData(function done(err) {
        if (err) {
            this.fire('error', {error: err});
            return;
        }
        this.fire('load');
    }.bind(this));
}

GeoJSONSource.prototype = util.inherit(Evented, /** @lends GeoJSONSource.prototype */ {
    // `type` is a property rather than a constant to make it easy for 3rd
    // parties to use GeoJSONSource to build their own source types.
    type: 'geojson',
    minzoom: 0,
    maxzoom: 18,
    tileSize: 512,
    isTileClipped: true,
    reparseOverscaled: true,

    onAdd: function (map) {
        this.map = map;
    },

    /**
     * Sets the GeoJSON data and re-renders the map.
     *
     * @param {Object|string} data A GeoJSON data object or a URL to one. The latter is preferable in the case of large GeoJSON files.
     * @returns {GeoJSONSource} this
     */
    setData: function(data) {
        this._data = data;

        this._updateWorkerData(function (err) {
            if (err) {
                return this.fire('error', { error: err });
            }
            this.fire('change');
        }.bind(this));

        return this;
    },

    /*
     * Responsible for invoking WorkerSource's geojson.loadData target, which
     * handles loading the geojson data and preparing to serve it up as tiles,
     * using geojson-vt or supercluster as appropriate.
     */
    _updateWorkerData: function(callback) {
        var options = util.extend({}, this.workerOptions);
        var data = this._data;
        if (typeof data === 'string') {
            options.url = typeof window != 'undefined' ? urlResolve(window.location.href, data) : data;
        } else {
            options.data = JSON.stringify(data);
        }

        // target {this.type}.loadData rather than literally geojson.loadData,
        // so that other geojson-like source types can easily reuse this
        // implementation
        this.workerID = this.dispatcher.send(this.type + '.loadData', options, function(err) {
            this._loaded = true;
            callback(err);

        }.bind(this));
    },

    loadTile: function (tile, callback) {
        var overscaling = tile.coord.z > this.maxzoom ? Math.pow(2, tile.coord.z - this.maxzoom) : 1;
        var params = {
            type: this.type,
            uid: tile.uid,
            coord: tile.coord,
            zoom: tile.coord.z,
            maxZoom: this.maxzoom,
            tileSize: this.tileSize,
            source: this.id,
            overscaling: overscaling,
            angle: this.map.transform.angle,
            pitch: this.map.transform.pitch,
            showCollisionBoxes: this.map.showCollisionBoxes
        };

        tile.workerID = this.dispatcher.send('load tile', params, function(err, data) {

            tile.unloadVectorData(this.map.painter);

            if (tile.aborted)
                return;

            if (err) {
                return callback(err);
            }

            tile.loadVectorData(data, this.map.style);

            if (tile.redoWhenDone) {
                tile.redoWhenDone = false;
                tile.redoPlacement(this);
            }

            return callback(null);

        }.bind(this), this.workerID);
    },

    abortTile: function(tile) {
        tile.aborted = true;
    },

    unloadTile: function(tile) {
        tile.unloadVectorData(this.map.painter);
        this.dispatcher.send('remove tile', { uid: tile.uid, source: this.id }, function() {}, tile.workerID);
    },

    serialize: function() {
        return {
            type: this.type,
            data: this._data
        };
    }
});

},{"../data/bucket":2,"../util/evented":111,"../util/util":120,"resolve-url":189}],34:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var ajax = require('../util/ajax');
var rewind = require('geojson-rewind');
var GeoJSONWrapper = require('./geojson_wrapper');
var vtpbf = require('vt-pbf');
var supercluster = require('supercluster');
var geojsonvt = require('geojson-vt');

var VectorTileWorkerSource = require('./vector_tile_worker_source');

module.exports = GeoJSONWorkerSource;

/**
 * The {@link WorkerSource} implementation that supports {@link GeoJSONSource}.
 * This class is designed to be easily reused to support custom source types
 * for data formats that can be parsed/converted into an in-memory GeoJSON
 * representation.  To do so, create it with
 * `new GeoJSONWorkerSource(actor, styleLayers, customLoadGeoJSONFunction)`.  For a full example, see [mapbox-gl-topojson](https://github.com/developmentseed/mapbox-gl-topojson).
 *
 * @class GeoJSONWorkerSource
 * @private
 * @param {Function} [loadGeoJSON] Optional method for custom loading/parsing of GeoJSON based on parameters passed from the main-thread Source.  See {@link GeoJSONWorkerSource#loadGeoJSON}.
 */
function GeoJSONWorkerSource (actor, styleLayers, loadGeoJSON) {
    if (loadGeoJSON) { this.loadGeoJSON = loadGeoJSON; }
    VectorTileWorkerSource.call(this, actor, styleLayers);
}

GeoJSONWorkerSource.prototype = util.inherit(VectorTileWorkerSource, /** @lends GeoJSONWorkerSource.prototype */ {
    // object mapping source ids to geojson-vt-like tile indexes
    _geoJSONIndexes: {},

    /**
     * See {@link VectorTileWorkerSource#loadTile}.
     */
    loadVectorData: function (params, callback) {
        var source = params.source,
            coord = params.coord;

        if (!this._geoJSONIndexes[source]) return callback(null, null); // we couldn't load the file

        var geoJSONTile = this._geoJSONIndexes[source].getTile(Math.min(coord.z, params.maxZoom), coord.x, coord.y);
        if (geoJSONTile) {
            var geojsonWrapper = new GeoJSONWrapper(geoJSONTile.features);
            geojsonWrapper.name = '_geojsonTileLayer';
            var pbf = vtpbf({ layers: { '_geojsonTileLayer': geojsonWrapper }});
            if (pbf.byteOffset !== 0 || pbf.byteLength !== pbf.buffer.byteLength) {
                // Compatibility with node Buffer (https://github.com/mapbox/pbf/issues/35)
                pbf = new Uint8Array(pbf);
            }
            callback(null, { tile: geojsonWrapper, rawTileData: pbf.buffer });
            // tile.parse(geojsonWrapper, this.layerFamilies, this.actor, rawTileData, callback);
        } else {
            return callback(null, null); // nothing in the given tile
        }
    },

    /**
     * Fetches (if appropriate), parses, and index geojson data into tiles. This
     * preparatory method must be called before {@link GeoJSONWorkerSource#loadTile}
     * can correctly serve up tiles.
     *
     * Defers to {@link GeoJSONWorkerSource#loadGeoJSON} for the fetching/parsing,
     * expecting `callback(error, data)` to be called with either an error or a
     * parsed GeoJSON object.
     * @param {object} params
     * @param {string} params.source The id of the source.
     * @param {Function} callback
     */
    loadData: function (params, callback) {
        var handleData = function(err, data) {
            if (err) return callback(err);
            if (typeof data != 'object') {
                return callback(new Error("Input data is not a valid GeoJSON object."));
            }
            rewind(data, true);
            this._indexData(data, params, function (err, indexed) {
                if (err) { return callback(err); }
                this._geoJSONIndexes[params.source] = indexed;
                callback(null);
            }.bind(this));
        }.bind(this);

        this.loadGeoJSON(params, handleData);
    },

    /**
     * Fetch and parse GeoJSON according to the given params.  Calls `callback`
     * with `(err, data)`, where `data` is a parsed GeoJSON object.
     *
     * GeoJSON is loaded and parsed from `params.url` if it exists, or else
     * expected as a literal (string or object) `params.data`.
     *
     * @param {object} params
     * @param {string} [params.url] A URL to the remote GeoJSON data.
     * @param {object} [params.data] Literal GeoJSON data. Must be provided if `params.url` is not.
     */
    loadGeoJSON: function (params, callback) {
        // Because of same origin issues, urls must either include an explicit
        // origin or absolute path.
        // ie: /foo/bar.json or http://example.com/bar.json
        // but not ../foo/bar.json
        if (params.url) {
            ajax.getJSON(params.url, callback);
        } else if (typeof params.data === 'string') {
            try {
                return callback(null, JSON.parse(params.data));
            } catch (e) {
                return callback(new Error("Input data is not a valid GeoJSON object."));
            }
        } else {
            return callback(new Error("Input data is not a valid GeoJSON object."));
        }
    },

    /**
     * Index the data using either geojson-vt or supercluster
     * @param {GeoJSON} data
     * @param {object} params forwarded from loadTile.
     * @param {callback} (err, indexedData)
     * @private
     */
    _indexData: function (data, params, callback) {
        try {
            if (params.cluster) {
                callback(null, supercluster(params.superclusterOptions).load(data.features));
            } else {
                callback(null, geojsonvt(data, params.geojsonVtOptions));
            }
        } catch (err) {
            return callback(err);
        }
    }
});

},{"../util/ajax":102,"../util/util":120,"./geojson_wrapper":35,"./vector_tile_worker_source":46,"geojson-rewind":137,"geojson-vt":142,"supercluster":191,"vt-pbf":202}],35:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');
var VectorTileFeature = require('vector-tile').VectorTileFeature;
var EXTENT = require('../data/bucket').EXTENT;

module.exports = GeoJSONWrapper;

// conform to vectortile api
function GeoJSONWrapper(features) {
    this.features = features;
    this.length = features.length;
    this.extent = EXTENT;
}

GeoJSONWrapper.prototype.feature = function(i) {
    return new FeatureWrapper(this.features[i]);
};

function FeatureWrapper(feature) {
    this.type = feature.type;
    if (feature.type === 1) {
        this.rawGeometry = [];
        for (var i = 0; i < feature.geometry.length; i++) {
            this.rawGeometry.push([feature.geometry[i]]);
        }
    } else {
        this.rawGeometry = feature.geometry;
    }
    this.properties = feature.tags;
    this.extent = EXTENT;
}

FeatureWrapper.prototype.loadGeometry = function() {
    var rings = this.rawGeometry;
    this.geometry = [];

    for (var i = 0; i < rings.length; i++) {
        var ring = rings[i],
            newRing = [];
        for (var j = 0; j < ring.length; j++) {
            newRing.push(new Point(ring[j][0], ring[j][1]));
        }
        this.geometry.push(newRing);
    }
    return this.geometry;
};

FeatureWrapper.prototype.bbox = function() {
    if (!this.geometry) this.loadGeometry();

    var rings = this.geometry,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    for (var i = 0; i < rings.length; i++) {
        var ring = rings[i];

        for (var j = 0; j < ring.length; j++) {
            var coord = ring[j];

            x1 = Math.min(x1, coord.x);
            x2 = Math.max(x2, coord.x);
            y1 = Math.min(y1, coord.y);
            y2 = Math.max(y2, coord.y);
        }
    }

    return [x1, y1, x2, y2];
};

FeatureWrapper.prototype.toGeoJSON = VectorTileFeature.prototype.toGeoJSON;

},{"../data/bucket":2,"point-geometry":187,"vector-tile":198}],36:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var TileCoord = require('./tile_coord');
var LngLat = require('../geo/lng_lat');
var Point = require('point-geometry');
var Evented = require('../util/evented');
var ajax = require('../util/ajax');
var EXTENT = require('../data/bucket').EXTENT;
var RasterBoundsArray = require('../render/draw_raster').RasterBoundsArray;
var Buffer = require('../data/buffer');
var VertexArrayObject = require('../render/vertex_array_object');

module.exports = ImageSource;

/**
 * A data source containing an image.
 * (See the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#sources-image) for detailed documentation of options.)
 *
 * @interface ImageSource
 * @example
 * // add to map
 * map.addSource('some id', {
 *    type: 'image',
 *    url: 'https://www.mapbox.com/images/foo.png',
 *    coordinates: [
 *        [-76.54, 39.18],
 *        [-76.52, 39.18],
 *        [-76.52, 39.17],
 *        [-76.54, 39.17]
 *    ]
 * });
 *
 * // update
 * var mySource = map.getSource('some id');
 * mySource.setCoordinates([
 *     [-76.54335737228394, 39.18579907229748],
 *     [-76.52803659439087, 39.1838364847587],
 *     [-76.5295386314392, 39.17683392507606],
 *     [-76.54520273208618, 39.17876344106642]
 * ]);
 *
 * map.removeSource('some id');  // remove
 */
function ImageSource(id, options, dispatcher) {
    this.id = id;
    this.dispatcher = dispatcher;
    this.url = options.url;
    this.coordinates = options.coordinates;

    ajax.getImage(options.url, function(err, image) {
        if (err) return this.fire('error', {error: err});

        this.image = image;

        this.image.addEventListener('load', function() {
            this.map._rerender();
        }.bind(this));

        this._loaded = true;
        this.fire('load');

        if (this.map) {
            this.setCoordinates(options.coordinates);
        }
    }.bind(this));
}

ImageSource.prototype = util.inherit(Evented, /** @lends ImageSource.prototype */ {
    minzoom: 0,
    maxzoom: 22,
    tileSize: 512,
    onAdd: function(map) {
        this.map = map;
        if (this.image) {
            this.setCoordinates(this.coordinates);
        }
    },

    /**
     * Sets the image's coordinates and re-renders the map.
     *
     * @param {Array<Array<number>>} coordinates Four geographical coordinates,
     *   represented as arrays of longitude and latitude numbers, which define the corners of the image.
     *   The coordinates start at the top left corner of the image and proceed in clockwise order.
     *   They do not have to represent a rectangle.
     * @returns {ImageSource} this
     */
    setCoordinates: function(coordinates) {
        this.coordinates = coordinates;

        // Calculate which mercator tile is suitable for rendering the video in
        // and create a buffer with the corner coordinates. These coordinates
        // may be outside the tile, because raster tiles aren't clipped when rendering.

        var map = this.map;
        var cornerZ0Coords = coordinates.map(function(coord) {
            return map.transform.locationCoordinate(LngLat.convert(coord)).zoomTo(0);
        });

        var centerCoord = this.centerCoord = util.getCoordinatesCenter(cornerZ0Coords);
        centerCoord.column = Math.round(centerCoord.column);
        centerCoord.row = Math.round(centerCoord.row);

        this.minzoom = this.maxzoom = centerCoord.zoom;
        this._coord = new TileCoord(centerCoord.zoom, centerCoord.column, centerCoord.row);
        this._tileCoords = cornerZ0Coords.map(function(coord) {
            var zoomedCoord = coord.zoomTo(centerCoord.zoom);
            return new Point(
                Math.round((zoomedCoord.column - centerCoord.column) * EXTENT),
                Math.round((zoomedCoord.row - centerCoord.row) * EXTENT));
        });

        this.fire('change');
        return this;
    },

    _setTile: function (tile) {
        this._prepared = false;
        this.tile = tile;
        var maxInt16 = 32767;
        var array = new RasterBoundsArray();
        array.emplaceBack(this._tileCoords[0].x, this._tileCoords[0].y, 0, 0);
        array.emplaceBack(this._tileCoords[1].x, this._tileCoords[1].y, maxInt16, 0);
        array.emplaceBack(this._tileCoords[3].x, this._tileCoords[3].y, 0, maxInt16);
        array.emplaceBack(this._tileCoords[2].x, this._tileCoords[2].y, maxInt16, maxInt16);

        this.tile.buckets = {};

        this.tile.boundsBuffer = new Buffer(array.serialize(), RasterBoundsArray.serialize(), Buffer.BufferType.VERTEX);
        this.tile.boundsVAO = new VertexArrayObject();
        this.tile.state = 'loaded';
    },

    prepare: function() {
        if (!this._loaded || !this.image || !this.image.complete) return;
        if (!this.tile) return;

        var painter = this.map.painter;
        var gl = painter.gl;

        if (!this._prepared) {
            this.tile.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.image);
        } else {
            gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.image);
        }
    },

    loadTile: function(tile, callback) {
        // We have a single tile -- whoose coordinates are this._coord -- that
        // covers the image we want to render.  If that's the one being
        // requested, set it up with the image; otherwise, mark the tile as
        // `errored` to indicate that we have no data for it.
        if (this._coord && this._coord.toString() === tile.coord.toString()) {
            this._setTile(tile);
            callback(null);
        } else {
            tile.state = 'errored';
            callback(null);
        }
    },

    serialize: function() {
        return {
            type: 'image',
            urls: this.url,
            coordinates: this.coordinates
        };
    }
});

},{"../data/bucket":2,"../data/buffer":8,"../geo/lng_lat":13,"../render/draw_raster":26,"../render/vertex_array_object":32,"../util/ajax":102,"../util/evented":111,"../util/util":120,"./tile_coord":44,"point-geometry":187}],37:[function(require,module,exports){
'use strict';
var util = require('../util/util');
var ajax = require('../util/ajax');
var browser = require('../util/browser');
var normalizeURL = require('../util/mapbox').normalizeSourceURL;

module.exports = function(options, callback) {
    var loaded = function(err, tileJSON) {
        if (err) {
            return callback(err);
        }

        var result = util.pick(tileJSON, ['tiles', 'minzoom', 'maxzoom', 'attribution']);

        if (tileJSON.vector_layers) {
            result.vectorLayers = tileJSON.vector_layers;
            result.vectorLayerIds = result.vectorLayers.map(function(layer) { return layer.id; });
        }

        callback(null, result);
    };

    if (options.url) {
        ajax.getJSON(normalizeURL(options.url), loaded);
    } else {
        browser.frame(loaded.bind(null, null, options));
    }
};


},{"../util/ajax":102,"../util/browser":103,"../util/mapbox":117,"../util/util":120}],38:[function(require,module,exports){
'use strict';

var Bucket = require('../data/bucket');

/**
 * Converts a pixel value at a the given zoom level to tile units.
 *
 * The shaders mostly calculate everything in tile units so style
 * properties need to be converted from pixels to tile units using this.
 *
 * For example, a translation by 30 pixels at zoom 6.5 will be a
 * translation by pixelsToTileUnits(30, 6.5) tile units.
 *
 * @param {object} tile a {Tile object} will work well, but any object that follows the format {coord: {TileCord object}, tileSize: {number}} will work
 * @param {number} pixelValue
 * @param {number} z
 * @returns {number} value in tile units
 * @private
 */
module.exports = function(tile, pixelValue, z) {
    return pixelValue * (Bucket.EXTENT / (tile.tileSize * Math.pow(2, z - tile.coord.z)));
};


},{"../data/bucket":2}],39:[function(require,module,exports){
'use strict';
var TileCoord = require('./tile_coord');

exports.rendered = function(sourceCache, styleLayers, queryGeometry, params, zoom, bearing) {
    var tilesIn = sourceCache.tilesIn(queryGeometry);

    tilesIn.sort(sortTilesIn);

    var renderedFeatureLayers = [];
    for (var r = 0; r < tilesIn.length; r++) {
        var tileIn = tilesIn[r];
        if (!tileIn.tile.featureIndex) continue;

        renderedFeatureLayers.push(tileIn.tile.featureIndex.query({
            queryGeometry: tileIn.queryGeometry,
            scale: tileIn.scale,
            tileSize: tileIn.tile.tileSize,
            bearing: bearing,
            params: params
        }, styleLayers));
    }
    return mergeRenderedFeatureLayers(renderedFeatureLayers);
};

exports.source = function(sourceCache, params) {
    var tiles = sourceCache.getRenderableIds().map(function(id) {
        return sourceCache.getTileByID(id);
    });

    var result = [];

    var dataTiles = {};
    for (var i = 0; i < tiles.length; i++) {
        var tile = tiles[i];
        var dataID = new TileCoord(Math.min(tile.sourceMaxZoom, tile.coord.z), tile.coord.x, tile.coord.y, 0).id;
        if (!dataTiles[dataID]) {
            dataTiles[dataID] = true;
            tile.querySourceFeatures(result, params);
        }
    }

    return result;
};

function sortTilesIn(a, b) {
    var coordA = a.coord;
    var coordB = b.coord;
    return (coordA.z - coordB.z) || (coordA.y - coordB.y) || (coordA.w - coordB.w) || (coordA.x - coordB.x);
}

function mergeRenderedFeatureLayers(tiles) {
    var result = tiles[0] || {};
    for (var i = 1; i < tiles.length; i++) {
        var tile = tiles[i];
        for (var layerID in tile) {
            var tileFeatures = tile[layerID];
            var resultFeatures = result[layerID];
            if (resultFeatures === undefined) {
                resultFeatures = result[layerID] = tileFeatures;
            } else {
                for (var f = 0; f < tileFeatures.length; f++) {
                    resultFeatures.push(tileFeatures[f]);
                }
            }
        }
    }
    return result;
}


},{"./tile_coord":44}],40:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var ajax = require('../util/ajax');
var Evented = require('../util/evented');
var loadTileJSON = require('./load_tilejson');
var normalizeURL = require('../util/mapbox').normalizeTileURL;

module.exports = RasterTileSource;

function RasterTileSource(id, options, dispatcher) {
    this.id = id;
    this.dispatcher = dispatcher;
    util.extend(this, util.pick(options, ['url', 'scheme', 'tileSize']));
    loadTileJSON(options, function (err, tileJSON) {
        if (err) {
            return this.fire('error', err);
        }
        util.extend(this, tileJSON);
        this.fire('load');
    }.bind(this));
}

RasterTileSource.prototype = util.inherit(Evented, {
    minzoom: 0,
    maxzoom: 22,
    roundZoom: true,
    scheme: 'xyz',
    tileSize: 512,
    _loaded: false,

    onAdd: function (map) {
        this.map = map;
    },

    serialize: function() {
        return {
            type: 'raster',
            url: this.url,
            tileSize: this.tileSize
        };
    },

    loadTile: function(tile, callback) {
        var url = normalizeURL(tile.coord.url(this.tiles, null, this.scheme), this.url, this.tileSize);

        tile.request = ajax.getImage(url, done.bind(this));

        function done(err, img) {
            delete tile.request;

            if (tile.aborted)
                return;

            if (err) {
                return callback(err);
            }

            var gl = this.map.painter.gl;
            tile.texture = this.map.painter.getTexture(img.width);
            if (tile.texture) {
                gl.bindTexture(gl.TEXTURE_2D, tile.texture);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, img);
            } else {
                tile.texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, tile.texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
                tile.texture.size = img.width;
            }
            gl.generateMipmap(gl.TEXTURE_2D);

            this.map.animationLoop.set(this.map.style.rasterFadeDuration);

            tile.state = 'loaded';

            callback(null);
        }
    },

    abortTile: function(tile) {
        if (tile.request) {
            tile.request.abort();
            delete tile.request;
        }
    },

    unloadTile: function(tile) {
        if (tile.texture) this.map.painter.saveTexture(tile.texture);
    }
});

},{"../util/ajax":102,"../util/evented":111,"../util/mapbox":117,"../util/util":120,"./load_tilejson":37}],41:[function(require,module,exports){
'use strict';

var util = require('../util/util');

var sourceTypes = {
    'vector': require('../source/vector_tile_source'),
    'raster': require('../source/raster_tile_source'),
    'geojson': require('../source/geojson_source'),
    'video': require('../source/video_source'),
    'image': require('../source/image_source')
};

/*
 * Creates a tiled data source instance given an options object.
 *
 * @param {string} id
 * @param {Object} source A source definition object compliant with [`mapbox-gl-style-spec`](https://www.mapbox.com/mapbox-gl-style-spec/#sources) or, for a third-party source type, with that type's requirements.
 * @param {string} options.type A source type like `raster`, `vector`, `video`, etc.
 * @param {Dispatcher} dispatcher
 * @returns {Source}
 */
exports.create = function(id, source, dispatcher) {
    source = new sourceTypes[source.type](id, source, dispatcher);

    if (source.id !== id) {
        throw new Error('Expected Source id to be ' + id + ' instead of ' + source.id);
    }

    util.bindAll(['load', 'abort', 'unload', 'serialize', 'prepare'], source);
    return source;
};

exports.getType = function (name) {
    return sourceTypes[name];
};

exports.setType = function (name, type) {
    sourceTypes[name] = type;
};

/**
 * The `Source` interface must be implemented by each source type, including "core" types (`vector`, `raster`, `video`, etc.) and all custom, third-party types.
 *
 * @class Source
 * @private
 *
 * @param {string} id The id for the source. Must not be used by any existing source.
 * @param {Object} options Source options, specific to the source type (except for `options.type`, which is always required).
 * @param {string} options.type The source type, matching the value of `name` used in {@link Style#addSourceType}.
 * @param {Dispatcher} dispatcher A {@link Dispatcher} instance, which can be used to send messages to the workers.
 *
 * @fires load to indicate source data has been loaded, so that it's okay to call `loadTile`
 * @fires change to indicate source data has changed, so that any current caches should be flushed
 * @property {string} id The id for the source.  Must match the id passed to the constructor.
 * @property {number} minzoom
 * @property {number} maxzoom
 * @property {boolean} isTileClipped `false` if tiles can be drawn outside their boundaries, `true` if they cannot.
 * @property {boolean} reparseOverscaled `true` if tiles should be sent back to the worker for each overzoomed zoom level, `false` if not.
 * @property {boolean} roundZoom `true` if zoom levels are rounded to the nearest integer in the source data, `false` if they are floor-ed to the nearest integer.
 */

/**
 * An optional URL to a script which, when run by a Worker, registers a {@link WorkerSource} implementation for this Source type by calling `self.registerWorkerSource(workerSource: WorkerSource)`.
 *
 * @member {URL|undefined} workerSourceURL
 * @memberof Source
 * @static
 */

/**
 * @method
 * @name loadTile
 * @param {Tile} tile
 * @param {Funtion} callback Called when tile has been loaded
 * @memberof Source
 * @instance
 */

/**
 * @method
 * @name abortTile
 * @param {Tile} tile
 * @memberof Source
 * @instance
 */

/**
 * @method
 * @name unloadTile
 * @param {Tile} tile
 * @memberof Source
 * @instance
 */

/**
 * @method
 * @name serialize
 * @returns {Object} A plain (stringifiable) JS object representing the current state of the source. Creating a source using the returned object as the `options` should result in a Source that is equivalent to this one.
 * @memberof Source
 * @instance
 */

/**
 * @method
 * @name prepare
 * @memberof Source
 * @instance
 */



/**
 * May be implemented by custom source types to provide code that can be run on
 * the WebWorkers. In addition to providing a custom
 * {@link WorkerSource#loadTile}, any other methods attached to a `WorkerSource`
 * implementation may also be targeted by the {@link Source} via
 * `dispatcher.send('source-type.methodname', params, callback)`.
 *
 * @see {@link Map#addSourceType}
 * @private
 *
 * @class WorkerSource
 * @param {Actor} actor
 * @param {object} styleLayers An accessor provided by the Worker to get the current style layers and layer families.
 * @param {Function} styleLayers.getLayers
 * @param {Function} styleLayers.getLayerFamilies
 */

/**
 * Loads a tile from the given params and parse it into buckets ready to send
 * back to the main thread for rendering.  Should call the callback with:
 * `{ buckets, featureIndex, collisionTile, symbolInstancesArray, symbolQuadsArray, rawTileData}`.
 *
 * @method
 * @name loadTile
 * @param {object} params Parameters sent by the main-thread Source identifying the tile to load.
 * @param {Function} callback
 * @memberof WorkerSource
 * @instance
 */

/**
 * Re-parses a tile that has already been loaded.  Yields the same data as
 * {@link WorkerSource#loadTile}.
 *
 * @method
 * @name reloadTile
 * @param {object} params
 * @param {Function} callback
 * @memberof WorkerSource
 * @instance
 */

/**
 * Aborts loading a tile that is in progress.
 * @method
 * @name abortTile
 * @param {object} params
 * @memberof WorkerSource
 * @instance
 */

/**
 * Removes this tile from any local caches.
 * @method
 * @name removeTile
 * @memberof WorkerSource
 * @instance
 */

},{"../source/geojson_source":33,"../source/image_source":36,"../source/raster_tile_source":40,"../source/vector_tile_source":45,"../source/video_source":47,"../util/util":120}],42:[function(require,module,exports){
'use strict';

var Source = require('./source');
var Tile = require('./tile');
var Evented = require('../util/evented');
var TileCoord = require('./tile_coord');
var Cache = require('../util/lru_cache');
var Coordinate = require('../geo/coordinate');
var util = require('../util/util');
var EXTENT = require('../data/bucket').EXTENT;

module.exports = SourceCache;

/**
 * A tile pyramid is a specialized cache and datastructure
 * that contains tiles. It's used by sources to manage their
 * data.
 *
 * @param {Object} options
 * @private
 */
function SourceCache(id, options, dispatcher) {
    this.id = id;
    this.dispatcher = dispatcher;

    var source = this._source = Source.create(id, options, dispatcher)
    .on('load', function () {
        if (this.map && this._source.onAdd) { this._source.onAdd(this.map); }

        this._sourceLoaded = true;

        this.tileSize = source.tileSize;
        this.minzoom = source.minzoom;
        this.maxzoom = source.maxzoom;
        this.roundZoom = source.roundZoom;
        this.reparseOverscaled = source.reparseOverscaled;
        this.isTileClipped = source.isTileClipped;
        this.attribution = source.attribution;

        this.vectorLayerIds = source.vectorLayerIds;

        this.fire('load');
    }.bind(this))
    .on('error', function (e) {
        this._sourceErrored = true;
        this.fire('error', e);
    }.bind(this))
    .on('change', function () {
        this.reload();
        if (this.transform) {
            this.update(this.transform, this.map && this.map.style.rasterFadeDuration);
        }
        this.fire('change');
    }.bind(this));

    this._tiles = {};
    this._cache = new Cache(0, this.unloadTile.bind(this));

    this._isIdRenderable = this._isIdRenderable.bind(this);
}


SourceCache.maxOverzooming = 10;
SourceCache.maxUnderzooming = 3;

SourceCache.prototype = util.inherit(Evented, {
    onAdd: function (map) {
        this.map = map;
        if (this._source && this._source.onAdd) {
            this._source.onAdd(map);
        }
    },

    /**
     * Return true if no tile data is pending, tiles will not change unless
     * an additional API call is received.
     * @returns {boolean}
     * @private
     */
    loaded: function() {
        if (this._sourceErrored) { return true; }
        if (!this._sourceLoaded) { return false; }
        for (var t in this._tiles) {
            var tile = this._tiles[t];
            if (tile.state !== 'loaded' && tile.state !== 'errored')
                return false;
        }
        return true;
    },

    /**
     * @returns {Source} The underlying source object
     * @private
     */
    getSource: function () {
        return this._source;
    },

    loadTile: function (tile, callback) {
        return this._source.loadTile(tile, callback);
    },

    unloadTile: function (tile) {
        if (this._source.unloadTile)
            return this._source.unloadTile(tile);
    },

    abortTile: function (tile) {
        if (this._source.abortTile)
            return this._source.abortTile(tile);
    },

    serialize: function () {
        return this._source.serialize();
    },

    prepare: function () {
        if (this._sourceLoaded && this._source.prepare)
            return this._source.prepare();
    },

    /**
     * Return all tile ids ordered with z-order, and cast to numbers
     * @returns {Array<number>} ids
     * @private
     */
    getIds: function() {
        return Object.keys(this._tiles).map(Number).sort(compareKeyZoom);
    },

    getRenderableIds: function() {
        return this.getIds().filter(this._isIdRenderable);
    },

    _isIdRenderable: function(id) {
        return this._tiles[id].isRenderable() && !this._coveredTiles[id];
    },

    reload: function() {
        this._cache.reset();
        for (var i in this._tiles) {
            var tile = this._tiles[i];

            // The difference between "loading" tiles and "reloading" tiles is
            // that "reloading" tiles are "renderable". Therefore, a "loading"
            // tile cannot become a "reloading" tile without first becoming
            // a "loaded" tile.
            if (tile.state !== 'loading') {
                tile.state = 'reloading';
            }

            this.loadTile(this._tiles[i], this._tileLoaded.bind(this, this._tiles[i]));
        }
    },

    _tileLoaded: function (tile, err) {
        if (err) {
            tile.state = 'errored';
            this.fire('tile.error', {tile: tile, error: err});
            this._source.fire('tile.error', {tile: tile, error: err});
            return;
        }

        tile.source = this;
        tile.timeAdded = new Date().getTime();
        this.fire('tile.load', {tile: tile});
        this._source.fire('tile.load', {tile: tile});
    },

    /**
     * Get a specific tile by TileCoordinate
     * @param {TileCoordinate} coord
     * @returns {Object} tile
     * @private
     */
    getTile: function(coord) {
        return this.getTileByID(coord.id);
    },

    /**
     * Get a specific tile by id
     * @param {number|string} id
     * @returns {Object} tile
     * @private
     */
    getTileByID: function(id) {
        return this._tiles[id];
    },

    /**
     * get the zoom level adjusted for the difference in map and source tilesizes
     * @param {Object} transform
     * @returns {number} zoom level
     * @private
     */
    getZoom: function(transform) {
        return transform.zoom + transform.scaleZoom(transform.tileSize / this.tileSize);
    },

    /**
     * Recursively find children of the given tile (up to maxCoveringZoom) that are already loaded;
     * adds found tiles to retain object; returns true if any child is found.
     *
     * @param {Coordinate} coord
     * @param {number} maxCoveringZoom
     * @param {boolean} retain
     * @returns {boolean} whether the operation was complete
     * @private
     */
    findLoadedChildren: function(coord, maxCoveringZoom, retain) {
        var found = false;

        for (var id in this._tiles) {
            var tile = this._tiles[id];

            // only consider renderable tiles on higher zoom levels (up to maxCoveringZoom)
            if (retain[id] || !tile.isRenderable() || tile.coord.z <= coord.z || tile.coord.z > maxCoveringZoom) continue;

            // disregard tiles that are not descendants of the given tile coordinate
            var z2 = Math.pow(2, Math.min(tile.coord.z, this.maxzoom) - Math.min(coord.z, this.maxzoom));
            if (Math.floor(tile.coord.x / z2) !== coord.x ||
                Math.floor(tile.coord.y / z2) !== coord.y)
                continue;

            // found loaded child
            retain[id] = true;
            found = true;

            // loop through parents; retain the topmost loaded one if found
            while (tile && tile.coord.z - 1 > coord.z) {
                var parentId = tile.coord.parent(this.maxzoom).id;
                tile = this._tiles[parentId];

                if (tile && tile.isRenderable()) {
                    delete retain[id];
                    retain[parentId] = true;
                }
            }
        }
        return found;
    },

    /**
     * Find a loaded parent of the given tile (up to minCoveringZoom);
     * adds the found tile to retain object and returns the tile if found
     *
     * @param {Coordinate} coord
     * @param {number} minCoveringZoom
     * @param {boolean} retain
     * @returns {Tile} tile object
     * @private
     */
    findLoadedParent: function(coord, minCoveringZoom, retain) {
        for (var z = coord.z - 1; z >= minCoveringZoom; z--) {
            coord = coord.parent(this.maxzoom);
            var tile = this._tiles[coord.id];
            if (tile && tile.isRenderable()) {
                retain[coord.id] = true;
                return tile;
            }
            if (this._cache.has(coord.id)) {
                this.addTile(coord);
                retain[coord.id] = true;
                return this._tiles[coord.id];
            }
        }
    },

    /**
     * Resizes the tile cache based on the current viewport's size.
     *
     * Larger viewports use more tiles and need larger caches. Larger viewports
     * are more likely to be found on devices with more memory and on pages where
     * the map is more important.
     *
     * @private
     */
    updateCacheSize: function(transform) {
        var widthInTiles = Math.ceil(transform.width / transform.tileSize) + 1;
        var heightInTiles = Math.ceil(transform.height / transform.tileSize) + 1;
        var approxTilesInView = widthInTiles * heightInTiles;
        var commonZoomRange = 5;
        this._cache.setMaxSize(Math.floor(approxTilesInView * commonZoomRange));
    },

    /**
     * Removes tiles that are outside the viewport and adds new tiles that
     * are inside the viewport.
     * @private
     */
    update: function(transform, fadeDuration) {
        if (!this._sourceLoaded) { return; }
        var i;
        var coord;
        var tile;

        this.updateCacheSize(transform);

        // Determine the overzooming/underzooming amounts.
        var zoom = (this.roundZoom ? Math.round : Math.floor)(this.getZoom(transform));
        var minCoveringZoom = Math.max(zoom - SourceCache.maxOverzooming, this.minzoom);
        var maxCoveringZoom = Math.max(zoom + SourceCache.maxUnderzooming,  this.minzoom);

        // Retain is a list of tiles that we shouldn't delete, even if they are not
        // the most ideal tile for the current viewport. This may include tiles like
        // parent or child tiles that are *already* loaded.
        var retain = {};
        var now = new Date().getTime();

        // Covered is a list of retained tiles who's areas are full covered by other,
        // better, retained tiles. They are not drawn separately.
        this._coveredTiles = {};

        var required = this.used ? transform.coveringTiles(this._source) : [];
        for (i = 0; i < required.length; i++) {
            coord = required[i];
            tile = this.addTile(coord);

            retain[coord.id] = true;

            if (tile.isRenderable())
                continue;

            // The tile we require is not yet loaded.
            // Retain child or parent tiles that cover the same area.
            if (!this.findLoadedChildren(coord, maxCoveringZoom, retain)) {
                this.findLoadedParent(coord, minCoveringZoom, retain);
            }
        }

        var parentsForFading = {};

        var ids = Object.keys(retain);
        for (var k = 0; k < ids.length; k++) {
            var id = ids[k];
            coord = TileCoord.fromID(id);
            tile = this._tiles[id];
            if (tile && tile.timeAdded > now - (fadeDuration || 0)) {
                // This tile is still fading in. Find tiles to cross-fade with it.
                if (this.findLoadedChildren(coord, maxCoveringZoom, retain)) {
                    retain[id] = true;
                }
                this.findLoadedParent(coord, minCoveringZoom, parentsForFading);
            }
        }

        var fadedParent;
        for (fadedParent in parentsForFading) {
            if (!retain[fadedParent]) {
                // If a tile is only needed for fading, mark it as covered so that it isn't rendered on it's own.
                this._coveredTiles[fadedParent] = true;
            }
        }
        for (fadedParent in parentsForFading) {
            retain[fadedParent] = true;
        }

        // Remove the tiles we don't need anymore.
        var remove = util.keysDifference(this._tiles, retain);
        for (i = 0; i < remove.length; i++) {
            this.removeTile(+remove[i]);
        }

        this.transform = transform;
    },

    /**
     * Add a tile, given its coordinate, to the pyramid.
     * @param {Coordinate} coord
     * @returns {Coordinate} the coordinate.
     * @private
     */
    addTile: function(coord) {
        var tile = this._tiles[coord.id];
        if (tile)
            return tile;

        var wrapped = coord.wrapped();
        tile = this._tiles[wrapped.id];

        if (!tile) {
            tile = this._cache.get(wrapped.id);
            if (tile && this._redoPlacement) {
                this._redoPlacement(tile);
            }
        }

        if (!tile) {
            var zoom = coord.z;
            var overscaling = zoom > this.maxzoom ? Math.pow(2, zoom - this.maxzoom) : 1;
            tile = new Tile(wrapped, this.tileSize * overscaling, this.maxzoom);
            this.loadTile(tile, this._tileLoaded.bind(this, tile));
        }

        tile.uses++;
        this._tiles[coord.id] = tile;
        this.fire('tile.add', {tile: tile});
        this._source.fire('tile.add', {tile: tile});

        return tile;
    },

    /**
     * Remove a tile, given its id, from the pyramid
     * @param {string|number} id tile id
     * @returns {undefined} nothing
     * @private
     */
    removeTile: function(id) {
        var tile = this._tiles[id];
        if (!tile)
            return;

        tile.uses--;
        delete this._tiles[id];
        this.fire('tile.remove', {tile: tile});
        this._source.fire('tile.remove', {tile: tile});

        if (tile.uses > 0)
            return;

        if (tile.isRenderable()) {
            this._cache.add(tile.coord.wrapped().id, tile);
        } else {
            tile.aborted = true;
            this.abortTile(tile);
            this.unloadTile(tile);
        }
    },

    /**
     * Remove all tiles from this pyramid
     * @private
     */
    clearTiles: function() {
        for (var id in this._tiles)
            this.removeTile(id);
        this._cache.reset();
    },

    /**
     * Search through our current tiles and attempt to find the tiles that
     * cover the given bounds.
     * @param {Array<Coordinate>} queryGeometry coordinates of the corners of bounding rectangle
     * @returns {Array<Object>} result items have {tile, minX, maxX, minY, maxY}, where min/max bounding values are the given bounds transformed in into the coordinate space of this tile.
     * @private
     */
    tilesIn: function(queryGeometry) {
        var tileResults = {};
        var ids = this.getIds();

        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var z = queryGeometry[0].zoom;

        for (var k = 0; k < queryGeometry.length; k++) {
            var p = queryGeometry[k];
            minX = Math.min(minX, p.column);
            minY = Math.min(minY, p.row);
            maxX = Math.max(maxX, p.column);
            maxY = Math.max(maxY, p.row);
        }

        for (var i = 0; i < ids.length; i++) {
            var tile = this._tiles[ids[i]];
            var coord = TileCoord.fromID(ids[i]);

            var tileSpaceBounds = [
                coordinateToTilePoint(coord, tile.sourceMaxZoom, new Coordinate(minX, minY, z)),
                coordinateToTilePoint(coord, tile.sourceMaxZoom, new Coordinate(maxX, maxY, z))
            ];

            if (tileSpaceBounds[0].x < EXTENT && tileSpaceBounds[0].y < EXTENT &&
                tileSpaceBounds[1].x >= 0 && tileSpaceBounds[1].y >= 0) {

                var tileSpaceQueryGeometry = [];
                for (var j = 0; j < queryGeometry.length; j++) {
                    tileSpaceQueryGeometry.push(coordinateToTilePoint(coord, tile.sourceMaxZoom, queryGeometry[j]));
                }

                var tileResult = tileResults[tile.coord.id];
                if (tileResult === undefined) {
                    tileResult = tileResults[tile.coord.id] = {
                        tile: tile,
                        coord: coord,
                        queryGeometry: [],
                        scale: Math.pow(2, this.transform.zoom - tile.coord.z)
                    };
                }

                // Wrapped tiles share one tileResult object but can have multiple queryGeometry parts
                tileResult.queryGeometry.push(tileSpaceQueryGeometry);
            }
        }

        var results = [];
        for (var t in tileResults) {
            results.push(tileResults[t]);
        }
        return results;
    },

    redoPlacement: function () {
        var ids = this.getIds();
        for (var i = 0; i < ids.length; i++) {
            var tile = this.getTileByID(ids[i]);
            tile.redoPlacement(this);
        }
    },

    getVisibleCoordinates: function () {
        return this.getRenderableIds().map(TileCoord.fromID);
    }
});

/**
 * Convert a coordinate to a point in a tile's coordinate space.
 * @param {Coordinate} tileCoord
 * @param {Coordinate} coord
 * @returns {Object} position
 * @private
 */
function coordinateToTilePoint(tileCoord, sourceMaxZoom, coord) {
    var zoomedCoord = coord.zoomTo(Math.min(tileCoord.z, sourceMaxZoom));
    return {
        x: (zoomedCoord.column - (tileCoord.x + tileCoord.w * Math.pow(2, tileCoord.z))) * EXTENT,
        y: (zoomedCoord.row - tileCoord.y) * EXTENT
    };

}

function compareKeyZoom(a, b) {
    return (a % 32) - (b % 32);
}

},{"../data/bucket":2,"../geo/coordinate":12,"../util/evented":111,"../util/lru_cache":116,"../util/util":120,"./source":41,"./tile":43,"./tile_coord":44}],43:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var Bucket = require('../data/bucket');
var FeatureIndex = require('../data/feature_index');
var vt = require('vector-tile');
var Protobuf = require('pbf');
var GeoJSONFeature = require('../util/vectortile_to_geojson');
var featureFilter = require('feature-filter');
var CollisionTile = require('../symbol/collision_tile');
var CollisionBoxArray = require('../symbol/collision_box');
var SymbolInstancesArray = require('../symbol/symbol_instances');
var SymbolQuadsArray = require('../symbol/symbol_quads');

module.exports = Tile;

/**
 * A tile object is the combination of a Coordinate, which defines
 * its place, as well as a unique ID and data tracking for its content
 *
 * @param {Coordinate} coord
 * @param {number} size
 * @private
 */
function Tile(coord, size, sourceMaxZoom) {
    this.coord = coord;
    this.uid = util.uniqueId();
    this.uses = 0;
    this.tileSize = size;
    this.sourceMaxZoom = sourceMaxZoom;
    this.buckets = {};

    // `this.state` must be one of
    //
    // - `loading`:   Tile data is in the process of loading.
    // - `loaded`:    Tile data has been loaded. Tile can be rendered.
    // - `reloading`: Tile data has been loaded and is being updated. Tile can be rendered.
    // - `unloaded`:  Tile data has been deleted.
    // - `errored`:   Tile data was not loaded because of an error.
    this.state = 'loading';
}

Tile.prototype = {

    /**
     * Given a data object with a 'buffers' property, load it into
     * this tile's elementGroups and buffers properties and set loaded
     * to true. If the data is null, like in the case of an empty
     * GeoJSON tile, no-op but still set loaded to true.
     * @param {Object} data
     * @returns {undefined}
     * @private
     */
    loadVectorData: function(data, style) {
        this.state = 'loaded';

        // empty GeoJSON tile
        if (!data) return;

        this.collisionBoxArray = new CollisionBoxArray(data.collisionBoxArray);
        this.collisionTile = new CollisionTile(data.collisionTile, this.collisionBoxArray);
        this.symbolInstancesArray = new SymbolInstancesArray(data.symbolInstancesArray);
        this.symbolQuadsArray = new SymbolQuadsArray(data.symbolQuadsArray);
        this.featureIndex = new FeatureIndex(data.featureIndex, data.rawTileData, this.collisionTile);
        this.rawTileData = data.rawTileData;
        this.buckets = unserializeBuckets(data.buckets, style);
    },

    /**
     * given a data object and a GL painter, destroy and re-create
     * all of its buffers.
     * @param {Object} data
     * @param {Object} painter
     * @returns {undefined}
     * @private
     */
    reloadSymbolData: function(data, painter, style) {
        if (this.state === 'unloaded') return;

        this.collisionTile = new CollisionTile(data.collisionTile, this.collisionBoxArray);
        this.featureIndex.setCollisionTile(this.collisionTile);

        // Destroy and delete existing symbol buckets
        for (var id in this.buckets) {
            var bucket = this.buckets[id];
            if (bucket.type === 'symbol') {
                bucket.destroy(painter.gl);
                delete this.buckets[id];
            }
        }

        // Add new symbol buckets
        util.extend(this.buckets, unserializeBuckets(data.buckets, style));
    },

    /**
     * Make sure that this tile doesn't own any data within a given
     * painter, so that it doesn't consume any memory or maintain
     * any references to the painter.
     * @param {Object} painter gl painter object
     * @returns {undefined}
     * @private
     */
    unloadVectorData: function(painter) {
        for (var id in this.buckets) {
            var bucket = this.buckets[id];
            bucket.destroy(painter.gl);
        }

        this.collisionBoxArray = null;
        this.symbolQuadsArray = null;
        this.symbolInstancesArray = null;
        this.collisionTile = null;
        this.featureIndex = null;
        this.rawTileData = null;
        this.buckets = null;
        this.state = 'unloaded';
    },

    redoPlacement: function(source) {
        if (this.state !== 'loaded' || this.state === 'reloading') {
            this.redoWhenDone = true;
            return;
        }

        this.state = 'reloading';

        source.dispatcher.send('redo placement', {
            uid: this.uid,
            source: source.id,
            angle: source.map.transform.angle,
            pitch: source.map.transform.pitch,
            showCollisionBoxes: source.map.showCollisionBoxes
        }, done.bind(this), this.workerID);

        function done(_, data) {
            this.reloadSymbolData(data, source.map.painter, source.map.style);
            source.fire('tile.load', {tile: this});

            this.state = 'loaded';
            if (this.redoWhenDone) {
                this.redoPlacement(source);
                this.redoWhenDone = false;
            }
        }
    },

    getBucket: function(layer) {
        return this.buckets && this.buckets[layer.ref || layer.id];
    },

    querySourceFeatures: function(result, params) {
        if (!this.rawTileData) return;

        if (!this.vtLayers) {
            this.vtLayers = new vt.VectorTile(new Protobuf(new Uint8Array(this.rawTileData))).layers;
        }

        var layer = this.vtLayers._geojsonTileLayer || this.vtLayers[params.sourceLayer];

        if (!layer) return;

        var filter = featureFilter(params.filter);
        var coord = { z: this.coord.z, x: this.coord.x, y: this.coord.y };

        for (var i = 0; i < layer.length; i++) {
            var feature = layer.feature(i);
            if (filter(feature)) {
                var geojsonFeature = new GeoJSONFeature(feature, this.coord.z, this.coord.x, this.coord.y);
                geojsonFeature.tile = coord;
                result.push(geojsonFeature);
            }
        }
    },

    isRenderable: function() {
        return this.state === 'loaded' || this.state === 'reloading';
    }
};

function unserializeBuckets(input, style) {
    // Guard against the case where the map's style has been set to null while
    // this bucket has been parsing.
    if (!style) return;

    var output = {};
    for (var i = 0; i < input.length; i++) {
        var layer = style.getLayer(input[i].layerId);
        if (!layer) continue;

        var bucket = Bucket.create(util.extend({
            layer: layer,
            childLayers: input[i].childLayerIds
                .map(style.getLayer.bind(style))
                .filter(function(layer) { return layer; })
        }, input[i]));
        output[bucket.id] = bucket;
    }
    return output;
}

},{"../data/bucket":2,"../data/feature_index":10,"../symbol/collision_box":70,"../symbol/collision_tile":72,"../symbol/symbol_instances":81,"../symbol/symbol_quads":82,"../util/util":120,"../util/vectortile_to_geojson":121,"feature-filter":136,"pbf":185,"vector-tile":198}],44:[function(require,module,exports){
'use strict';

var assert = require('assert');
var WhooTS = require('whoots-js');
var Coordinate = require('../geo/coordinate');

module.exports = TileCoord;

function TileCoord(z, x, y, w) {
    assert(!isNaN(z) && z >= 0 && z % 1 === 0);
    assert(!isNaN(x) && x >= 0 && x % 1 === 0);
    assert(!isNaN(y) && y >= 0 && y % 1 === 0);

    if (isNaN(w)) w = 0;

    this.z = +z;
    this.x = +x;
    this.y = +y;
    this.w = +w;

    // calculate id
    w *= 2;
    if (w < 0) w = w * -1 - 1;
    var dim = 1 << this.z;
    this.id = ((dim * dim * w + dim * this.y + this.x) * 32) + this.z;

    // for caching pos matrix calculation when rendering
    this.posMatrix = null;
}

TileCoord.prototype.toString = function() {
    return this.z + "/" + this.x + "/" + this.y;
};

TileCoord.prototype.toCoordinate = function(sourceMaxZoom) {
    var zoom = Math.min(this.z, sourceMaxZoom);
    var tileScale = Math.pow(2, zoom);
    var row = this.y;
    var column = this.x + tileScale * this.w;
    return new Coordinate(column, row, zoom);
};

// Parse a packed integer id into a TileCoord object
TileCoord.fromID = function(id) {
    var z = id % 32, dim = 1 << z;
    var xy = ((id - z) / 32);
    var x = xy % dim, y = ((xy - x) / dim) % dim;
    var w = Math.floor(xy / (dim * dim));
    if (w % 2 !== 0) w = w * -1 - 1;
    w /= 2;
    return new TileCoord(z, x, y, w);
};

function getQuadkey(z, x, y) {
    var quadkey = '', mask;
    for (var i = z; i > 0; i--) {
        mask = 1 << (i - 1);
        quadkey += ((x & mask ? 1 : 0) + (y & mask ? 2 : 0));
    }
    return quadkey;
}

// given a list of urls, choose a url template and return a tile URL
TileCoord.prototype.url = function(urls, sourceMaxZoom, scheme) {
    var bbox = WhooTS.getTileBBox(this.x, this.y, this.z);
    var quadkey = getQuadkey(this.z, this.x, this.y);

    return urls[(this.x + this.y) % urls.length]
        .replace('{prefix}', (this.x % 16).toString(16) + (this.y % 16).toString(16))
        .replace('{z}', Math.min(this.z, sourceMaxZoom || this.z))
        .replace('{x}', this.x)
        .replace('{y}', scheme === 'tms' ? (Math.pow(2, this.z) - this.y - 1) : this.y)
        .replace('{quadkey}', quadkey)
        .replace('{bbox-epsg-3857}', bbox);
};

// Return the coordinate of the parent tile
TileCoord.prototype.parent = function(sourceMaxZoom) {
    if (this.z === 0) return null;

    // the id represents an overscaled tile, return the same coordinates with a lower z
    if (this.z > sourceMaxZoom) {
        return new TileCoord(this.z - 1, this.x, this.y, this.w);
    }

    return new TileCoord(this.z - 1, Math.floor(this.x / 2), Math.floor(this.y / 2), this.w);
};

TileCoord.prototype.wrapped = function() {
    return new TileCoord(this.z, this.x, this.y, 0);
};

// Return the coordinates of the tile's children
TileCoord.prototype.children = function(sourceMaxZoom) {

    if (this.z >= sourceMaxZoom) {
        // return a single tile coord representing a an overscaled tile
        return [new TileCoord(this.z + 1, this.x, this.y, this.w)];
    }

    var z = this.z + 1;
    var x = this.x * 2;
    var y = this.y * 2;
    return [
        new TileCoord(z, x, y, this.w),
        new TileCoord(z, x + 1, y, this.w),
        new TileCoord(z, x, y + 1, this.w),
        new TileCoord(z, x + 1, y + 1, this.w)
    ];
};

// Taken from polymaps src/Layer.js
// https://github.com/simplegeo/polymaps/blob/master/src/Layer.js#L333-L383

function edge(a, b) {
    if (a.row > b.row) { var t = a; a = b; b = t; }
    return {
        x0: a.column,
        y0: a.row,
        x1: b.column,
        y1: b.row,
        dx: b.column - a.column,
        dy: b.row - a.row
    };
}

function scanSpans(e0, e1, ymin, ymax, scanLine) {
    var y0 = Math.max(ymin, Math.floor(e1.y0));
    var y1 = Math.min(ymax, Math.ceil(e1.y1));

    // sort edges by x-coordinate
    if ((e0.x0 === e1.x0 && e0.y0 === e1.y0) ?
            (e0.x0 + e1.dy / e0.dy * e0.dx < e1.x1) :
            (e0.x1 - e1.dy / e0.dy * e0.dx < e1.x0)) {
        var t = e0; e0 = e1; e1 = t;
    }

    // scan lines!
    var m0 = e0.dx / e0.dy;
    var m1 = e1.dx / e1.dy;
    var d0 = e0.dx > 0; // use y + 1 to compute x0
    var d1 = e1.dx < 0; // use y + 1 to compute x1
    for (var y = y0; y < y1; y++) {
        var x0 = m0 * Math.max(0, Math.min(e0.dy, y + d0 - e0.y0)) + e0.x0;
        var x1 = m1 * Math.max(0, Math.min(e1.dy, y + d1 - e1.y0)) + e1.x0;
        scanLine(Math.floor(x1), Math.ceil(x0), y);
    }
}

function scanTriangle(a, b, c, ymin, ymax, scanLine) {
    var ab = edge(a, b),
        bc = edge(b, c),
        ca = edge(c, a);

    var t;

    // sort edges by y-length
    if (ab.dy > bc.dy) { t = ab; ab = bc; bc = t; }
    if (ab.dy > ca.dy) { t = ab; ab = ca; ca = t; }
    if (bc.dy > ca.dy) { t = bc; bc = ca; ca = t; }

    // scan span! scan span!
    if (ab.dy) scanSpans(ca, ab, ymin, ymax, scanLine);
    if (bc.dy) scanSpans(ca, bc, ymin, ymax, scanLine);
}

TileCoord.cover = function(z, bounds, actualZ) {
    var tiles = 1 << z;
    var t = {};

    function scanLine(x0, x1, y) {
        var x, wx, coord;
        if (y >= 0 && y <= tiles) {
            for (x = x0; x < x1; x++) {
                wx = (x % tiles + tiles) % tiles;
                coord = new TileCoord(actualZ, wx, y, Math.floor(x / tiles));
                t[coord.id] = coord;
            }
        }
    }

    // Divide the screen up in two triangles and scan each of them:
    // +---/
    // | / |
    // /---+
    scanTriangle(bounds[0], bounds[1], bounds[2], 0, tiles, scanLine);
    scanTriangle(bounds[2], bounds[3], bounds[0], 0, tiles, scanLine);

    return Object.keys(t).map(function(id) {
        return t[id];
    });
};

},{"../geo/coordinate":12,"assert":122,"whoots-js":206}],45:[function(require,module,exports){
'use strict';

var Evented = require('../util/evented');
var util = require('../util/util');
var loadTileJSON = require('./load_tilejson');
var normalizeURL = require('../util/mapbox').normalizeTileURL;

module.exports = VectorTileSource;

function VectorTileSource(id, options, dispatcher) {
    this.id = id;
    this.dispatcher = dispatcher;
    util.extend(this, util.pick(options, ['url', 'scheme', 'tileSize']));
    this._options = util.extend({ type: 'vector' }, options);

    if (this.tileSize !== 512) {
        throw new Error('vector tile sources must have a tileSize of 512');
    }

    loadTileJSON(options, function (err, tileJSON) {
        if (err) {
            this.fire('error', err);
            return;
        }
        util.extend(this, tileJSON);
        this.fire('load');
    }.bind(this));
}

VectorTileSource.prototype = util.inherit(Evented, {
    minzoom: 0,
    maxzoom: 22,
    scheme: 'xyz',
    tileSize: 512,
    reparseOverscaled: true,
    isTileClipped: true,

    onAdd: function(map) {
        this.map = map;
    },

    serialize: function() {
        return util.extend({}, this._options);
    },

    loadTile: function(tile, callback) {
        var overscaling = tile.coord.z > this.maxzoom ? Math.pow(2, tile.coord.z - this.maxzoom) : 1;
        var params = {
            url: normalizeURL(tile.coord.url(this.tiles, this.maxzoom, this.scheme), this.url),
            uid: tile.uid,
            coord: tile.coord,
            zoom: tile.coord.z,
            tileSize: this.tileSize * overscaling,
            source: this.id,
            overscaling: overscaling,
            angle: this.map.transform.angle,
            pitch: this.map.transform.pitch,
            showCollisionBoxes: this.map.showCollisionBoxes
        };

        if (tile.workerID) {
            if (tile.state === 'loading') {
                // schedule tile reloading after it has been loaded
                tile.reloadCallback = callback;
            } else {
                params.rawTileData = tile.rawTileData;
                this.dispatcher.send('reload tile', params, done.bind(this), tile.workerID);
            }
        } else {
            tile.workerID = this.dispatcher.send('load tile', params, done.bind(this));
        }

        function done(err, data) {
            if (tile.aborted)
                return;

            if (err) {
                return callback(err);
            }

            tile.loadVectorData(data, this.map.style);

            if (tile.redoWhenDone) {
                tile.redoWhenDone = false;
                tile.redoPlacement(this);
            }

            callback(null);

            if (tile.reloadCallback) {
                this.loadTile(tile, tile.reloadCallback);
                tile.reloadCallback = null;
            }
        }
    },

    abortTile: function(tile) {
        this.dispatcher.send('abort tile', { uid: tile.uid, source: this.id }, null, tile.workerID);
    },

    unloadTile: function(tile) {
        tile.unloadVectorData(this.map.painter);
        this.dispatcher.send('remove tile', { uid: tile.uid, source: this.id }, null, tile.workerID);
    }
});

},{"../util/evented":111,"../util/mapbox":117,"../util/util":120,"./load_tilejson":37}],46:[function(require,module,exports){
'use strict';
var ajax = require('../util/ajax');
var vt = require('vector-tile');
var Protobuf = require('pbf');
var WorkerTile = require('./worker_tile');

module.exports = VectorTileWorkerSource;

/**
 * The {@link WorkerSource} implementation that supports {@link VectorTileSource}.
 * This class is designed to be easily reused to support custom source types
 * for data formats that can be parsed/converted into an in-memory VectorTile
 * representation.  To do so, create it with
 * `new VectorTileWorkerSource(actor, styleLayers, customLoadVectorDataFunction)`.
 *
 * @class VectorTileWorkerSource
 * @private
 * @param {Function} [loadVectorData] Optional method for custom loading of a VectorTile object based on parameters passed from the main-thread Source.  See {@link VectorTileWorkerSource#loadTile}.  The default implementation simply loads the pbf at `params.url`.
 */
function VectorTileWorkerSource (actor, styleLayers, loadVectorData) {
    this.actor = actor;
    this.styleLayers = styleLayers;

    if (loadVectorData) { this.loadVectorData = loadVectorData; }

    this.loading = {};
    this.loaded = {};
}

VectorTileWorkerSource.prototype = {
    /**
     * Implements {@link WorkerSource#loadTile}.  Delegates to {@link VectorTileWorkerSource#loadVectorData} (which by default expects a `params.url` property) for fetching and producing a VectorTile object.
     *
     * @param {object} params
     * @param {string} params.source The id of the source for which we're loading this tile.
     * @param {string} params.uid The UID for this tile.
     * @param {TileCoord} params.coord
     * @param {number} params.zoom
     * @param {number} params.overscaling
     * @param {number} params.angle
     * @param {number} params.pitch
     * @param {boolean} params.showCollisionBoxes
     */
    loadTile: function(params, callback) {
        var source = params.source,
            uid = params.uid;

        if (!this.loading[source])
            this.loading[source] = {};

        var tile = this.loading[source][uid] = new WorkerTile(params);
        tile.abort = this.loadVectorData(params, done.bind(this));

        function done(err, data) {
            delete this.loading[source][uid];

            if (err) return callback(err);
            if (!data) return callback(null, null);

            tile.data = data.tile;
            tile.parse(tile.data, this.styleLayers.getLayerFamilies(), this.actor, data.rawTileData, callback);

            this.loaded[source] = this.loaded[source] || {};
            this.loaded[source][uid] = tile;
        }
    },

    /**
     * Implements {@link WorkerSource#reloadTile}.
     *
     * @param {object} params
     * @param {string} params.source The id of the source for which we're loading this tile.
     * @param {string} params.uid The UID for this tile.
     */
    reloadTile: function(params, callback) {
        var loaded = this.loaded[params.source],
            uid = params.uid;
        if (loaded && loaded[uid]) {
            var tile = loaded[uid];
            tile.parse(tile.data, this.styleLayers.getLayerFamilies(), this.actor, params.rawTileData, callback);
        }
    },

    /**
     * Implements {@link WorkerSource#abortTile}.
     *
     * @param {object} params
     * @param {string} params.source The id of the source for which we're loading this tile.
     * @param {string} params.uid The UID for this tile.
     */
    abortTile: function(params) {
        var loading = this.loading[params.source],
            uid = params.uid;
        if (loading && loading[uid] && loading[uid].abort) {
            loading[uid].abort();
            delete loading[uid];
        }
    },

    /**
     * Implements {@link WorkerSource#removeTile}.
     *
     * @param {object} params
     * @param {string} params.source The id of the source for which we're loading this tile.
     * @param {string} params.uid The UID for this tile.
     */
    removeTile: function(params) {
        var loaded = this.loaded[params.source],
            uid = params.uid;
        if (loaded && loaded[uid]) {
            delete loaded[uid];
        }
    },

    /**
     * @param {object} params
     * @param {string} params.url The URL of the tile PBF to load.
     */
    loadVectorData: function (params, callback) {
        var xhr = ajax.getArrayBuffer(params.url, done.bind(this));
        return function abort () { xhr.abort(); };
        function done(err, data) {
            if (err) { return callback(err); }
            var tile =  new vt.VectorTile(new Protobuf(new Uint8Array(data)));
            callback(err, { tile: tile, rawTileData: data });
        }
    },

    redoPlacement: function(params, callback) {
        var loaded = this.loaded[params.source],
            loading = this.loading[params.source],
            uid = params.uid;

        if (loaded && loaded[uid]) {
            var tile = loaded[uid];
            var result = tile.redoPlacement(params.angle, params.pitch, params.showCollisionBoxes);

            if (result.result) {
                callback(null, result.result, result.transferables);
            }

        } else if (loading && loading[uid]) {
            loading[uid].angle = params.angle;
        }
    }
};

},{"../util/ajax":102,"./worker_tile":49,"pbf":185,"vector-tile":198}],47:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var TileCoord = require('./tile_coord');
var LngLat = require('../geo/lng_lat');
var Point = require('point-geometry');
var Evented = require('../util/evented');
var ajax = require('../util/ajax');
var EXTENT = require('../data/bucket').EXTENT;
var RasterBoundsArray = require('../render/draw_raster').RasterBoundsArray;
var Buffer = require('../data/buffer');
var VertexArrayObject = require('../render/vertex_array_object');

module.exports = VideoSource;

/**
 * A data source containing video.
 * (See the [Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#sources-video) for detailed documentation of options.)
 * @interface VideoSource
 * @example
 * // add to map
 * map.addSource('some id', {
 *    type: 'video',
 *    url: [
 *        'https://www.mapbox.com/videos/baltimore-smoke.mp4',
 *        'https://www.mapbox.com/videos/baltimore-smoke.webm'
 *    ],
 *    coordinates: [
 *        [-76.54, 39.18],
 *        [-76.52, 39.18],
 *        [-76.52, 39.17],
 *        [-76.54, 39.17]
 *    ]
 * });
 *
 * // update
 * var mySource = map.getSource('some id');
 * mySource.setCoordinates([
 *     [-76.54335737228394, 39.18579907229748],
 *     [-76.52803659439087, 39.1838364847587],
 *     [-76.5295386314392, 39.17683392507606],
 *     [-76.54520273208618, 39.17876344106642]
 * ]);
 *
 * map.removeSource('some id');  // remove
 */
function VideoSource(id, options) {
    this.id = id;
    this.urls = options.urls;
    this.coordinates = options.coordinates;

    ajax.getVideo(options.urls, function(err, video) {
        if (err) return this.fire('error', {error: err});

        this.video = video;
        this.video.loop = true;

        var loopID;

        // start repainting when video starts playing
        this.video.addEventListener('playing', function() {
            loopID = this.map.style.animationLoop.set(Infinity);
            this.map._rerender();
        }.bind(this));

        // stop repainting when video stops
        this.video.addEventListener('pause', function() {
            this.map.style.animationLoop.cancel(loopID);
        }.bind(this));

        if (this.map) {
            this.video.play();
            this.setCoordinates(options.coordinates);
        }

        this.fire('load');
    }.bind(this));
}

VideoSource.prototype = util.inherit(Evented, /** @lends VideoSource.prototype */{
    minzoom: 0,
    maxzoom: 22,
    tileSize: 512,
    roundZoom: true,

    /**
     * Returns the HTML `video` element.
     *
     * @returns {HTMLVideoElement} The HTML `video` element.
     */
    getVideo: function() {
        return this.video;
    },

    onAdd: function(map) {
        if (this.map) return;
        this.map = map;
        if (this.video) {
            this.video.play();
            this.setCoordinates(this.coordinates);
        }
    },

    /**
     * Sets the video's coordinates and re-renders the map.
     *
     * @param {Array<Array<number>>} coordinates Four geographical coordinates,
     *   represented as arrays of longitude and latitude numbers, which define the corners of the video.
     *   The coordinates start at the top left corner of the video and proceed in clockwise order.
     *   They do not have to represent a rectangle.
     * @returns {VideoSource} this
     */
    setCoordinates: function(coordinates) {
        this.coordinates = coordinates;

        // Calculate which mercator tile is suitable for rendering the video in
        // and create a buffer with the corner coordinates. These coordinates
        // may be outside the tile, because raster tiles aren't clipped when rendering.

        var map = this.map;
        var cornerZ0Coords = coordinates.map(function(coord) {
            return map.transform.locationCoordinate(LngLat.convert(coord)).zoomTo(0);
        });

        var centerCoord = this.centerCoord = util.getCoordinatesCenter(cornerZ0Coords);
        centerCoord.column = Math.round(centerCoord.column);
        centerCoord.row = Math.round(centerCoord.row);

        this.minzoom = this.maxzoom = centerCoord.zoom;
        this._coord = new TileCoord(centerCoord.zoom, centerCoord.column, centerCoord.row);
        this._tileCoords = cornerZ0Coords.map(function(coord) {
            var zoomedCoord = coord.zoomTo(centerCoord.zoom);
            return new Point(
                Math.round((zoomedCoord.column - centerCoord.column) * EXTENT),
                Math.round((zoomedCoord.row - centerCoord.row) * EXTENT));
        });

        this.fire('change');
        return this;
    },

    _setTile: function (tile) {
        this._prepared = false;
        this.tile = tile;
        var maxInt16 = 32767;
        var array = new RasterBoundsArray();
        array.emplaceBack(this._tileCoords[0].x, this._tileCoords[0].y, 0, 0);
        array.emplaceBack(this._tileCoords[1].x, this._tileCoords[1].y, maxInt16, 0);
        array.emplaceBack(this._tileCoords[3].x, this._tileCoords[3].y, 0, maxInt16);
        array.emplaceBack(this._tileCoords[2].x, this._tileCoords[2].y, maxInt16, maxInt16);

        this.tile.buckets = {};

        this.tile.boundsBuffer = new Buffer(array.serialize(), RasterBoundsArray.serialize(), Buffer.BufferType.VERTEX);
        this.tile.boundsVAO = new VertexArrayObject();
        this.tile.state = 'loaded';
    },

    prepare: function() {
        if (this.video.readyState < 2) return; // not enough data for current position
        if (!this.tile) return;

        var gl = this.map.painter.gl;
        if (!this._prepared) {
            this._prepared = true;
            this.tile.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
        } else {
            gl.bindTexture(gl.TEXTURE_2D, this.tile.texture);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
        }

        this._currentTime = this.video.currentTime;
    },

    loadTile: function(tile, callback) {
        // We have a single tile -- whoose coordinates are this._coord -- that
        // covers the video frame we want to render.  If that's the one being
        // requested, set it up with the image; otherwise, mark the tile as
        // `errored` to indicate that we have no data for it.
        if (this._coord && this._coord.toString() === tile.coord.toString()) {
            this._setTile(tile);
            callback(null);
        } else {
            tile.state = 'errored';
            callback(null);
        }
    },

    serialize: function() {
        return {
            type: 'video',
            urls: this.urls,
            coordinates: this.coordinates
        };
    }
});

},{"../data/bucket":2,"../data/buffer":8,"../geo/lng_lat":13,"../render/draw_raster":26,"../render/vertex_array_object":32,"../util/ajax":102,"../util/evented":111,"../util/util":120,"./tile_coord":44,"point-geometry":187}],48:[function(require,module,exports){
'use strict';

var Actor = require('../util/actor');
var StyleLayer = require('../style/style_layer');
var util = require('../util/util');

var VectorTileWorkerSource = require('./vector_tile_worker_source');
var GeoJSONWorkerSource = require('./geojson_worker_source');

module.exports = function createWorker(self) {
    return new Worker(self);
};

function Worker(self) {
    this.self = self;
    this.actor = new Actor(self, this);

    // simple accessor object for passing to WorkerSources
    var styleLayers = {
        getLayers: function () { return this.layers; }.bind(this),
        getLayerFamilies: function () { return this.layerFamilies; }.bind(this)
    };

    this.workerSources = {
        vector: new VectorTileWorkerSource(this.actor, styleLayers),
        geojson: new GeoJSONWorkerSource(this.actor, styleLayers)
    };

    this.self.registerWorkerSource = function (name, WorkerSource) {
        if (this.workerSources[name]) {
            throw new Error('Worker source with name "' + name + '" already registered.');
        }
        this.workerSources[name] = new WorkerSource(this.actor, styleLayers);
    }.bind(this);
}

util.extend(Worker.prototype, {
    'set layers': function(layers) {
        this.layers = {};
        var that = this;

        // Filter layers and create an id -> layer map
        var childLayerIndicies = [];
        for (var i = 0; i < layers.length; i++) {
            var layer = layers[i];
            if (layer.type === 'fill' || layer.type === 'line' || layer.type === 'circle' || layer.type === 'symbol' || layer.type === 'extrusion') {
                if (layer.ref) {
                    childLayerIndicies.push(i);
                } else {
                    setLayer(layer);
                }
            }
        }

        // Create an instance of StyleLayer per layer
        for (var j = 0; j < childLayerIndicies.length; j++) {
            setLayer(layers[childLayerIndicies[j]]);
        }

        function setLayer(serializedLayer) {
            var styleLayer = StyleLayer.create(
                serializedLayer,
                serializedLayer.ref && that.layers[serializedLayer.ref]
            );
            styleLayer.updatePaintTransitions({}, {transition: false});
            that.layers[styleLayer.id] = styleLayer;
        }

        this.layerFamilies = createLayerFamilies(this.layers);
    },

    'update layers': function(layers) {
        var that = this;
        var id;
        var layer;

        // Update ref parents
        for (id in layers) {
            layer = layers[id];
            if (layer.ref) updateLayer(layer);
        }

        // Update ref children
        for (id in layers) {
            layer = layers[id];
            if (!layer.ref) updateLayer(layer);
        }

        function updateLayer(layer) {
            var refLayer = that.layers[layer.ref];
            if (that.layers[layer.id]) {
                that.layers[layer.id].set(layer, refLayer);
            } else {
                that.layers[layer.id] = StyleLayer.create(layer, refLayer);
            }
            that.layers[layer.id].updatePaintTransitions({}, {transition: false});
        }

        this.layerFamilies = createLayerFamilies(this.layers);
    },

    'load tile': function(params, callback) {
        var type = params.type || 'vector';
        this.workerSources[type].loadTile(params, callback);
    },

    'reload tile': function(params, callback) {
        var type = params.type || 'vector';
        this.workerSources[type].reloadTile(params, callback);
    },

    'abort tile': function(params) {
        var type = params.type || 'vector';
        this.workerSources[type].abortTile(params);
    },

    'remove tile': function(params) {
        var type = params.type || 'vector';
        this.workerSources[type].removeTile(params);
    },

    'redo placement': function(params, callback) {
        var type = params.type || 'vector';
        this.workerSources[type].redoPlacement(params, callback);
    },

    /**
     * Load a {@link WorkerSource} script at params.url.  The script is run
     * (using importScripts) with `registerWorkerSource` in scope, which is a
     * function taking `(name, workerSourceObject)`.
     *  @private
     */
    'load worker source': function(params, callback) {
        try {
            this.self.importScripts(params.url);
            callback();
        } catch (e) {
            callback(e);
        }
    }
});

function createLayerFamilies(layers) {
    var families = {};

    for (var layerId in layers) {
        var layer = layers[layerId];
        var parentLayerId = layer.ref || layer.id;
        var parentLayer = layers[parentLayerId];

        if (parentLayer.layout && parentLayer.layout.visibility === 'none') continue;

        families[parentLayerId] = families[parentLayerId] || [];
        if (layerId === parentLayerId) {
            families[parentLayerId].unshift(layer);
        } else {
            families[parentLayerId].push(layer);
        }
    }

    return families;
}

},{"../style/style_layer":56,"../util/actor":101,"../util/util":120,"./geojson_worker_source":34,"./vector_tile_worker_source":46}],49:[function(require,module,exports){
'use strict';

var FeatureIndex = require('../data/feature_index');
var CollisionTile = require('../symbol/collision_tile');
var Bucket = require('../data/bucket');
var CollisionBoxArray = require('../symbol/collision_box');
var DictionaryCoder = require('../util/dictionary_coder');
var util = require('../util/util');
var SymbolInstancesArray = require('../symbol/symbol_instances');
var SymbolQuadsArray = require('../symbol/symbol_quads');

module.exports = WorkerTile;

function WorkerTile(params) {
    this.coord = params.coord;
    this.uid = params.uid;
    this.zoom = params.zoom;
    this.tileSize = params.tileSize;
    this.source = params.source;
    this.overscaling = params.overscaling;
    this.angle = params.angle;
    this.pitch = params.pitch;
    this.showCollisionBoxes = params.showCollisionBoxes;
}

WorkerTile.prototype.parse = function(data, layerFamilies, actor, rawTileData, callback) {

    this.status = 'parsing';
    this.data = data;

    this.collisionBoxArray = new CollisionBoxArray();
    this.symbolInstancesArray = new SymbolInstancesArray();
    this.symbolQuadsArray = new SymbolQuadsArray();
    var collisionTile = new CollisionTile(this.angle, this.pitch, this.collisionBoxArray);
    var featureIndex = new FeatureIndex(this.coord, this.overscaling, collisionTile, data.layers);
    var sourceLayerCoder = new DictionaryCoder(data.layers ? Object.keys(data.layers).sort() : ['_geojsonTileLayer']);

    var tile = this;
    var bucketsById = {};
    var bucketsBySourceLayer = {};
    var i;
    var layer;
    var sourceLayerId;
    var bucket;

    // Map non-ref layers to buckets.
    var bucketIndex = 0;
    for (var layerId in layerFamilies) {
        layer = layerFamilies[layerId][0];

        if (layer.source !== this.source) continue;
        if (layer.ref) continue;
        if (layer.minzoom && this.zoom < layer.minzoom) continue;
        if (layer.maxzoom && this.zoom >= layer.maxzoom) continue;
        if (layer.layout && layer.layout.visibility === 'none') continue;
        if (data.layers && !data.layers[layer.sourceLayer]) continue;

        bucket = Bucket.create({
            layer: layer,
            index: bucketIndex++,
            childLayers: layerFamilies[layerId],
            zoom: this.zoom,
            overscaling: this.overscaling,
            showCollisionBoxes: this.showCollisionBoxes,
            collisionBoxArray: this.collisionBoxArray,
            symbolQuadsArray: this.symbolQuadsArray,
            symbolInstancesArray: this.symbolInstancesArray,
            sourceLayerIndex: sourceLayerCoder.encode(layer.sourceLayer || '_geojsonTileLayer')
        });
        bucket.createFilter();

        bucketsById[layer.id] = bucket;

        if (data.layers) { // vectortile
            sourceLayerId = layer.sourceLayer;
            bucketsBySourceLayer[sourceLayerId] = bucketsBySourceLayer[sourceLayerId] || {};
            bucketsBySourceLayer[sourceLayerId][layer.id] = bucket;
        }
    }

    // read each layer, and sort its features into buckets
    if (data.layers) { // vectortile
        for (sourceLayerId in bucketsBySourceLayer) {
            if (layer.version === 1) {
                util.warnOnce(
                    'Vector tile source "' + this.source + '" layer "' +
                    sourceLayerId + '" does not use vector tile spec v2 ' +
                    'and therefore may have some rendering errors.'
                );
            }
            layer = data.layers[sourceLayerId];
            if (layer) {
                sortLayerIntoBuckets(layer, bucketsBySourceLayer[sourceLayerId]);
            }
        }
    } else { // geojson
        sortLayerIntoBuckets(data, bucketsById);
    }

    function sortLayerIntoBuckets(layer, buckets) {
        for (var i = 0; i < layer.length; i++) {
            var feature = layer.feature(i);
            feature.index = i;
            for (var id in buckets) {
                if (buckets[id].filter(feature))
                    buckets[id].features.push(feature);
            }
        }
    }

    var buckets = [],
        symbolBuckets = this.symbolBuckets = [],
        otherBuckets = [];

    featureIndex.bucketLayerIDs = {};

    for (var id in bucketsById) {
        bucket = bucketsById[id];
        if (bucket.features.length === 0) continue;

        featureIndex.bucketLayerIDs[bucket.index] = bucket.childLayers.map(getLayerId);

        buckets.push(bucket);

        if (bucket.type === 'symbol')
            symbolBuckets.push(bucket);
        else
            otherBuckets.push(bucket);
    }

    var icons = {};
    var stacks = {};
    var deps = 0;


    if (symbolBuckets.length > 0) {

        // Get dependencies for symbol buckets
        for (i = symbolBuckets.length - 1; i >= 0; i--) {
            symbolBuckets[i].updateIcons(icons);
            symbolBuckets[i].updateFont(stacks);
        }

        for (var fontName in stacks) {
            stacks[fontName] = Object.keys(stacks[fontName]).map(Number);
        }
        icons = Object.keys(icons);

        actor.send('get glyphs', {uid: this.uid, stacks: stacks}, function(err, newStacks) {
            stacks = newStacks;
            gotDependency(err);
        });

        if (icons.length) {
            actor.send('get icons', {icons: icons}, function(err, newIcons) {
                icons = newIcons;
                gotDependency(err);
            });
        } else {
            gotDependency();
        }
    }

    // immediately parse non-symbol buckets (they have no dependencies)
    for (i = otherBuckets.length - 1; i >= 0; i--) {
        parseBucket(this, otherBuckets[i]);
    }

    if (symbolBuckets.length === 0)
        return done();

    function gotDependency(err) {
        if (err) return callback(err);
        deps++;
        if (deps === 2) {
            // all symbol bucket dependencies fetched; parse them in proper order
            for (var i = symbolBuckets.length - 1; i >= 0; i--) {
                parseBucket(tile, symbolBuckets[i]);
            }
            done();
        }
    }

    function parseBucket(tile, bucket) {
        bucket.populateArrays(collisionTile, stacks, icons);


        if (bucket.type !== 'symbol') {
            for (var i = 0; i < bucket.features.length; i++) {
                var feature = bucket.features[i];
                featureIndex.insert(feature, feature.index, bucket.sourceLayerIndex, bucket.index);
            }
        }

        bucket.features = null;
    }

    function done() {
        tile.status = 'done';

        if (tile.redoPlacementAfterDone) {
            tile.redoPlacement(tile.angle, tile.pitch, null);
            tile.redoPlacementAfterDone = false;
        }

        var featureIndex_ = featureIndex.serialize();
        var collisionTile_ = collisionTile.serialize();
        var collisionBoxArray = tile.collisionBoxArray.serialize();
        var symbolInstancesArray = tile.symbolInstancesArray.serialize();
        var symbolQuadsArray = tile.symbolQuadsArray.serialize();
        var transferables = [rawTileData].concat(featureIndex_.transferables).concat(collisionTile_.transferables);
        var nonEmptyBuckets = buckets.filter(isBucketNonEmpty);

        callback(null, {
            buckets: nonEmptyBuckets.map(serializeBucket),
            featureIndex: featureIndex_.data,
            collisionTile: collisionTile_.data,
            collisionBoxArray: collisionBoxArray,
            symbolInstancesArray: symbolInstancesArray,
            symbolQuadsArray: symbolQuadsArray,
            rawTileData: rawTileData
        }, getTransferables(nonEmptyBuckets).concat(transferables));
    }
};

WorkerTile.prototype.redoPlacement = function(angle, pitch, showCollisionBoxes) {
    if (this.status !== 'done') {
        this.redoPlacementAfterDone = true;
        this.angle = angle;
        return {};
    }

    var collisionTile = new CollisionTile(angle, pitch, this.collisionBoxArray);

    var buckets = this.symbolBuckets;

    for (var i = buckets.length - 1; i >= 0; i--) {
        buckets[i].placeFeatures(collisionTile, showCollisionBoxes);
    }

    var collisionTile_ = collisionTile.serialize();
    var nonEmptyBuckets = buckets.filter(isBucketNonEmpty);

    return {
        result: {
            buckets: nonEmptyBuckets.map(serializeBucket),
            collisionTile: collisionTile_.data
        },
        transferables: getTransferables(nonEmptyBuckets).concat(collisionTile_.transferables)
    };
};

function isBucketNonEmpty(bucket) {
    return !bucket.isEmpty();
}

function serializeBucket(bucket) {
    return bucket.serialize();
}

function getTransferables(buckets) {
    var transferables = [];
    for (var i in buckets) {
        buckets[i].getTransferables(transferables);
    }
    return transferables;
}

function getLayerId(layer) {
    return layer.id;
}

},{"../data/bucket":2,"../data/feature_index":10,"../symbol/collision_box":70,"../symbol/collision_tile":72,"../symbol/symbol_instances":81,"../symbol/symbol_quads":82,"../util/dictionary_coder":109,"../util/util":120}],50:[function(require,module,exports){
'use strict';

module.exports = AnimationLoop;

function AnimationLoop() {
    this.n = 0;
    this.times = [];
}

// Are all animations done?
AnimationLoop.prototype.stopped = function() {
    this.times = this.times.filter(function(t) {
        return t.time >= (new Date()).getTime();
    });
    return !this.times.length;
};

// Add a new animation that will run t milliseconds
// Returns an id that can be used to cancel it layer
AnimationLoop.prototype.set = function(t) {
    this.times.push({ id: this.n, time: t + (new Date()).getTime() });
    return this.n++;
};

// Cancel an animation
AnimationLoop.prototype.cancel = function(n) {
    this.times = this.times.filter(function(t) {
        return t.id !== n;
    });
};

},{}],51:[function(require,module,exports){
'use strict';

var Evented = require('../util/evented');
var ajax = require('../util/ajax');
var browser = require('../util/browser');
var normalizeURL = require('../util/mapbox').normalizeSpriteURL;

module.exports = ImageSprite;

function ImageSprite(base) {
    this.base = base;
    this.retina = browser.devicePixelRatio > 1;

    var format = this.retina ? '@2x' : '';

    ajax.getJSON(normalizeURL(base, format, '.json'), function(err, data) {
        if (err) {
            this.fire('error', {error: err});
            return;
        }

        this.data = data;
        if (this.img) this.fire('load');
    }.bind(this));

    ajax.getImage(normalizeURL(base, format, '.png'), function(err, img) {
        if (err) {
            this.fire('error', {error: err});
            return;
        }

        // premultiply the sprite
        var data = img.getData();
        var newdata = img.data = new Uint8Array(data.length);
        for (var i = 0; i < data.length; i += 4) {
            var alpha = data[i + 3] / 255;
            newdata[i + 0] = data[i + 0] * alpha;
            newdata[i + 1] = data[i + 1] * alpha;
            newdata[i + 2] = data[i + 2] * alpha;
            newdata[i + 3] = data[i + 3];
        }

        this.img = img;
        if (this.data) this.fire('load');
    }.bind(this));
}

ImageSprite.prototype = Object.create(Evented);

ImageSprite.prototype.toJSON = function() {
    return this.base;
};

ImageSprite.prototype.loaded = function() {
    return !!(this.data && this.img);
};

ImageSprite.prototype.resize = function(/*gl*/) {
    if (browser.devicePixelRatio > 1 !== this.retina) {
        var newSprite = new ImageSprite(this.base);
        newSprite.on('load', function() {
            this.img = newSprite.img;
            this.data = newSprite.data;
            this.retina = newSprite.retina;
        }.bind(this));
    }
};

function SpritePosition() {}
SpritePosition.prototype = { x: 0, y: 0, width: 0, height: 0, pixelRatio: 1, sdf: false };

ImageSprite.prototype.getSpritePosition = function(name) {
    if (!this.loaded()) return new SpritePosition();

    var pos = this.data && this.data[name];
    if (pos && this.img) return pos;

    return new SpritePosition();
};

},{"../util/ajax":102,"../util/browser":103,"../util/evented":111,"../util/mapbox":117}],52:[function(require,module,exports){
'use strict';

var parseColorString = require('csscolorparser').parseCSSColor;
var util = require('../util/util');
var StyleFunction = require('./style_function');

var cache = {};

module.exports = function parseColor(input, transformColor) {

    if (StyleFunction.isFunctionDefinition(input)) {

        return util.extend({}, input, {
            stops: input.stops.map(function(stop) {
                return [stop[0], parseColor(stop[1], transformColor)];
            })
        });

    } else if (typeof input === 'string') {

        if (!cache[input] || transformColor) {
            var rgba = parseColorString(input);
            if (!rgba) { throw new Error('Invalid color ' + input); }
            if (transformColor) rgba = transformColor(rgba);

            // GL expects all components to be in the range [0, 1] and to be
            // multipled by the alpha value.
            cache[input] = [
                rgba[0] / 255 * rgba[3],
                rgba[1] / 255 * rgba[3],
                rgba[2] / 255 * rgba[3],
                rgba[3]
            ];
        }

        return cache[input];

    } else {
        throw new Error('Invalid color ' + input);
    }
};

},{"../util/util":120,"./style_function":55,"csscolorparser":134}],53:[function(require,module,exports){
'use strict';

var Evented = require('../util/evented');
var StyleLayer = require('./style_layer');
var ImageSprite = require('./image_sprite');
var GlyphSource = require('../symbol/glyph_source');
var SpriteAtlas = require('../symbol/sprite_atlas');
var LineAtlas = require('../render/line_atlas');
var util = require('../util/util');
var ajax = require('../util/ajax');
var normalizeURL = require('../util/mapbox').normalizeStyleURL;
var browser = require('../util/browser');
var Dispatcher = require('../util/dispatcher');
var AnimationLoop = require('./animation_loop');
var validateStyle = require('./validate_style');
var Source = require('../source/source');
var QueryFeatures = require('../source/query_features');
var SourceCache = require('../source/source_cache');
var styleSpec = require('./style_spec');
var StyleFunction = require('./style_function');

module.exports = Style;

function Style(stylesheet, animationLoop, workerCount) {
    this.animationLoop = animationLoop || new AnimationLoop();
    this.dispatcher = new Dispatcher(workerCount || 1, this);
    this.spriteAtlas = new SpriteAtlas(1024, 1024);
    this.lineAtlas = new LineAtlas(256, 512);

    this._layers = {};
    this._order  = [];
    this._groups = [];
    this.sources = {};
    this.zoomHistory = {};
    this._light = {};

    util.bindAll([
        '_forwardSourceEvent',
        '_forwardTileEvent',
        '_forwardLayerEvent',
        '_redoPlacement'
    ], this);

    this._resetUpdates();

    var stylesheetLoaded = function(err, stylesheet) {
        if (err) {
            this.fire('error', {error: err});
            return;
        }

        if (validateStyle.emitErrors(this, validateStyle(stylesheet))) return;

        this._loaded = true;
        this.stylesheet = stylesheet;

        this.updateClasses();

        var sources = stylesheet.sources;
        for (var id in sources) {
            this.addSource(id, sources[id]);
        }

        if (stylesheet.light) {
            if (stylesheet.light['light-anchor']) {
                this._light.lightAnchor = stylesheet.light['light-anchor'];
            }
            if (stylesheet.light['light-direction']) {
                this._light.lightDirection = stylesheet.light['light-direction'];
            }
            if (stylesheet.light['light-color']) {
                this._light.lightColor = stylesheet.light['light-color'];
            }
        }

        if (stylesheet.sprite) {
            this.sprite = new ImageSprite(stylesheet.sprite);
            this.sprite.on('load', this.fire.bind(this, 'change'));
        }

        this.glyphSource = new GlyphSource(stylesheet.glyphs);
        this._resolve();
        this.fire('load');
    }.bind(this);

    if (typeof stylesheet === 'string') {
        ajax.getJSON(normalizeURL(stylesheet), stylesheetLoaded);
    } else {
        browser.frame(stylesheetLoaded.bind(this, null, stylesheet));
    }

    this.on('source.load', function(event) {
        var source = event.source;
        if (source && source.vectorLayerIds) {
            for (var layerId in this._layers) {
                var layer = this._layers[layerId];
                if (layer.source === source.id) {
                    this._validateLayer(layer);
                }
            }
        }
    });
}

Style.prototype = util.inherit(Evented, {
    _loaded: false,

    _validateLayer: function(layer) {
        var source = this.sources[layer.source];

        if (!layer.sourceLayer) return;
        if (!source) return;
        if (!source.vectorLayerIds) return;

        if (source.vectorLayerIds.indexOf(layer.sourceLayer) === -1) {
            this.fire('error', {
                error: new Error(
                    'Source layer "' + layer.sourceLayer + '" ' +
                    'does not exist on source "' + source.id + '" ' +
                    'as specified by style layer "' + layer.id + '"'
                )
            });
        }
    },

    loaded: function() {
        if (!this._loaded)
            return false;

        if (Object.keys(this._updates.sources).length)
            return false;

        for (var id in this.sources)
            if (!this.sources[id].loaded())
                return false;

        if (this.sprite && !this.sprite.loaded())
            return false;

        return true;
    },

    _resolve: function() {
        var layer, layerJSON;

        this._layers = {};
        this._order  = this.stylesheet.layers.map(function(layer) {
            return layer.id;
        });

        // resolve all layers WITHOUT a ref
        for (var i = 0; i < this.stylesheet.layers.length; i++) {
            layerJSON = this.stylesheet.layers[i];
            if (layerJSON.ref) continue;
            layer = StyleLayer.create(layerJSON);
            this._layers[layer.id] = layer;
            layer.on('error', this._forwardLayerEvent);
        }

        // resolve all layers WITH a ref
        for (var j = 0; j < this.stylesheet.layers.length; j++) {
            layerJSON = this.stylesheet.layers[j];
            if (!layerJSON.ref) continue;
            var refLayer = this.getLayer(layerJSON.ref);
            layer = StyleLayer.create(layerJSON, refLayer);
            this._layers[layer.id] = layer;
            layer.on('error', this._forwardLayerEvent);
        }

        this._groupLayers();
        this._updateWorkerLayers();
    },

    _groupLayers: function() {
        var group;

        this._groups = [];

        // Split into groups of consecutive top-level layers with the same source.
        for (var i = 0; i < this._order.length; ++i) {
            var layer = this._layers[this._order[i]];

            if (!group || layer.source !== group.source) {
                group = [];
                group.source = layer.source;
                this._groups.push(group);
            }

            group.push(layer);
        }
    },

    _updateWorkerLayers: function(ids) {
        this.dispatcher.broadcast(ids ? 'update layers' : 'set layers', this._serializeLayers(ids));
    },

    _serializeLayers: function(ids) {
        ids = ids || this._order;
        var serialized = [];
        var options = {includeRefProperties: true};
        for (var i = 0; i < ids.length; i++) {
            serialized.push(this._layers[ids[i]].serialize(options));
        }
        return serialized;
    },

    _applyClasses: function(classes, options) {
        if (!this._loaded) return;

        classes = classes || [];
        options = options || {transition: true};
        var transition = this.stylesheet.transition || {};

        var layers = this._updates.allPaintProps ? this._layers : this._updates.paintProps;

        for (var id in layers) {
            var layer = this._layers[id];
            var props = this._updates.paintProps[id];

            if (this._updates.allPaintProps || props.all) {
                layer.updatePaintTransitions(classes, options, transition, this.animationLoop);
            } else {
                for (var paintName in props) {
                    this._layers[id].updatePaintTransition(paintName, classes, options, transition, this.animationLoop);
                }
            }
        }
    },

    _recalculate: function(z) {
        for (var sourceId in this.sources)
            this.sources[sourceId].used = false;

        this._updateZoomHistory(z);

        this.rasterFadeDuration = 300;
        for (var layerId in this._layers) {
            var layer = this._layers[layerId];

            layer.recalculate(z, this.zoomHistory);
            if (!layer.isHidden(z) && layer.source) {
                this.sources[layer.source].used = true;
            }
        }

        var maxZoomTransitionDuration = 300;
        if (Math.floor(this.z) !== Math.floor(z)) {
            this.animationLoop.set(maxZoomTransitionDuration);
        }

        this.z = z;
        this.fire('zoom');
    },

    _updateZoomHistory: function(z) {

        var zh = this.zoomHistory;

        if (zh.lastIntegerZoom === undefined) {
            // first time
            zh.lastIntegerZoom = Math.floor(z);
            zh.lastIntegerZoomTime = 0;
            zh.lastZoom = z;
        }

        // check whether an integer zoom level as passed since the last frame
        // and if yes, record it with the time. Used for transitioning patterns.
        if (Math.floor(zh.lastZoom) < Math.floor(z)) {
            zh.lastIntegerZoom = Math.floor(z);
            zh.lastIntegerZoomTime = Date.now();

        } else if (Math.floor(zh.lastZoom) > Math.floor(z)) {
            zh.lastIntegerZoom = Math.floor(z + 1);
            zh.lastIntegerZoomTime = Date.now();
        }

        zh.lastZoom = z;
    },

    _checkLoaded: function () {
        if (!this._loaded) {
            throw new Error('Style is not done loading');
        }
    },

    /**
     * Apply queued style updates in a batch
     * @private
     */
    update: function(classes, options) {
        if (!this._updates.changed) return this;

        if (this._updates.allLayers) {
            this._groupLayers();
            this._updateWorkerLayers();
        } else {
            var updatedIds = Object.keys(this._updates.layers);
            if (updatedIds.length) {
                this._updateWorkerLayers(updatedIds);
            }
        }

        var updatedSourceIds = Object.keys(this._updates.sources);
        var i;
        for (i = 0; i < updatedSourceIds.length; i++) {
            this._reloadSource(updatedSourceIds[i]);
        }

        for (i = 0; i < this._updates.events.length; i++) {
            var args = this._updates.events[i];
            this.fire(args[0], args[1]);
        }

        this._applyClasses(classes, options);

        if (this._updates.changed) {
            this.fire('change');
        }

        this._resetUpdates();

        return this;
    },

    _resetUpdates: function() {
        this._updates = {
            events: [],
            layers: {},
            sources: {},
            paintProps: {}
        };
    },

    addSource: function(id, source) {
        this._checkLoaded();
        if (this.sources[id] !== undefined) {
            throw new Error('There is already a source with this ID');
        }
        if (!source.type) {
            throw new Error('The type property must be defined, but the only the following properties were given: ' + Object.keys(source) + '.');
        }
        var builtIns = ['vector', 'raster', 'geojson', 'video', 'image'];
        var shouldValidate = builtIns.indexOf(source.type) >= 0;
        if (shouldValidate && this._handleErrors(validateStyle.source, 'sources.' + id, source)) return this;

        source = new SourceCache(id, source, this.dispatcher);
        this.sources[id] = source;
        source.style = this;
        source
            .on('load', this._forwardSourceEvent)
            .on('error', this._forwardSourceEvent)
            .on('change', this._forwardSourceEvent)
            .on('tile.add', this._forwardTileEvent)
            .on('tile.load', this._forwardTileEvent)
            .on('tile.error', this._forwardTileEvent)
            .on('tile.remove', this._forwardTileEvent)
            .on('tile.stats', this._forwardTileEvent);

        this._updates.events.push(['source.add', {source: source}]);
        this._updates.changed = true;

        return this;
    },

    /**
     * Remove a source from this stylesheet, given its id.
     * @param {string} id id of the source to remove
     * @returns {Style} this style
     * @throws {Error} if no source is found with the given ID
     * @private
     */
    removeSource: function(id) {
        this._checkLoaded();

        if (this.sources[id] === undefined) {
            throw new Error('There is no source with this ID');
        }
        var source = this.sources[id];
        delete this.sources[id];
        delete this._updates.sources[id];
        source
            .off('load', this._forwardSourceEvent)
            .off('error', this._forwardSourceEvent)
            .off('change', this._forwardSourceEvent)
            .off('tile.add', this._forwardTileEvent)
            .off('tile.load', this._forwardTileEvent)
            .off('tile.error', this._forwardTileEvent)
            .off('tile.remove', this._forwardTileEvent)
            .off('tile.stats', this._forwardTileEvent);

        this._updates.events.push(['source.remove', {source: source}]);
        this._updates.changed = true;

        return this;
    },

    /**
     * Get a source by id.
     * @param {string} id id of the desired source
     * @returns {Object} source
     * @private
     */
    getSource: function(id) {
        return this.sources[id] && this.sources[id].getSource();
    },

    /**
     * Add a layer to the map style. The layer will be inserted before the layer with
     * ID `before`, or appended if `before` is omitted.
     * @param {StyleLayer|Object} layer
     * @param {string=} before  ID of an existing layer to insert before
     * @fires layer.add
     * @returns {Style} `this`
     * @private
     */
    addLayer: function(layer, before) {
        this._checkLoaded();

        if (!(layer instanceof StyleLayer)) {
            // this layer is not in the style.layers array, so we pass an impossible array index
            if (this._handleErrors(validateStyle.layer,
                    'layers.' + layer.id, layer, false, {arrayIndex: -1})) return this;

            var refLayer = layer.ref && this.getLayer(layer.ref);
            layer = StyleLayer.create(layer, refLayer);
        }
        this._validateLayer(layer);

        layer.on('error', this._forwardLayerEvent);

        this._layers[layer.id] = layer;
        this._order.splice(before ? this._order.indexOf(before) : Infinity, 0, layer.id);

        this._updates.allLayers = true;
        if (layer.source) {
            this._updates.sources[layer.source] = true;
        }
        this._updates.events.push(['layer.add', {layer: layer}]);

        return this.updateClasses(layer.id);
    },

    /**
     * Remove a layer from this stylesheet, given its id.
     * @param {string} id id of the layer to remove
     * @returns {Style} this style
     * @throws {Error} if no layer is found with the given ID
     * @private
     */
    removeLayer: function(id) {
        this._checkLoaded();

        var layer = this._layers[id];
        if (layer === undefined) {
            throw new Error('There is no layer with this ID');
        }
        for (var i in this._layers) {
            if (this._layers[i].ref === id) {
                this.removeLayer(i);
            }
        }

        layer.off('error', this._forwardLayerEvent);

        delete this._layers[id];
        delete this._updates.layers[id];
        delete this._updates.paintProps[id];
        this._order.splice(this._order.indexOf(id), 1);

        this._updates.allLayers = true;
        this._updates.events.push(['layer.remove', {layer: layer}]);
        this._updates.changed = true;

        return this;
    },

    /**
     * Return the style layer object with the given `id`.
     *
     * @param {string} id - id of the desired layer
     * @returns {?Object} a layer, if one with the given `id` exists
     * @private
     */
    getLayer: function(id) {
        return this._layers[id];
    },

    /**
     * If a layer has a `ref` property that makes it derive some values
     * from another layer, return that referent layer. Otherwise,
     * returns the layer itself.
     * @param {string} id the layer's id
     * @returns {Layer} the referent layer or the layer itself
     * @private
     */
    getReferentLayer: function(id) {
        var layer = this.getLayer(id);
        if (layer.ref) {
            layer = this.getLayer(layer.ref);
        }
        return layer;
    },

    setLayerZoomRange: function(layerId, minzoom, maxzoom) {
        this._checkLoaded();

        var layer = this.getReferentLayer(layerId);

        if (layer.minzoom === minzoom && layer.maxzoom === maxzoom) return this;

        if (minzoom != null) {
            layer.minzoom = minzoom;
        }
        if (maxzoom != null) {
            layer.maxzoom = maxzoom;
        }
        return this._updateLayer(layer);
    },

    setFilter: function(layerId, filter) {
        this._checkLoaded();

        var layer = this.getReferentLayer(layerId);

        if (filter !== null && this._handleErrors(validateStyle.filter, 'layers.' + layer.id + '.filter', filter)) return this;

        if (util.deepEqual(layer.filter, filter)) return this;
        layer.filter = util.clone(filter);

        return this._updateLayer(layer);
    },

    /**
     * Get a layer's filter object
     * @param {string} layer the layer to inspect
     * @returns {*} the layer's filter, if any
     * @private
     */
    getFilter: function(layer) {
        return this.getReferentLayer(layer).filter;
    },

    setLayoutProperty: function(layerId, name, value) {
        this._checkLoaded();

        var layer = this.getReferentLayer(layerId);

        if (util.deepEqual(layer.getLayoutProperty(name), value)) return this;

        layer.setLayoutProperty(name, value);
        return this._updateLayer(layer);
    },

    /**
     * Get a layout property's value from a given layer
     * @param {string} layer the layer to inspect
     * @param {string} name the name of the layout property
     * @returns {*} the property value
     * @private
     */
    getLayoutProperty: function(layer, name) {
        return this.getReferentLayer(layer).getLayoutProperty(name);
    },

    setPaintProperty: function(layerId, name, value, klass) {
        this._checkLoaded();

        var layer = this.getLayer(layerId);

        if (util.deepEqual(layer.getPaintProperty(name, klass), value)) return this;

        var wasFeatureConstant = layer.isPaintValueFeatureConstant(name);
        layer.setPaintProperty(name, value, klass);

        var isFeatureConstant = !(
            value &&
            StyleFunction.isFunctionDefinition(value) &&
            value.property !== '$zoom' &&
            value.property !== undefined
        );

        if (!isFeatureConstant || !wasFeatureConstant) {
            this._updates.layers[layerId] = true;
            if (layer.source) {
                this._updates.sources[layer.source] = true;
            }
        }

        return this.updateClasses(layerId, name);
    },

    getPaintProperty: function(layer, name, klass) {
        return this.getLayer(layer).getPaintProperty(name, klass);
    },

    updateClasses: function (layerId, paintName) {
        this._updates.changed = true;
        if (!layerId) {
            this._updates.allPaintProps = true;
        } else {
            var props = this._updates.paintProps;
            if (!props[layerId]) props[layerId] = {};
            props[layerId][paintName || 'all'] = true;
        }
        return this;
    },

    serialize: function() {
        return util.filterObject({
            version: this.stylesheet.version,
            name: this.stylesheet.name,
            metadata: this.stylesheet.metadata,
            light: this.stylesheet.light,
            center: this.stylesheet.center,
            zoom: this.stylesheet.zoom,
            bearing: this.stylesheet.bearing,
            pitch: this.stylesheet.pitch,
            sprite: this.stylesheet.sprite,
            glyphs: this.stylesheet.glyphs,
            transition: this.stylesheet.transition,
            sources: util.mapObject(this.sources, function(source) {
                return source.serialize();
            }),
            layers: this._order.map(function(id) {
                return this._layers[id].serialize();
            }, this)
        }, function(value) { return value !== undefined; });
    },

    _updateLayer: function (layer) {
        this._updates.layers[layer.id] = true;
        if (layer.source) {
            this._updates.sources[layer.source] = true;
        }
        this._updates.changed = true;
        return this;
    },

    _flattenRenderedFeatures: function(sourceResults) {
        var features = [];
        for (var l = this._order.length - 1; l >= 0; l--) {
            var layerID = this._order[l];
            for (var s = 0; s < sourceResults.length; s++) {
                var layerFeatures = sourceResults[s][layerID];
                if (layerFeatures) {
                    for (var f = 0; f < layerFeatures.length; f++) {
                        features.push(layerFeatures[f]);
                    }
                }
            }
        }
        return features;
    },

    queryRenderedFeatures: function(queryGeometry, params, zoom, bearing) {
        if (params && params.filter) {
            this._handleErrors(validateStyle.filter, 'queryRenderedFeatures.filter', params.filter, true);
        }

        var includedSources = {};
        if (params && params.layers) {
            for (var i = 0; i < params.layers.length; i++) {
                var layerId = params.layers[i];
                includedSources[this._layers[layerId].source] = true;
            }
        }

        var sourceResults = [];
        for (var id in this.sources) {
            if (params.layers && !includedSources[id]) continue;
            var source = this.sources[id];
            var results = QueryFeatures.rendered(source, this._layers, queryGeometry, params, zoom, bearing);
            sourceResults.push(results);
        }
        return this._flattenRenderedFeatures(sourceResults);
    },

    querySourceFeatures: function(sourceID, params) {
        if (params && params.filter) {
            this._handleErrors(validateStyle.filter, 'querySourceFeatures.filter', params.filter, true);
        }
        var source = this.sources[sourceID];
        return source ? QueryFeatures.source(source, params) : [];
    },

    addSourceType: function (name, SourceType, callback) {
        if (Source.getType(name)) {
            return callback(new Error('A source type called "' + name + '" already exists.'));
        }

        Source.setType(name, SourceType);

        if (!SourceType.workerSourceURL) {
            return callback(null, null);
        }

        this.dispatcher.broadcast('load worker source', {
            name: name,
            url: SourceType.workerSourceURL
        }, callback);
    },

    _handleErrors: function(validate, key, value, throws, props) {
        var action = throws ? validateStyle.throwErrors : validateStyle.emitErrors;
        var result = validate.call(validateStyle, util.extend({
            key: key,
            style: this.serialize(),
            value: value,
            styleSpec: styleSpec
        }, props));
        return action.call(validateStyle, this, result);
    },

    _remove: function() {
        this.dispatcher.remove();
    },

    _reloadSource: function(id) {
        this.sources[id].reload();
    },

    _updateSources: function(transform) {
        for (var id in this.sources) {
            this.sources[id].update(transform);
        }
    },

    _redoPlacement: function() {
        for (var id in this.sources) {
            if (this.sources[id].redoPlacement) this.sources[id].redoPlacement();
        }
    },

    _forwardSourceEvent: function(e) {
        this.fire('source.' + e.type, util.extend({source: e.target.getSource()}, e));
    },

    _forwardTileEvent: function(e) {
        this.fire(e.type, util.extend({source: e.target}, e));
    },

    _forwardLayerEvent: function(e) {
        this.fire('layer.' + e.type, util.extend({layer: {id: e.target.id}}, e));
    },

    // Callbacks from web workers

    'get sprite json': function(params, callback) {
        var sprite = this.sprite;
        if (sprite.loaded()) {
            callback(null, { sprite: sprite.data, retina: sprite.retina });
        } else {
            sprite.on('load', function() {
                callback(null, { sprite: sprite.data, retina: sprite.retina });
            });
        }
    },

    'get icons': function(params, callback) {
        var sprite = this.sprite;
        var spriteAtlas = this.spriteAtlas;
        if (sprite.loaded()) {
            spriteAtlas.setSprite(sprite);
            spriteAtlas.addIcons(params.icons, callback);
        } else {
            sprite.on('load', function() {
                spriteAtlas.setSprite(sprite);
                spriteAtlas.addIcons(params.icons, callback);
            });
        }
    },

    'get glyphs': function(params, callback) {
        var stacks = params.stacks,
            remaining = Object.keys(stacks).length,
            allGlyphs = {};

        for (var fontName in stacks) {
            this.glyphSource.getSimpleGlyphs(fontName, stacks[fontName], params.uid, done);
        }

        function done(err, glyphs, fontName) {
            if (err) console.error(err);

            allGlyphs[fontName] = glyphs;
            remaining--;

            if (remaining === 0)
                callback(null, allGlyphs);
        }
    }
});


},{"../render/line_atlas":29,"../source/query_features":39,"../source/source":41,"../source/source_cache":42,"../symbol/glyph_source":75,"../symbol/sprite_atlas":80,"../util/ajax":102,"../util/browser":103,"../util/dispatcher":110,"../util/evented":111,"../util/mapbox":117,"../util/util":120,"./animation_loop":50,"./image_sprite":51,"./style_function":55,"./style_layer":56,"./style_spec":64,"./validate_style":66}],54:[function(require,module,exports){
'use strict';

var MapboxGLFunction = require('./style_function');
var parseColor = require('./parse_color');
var util = require('../util/util');

module.exports = StyleDeclaration;

function StyleDeclaration(propName, reference, value) {
    this.value = util.clone(value);
    this.isFunction = MapboxGLFunction.isFunctionDefinition(value);

    // immutable representation of value. used for comparison
    this.json = JSON.stringify(this.value);

    var parsedValue;
    if (propName === 'extrusion-color') {
        parsedValue = this.value && parseColor(this.value, function(rgba) {
            return rgba.slice(0,3).concat(1);
        });
    } else {
        parsedValue = reference.type === 'color' && this.value ? parseColor(this.value) : value;
    }
    var specDefault = reference.default;
    if (specDefault && reference.type === 'color') specDefault = parseColor(specDefault);
    this.calculate = MapboxGLFunction[reference.function || 'piecewise-constant'](parsedValue, specDefault);
    this.isFeatureConstant = this.calculate.isFeatureConstant;
    this.isZoomConstant = this.calculate.isZoomConstant;

    if (reference.function === 'piecewise-constant' && reference.transition) {
        this.calculate = transitioned(this.calculate);
    }

    if (!this.isFeatureConstant && !this.isZoomConstant) {
        this.stopZoomLevels = [];
        var interpolationAmountStops = [];
        var stops = this.value.stops;
        for (var i = 0; i < this.value.stops.length; i++) {
            var zoom = stops[i][0].zoom;
            if (this.stopZoomLevels.indexOf(zoom) < 0) {
                this.stopZoomLevels.push(zoom);
                interpolationAmountStops.push([zoom, interpolationAmountStops.length]);
            }
        }

        this.calculateInterpolationT = MapboxGLFunction.interpolated({
            stops: interpolationAmountStops,
            base: value.base
        });
    }
}

// This function is used to smoothly transition between discrete values, such
// as images and dasharrays.
function transitioned(calculate) {
    return function(globalProperties, featureProperties) {
        var z = globalProperties.zoom;
        var zh = globalProperties.zoomHistory;
        var duration = globalProperties.duration;

        var fraction = z % 1;
        var t = Math.min((Date.now() - zh.lastIntegerZoomTime) / duration, 1);
        var fromScale = 1;
        var toScale = 1;
        var mix, from, to;

        if (z > zh.lastIntegerZoom) {
            mix = fraction + (1 - fraction) * t;
            fromScale *= 2;
            from = calculate({zoom: z - 1}, featureProperties);
            to = calculate({zoom: z}, featureProperties);
        } else {
            mix = 1 - (1 - t) * fraction;
            to = calculate({zoom: z}, featureProperties);
            from = calculate({zoom: z + 1}, featureProperties);
            fromScale /= 2;
        }

        if (from === undefined || to === undefined) {
            return undefined;
        } else {
            return {
                from: from,
                fromScale: fromScale,
                to: to,
                toScale: toScale,
                t: mix
            };
        }
    };
}

},{"../util/util":120,"./parse_color":52,"./style_function":55}],55:[function(require,module,exports){
'use strict';

var MapboxGLFunction = require('mapbox-gl-function');

exports.interpolated = function(parameters, specDefault) {
    var inner = MapboxGLFunction.interpolated(parameters, specDefault);
    var outer = function(globalProperties, featureProperties) {
        return inner(globalProperties && globalProperties.zoom, featureProperties || {});
    };
    outer.isFeatureConstant = inner.isFeatureConstant;
    outer.isZoomConstant = inner.isZoomConstant;
    return outer;
};

exports['piecewise-constant'] = function(parameters, specDefault) {
    var inner = MapboxGLFunction['piecewise-constant'](parameters, specDefault);
    var outer = function(globalProperties, featureProperties) {
        return inner(globalProperties && globalProperties.zoom, featureProperties || {});
    };
    outer.isFeatureConstant = inner.isFeatureConstant;
    outer.isZoomConstant = inner.isZoomConstant;
    return outer;
};

exports.isFunctionDefinition = MapboxGLFunction.isFunctionDefinition;

},{"mapbox-gl-function":158}],56:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var StyleTransition = require('./style_transition');
var StyleDeclaration = require('./style_declaration');
var styleSpec = require('./style_spec');
var validateStyle = require('./validate_style');
var parseColor = require('./parse_color');
var Evented = require('../util/evented');

module.exports = StyleLayer;

var TRANSITION_SUFFIX = '-transition';

StyleLayer.create = function(layer, refLayer) {
    var Classes = {
        background: require('./style_layer/background_style_layer'),
        circle: require('./style_layer/circle_style_layer'),
        fill: require('./style_layer/fill_style_layer'),
        line: require('./style_layer/line_style_layer'),
        raster: require('./style_layer/raster_style_layer'),
        symbol: require('./style_layer/symbol_style_layer'),
        extrusion: require('./style_layer/extrusion_style_layer')
    };
    return new Classes[(refLayer || layer).type](layer, refLayer);
};

function StyleLayer(layer, refLayer) {
    this.set(layer, refLayer);
}

StyleLayer.prototype = util.inherit(Evented, {

    set: function(layer, refLayer) {
        this.id = layer.id;
        this.ref = layer.ref;
        this.metadata = layer.metadata;
        this.type = (refLayer || layer).type;
        this.source = (refLayer || layer).source;
        this.sourceLayer = (refLayer || layer)['source-layer'];
        this.minzoom = (refLayer || layer).minzoom;
        this.maxzoom = (refLayer || layer).maxzoom;
        this.filter = (refLayer || layer).filter;

        this.paint = {};
        this.layout = {};

        this._paintSpecifications = styleSpec['paint_' + this.type];
        this._layoutSpecifications = styleSpec['layout_' + this.type];

        this._paintTransitions = {}; // {[propertyName]: StyleTransition}
        this._paintTransitionOptions = {}; // {[className]: {[propertyName]: { duration:Number, delay:Number }}}
        this._paintDeclarations = {}; // {[className]: {[propertyName]: StyleDeclaration}}
        this._layoutDeclarations = {}; // {[propertyName]: StyleDeclaration}
        this._layoutFunctions = {}; // {[propertyName]: Boolean}

        var paintName, layoutName;

        // Resolve paint declarations
        for (var key in layer) {
            var match = key.match(/^paint(?:\.(.*))?$/);
            if (match) {
                var klass = match[1] || '';
                for (paintName in layer[key]) {
                    this.setPaintProperty(paintName, layer[key][paintName], klass);
                }
            }
        }

        // Resolve layout declarations
        if (this.ref) {
            this._layoutDeclarations = refLayer._layoutDeclarations;
        } else {
            for (layoutName in layer.layout) {
                this.setLayoutProperty(layoutName, layer.layout[layoutName]);
            }
        }

        // set initial layout/paint values
        for (paintName in this._paintSpecifications) {
            this.paint[paintName] = this.getPaintValue(paintName);
        }
        for (layoutName in this._layoutSpecifications) {
            this._updateLayoutValue(layoutName);
        }
    },

    setLayoutProperty: function(name, value) {

        if (value == null) {
            delete this._layoutDeclarations[name];
        } else {
            var key = 'layers.' + this.id + '.layout.' + name;
            if (this._handleErrors(validateStyle.layoutProperty, key, name, value)) return;
            this._layoutDeclarations[name] = new StyleDeclaration(name, this._layoutSpecifications[name], value);
        }
        this._updateLayoutValue(name);
    },

    getLayoutProperty: function(name) {
        return (
            this._layoutDeclarations[name] &&
            this._layoutDeclarations[name].value
        );
    },

    getLayoutValue: function(name, globalProperties, featureProperties) {
        var specification = this._layoutSpecifications[name];
        var declaration = this._layoutDeclarations[name];

        if (declaration) {
            return declaration.calculate(globalProperties, featureProperties);
        } else {
            return specification.default;
        }
    },

    setPaintProperty: function(name, value, klass) {
        var validateStyleKey = 'layers.' + this.id + (klass ? '["paint.' + klass + '"].' : '.paint.') + name;

        if (util.endsWith(name, TRANSITION_SUFFIX)) {
            if (!this._paintTransitionOptions[klass || '']) {
                this._paintTransitionOptions[klass || ''] = {};
            }
            if (value === null || value === undefined) {
                delete this._paintTransitionOptions[klass || ''][name];
            } else {
                if (this._handleErrors(validateStyle.paintProperty, validateStyleKey, name, value)) return;
                this._paintTransitionOptions[klass || ''][name] = value;
            }
        } else {
            if (!this._paintDeclarations[klass || '']) {
                this._paintDeclarations[klass || ''] = {};
            }
            if (value === null || value === undefined) {
                delete this._paintDeclarations[klass || ''][name];
            } else {
                if (this._handleErrors(validateStyle.paintProperty, validateStyleKey, name, value)) return;
                this._paintDeclarations[klass || ''][name] = new StyleDeclaration(name, this._paintSpecifications[name], value);
            }
        }
    },

    getPaintProperty: function(name, klass) {
        klass = klass || '';
        if (util.endsWith(name, TRANSITION_SUFFIX)) {
            return (
                this._paintTransitionOptions[klass] &&
                this._paintTransitionOptions[klass][name]
            );
        } else {
            return (
                this._paintDeclarations[klass] &&
                this._paintDeclarations[klass][name] &&
                this._paintDeclarations[klass][name].value
            );
        }
    },

    getPaintValue: function(name, globalProperties, featureProperties) {
        var specification = this._paintSpecifications[name];
        var transition = this._paintTransitions[name];

        if (transition) {
            return transition.calculate(globalProperties, featureProperties);
        } else if (specification.type === 'color' && specification.default) {
            return parseColor(specification.default);
        } else {
            return specification.default;
        }
    },

    getPaintValueStopZoomLevels: function(name) {
        var transition = this._paintTransitions[name];
        if (transition) {
            return transition.declaration.stopZoomLevels;
        } else {
            return [];
        }
    },

    getPaintInterpolationT: function(name, zoom) {
        var transition = this._paintTransitions[name];
        return transition.declaration.calculateInterpolationT({ zoom: zoom });
    },

    isPaintValueFeatureConstant: function(name) {
        var transition = this._paintTransitions[name];

        if (transition) {
            return transition.declaration.isFeatureConstant;
        } else {
            return true;
        }
    },

    isLayoutValueFeatureConstant: function(name) {
        var declaration = this._layoutDeclarations[name];

        if (declaration) {
            return declaration.isFeatureConstant;
        } else {
            return true;
        }
    },

    isPaintValueZoomConstant: function(name) {
        var transition = this._paintTransitions[name];

        if (transition) {
            return transition.declaration.isZoomConstant;
        } else {
            return true;
        }
    },


    isHidden: function(zoom) {
        if (this.minzoom && zoom < this.minzoom) return true;
        if (this.maxzoom && zoom >= this.maxzoom) return true;
        if (this.layout['visibility'] === 'none') return true;
        if (this.paint[this.type + '-opacity'] === 0) return true;
        return false;
    },

    updatePaintTransitions: function(classes, options, globalOptions, animationLoop) {
        var declarations = util.extend({}, this._paintDeclarations['']);
        for (var i = 0; i < classes.length; i++) {
            util.extend(declarations, this._paintDeclarations[classes[i]]);
        }

        var name;
        for (name in declarations) { // apply new declarations
            this._applyPaintDeclaration(name, declarations[name], options, globalOptions, animationLoop);
        }
        for (name in this._paintTransitions) {
            if (!(name in declarations)) // apply removed declarations
                this._applyPaintDeclaration(name, null, options, globalOptions, animationLoop);
        }
    },

    updatePaintTransition: function(name, classes, options, globalOptions, animationLoop) {
        var declaration = this._paintDeclarations[''][name];
        for (var i = 0; i < classes.length; i++) {
            var classPaintDeclarations = this._paintDeclarations[classes[i]];
            if (classPaintDeclarations && classPaintDeclarations[name]) {
                declaration = classPaintDeclarations[name];
            }
        }
        this._applyPaintDeclaration(name, declaration, options, globalOptions, animationLoop);
    },

    // update all zoom-dependent layout/paint values
    recalculate: function(zoom, zoomHistory) {
        for (var paintName in this._paintTransitions) {
            this.paint[paintName] = this.getPaintValue(paintName, {zoom: zoom, zoomHistory: zoomHistory});
        }
        for (var layoutName in this._layoutFunctions) {
            this.layout[layoutName] = this.getLayoutValue(layoutName, {zoom: zoom, zoomHistory: zoomHistory});
        }
    },

    serialize: function(options) {
        var output = {
            'id': this.id,
            'ref': this.ref,
            'metadata': this.metadata,
            'minzoom': this.minzoom,
            'maxzoom': this.maxzoom
        };

        for (var klass in this._paintDeclarations) {
            var key = klass === '' ? 'paint' : 'paint.' + klass;
            output[key] = util.mapObject(this._paintDeclarations[klass], getDeclarationValue);
        }

        if (!this.ref || (options && options.includeRefProperties)) {
            util.extend(output, {
                'type': this.type,
                'source': this.source,
                'source-layer': this.sourceLayer,
                'filter': this.filter,
                'layout': util.mapObject(this._layoutDeclarations, getDeclarationValue)
            });
        }

        return util.filterObject(output, function(value, key) {
            return value !== undefined && !(key === 'layout' && !Object.keys(value).length);
        });
    },

    // set paint transition based on a given paint declaration
    _applyPaintDeclaration: function (name, declaration, options, globalOptions, animationLoop) {
        var oldTransition = options.transition ? this._paintTransitions[name] : undefined;
        var spec = this._paintSpecifications[name];

        if (declaration === null || declaration === undefined) {
            declaration = new StyleDeclaration(name, spec, spec.default);
        }

        if (oldTransition && oldTransition.declaration.json === declaration.json) return;

        var transitionOptions = util.extend({
            duration: 300,
            delay: 0
        }, globalOptions, this.getPaintProperty(name + TRANSITION_SUFFIX));

        var newTransition = this._paintTransitions[name] =
            new StyleTransition(spec, declaration, oldTransition, transitionOptions);

        if (!newTransition.instant()) {
            newTransition.loopID = animationLoop.set(newTransition.endTime - Date.now());
        }
        if (oldTransition) {
            animationLoop.cancel(oldTransition.loopID);
        }
    },

    // update layout value if it's constant, or mark it as zoom-dependent
    _updateLayoutValue: function(name) {
        var declaration = this._layoutDeclarations[name];

        if (declaration && declaration.isFunction) {
            this._layoutFunctions[name] = true;
        } else {
            delete this._layoutFunctions[name];
            this.layout[name] = this.getLayoutValue(name);
        }
    },

    _handleErrors: function(validate, key, name, value) {
        return validateStyle.emitErrors(this, validate.call(validateStyle, {
            key: key,
            layerType: this.type,
            objectKey: name,
            value: value,
            styleSpec: styleSpec,
            // Workaround for https://github.com/mapbox/mapbox-gl-js/issues/2407
            style: {glyphs: true, sprite: true}
        }));
    }
});

function getDeclarationValue(declaration) {
    return declaration.value;
}

},{"../util/evented":111,"../util/util":120,"./parse_color":52,"./style_declaration":54,"./style_layer/background_style_layer":57,"./style_layer/circle_style_layer":58,"./style_layer/extrusion_style_layer":59,"./style_layer/fill_style_layer":60,"./style_layer/line_style_layer":61,"./style_layer/raster_style_layer":62,"./style_layer/symbol_style_layer":63,"./style_spec":64,"./style_transition":65,"./validate_style":66}],57:[function(require,module,exports){
'use strict';

var util = require('../../util/util');
var StyleLayer = require('../style_layer');

function BackgroundStyleLayer() {
    StyleLayer.apply(this, arguments);
}

module.exports = BackgroundStyleLayer;

BackgroundStyleLayer.prototype = util.inherit(StyleLayer, {});

},{"../../util/util":120,"../style_layer":56}],58:[function(require,module,exports){
'use strict';

var util = require('../../util/util');
var StyleLayer = require('../style_layer');

function CircleStyleLayer() {
    StyleLayer.apply(this, arguments);
}

module.exports = CircleStyleLayer;

CircleStyleLayer.prototype = util.inherit(StyleLayer, {});

},{"../../util/util":120,"../style_layer":56}],59:[function(require,module,exports){
'use strict';

var util = require('../../util/util');
var StyleLayer = require('../style_layer');

function ExtrusionStyleLayer() {
    StyleLayer.apply(this, arguments);
}

module.exports = ExtrusionStyleLayer;
ExtrusionStyleLayer.prototype = util.inherit(StyleLayer, {});

},{"../../util/util":120,"../style_layer":56}],60:[function(require,module,exports){
'use strict';

var util = require('../../util/util');
var StyleLayer = require('../style_layer');

function FillStyleLayer() {
    StyleLayer.apply(this, arguments);
}

FillStyleLayer.prototype = util.inherit(StyleLayer, {

    getPaintValue: function(name, globalProperties, featureProperties) {
        if (name === 'fill-outline-color' && this.getPaintProperty('fill-outline-color') === undefined) {
            return StyleLayer.prototype.getPaintValue.call(this, 'fill-color', globalProperties, featureProperties);
        } else {
            return StyleLayer.prototype.getPaintValue.call(this, name, globalProperties, featureProperties);
        }
    },

    getPaintValueStopZoomLevels: function(name) {
        if (name === 'fill-outline-color' && this.getPaintProperty('fill-outline-color') === undefined) {
            return StyleLayer.prototype.getPaintValueStopZoomLevels.call(this, 'fill-color');
        } else {
            return StyleLayer.prototype.getPaintValueStopZoomLevels.call(this, arguments);
        }
    },

    getPaintInterpolationT: function(name, zoom) {
        if (name === 'fill-outline-color' && this.getPaintProperty('fill-outline-color') === undefined) {
            return StyleLayer.prototype.getPaintInterpolationT.call(this, 'fill-color', zoom);
        } else {
            return StyleLayer.prototype.getPaintInterpolationT.call(this, name, zoom);
        }
    },

    isPaintValueFeatureConstant: function(name) {
        if (name === 'fill-outline-color' && this.getPaintProperty('fill-outline-color') === undefined) {
            return StyleLayer.prototype.isPaintValueFeatureConstant.call(this, 'fill-color');
        } else {
            return StyleLayer.prototype.isPaintValueFeatureConstant.call(this, name);
        }
    },

    isPaintValueZoomConstant: function(name) {
        if (name === 'fill-outline-color' && this.getPaintProperty('fill-outline-color') === undefined) {
            return StyleLayer.prototype.isPaintValueZoomConstant.call(this, 'fill-color');
        } else {
            return StyleLayer.prototype.isPaintValueZoomConstant.call(this, name);
        }
    }

});

module.exports = FillStyleLayer;

},{"../../util/util":120,"../style_layer":56}],61:[function(require,module,exports){
'use strict';

var util = require('../../util/util');
var StyleLayer = require('../style_layer');

function LineStyleLayer() {
    StyleLayer.apply(this, arguments);
}

module.exports = LineStyleLayer;

LineStyleLayer.prototype = util.inherit(StyleLayer, {

    getPaintValue: function(name, globalProperties, featureProperties) {
        var value = StyleLayer.prototype.getPaintValue.apply(this, arguments);

        // If the line is dashed, scale the dash lengths by the line
        // width at the previous round zoom level.
        if (value && name === 'line-dasharray') {
            var flooredZoom = Math.floor(globalProperties.zoom);
            if (this._flooredZoom !== flooredZoom) {
                this._flooredZoom = flooredZoom;
                this._flooredLineWidth = this.getPaintValue('line-width', globalProperties, featureProperties);
            }

            value.fromScale *= this._flooredLineWidth;
            value.toScale *= this._flooredLineWidth;
        }

        return value;
    }
});

},{"../../util/util":120,"../style_layer":56}],62:[function(require,module,exports){
'use strict';

var util = require('../../util/util');
var StyleLayer = require('../style_layer');

function RasterStyleLayer() {
    StyleLayer.apply(this, arguments);
}

module.exports = RasterStyleLayer;

RasterStyleLayer.prototype = util.inherit(StyleLayer, {});

},{"../../util/util":120,"../style_layer":56}],63:[function(require,module,exports){
'use strict';

var util = require('../../util/util');
var StyleLayer = require('../style_layer');

function SymbolStyleLayer() {
    StyleLayer.apply(this, arguments);
}

module.exports = SymbolStyleLayer;

SymbolStyleLayer.prototype = util.inherit(StyleLayer, {

    isHidden: function() {
        if (StyleLayer.prototype.isHidden.apply(this, arguments)) return true;

        var isTextHidden = this.paint['text-opacity'] === 0 || !this.layout['text-field'];
        var isIconHidden = this.paint['icon-opacity'] === 0 || !this.layout['icon-image'];
        if (isTextHidden && isIconHidden) return true;

        return false;
    },

    getLayoutValue: function(name, globalProperties, featureProperties) {
        if (name === 'text-rotation-alignment' &&
                this.getLayoutValue('symbol-placement', globalProperties, featureProperties) === 'line' &&
                !this.getLayoutProperty('text-rotation-alignment')) {
            return 'map';
        } else if (name === 'icon-rotation-alignment' &&
                this.getLayoutValue('symbol-placement', globalProperties, featureProperties) === 'line' &&
                !this.getLayoutProperty('icon-rotation-alignment')) {
            return 'map';
        // If unspecified `text-pitch-alignment` inherits `text-rotation-alignment`
        } else if (name === 'text-pitch-alignment' && !this.getLayoutProperty('text-pitch-alignment')) {
            return this.getLayoutValue('text-rotation-alignment');
        } else {
            return StyleLayer.prototype.getLayoutValue.apply(this, arguments);
        }
    }

});

},{"../../util/util":120,"../style_layer":56}],64:[function(require,module,exports){
'use strict';

module.exports = require('mapbox-gl-style-spec/reference/latest.min');

},{"mapbox-gl-style-spec/reference/latest.min":181}],65:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var interpolate = require('../util/interpolate');

module.exports = StyleTransition;

/*
 * Represents a transition between two declarations
 */
function StyleTransition(reference, declaration, oldTransition, value) {

    this.declaration = declaration;
    this.startTime = this.endTime = (new Date()).getTime();

    if (reference.function === 'piecewise-constant' && reference.transition) {
        this.interp = interpZoomTransitioned;
    } else {
        this.interp = interpolate[reference.type];
    }

    this.oldTransition = oldTransition;
    this.duration = value.duration || 0;
    this.delay = value.delay || 0;

    if (!this.instant()) {
        this.endTime = this.startTime + this.duration + this.delay;
        this.ease = util.easeCubicInOut;
    }

    if (oldTransition && oldTransition.endTime <= this.startTime) {
        // Old transition is done running, so we can
        // delete its reference to its old transition.

        delete oldTransition.oldTransition;
    }
}

StyleTransition.prototype.instant = function() {
    return !this.oldTransition || !this.interp || (this.duration === 0 && this.delay === 0);
};

/*
 * Return the value of the transitioning property at zoom level `z` and optional time `t`
 */
StyleTransition.prototype.calculate = function(globalProperties, featureProperties) {
    var value = this.declaration.calculate(
        util.extend({}, globalProperties, {duration: this.duration}),
        featureProperties
    );

    if (this.instant()) return value;

    var t = globalProperties.time || Date.now();

    if (t < this.endTime) {
        var oldValue = this.oldTransition.calculate(
            util.extend({}, globalProperties, {time: this.startTime}),
            featureProperties
        );
        var eased = this.ease((t - this.startTime - this.delay) / this.duration);
        value = this.interp(oldValue, value, eased);
    }

    return value;

};

// This function is used to smoothly transition between discrete values, such
// as images and dasharrays.
function interpZoomTransitioned(from, to, t) {
    if ((from && from.to) === undefined || (to && to.to) === undefined) {
        return undefined;
    } else {
        return {
            from: from.to,
            fromScale: from.toScale,
            to: to.to,
            toScale: to.toScale,
            t: t
        };
    }
}

},{"../util/interpolate":114,"../util/util":120}],66:[function(require,module,exports){
'use strict';

module.exports = require('mapbox-gl-style-spec/lib/validate_style.min');

module.exports.emitErrors = function throwErrors(emitter, errors) {
    if (errors && errors.length) {
        for (var i = 0; i < errors.length; i++) {
            emitter.fire('error', { error: new Error(errors[i].message) });
        }
        return true;
    } else {
        return false;
    }
};

module.exports.throwErrors = function throwErrors(emitter, errors) {
    if (errors) {
        for (var i = 0; i < errors.length; i++) {
            throw new Error(errors[i].message);
        }
    }
};

},{"mapbox-gl-style-spec/lib/validate_style.min":180}],67:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = Anchor;

function Anchor(x, y, angle, segment) {
    this.x = x;
    this.y = y;
    this.angle = angle;

    if (segment !== undefined) {
        this.segment = segment;
    }
}

Anchor.prototype = Object.create(Point.prototype);

Anchor.prototype.clone = function() {
    return new Anchor(this.x, this.y, this.angle, this.segment);
};

},{"point-geometry":187}],68:[function(require,module,exports){
'use strict';

module.exports = checkMaxAngle;

/**
 * Labels placed around really sharp angles aren't readable. Check if any
 * part of the potential label has a combined angle that is too big.
 *
 * @param {Array<Point>} line
 * @param {Anchor} anchor The point on the line around which the label is anchored.
 * @param {number} labelLength The length of the label in geometry units.
 * @param {number} windowSize The check fails if the combined angles within a part of the line that is `windowSize` long is too big.
 * @param {number} maxAngle The maximum combined angle that any window along the label is allowed to have.
 *
 * @returns {boolean} whether the label should be placed
 * @private
 */
function checkMaxAngle(line, anchor, labelLength, windowSize, maxAngle) {

    // horizontal labels always pass
    if (anchor.segment === undefined) return true;

    var p = anchor;
    var index = anchor.segment + 1;
    var anchorDistance = 0;

    // move backwards along the line to the first segment the label appears on
    while (anchorDistance > -labelLength / 2) {
        index--;

        // there isn't enough room for the label after the beginning of the line
        if (index < 0) return false;

        anchorDistance -= line[index].dist(p);
        p = line[index];
    }

    anchorDistance += line[index].dist(line[index + 1]);
    index++;

    // store recent corners and their total angle difference
    var recentCorners = [];
    var recentAngleDelta = 0;

    // move forwards by the length of the label and check angles along the way
    while (anchorDistance < labelLength / 2) {
        var prev = line[index - 1];
        var current = line[index];
        var next = line[index + 1];

        // there isn't enough room for the label before the end of the line
        if (!next) return false;

        var angleDelta = prev.angleTo(current) - current.angleTo(next);
        // restrict angle to -pi..pi range
        angleDelta = Math.abs(((angleDelta + 3 * Math.PI) % (Math.PI * 2)) - Math.PI);

        recentCorners.push({
            distance: anchorDistance,
            angleDelta: angleDelta
        });
        recentAngleDelta += angleDelta;

        // remove corners that are far enough away from the list of recent anchors
        while (anchorDistance - recentCorners[0].distance > windowSize) {
            recentAngleDelta -= recentCorners.shift().angleDelta;
        }

        // the sum of angles within the window area exceeds the maximum allowed value. check fails.
        if (recentAngleDelta > maxAngle) return false;

        index++;
        anchorDistance += current.dist(next);
    }

    // no part of the line had an angle greater than the maximum allowed. check passes.
    return true;
}

},{}],69:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = clipLine;

/**
 * Returns the part of a multiline that intersects with the provided rectangular box.
 *
 * @param {Array<Array<Point>>} lines
 * @param {number} x1 the left edge of the box
 * @param {number} y1 the top edge of the box
 * @param {number} x2 the right edge of the box
 * @param {number} y2 the bottom edge of the box
 * @returns {Array<Array<Point>>} lines
 * @private
 */
function clipLine(lines, x1, y1, x2, y2) {
    var clippedLines = [];

    for (var l = 0; l < lines.length; l++) {
        var line = lines[l];
        var clippedLine;

        for (var i = 0; i < line.length - 1; i++) {
            var p0 = line[i];
            var p1 = line[i + 1];


            if (p0.x < x1 && p1.x < x1) {
                continue;
            } else if (p0.x < x1) {
                p0 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();
            } else if (p1.x < x1) {
                p1 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();
            }

            if (p0.y < y1 && p1.y < y1) {
                continue;
            } else if (p0.y < y1) {
                p0 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();
            } else if (p1.y < y1) {
                p1 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();
            }

            if (p0.x >= x2 && p1.x >= x2) {
                continue;
            } else if (p0.x >= x2) {
                p0 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();
            } else if (p1.x >= x2) {
                p1 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();
            }

            if (p0.y >= y2 && p1.y >= y2) {
                continue;
            } else if (p0.y >= y2) {
                p0 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();
            } else if (p1.y >= y2) {
                p1 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();
            }

            if (!clippedLine || !p0.equals(clippedLine[clippedLine.length - 1])) {
                clippedLine = [p0];
                clippedLines.push(clippedLine);
            }

            clippedLine.push(p1);
        }
    }

    return clippedLines;
}

},{"point-geometry":187}],70:[function(require,module,exports){
'use strict';

var StructArrayType = require('../util/struct_array');
var util = require('../util/util');
var Point = require('point-geometry');

/**
 * A collision box represents an area of the map that that is covered by a
 * label. CollisionFeature uses one or more of these collision boxes to
 * represent all the area covered by a single label. They are used to
 * prevent collisions between labels.
 *
 * A collision box actually represents a 3d volume. The first two dimensions,
 * x and y, are specified with `anchor` along with `x1`, `y1`, `x2`, `y2`.
 * The third dimension, zoom, is limited by `maxScale` which determines
 * how far in the z dimensions the box extends.
 *
 * As you zoom in on a map, all points on the map get further and further apart
 * but labels stay roughly the same size. Labels cover less real world area on
 * the map at higher zoom levels than they do at lower zoom levels. This is why
 * areas are are represented with an anchor point and offsets from that point
 * instead of just using four absolute points.
 *
 * Line labels are represented by a set of these boxes spaced out along a line.
 * When you zoom in, line labels cover less real world distance along the line
 * than they used to. Collision boxes near the edges that used to cover label
 * no longer do. If a box doesn't cover the label anymore it should be ignored
 * when doing collision checks. `maxScale` is how much you can scale the map
 * before the label isn't within the box anymore.
 * For example
 * lower zoom:
 * https://cloud.githubusercontent.com/assets/1421652/8060094/4d975f76-0e91-11e5-84b1-4edeb30a5875.png
 * slightly higher zoom:
 * https://cloud.githubusercontent.com/assets/1421652/8060061/26ae1c38-0e91-11e5-8c5a-9f380bf29f0a.png
 * In the zoomed in image the two grey boxes on either side don't cover the
 * label anymore. Their maxScale is smaller than the current scale.
 *
 *
 * @class CollisionBoxArray
 * @private
 */

var CollisionBoxArray = module.exports = new StructArrayType({
    members: [
        // the box is centered around the anchor point
        { type: 'Int16', name: 'anchorPointX' },
        { type: 'Int16', name: 'anchorPointY' },

        // distances to the edges from the anchor
        { type: 'Int16', name: 'x1' },
        { type: 'Int16', name: 'y1' },
        { type: 'Int16', name: 'x2' },
        { type: 'Int16', name: 'y2' },

        // the box is only valid for scales < maxScale.
        // The box does not block other boxes at scales >= maxScale;
        { type: 'Float32', name: 'maxScale' },

        // the index of the feature in the original vectortile
        { type: 'Uint32', name: 'featureIndex' },
        // the source layer the feature appears in
        { type: 'Uint16', name: 'sourceLayerIndex' },
        // the bucket the feature appears in
        { type: 'Uint16', name: 'bucketIndex' },

        // rotated and scaled bbox used for indexing
        { type: 'Int16', name: 'bbox0' },
        { type: 'Int16', name: 'bbox1' },
        { type: 'Int16', name: 'bbox2' },
        { type: 'Int16', name: 'bbox3' },

        { type: 'Float32', name: 'placementScale' }
    ]});

util.extendAll(CollisionBoxArray.prototype.StructType.prototype, {
    get anchorPoint() {
        return new Point(this.anchorPointX, this.anchorPointY);
    }
});

},{"../util/struct_array":118,"../util/util":120,"point-geometry":187}],71:[function(require,module,exports){
'use strict';

module.exports = CollisionFeature;

/**
 * A CollisionFeature represents the area of the tile covered by a single label.
 * It is used with CollisionTile to check if the label overlaps with any
 * previous labels. A CollisionFeature is mostly just a set of CollisionBox
 * objects.
 *
 * @class CollisionFeature
 * @param {Array<Point>} line The geometry the label is placed on.
 * @param {Anchor} anchor The point along the line around which the label is anchored.
 * @param {VectorTileFeature} feature The VectorTileFeature that this CollisionFeature was created for.
 * @param {Array<string>} layerIDs The IDs of the layers that this CollisionFeature is a part of.
 * @param {Object} shaped The text or icon shaping results.
 * @param {number} boxScale A magic number used to convert from glyph metrics units to geometry units.
 * @param {number} padding The amount of padding to add around the label edges.
 * @param {boolean} alignLine Whether the label is aligned with the line or the viewport.
 *
 * @private
 */
function CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex, shaped, boxScale, padding, alignLine, straight) {

    var y1 = shaped.top * boxScale - padding;
    var y2 = shaped.bottom * boxScale + padding;
    var x1 = shaped.left * boxScale - padding;
    var x2 = shaped.right * boxScale + padding;

    this.boxStartIndex = collisionBoxArray.length;

    if (alignLine) {

        var height = y2 - y1;
        var length = x2 - x1;

        if (height > 0) {
            // set minimum box height to avoid very many small labels
            height = Math.max(10 * boxScale, height);

            if (straight) {
                // used for icon labels that are aligned with the line, but don't curve along it
                var vector = line[anchor.segment + 1].sub(line[anchor.segment])._unit()._mult(length);
                var straightLine = [anchor.sub(vector), anchor.add(vector)];
                this._addLineCollisionBoxes(collisionBoxArray, straightLine, anchor, 0, length, height, featureIndex, sourceLayerIndex, bucketIndex);
            } else {
                // used for text labels that curve along a line
                this._addLineCollisionBoxes(collisionBoxArray, line, anchor, anchor.segment, length, height, featureIndex, sourceLayerIndex, bucketIndex);
            }
        }

    } else {
        collisionBoxArray.emplaceBack(anchor.x, anchor.y, x1, y1, x2, y2, Infinity, featureIndex, sourceLayerIndex, bucketIndex,
                0, 0, 0, 0, 0);
    }

    this.boxEndIndex = collisionBoxArray.length;
}

/**
 * Create a set of CollisionBox objects for a line.
 *
 * @param {Array<Point>} line
 * @param {Anchor} anchor
 * @param {number} labelLength The length of the label in geometry units.
 * @param {Anchor} anchor The point along the line around which the label is anchored.
 * @param {VectorTileFeature} feature The VectorTileFeature that this CollisionFeature was created for.
 * @param {number} boxSize The size of the collision boxes that will be created.
 *
 * @private
 */
CollisionFeature.prototype._addLineCollisionBoxes = function(collisionBoxArray, line, anchor, segment, labelLength, boxSize, featureIndex, sourceLayerIndex, bucketIndex) {
    var step = boxSize / 2;
    var nBoxes = Math.floor(labelLength / step);

    // offset the center of the first box by half a box so that the edge of the
    // box is at the edge of the label.
    var firstBoxOffset = -boxSize / 2;

    var bboxes = this.boxes;

    var p = anchor;
    var index = segment + 1;
    var anchorDistance = firstBoxOffset;

    // move backwards along the line to the first segment the label appears on
    do {
        index--;

        // there isn't enough room for the label after the beginning of the line
        // checkMaxAngle should have already caught this
        if (index < 0) return bboxes;

        anchorDistance -= line[index].dist(p);
        p = line[index];
    } while (anchorDistance > -labelLength / 2);

    var segmentLength = line[index].dist(line[index + 1]);

    for (var i = 0; i < nBoxes; i++) {
        // the distance the box will be from the anchor
        var boxDistanceToAnchor = -labelLength / 2 + i * step;

        // the box is not on the current segment. Move to the next segment.
        while (anchorDistance + segmentLength < boxDistanceToAnchor) {
            anchorDistance += segmentLength;
            index++;

            // There isn't enough room before the end of the line.
            if (index + 1 >= line.length) return bboxes;

            segmentLength = line[index].dist(line[index + 1]);
        }

        // the distance the box will be from the beginning of the segment
        var segmentBoxDistance = boxDistanceToAnchor - anchorDistance;

        var p0 = line[index];
        var p1 = line[index + 1];
        var boxAnchorPoint = p1.sub(p0)._unit()._mult(segmentBoxDistance)._add(p0)._round();

        var distanceToInnerEdge = Math.max(Math.abs(boxDistanceToAnchor - firstBoxOffset) - step / 2, 0);
        var maxScale = labelLength / 2 / distanceToInnerEdge;

        collisionBoxArray.emplaceBack(boxAnchorPoint.x, boxAnchorPoint.y,
                -boxSize / 2, -boxSize / 2, boxSize / 2, boxSize / 2, maxScale,
                featureIndex, sourceLayerIndex, bucketIndex,
                0, 0, 0, 0, 0);
    }

    return bboxes;
};

},{}],72:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');
var EXTENT = require('../data/bucket').EXTENT;
var Grid = require('grid-index');

module.exports = CollisionTile;

/**
 * A collision tile used to prevent symbols from overlapping. It keep tracks of
 * where previous symbols have been placed and is used to check if a new
 * symbol overlaps with any previously added symbols.
 *
 * @class CollisionTile
 * @param {number} angle
 * @param {number} pitch
 * @private
 */
function CollisionTile(angle, pitch, collisionBoxArray) {
    if (typeof angle === 'object') {
        var serialized = angle;
        collisionBoxArray = pitch;
        angle = serialized.angle;
        pitch = serialized.pitch;
        this.grid = new Grid(serialized.grid);
        this.ignoredGrid = new Grid(serialized.ignoredGrid);
    } else {
        this.grid = new Grid(EXTENT, 12, 6);
        this.ignoredGrid = new Grid(EXTENT, 12, 0);
    }

    this.angle = angle;
    this.pitch = pitch;

    var sin = Math.sin(angle),
        cos = Math.cos(angle);
    this.rotationMatrix = [cos, -sin, sin, cos];
    this.reverseRotationMatrix = [cos, sin, -sin, cos];

    // Stretch boxes in y direction to account for the map tilt.
    this.yStretch = 1 / Math.cos(pitch / 180 * Math.PI);

    // The amount the map is squished depends on the y position.
    // Sort of account for this by making all boxes a bit bigger.
    this.yStretch = Math.pow(this.yStretch, 1.3);

    this.collisionBoxArray = collisionBoxArray;
    if (collisionBoxArray.length === 0) {
        // the first collisionBoxArray is passed to a CollisionTile

        // tempCollisionBox
        collisionBoxArray.emplaceBack();

        var maxInt16 = 32767;
        //left
        collisionBoxArray.emplaceBack(0, 0, 0, -maxInt16, 0, maxInt16, maxInt16,
                0, 0, 0, 0, 0, 0, 0, 0,
                0);
        // right
        collisionBoxArray.emplaceBack(EXTENT, 0, 0, -maxInt16, 0, maxInt16, maxInt16,
                0, 0, 0, 0, 0, 0, 0, 0,
                0);
        // top
        collisionBoxArray.emplaceBack(0, 0, -maxInt16, 0, maxInt16, 0, maxInt16,
                0, 0, 0, 0, 0, 0, 0, 0,
                0);
        // bottom
        collisionBoxArray.emplaceBack(0, EXTENT, -maxInt16, 0, maxInt16, 0, maxInt16,
                0, 0, 0, 0, 0, 0, 0, 0,
                0);
    }

    this.tempCollisionBox = collisionBoxArray.get(0);
    this.edges = [
        collisionBoxArray.get(1),
        collisionBoxArray.get(2),
        collisionBoxArray.get(3),
        collisionBoxArray.get(4)
    ];
}

CollisionTile.prototype.serialize = function() {
    var data = {
        angle: this.angle,
        pitch: this.pitch,
        grid: this.grid.toArrayBuffer(),
        ignoredGrid: this.ignoredGrid.toArrayBuffer()
    };
    return {
        data: data,
        transferables: [data.grid, data.ignoredGrid]
    };
};

CollisionTile.prototype.minScale = 0.25;
CollisionTile.prototype.maxScale = 2;


/**
 * Find the scale at which the collisionFeature can be shown without
 * overlapping with other features.
 *
 * @param {CollisionFeature} collisionFeature
 * @returns {number} placementScale
 * @private
 */
CollisionTile.prototype.placeCollisionFeature = function(collisionFeature, allowOverlap, avoidEdges) {

    var collisionBoxArray = this.collisionBoxArray;
    var minPlacementScale = this.minScale;
    var rotationMatrix = this.rotationMatrix;
    var yStretch = this.yStretch;

    for (var b = collisionFeature.boxStartIndex; b < collisionFeature.boxEndIndex; b++) {

        var box = collisionBoxArray.get(b);

        var anchorPoint = box.anchorPoint._matMult(rotationMatrix);
        var x = anchorPoint.x;
        var y = anchorPoint.y;

        var x1 = x + box.x1;
        var y1 = y + box.y1 * yStretch;
        var x2 = x + box.x2;
        var y2 = y + box.y2 * yStretch;

        box.bbox0 = x1;
        box.bbox1 = y1;
        box.bbox2 = x2;
        box.bbox3 = y2;

        if (!allowOverlap) {
            var blockingBoxes = this.grid.query(x1, y1, x2, y2);

            for (var i = 0; i < blockingBoxes.length; i++) {
                var blocking = collisionBoxArray.get(blockingBoxes[i]);
                var blockingAnchorPoint = blocking.anchorPoint._matMult(rotationMatrix);

                minPlacementScale = this.getPlacementScale(minPlacementScale, anchorPoint, box, blockingAnchorPoint, blocking);
                if (minPlacementScale >= this.maxScale) {
                    return minPlacementScale;
                }
            }
        }

        if (avoidEdges) {
            var rotatedCollisionBox;

            if (this.angle) {
                var reverseRotationMatrix = this.reverseRotationMatrix;
                var tl = new Point(box.x1, box.y1).matMult(reverseRotationMatrix);
                var tr = new Point(box.x2, box.y1).matMult(reverseRotationMatrix);
                var bl = new Point(box.x1, box.y2).matMult(reverseRotationMatrix);
                var br = new Point(box.x2, box.y2).matMult(reverseRotationMatrix);

                rotatedCollisionBox = this.tempCollisionBox;
                rotatedCollisionBox.anchorPointX = box.anchorPoint.x;
                rotatedCollisionBox.anchorPointY = box.anchorPoint.y;
                rotatedCollisionBox.x1 = Math.min(tl.x, tr.x, bl.x, br.x);
                rotatedCollisionBox.y1 = Math.min(tl.y, tr.x, bl.x, br.x);
                rotatedCollisionBox.x2 = Math.max(tl.x, tr.x, bl.x, br.x);
                rotatedCollisionBox.y2 = Math.max(tl.y, tr.x, bl.x, br.x);
                rotatedCollisionBox.maxScale = box.maxScale;
            } else {
                rotatedCollisionBox = box;
            }

            for (var k = 0; k < this.edges.length; k++) {
                var edgeBox = this.edges[k];
                minPlacementScale = this.getPlacementScale(minPlacementScale, box.anchorPoint, rotatedCollisionBox, edgeBox.anchorPoint, edgeBox);
                if (minPlacementScale >= this.maxScale) {
                    return minPlacementScale;
                }
            }
        }
    }

    return minPlacementScale;
};

CollisionTile.prototype.queryRenderedSymbols = function(minX, minY, maxX, maxY, scale) {
    var sourceLayerFeatures = {};
    var result = [];

    var collisionBoxArray = this.collisionBoxArray;
    var rotationMatrix = this.rotationMatrix;
    var anchorPoint = new Point(minX, minY)._matMult(rotationMatrix);

    var queryBox = this.tempCollisionBox;
    queryBox.anchorX = anchorPoint.x;
    queryBox.anchorY = anchorPoint.y;
    queryBox.x1 = 0;
    queryBox.y1 = 0;
    queryBox.x2 = maxX - minX;
    queryBox.y2 = maxY - minY;
    queryBox.maxScale = scale;

    // maxScale is stored using a Float32. Convert `scale` to the stored Float32 value.
    scale = queryBox.maxScale;

    var searchBox = [
        anchorPoint.x + queryBox.x1 / scale,
        anchorPoint.y + queryBox.y1 / scale * this.yStretch,
        anchorPoint.x + queryBox.x2 / scale,
        anchorPoint.y + queryBox.y2 / scale * this.yStretch
    ];

    var blockingBoxKeys = this.grid.query(searchBox[0], searchBox[1], searchBox[2], searchBox[3]);
    var blockingBoxKeys2 = this.ignoredGrid.query(searchBox[0], searchBox[1], searchBox[2], searchBox[3]);
    for (var k = 0; k < blockingBoxKeys2.length; k++) {
        blockingBoxKeys.push(blockingBoxKeys2[k]);
    }

    for (var i = 0; i < blockingBoxKeys.length; i++) {
        var blocking = collisionBoxArray.get(blockingBoxKeys[i]);

        var sourceLayer = blocking.sourceLayerIndex;
        var featureIndex = blocking.featureIndex;
        if (sourceLayerFeatures[sourceLayer] === undefined) {
            sourceLayerFeatures[sourceLayer] = {};
        }

        if (!sourceLayerFeatures[sourceLayer][featureIndex]) {
            var blockingAnchorPoint = blocking.anchorPoint.matMult(rotationMatrix);
            var minPlacementScale = this.getPlacementScale(this.minScale, anchorPoint, queryBox, blockingAnchorPoint, blocking);
            if (minPlacementScale >= scale) {
                sourceLayerFeatures[sourceLayer][featureIndex] = true;
                result.push(blockingBoxKeys[i]);
            }
        }
    }

    return result;
};

CollisionTile.prototype.getPlacementScale = function(minPlacementScale, anchorPoint, box, blockingAnchorPoint, blocking) {

    // Find the lowest scale at which the two boxes can fit side by side without overlapping.
    // Original algorithm:
    var anchorDiffX = anchorPoint.x - blockingAnchorPoint.x;
    var anchorDiffY = anchorPoint.y - blockingAnchorPoint.y;
    var s1 = (blocking.x1 - box.x2) / anchorDiffX; // scale at which new box is to the left of old box
    var s2 = (blocking.x2 - box.x1) / anchorDiffX; // scale at which new box is to the right of old box
    var s3 = (blocking.y1 - box.y2) * this.yStretch / anchorDiffY; // scale at which new box is to the top of old box
    var s4 = (blocking.y2 - box.y1) * this.yStretch / anchorDiffY; // scale at which new box is to the bottom of old box

    if (isNaN(s1) || isNaN(s2)) s1 = s2 = 1;
    if (isNaN(s3) || isNaN(s4)) s3 = s4 = 1;

    var collisionFreeScale = Math.min(Math.max(s1, s2), Math.max(s3, s4));
    var blockingMaxScale = blocking.maxScale;
    var boxMaxScale = box.maxScale;

    if (collisionFreeScale > blockingMaxScale) {
        // After a box's maxScale the label has shrunk enough that the box is no longer needed to cover it,
        // so unblock the new box at the scale that the old box disappears.
        collisionFreeScale = blockingMaxScale;
    }

    if (collisionFreeScale > boxMaxScale) {
        // If the box can only be shown after it is visible, then the box can never be shown.
        // But the label can be shown after this box is not visible.
        collisionFreeScale = boxMaxScale;
    }

    if (collisionFreeScale > minPlacementScale &&
            collisionFreeScale >= blocking.placementScale) {
        // If this collision occurs at a lower scale than previously found collisions
        // and the collision occurs while the other label is visible

        // this this is the lowest scale at which the label won't collide with anything
        minPlacementScale = collisionFreeScale;
    }

    return minPlacementScale;
};


/**
 * Remember this collisionFeature and what scale it was placed at to block
 * later features from overlapping with it.
 *
 * @param {CollisionFeature} collisionFeature
 * @param {number} minPlacementScale
 * @private
 */
CollisionTile.prototype.insertCollisionFeature = function(collisionFeature, minPlacementScale, ignorePlacement) {

    var grid = ignorePlacement ? this.ignoredGrid : this.grid;
    var collisionBoxArray = this.collisionBoxArray;

    for (var k = collisionFeature.boxStartIndex; k < collisionFeature.boxEndIndex; k++) {
        var box = collisionBoxArray.get(k);
        box.placementScale = minPlacementScale;
        if (minPlacementScale < this.maxScale) {
            grid.insert(k, box.bbox0, box.bbox1, box.bbox2, box.bbox3);
        }
    }
};

},{"../data/bucket":2,"grid-index":157,"point-geometry":187}],73:[function(require,module,exports){
'use strict';

var interpolate = require('../util/interpolate');
var Anchor = require('../symbol/anchor');
var checkMaxAngle = require('./check_max_angle');

module.exports = getAnchors;

function getAnchors(line, spacing, maxAngle, shapedText, shapedIcon, glyphSize, boxScale, overscaling, tileExtent) {

    // Resample a line to get anchor points for labels and check that each
    // potential label passes text-max-angle check and has enough froom to fit
    // on the line.

    var angleWindowSize = shapedText ?
        3 / 5 * glyphSize * boxScale :
        0;

    var labelLength = Math.max(
        shapedText ? shapedText.right - shapedText.left : 0,
        shapedIcon ? shapedIcon.right - shapedIcon.left : 0);

    // Is the line continued from outside the tile boundary?
    var isLineContinued = line[0].x === 0 || line[0].x === tileExtent || line[0].y === 0 || line[0].y === tileExtent;

    // Is the label long, relative to the spacing?
    // If so, adjust the spacing so there is always a minimum space of `spacing / 4` between label edges.
    if (spacing - labelLength * boxScale  < spacing / 4) {
        spacing = labelLength * boxScale + spacing / 4;
    }

    // Offset the first anchor by:
    // Either half the label length plus a fixed extra offset if the line is not continued
    // Or half the spacing if the line is continued.

    // For non-continued lines, add a bit of fixed extra offset to avoid collisions at T intersections.
    var fixedExtraOffset = glyphSize * 2;

    var offset = !isLineContinued ?
        ((labelLength / 2 + fixedExtraOffset) * boxScale * overscaling) % spacing :
        (spacing / 2 * overscaling) % spacing;

    return resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength * boxScale, isLineContinued, false, tileExtent);
}


function resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, placeAtMiddle, tileExtent) {

    var halfLabelLength = labelLength / 2;
    var lineLength = 0;
    for (var k = 0; k < line.length - 1; k++) {
        lineLength += line[k].dist(line[k + 1]);
    }

    var distance = 0,
        markedDistance = offset - spacing;

    var anchors = [];

    for (var i = 0; i < line.length - 1; i++) {

        var a = line[i],
            b = line[i + 1];

        var segmentDist = a.dist(b),
            angle = b.angleTo(a);

        while (markedDistance + spacing < distance + segmentDist) {
            markedDistance += spacing;

            var t = (markedDistance - distance) / segmentDist,
                x = interpolate(a.x, b.x, t),
                y = interpolate(a.y, b.y, t);

            // Check that the point is within the tile boundaries and that
            // the label would fit before the beginning and end of the line
            // if placed at this point.
            if (x >= 0 && x < tileExtent && y >= 0 && y < tileExtent &&
                    markedDistance - halfLabelLength >= 0 &&
                    markedDistance + halfLabelLength <= lineLength) {
                var anchor = new Anchor(x, y, angle, i)._round();

                if (!angleWindowSize || checkMaxAngle(line, anchor, labelLength, angleWindowSize, maxAngle)) {
                    anchors.push(anchor);
                }
            }
        }

        distance += segmentDist;
    }

    if (!placeAtMiddle && !anchors.length && !isLineContinued) {
        // The first attempt at finding anchors at which labels can be placed failed.
        // Try again, but this time just try placing one anchor at the middle of the line.
        // This has the most effect for short lines in overscaled tiles, since the
        // initial offset used in overscaled tiles is calculated to align labels with positions in
        // parent tiles instead of placing the label as close to the beginning as possible.
        anchors = resample(line, distance / 2, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, true, tileExtent);
    }

    return anchors;
}

},{"../symbol/anchor":67,"../util/interpolate":114,"./check_max_angle":68}],74:[function(require,module,exports){
'use strict';

var ShelfPack = require('shelf-pack');
var util = require('../util/util');

var SIZE_GROWTH_RATE = 4;
var DEFAULT_SIZE = 128;
// must be "DEFAULT_SIZE * SIZE_GROWTH_RATE ^ n" for some integer n
var MAX_SIZE = 2048;

module.exports = GlyphAtlas;
function GlyphAtlas() {
    this.width = DEFAULT_SIZE;
    this.height = DEFAULT_SIZE;

    this.bin = new ShelfPack(this.width, this.height);
    this.index = {};
    this.ids = {};
    this.data = new Uint8Array(this.width * this.height);
}

GlyphAtlas.prototype.getGlyphs = function() {
    var glyphs = {},
        split,
        name,
        id;

    for (var key in this.ids) {
        split = key.split('#');
        name = split[0];
        id = split[1];

        if (!glyphs[name]) glyphs[name] = [];
        glyphs[name].push(id);
    }

    return glyphs;
};

GlyphAtlas.prototype.getRects = function() {
    var rects = {},
        split,
        name,
        id;

    for (var key in this.ids) {
        split = key.split('#');
        name = split[0];
        id = split[1];

        if (!rects[name]) rects[name] = {};
        rects[name][id] = this.index[key];
    }

    return rects;
};


GlyphAtlas.prototype.addGlyph = function(id, name, glyph, buffer) {
    if (!glyph) return null;

    var key = name + "#" + glyph.id;

    // The glyph is already in this texture.
    if (this.index[key]) {
        if (this.ids[key].indexOf(id) < 0) {
            this.ids[key].push(id);
        }
        return this.index[key];
    }

    // The glyph bitmap has zero width.
    if (!glyph.bitmap) {
        return null;
    }

    var bufferedWidth = glyph.width + buffer * 2;
    var bufferedHeight = glyph.height + buffer * 2;

    // Add a 1px border around every image.
    var padding = 1;
    var packWidth = bufferedWidth + 2 * padding;
    var packHeight = bufferedHeight + 2 * padding;

    // Increase to next number divisible by 4, but at least 1.
    // This is so we can scale down the texture coordinates and pack them
    // into fewer bytes.
    packWidth += (4 - packWidth % 4);
    packHeight += (4 - packHeight % 4);

    var rect = this.bin.packOne(packWidth, packHeight);
    if (!rect) {
        this.resize();
        rect = this.bin.packOne(packWidth, packHeight);
    }
    if (!rect) {
        util.warnOnce('glyph bitmap overflow');
        return null;
    }

    this.index[key] = rect;
    this.ids[key] = [id];

    var target = this.data;
    var source = glyph.bitmap;
    for (var y = 0; y < bufferedHeight; y++) {
        var y1 = this.width * (rect.y + y + padding) + rect.x + padding;
        var y2 = bufferedWidth * y;
        for (var x = 0; x < bufferedWidth; x++) {
            target[y1 + x] = source[y2 + x];
        }
    }

    this.dirty = true;

    return rect;
};

GlyphAtlas.prototype.resize = function() {
    var prevWidth = this.width;
    var prevHeight = this.height;

    if (prevWidth >= MAX_SIZE || prevHeight >= MAX_SIZE) return;

    if (this.texture) {
        if (this.gl) {
            this.gl.deleteTexture(this.texture);
        }
        this.texture = null;
    }

    this.width *= SIZE_GROWTH_RATE;
    this.height *= SIZE_GROWTH_RATE;
    this.bin.resize(this.width, this.height);

    var buf = new ArrayBuffer(this.width * this.height);
    for (var i = 0; i < prevHeight; i++) {
        var src = new Uint8Array(this.data.buffer, prevHeight * i, prevWidth);
        var dst = new Uint8Array(buf, prevHeight * i * SIZE_GROWTH_RATE, prevWidth);
        dst.set(src);
    }
    this.data = new Uint8Array(buf);
};

GlyphAtlas.prototype.bind = function(gl) {
    this.gl = gl;
    if (!this.texture) {
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, this.width, this.height, 0, gl.ALPHA, gl.UNSIGNED_BYTE, null);

    } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
    }
};

GlyphAtlas.prototype.updateTexture = function(gl) {
    this.bind(gl);
    if (this.dirty) {
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, gl.ALPHA, gl.UNSIGNED_BYTE, this.data);
        this.dirty = false;
    }
};

},{"../util/util":120,"shelf-pack":190}],75:[function(require,module,exports){
'use strict';

var normalizeURL = require('../util/mapbox').normalizeGlyphsURL;
var getArrayBuffer = require('../util/ajax').getArrayBuffer;
var Glyphs = require('../util/glyphs');
var GlyphAtlas = require('../symbol/glyph_atlas');
var Protobuf = require('pbf');

module.exports = GlyphSource;

/**
 * A glyph source has a URL from which to load new glyphs and manages
 * GlyphAtlases in which to store glyphs used by the requested fontstacks
 * and ranges.
 *
 * @param {string} url glyph template url
 * @private
 */
function GlyphSource(url) {
    this.url = url && normalizeURL(url);
    this.atlases = {};
    this.stacks = {};
    this.loading = {};
}

GlyphSource.prototype.getSimpleGlyphs = function(fontstack, glyphIDs, uid, callback) {
    if (this.stacks[fontstack] === undefined) {
        this.stacks[fontstack] = {};
    }
    if (this.atlases[fontstack] === undefined) {
        this.atlases[fontstack] = new GlyphAtlas();
    }

    var glyphs = {};
    var stack = this.stacks[fontstack];
    var atlas = this.atlases[fontstack];

    // the number of pixels the sdf bitmaps are padded by
    var buffer = 3;

    var missing = {};
    var remaining = 0;
    var range;

    for (var i = 0; i < glyphIDs.length; i++) {
        var glyphID = glyphIDs[i];
        range = Math.floor(glyphID / 256);

        if (stack[range]) {
            var glyph = stack[range].glyphs[glyphID];
            var rect  = atlas.addGlyph(uid, fontstack, glyph, buffer);
            if (glyph) glyphs[glyphID] = new SimpleGlyph(glyph, rect, buffer);
        } else {
            if (missing[range] === undefined) {
                missing[range] = [];
                remaining++;
            }
            missing[range].push(glyphID);
        }
    }

    if (!remaining) callback(undefined, glyphs, fontstack);

    var onRangeLoaded = function(err, range, data) {
        if (!err) {
            var stack = this.stacks[fontstack][range] = data.stacks[0];
            for (var i = 0; i < missing[range].length; i++) {
                var glyphID = missing[range][i];
                var glyph = stack.glyphs[glyphID];
                var rect  = atlas.addGlyph(uid, fontstack, glyph, buffer);
                if (glyph) glyphs[glyphID] = new SimpleGlyph(glyph, rect, buffer);
            }
        }
        remaining--;
        if (!remaining) callback(undefined, glyphs, fontstack);
    }.bind(this);

    for (var r in missing) {
        this.loadRange(fontstack, r, onRangeLoaded);
    }
};

// A simplified representation of the glyph containing only the properties needed for shaping.
function SimpleGlyph(glyph, rect, buffer) {
    var padding = 1;
    this.advance = glyph.advance;
    this.left = glyph.left - buffer - padding;
    this.top = glyph.top + buffer + padding;
    this.rect = rect;
}

GlyphSource.prototype.loadRange = function(fontstack, range, callback) {
    if (range * 256 > 65535) return callback('glyphs > 65535 not supported');

    if (this.loading[fontstack] === undefined) {
        this.loading[fontstack] = {};
    }
    var loading = this.loading[fontstack];

    if (loading[range]) {
        loading[range].push(callback);
    } else {
        loading[range] = [callback];

        var rangeName = (range * 256) + '-' + (range * 256 + 255);
        var url = glyphUrl(fontstack, rangeName, this.url);

        getArrayBuffer(url, function(err, data) {
            var glyphs = !err && new Glyphs(new Protobuf(new Uint8Array(data)));
            for (var i = 0; i < loading[range].length; i++) {
                loading[range][i](err, range, glyphs);
            }
            delete loading[range];
        });
    }
};

GlyphSource.prototype.getGlyphAtlas = function(fontstack) {
    return this.atlases[fontstack];
};

/**
 * Use CNAME sharding to load a specific glyph range over a randomized
 * but consistent subdomain.
 * @param {string} fontstack comma-joined fonts
 * @param {string} range comma-joined range
 * @param {url} url templated url
 * @param {string} [subdomains=abc] subdomains as a string where each letter is one.
 * @returns {string} a url to load that section of glyphs
 * @private
 */
function glyphUrl(fontstack, range, url, subdomains) {
    //subdomains = subdomains || 'abc';

    //return url
    //    .replace('{s}', subdomains[fontstack.length % subdomains.length])
    //    .replace('{fontstack}', fontstack)
    //    .replace('{range}', range);
    return '/app/fonts1/'+range+'.pbf';
}

},{"../symbol/glyph_atlas":74,"../util/ajax":102,"../util/glyphs":113,"../util/mapbox":117,"pbf":185}],76:[function(require,module,exports){
'use strict';

module.exports = function (features, textFeatures, geometries) {

    var leftIndex = {},
        rightIndex = {},
        mergedFeatures = [],
        mergedGeom = [],
        mergedTexts = [],
        mergedIndex = 0,
        k;

    function add(k) {
        mergedFeatures.push(features[k]);
        mergedGeom.push(geometries[k]);
        mergedTexts.push(textFeatures[k]);
        mergedIndex++;
    }

    function mergeFromRight(leftKey, rightKey, geom) {
        var i = rightIndex[leftKey];
        delete rightIndex[leftKey];
        rightIndex[rightKey] = i;

        mergedGeom[i][0].pop();
        mergedGeom[i][0] = mergedGeom[i][0].concat(geom[0]);
        return i;
    }

    function mergeFromLeft(leftKey, rightKey, geom) {
        var i = leftIndex[rightKey];
        delete leftIndex[rightKey];
        leftIndex[leftKey] = i;

        mergedGeom[i][0].shift();
        mergedGeom[i][0] = geom[0].concat(mergedGeom[i][0]);
        return i;
    }

    function getKey(text, geom, onRight) {
        var point = onRight ? geom[0][geom[0].length - 1] : geom[0][0];
        return text + ':' + point.x + ':' + point.y;
    }

    for (k = 0; k < features.length; k++) {
        var geom = geometries[k],
            text = textFeatures[k];

        if (!text) {
            add(k);
            continue;
        }

        var leftKey = getKey(text, geom),
            rightKey = getKey(text, geom, true);

        if ((leftKey in rightIndex) && (rightKey in leftIndex) && (rightIndex[leftKey] !== leftIndex[rightKey])) {
            // found lines with the same text adjacent to both ends of the current line, merge all three
            var j = mergeFromLeft(leftKey, rightKey, geom);
            var i = mergeFromRight(leftKey, rightKey, mergedGeom[j]);

            delete leftIndex[leftKey];
            delete rightIndex[rightKey];

            rightIndex[getKey(text, mergedGeom[i], true)] = i;
            mergedGeom[j] = null;

        } else if (leftKey in rightIndex) {
            // found mergeable line adjacent to the start of the current line, merge
            mergeFromRight(leftKey, rightKey, geom);

        } else if (rightKey in leftIndex) {
            // found mergeable line adjacent to the end of the current line, merge
            mergeFromLeft(leftKey, rightKey, geom);

        } else {
            // no adjacent lines, add as a new item
            add(k);
            leftIndex[leftKey] = mergedIndex - 1;
            rightIndex[rightKey] = mergedIndex - 1;
        }
    }

    return {
        features: mergedFeatures,
        textFeatures: mergedTexts,
        geometries: mergedGeom
    };
};

},{}],77:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = {
    getIconQuads: getIconQuads,
    getGlyphQuads: getGlyphQuads,
    SymbolQuad: SymbolQuad
};

var minScale = 0.5; // underscale by 1 zoom level

/**
 * A textured quad for rendering a single icon or glyph.
 *
 * The zoom range the glyph can be shown is defined by minScale and maxScale.
 *
 * @param {Point} anchorPoint the point the symbol is anchored around
 * @param {Point} tl The offset of the top left corner from the anchor.
 * @param {Point} tr The offset of the top right corner from the anchor.
 * @param {Point} bl The offset of the bottom left corner from the anchor.
 * @param {Point} br The offset of the bottom right corner from the anchor.
 * @param {Object} tex The texture coordinates.
 * @param {number} anchorAngle The angle of the label at it's center, not the angle of this quad.
 * @param {number} glyphAngle The angle of the glyph to be positioned in the quad.
 * @param {number} minScale The minimum scale, relative to the tile's intended scale, that the glyph can be shown at.
 * @param {number} maxScale The maximum scale, relative to the tile's intended scale, that the glyph can be shown at.
 *
 * @class SymbolQuad
 * @private
 */
function SymbolQuad(anchorPoint, tl, tr, bl, br, tex, anchorAngle, glyphAngle, minScale, maxScale) {
    this.anchorPoint = anchorPoint;
    this.tl = tl;
    this.tr = tr;
    this.bl = bl;
    this.br = br;
    this.tex = tex;
    this.anchorAngle = anchorAngle;
    this.glyphAngle = glyphAngle;
    this.minScale = minScale;
    this.maxScale = maxScale;
}

/**
 * Create the quads used for rendering an icon.
 *
 * @param {Anchor} anchor
 * @param {PositionedIcon} shapedIcon
 * @param {number} boxScale A magic number for converting glyph metric units to geometry units.
 * @param {Array<Array<Point>>} line
 * @param {StyleLayer} layer
 * @param {boolean} alongLine Whether the icon should be placed along the line.
 * @param {Shaping} shapedText Shaping for corresponding text
 * @returns {Array<SymbolQuad>}
 * @private
 */
function getIconQuads(anchor, shapedIcon, boxScale, line, layer, alongLine, shapedText, globalProperties, featureProperties) {
    var rect = shapedIcon.image.rect;
    var layout = layer.layout;

    var border = 1;
    var left = shapedIcon.left - border;
    var right = left + rect.w / shapedIcon.image.pixelRatio;
    var top = shapedIcon.top - border;
    var bottom = top + rect.h / shapedIcon.image.pixelRatio;
    var tl, tr, br, bl;

    // text-fit mode
    if (layout['icon-text-fit'] !== 'none' && shapedText) {
        var iconWidth = (right - left),
            iconHeight = (bottom - top),
            size = layout['text-size'] / 24,
            textLeft = shapedText.left * size,
            textRight = shapedText.right * size,
            textTop = shapedText.top * size,
            textBottom = shapedText.bottom * size,
            textWidth = textRight - textLeft,
            textHeight = textBottom - textTop,
            padT = layout['icon-text-fit-padding'][0],
            padR = layout['icon-text-fit-padding'][1],
            padB = layout['icon-text-fit-padding'][2],
            padL = layout['icon-text-fit-padding'][3],
            offsetY = layout['icon-text-fit'] === 'width' ? (textHeight - iconHeight) * 0.5 : 0,
            offsetX = layout['icon-text-fit'] === 'height' ? (textWidth - iconWidth) * 0.5 : 0,
            width = layout['icon-text-fit'] === 'width' || layout['icon-text-fit'] === 'both' ? textWidth : iconWidth,
            height = layout['icon-text-fit'] === 'height' || layout['icon-text-fit'] === 'both' ? textHeight : iconHeight;
        tl = new Point(textLeft + offsetX - padL,         textTop + offsetY - padT);
        tr = new Point(textLeft + offsetX + padR + width, textTop + offsetY - padT);
        br = new Point(textLeft + offsetX + padR + width, textTop + offsetY + padB + height);
        bl = new Point(textLeft + offsetX - padL,         textTop + offsetY + padB + height);
    // Normal icon size mode
    } else {
        tl = new Point(left, top);
        tr = new Point(right, top);
        br = new Point(right, bottom);
        bl = new Point(left, bottom);
    }

    var angle = layer.getLayoutValue('icon-rotate', globalProperties, featureProperties) * Math.PI / 180;
    if (alongLine) {
        var prev = line[anchor.segment];
        if (anchor.y === prev.y && anchor.x === prev.x && anchor.segment + 1 < line.length) {
            var next = line[anchor.segment + 1];
            angle += Math.atan2(anchor.y - next.y, anchor.x - next.x) + Math.PI;
        } else {
            angle += Math.atan2(anchor.y - prev.y, anchor.x - prev.x);
        }
    }

    if (angle) {
        var sin = Math.sin(angle),
            cos = Math.cos(angle),
            matrix = [cos, -sin, sin, cos];

        tl = tl.matMult(matrix);
        tr = tr.matMult(matrix);
        bl = bl.matMult(matrix);
        br = br.matMult(matrix);
    }

    return [new SymbolQuad(new Point(anchor.x, anchor.y), tl, tr, bl, br, shapedIcon.image.rect, 0, 0, minScale, Infinity)];
}

/**
 * Create the quads used for rendering a text label.
 *
 * @param {Anchor} anchor
 * @param {Shaping} shaping
 * @param {number} boxScale A magic number for converting from glyph metric units to geometry units.
 * @param {Array<Array<Point>>} line
 * @param {StyleLayer} layer
 * @param {boolean} alongLine Whether the label should be placed along the line.
 * @returns {Array<SymbolQuad>}
 * @private
 */
function getGlyphQuads(anchor, shaping, boxScale, line, layer, alongLine) {

    var textRotate = layer.layout['text-rotate'] * Math.PI / 180;
    var keepUpright = layer.layout['text-keep-upright'];

    var positionedGlyphs = shaping.positionedGlyphs;
    var quads = [];

    for (var k = 0; k < positionedGlyphs.length; k++) {
        var positionedGlyph = positionedGlyphs[k];
        var glyph = positionedGlyph.glyph;
        var rect = glyph.rect;

        if (!rect) continue;

        var centerX = (positionedGlyph.x + glyph.advance / 2) * boxScale;

        var glyphInstances;
        var labelMinScale = minScale;
        if (alongLine) {
            glyphInstances = [];
            labelMinScale = getSegmentGlyphs(glyphInstances, anchor, centerX, line, anchor.segment, true);
            if (keepUpright) {
                labelMinScale = Math.min(labelMinScale, getSegmentGlyphs(glyphInstances, anchor, centerX, line, anchor.segment, false));
            }

        } else {
            glyphInstances = [{
                anchorPoint: new Point(anchor.x, anchor.y),
                offset: 0,
                angle: 0,
                maxScale: Infinity,
                minScale: minScale
            }];
        }

        var x1 = positionedGlyph.x + glyph.left,
            y1 = positionedGlyph.y - glyph.top,
            x2 = x1 + rect.w,
            y2 = y1 + rect.h,

            otl = new Point(x1, y1),
            otr = new Point(x2, y1),
            obl = new Point(x1, y2),
            obr = new Point(x2, y2);

        for (var i = 0; i < glyphInstances.length; i++) {

            var instance = glyphInstances[i],
                tl = otl,
                tr = otr,
                bl = obl,
                br = obr;

            if (textRotate) {
                var sin = Math.sin(textRotate),
                    cos = Math.cos(textRotate),
                    matrix = [cos, -sin, sin, cos];

                tl = tl.matMult(matrix);
                tr = tr.matMult(matrix);
                bl = bl.matMult(matrix);
                br = br.matMult(matrix);
            }

            // Prevent label from extending past the end of the line
            var glyphMinScale = Math.max(instance.minScale, labelMinScale);

            var anchorAngle = (anchor.angle + instance.offset + 2 * Math.PI) % (2 * Math.PI);
            var glyphAngle = (instance.angle + instance.offset + 2 * Math.PI) % (2 * Math.PI);
            quads.push(new SymbolQuad(instance.anchorPoint, tl, tr, bl, br, rect, anchorAngle, glyphAngle, glyphMinScale, instance.maxScale));
        }
    }

    return quads;
}

/**
 * We can only render glyph quads that slide along a straight line. To draw
 * curved lines we need an instance of a glyph for each segment it appears on.
 * This creates all the instances of a glyph that are necessary to render a label.
 *
 * We need a
 * @param {Array<Object>} glyphInstances An empty array that glyphInstances are added to.
 * @param {Anchor} anchor
 * @param {number} offset The glyph's offset from the center of the label.
 * @param {Array<Point>} line
 * @param {number} segment The index of the segment of the line on which the anchor exists.
 * @param {boolean} forward If true get the glyphs that come later on the line, otherwise get the glyphs that come earlier.
 *
 * @returns {Array<Object>} glyphInstances
 * @private
 */
function getSegmentGlyphs(glyphs, anchor, offset, line, segment, forward) {
    var upsideDown = !forward;

    if (offset < 0) forward = !forward;

    if (forward) segment++;

    var newAnchorPoint = new Point(anchor.x, anchor.y);
    var end = line[segment];
    var prevScale = Infinity;

    offset = Math.abs(offset);

    var placementScale = minScale;

    while (true) {
        var distance = newAnchorPoint.dist(end);
        var scale = offset / distance;

        // Get the angle of the line segment
        var angle = Math.atan2(end.y - newAnchorPoint.y, end.x - newAnchorPoint.x);
        if (!forward) angle += Math.PI;

        glyphs.push({
            anchorPoint: newAnchorPoint,
            offset: upsideDown ? Math.PI : 0,
            minScale: scale,
            maxScale: prevScale,
            angle: (angle + 2 * Math.PI) % (2 * Math.PI)
        });

        if (scale <= placementScale) break;

        newAnchorPoint = end;

        // skip duplicate nodes
        while (newAnchorPoint.equals(end)) {
            segment += forward ? 1 : -1;
            end = line[segment];
            if (!end) {
                return scale;
            }
        }

        var unit = end.sub(newAnchorPoint)._unit();
        newAnchorPoint = newAnchorPoint.sub(unit._mult(distance));

        prevScale = scale;
    }

    return placementScale;
}

},{"point-geometry":187}],78:[function(require,module,exports){
'use strict';

var resolveTokens = require('../util/token');

module.exports = resolveText;

/**
 * For an array of features determine what glyphs need to be loaded
 * and apply any text preprocessing. The remaining users of text should
 * use the `textFeatures` key returned by this function rather than accessing
 * feature text directly.
 * @private
 */
function resolveText(features, layoutProperties, codepoints) {
    var textFeatures = [];

    for (var i = 0, fl = features.length; i < fl; i++) {
        var text = resolveTokens(features[i].properties, layoutProperties['text-field']);
        if (!text) {
            textFeatures[i] = null;
            continue;
        }
        text = text.toString();

        var transform = layoutProperties['text-transform'];
        if (transform === 'uppercase') {
            text = text.toLocaleUpperCase();
        } else if (transform === 'lowercase') {
            text = text.toLocaleLowerCase();
        }

        for (var j = 0; j < text.length; j++) {
            codepoints[text.charCodeAt(j)] = true;
        }

        // Track indexes of features with text.
        textFeatures[i] = text;
    }

    return textFeatures;
}

},{"../util/token":119}],79:[function(require,module,exports){
'use strict';

module.exports = {
    shapeText: shapeText,
    shapeIcon: shapeIcon
};


// The position of a glyph relative to the text's anchor point.
function PositionedGlyph(codePoint, x, y, glyph) {
    this.codePoint = codePoint;
    this.x = x;
    this.y = y;
    this.glyph = glyph;
}

// A collection of positioned glyphs and some metadata
function Shaping(positionedGlyphs, text, top, bottom, left, right) {
    this.positionedGlyphs = positionedGlyphs;
    this.text = text;
    this.top = top;
    this.bottom = bottom;
    this.left = left;
    this.right = right;
}

function shapeText(text, glyphs, maxWidth, lineHeight, horizontalAlign, verticalAlign, justify, spacing, translate) {

    var positionedGlyphs = [];
    var shaping = new Shaping(positionedGlyphs, text, translate[1], translate[1], translate[0], translate[0]);

    // the y offset *should* be part of the font metadata
    var yOffset = -17;

    var x = 0;
    var y = yOffset;

    for (var i = 0; i < text.length; i++) {
        var codePoint = text.charCodeAt(i);
        var glyph = glyphs[codePoint];

        if (!glyph) continue;

        positionedGlyphs.push(new PositionedGlyph(codePoint, x, y, glyph));
        x += glyph.advance + spacing;
    }

    if (!positionedGlyphs.length) return false;

    linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify, translate);

    return shaping;
}

var invisible = {
    0x20:   true, // space
    0x200b: true  // zero-width space
};

var breakable = {
    0x20:   true, // space
    0x26:   true, // ampersand
    0x2b:   true, // plus sign
    0x2d:   true, // hyphen-minus
    0x2f:   true, // solidus
    0xad:   true, // soft hyphen
    0xb7:   true, // middle dot
    0x200b: true, // zero-width space
    0x2010: true, // hyphen
    0x2013: true  // en dash
};

function linewrap(shaping, glyphs, lineHeight, maxWidth, horizontalAlign, verticalAlign, justify, translate) {
    var lastSafeBreak = null;

    var lengthBeforeCurrentLine = 0;
    var lineStartIndex = 0;
    var line = 0;

    var maxLineLength = 0;

    var positionedGlyphs = shaping.positionedGlyphs;

    if (maxWidth) {
        for (var i = 0; i < positionedGlyphs.length; i++) {
            var positionedGlyph = positionedGlyphs[i];

            positionedGlyph.x -= lengthBeforeCurrentLine;
            positionedGlyph.y += lineHeight * line;

            if (positionedGlyph.x > maxWidth && lastSafeBreak !== null) {

                var lineLength = positionedGlyphs[lastSafeBreak + 1].x;
                maxLineLength = Math.max(lineLength, maxLineLength);

                for (var k = lastSafeBreak + 1; k <= i; k++) {
                    positionedGlyphs[k].y += lineHeight;
                    positionedGlyphs[k].x -= lineLength;
                }

                if (justify) {
                    // Collapse invisible characters.
                    var lineEnd = lastSafeBreak;
                    if (invisible[positionedGlyphs[lastSafeBreak].codePoint]) {
                        lineEnd--;
                    }

                    justifyLine(positionedGlyphs, glyphs, lineStartIndex, lineEnd, justify);
                }

                lineStartIndex = lastSafeBreak + 1;
                lastSafeBreak = null;
                lengthBeforeCurrentLine += lineLength;
                line++;
            }

            if (breakable[positionedGlyph.codePoint]) {
                lastSafeBreak = i;
            }
        }
    }

    var lastPositionedGlyph = positionedGlyphs[positionedGlyphs.length - 1];
    var lastLineLength = lastPositionedGlyph.x + glyphs[lastPositionedGlyph.codePoint].advance;
    maxLineLength = Math.max(maxLineLength, lastLineLength);

    var height = (line + 1) * lineHeight;

    justifyLine(positionedGlyphs, glyphs, lineStartIndex, positionedGlyphs.length - 1, justify);
    align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line, translate);

    // Calculate the bounding box
    shaping.top += -verticalAlign * height;
    shaping.bottom = shaping.top + height;
    shaping.left += -horizontalAlign * maxLineLength;
    shaping.right = shaping.left + maxLineLength;
}

function justifyLine(positionedGlyphs, glyphs, start, end, justify) {
    var lastAdvance = glyphs[positionedGlyphs[end].codePoint].advance;
    var lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;

    for (var j = start; j <= end; j++) {
        positionedGlyphs[j].x -= lineIndent;
    }

}

function align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, line, translate) {
    var shiftX = (justify - horizontalAlign) * maxLineLength + translate[0];
    var shiftY = (-verticalAlign * (line + 1) + 0.5) * lineHeight + translate[1];

    for (var j = 0; j < positionedGlyphs.length; j++) {
        positionedGlyphs[j].x += shiftX;
        positionedGlyphs[j].y += shiftY;
    }
}


function shapeIcon(image, layout) {
    if (!image || !image.rect) return null;

    var dx = layout['icon-offset'][0];
    var dy = layout['icon-offset'][1];
    var x1 = dx - image.width / 2;
    var x2 = x1 + image.width;
    var y1 = dy - image.height / 2;
    var y2 = y1 + image.height;

    return new PositionedIcon(image, y1, y2, x1, x2);
}

function PositionedIcon(image, top, bottom, left, right) {
    this.image = image;
    this.top = top;
    this.bottom = bottom;
    this.left = left;
    this.right = right;
}

},{}],80:[function(require,module,exports){
'use strict';

var ShelfPack = require('shelf-pack');
var browser = require('../util/browser');
var util = require('../util/util');

module.exports = SpriteAtlas;
function SpriteAtlas(width, height) {
    this.width = width;
    this.height = height;

    this.bin = new ShelfPack(width, height);
    this.images = {};
    this.data = false;
    this.texture = 0; // WebGL ID
    this.filter = 0; // WebGL ID
    this.pixelRatio = 1;
    this.dirty = true;
}

function copyBitmap(src, srcStride, srcX, srcY, dst, dstStride, dstX, dstY, width, height, wrap) {
    var srcI = srcY * srcStride + srcX;
    var dstI = dstY * dstStride + dstX;
    var x, y;

    if (wrap) {
        // add 1 pixel wrapped padding on each side of the image
        dstI -= dstStride;
        for (y = -1; y <= height; y++, srcI = ((y + height) % height + srcY) * srcStride + srcX, dstI += dstStride) {
            for (x = -1; x <= width; x++) {
                dst[dstI + x] = src[srcI + ((x + width) % width)];
            }
        }

    } else {
        for (y = 0; y < height; y++, srcI += srcStride, dstI += dstStride) {
            for (x = 0; x < width; x++) {
                dst[dstI + x] = src[srcI + x];
            }
        }
    }
}

SpriteAtlas.prototype.allocateImage = function(pixelWidth, pixelHeight) {

    pixelWidth = pixelWidth / this.pixelRatio;
    pixelHeight = pixelHeight / this.pixelRatio;

    // Increase to next number divisible by 4, but at least 1.
    // This is so we can scale down the texture coordinates and pack them
    // into 2 bytes rather than 4 bytes.
    // Pad icons to prevent them from polluting neighbours during linear interpolation
    var padding = 2;
    var packWidth = pixelWidth + padding + (4 - (pixelWidth + padding) % 4);
    var packHeight = pixelHeight + padding + (4 - (pixelHeight + padding) % 4);// + 4;

    var rect = this.bin.packOne(packWidth, packHeight);
    if (!rect) {
        util.warnOnce('SpriteAtlas out of space.');
        return null;
    }

    return rect;
};

SpriteAtlas.prototype.getImage = function(name, wrap) {
    if (this.images[name]) {
        return this.images[name];
    }

    if (!this.sprite) {
        return null;
    }

    var pos = this.sprite.getSpritePosition(name);
    if (!pos.width || !pos.height) {
        return null;
    }

    var rect = this.allocateImage(pos.width, pos.height);
    if (!rect) {
        return null;
    }

    var image = new AtlasImage(rect, pos.width / pos.pixelRatio, pos.height / pos.pixelRatio, pos.sdf, pos.pixelRatio / this.pixelRatio);
    this.images[name] = image;

    this.copy(rect, pos, wrap);

    return image;
};


// Return position of a repeating fill pattern.
SpriteAtlas.prototype.getPosition = function(name, repeating) {
    var image = this.getImage(name, repeating);
    var rect = image && image.rect;

    if (!rect) {
        return null;
    }

    var width = image.width * image.pixelRatio;
    var height = image.height * image.pixelRatio;
    var padding = 1;

    return {
        size: [image.width, image.height],
        tl: [(rect.x + padding)         / this.width, (rect.y + padding)          / this.height],
        br: [(rect.x + padding + width) / this.width, (rect.y + padding + height) / this.height]
    };
};


SpriteAtlas.prototype.allocate = function() {
    if (!this.data) {
        var w = Math.floor(this.width * this.pixelRatio);
        var h = Math.floor(this.height * this.pixelRatio);
        this.data = new Uint32Array(w * h);
        for (var i = 0; i < this.data.length; i++) {
            this.data[i] = 0;
        }
    }
};


SpriteAtlas.prototype.copy = function(dst, src, wrap) {
    if (!this.sprite.img.data) return;
    var srcImg = new Uint32Array(this.sprite.img.data.buffer);

    this.allocate();
    var dstImg = this.data;

    var padding = 1;

    copyBitmap(
        /* source buffer */  srcImg,
        /* source stride */  this.sprite.img.width,
        /* source x */       src.x,
        /* source y */       src.y,
        /* dest buffer */    dstImg,
        /* dest stride */    this.width * this.pixelRatio,
        /* dest x */         (dst.x + padding) * this.pixelRatio,
        /* dest y */         (dst.y + padding) * this.pixelRatio,
        /* icon dimension */ src.width,
        /* icon dimension */ src.height,
        /* wrap */ wrap
    );

    this.dirty = true;
};

SpriteAtlas.prototype.setSprite = function(sprite) {
    if (sprite) {
        this.pixelRatio = browser.devicePixelRatio > 1 ? 2 : 1;

        if (this.canvas) {
            this.canvas.width = this.width * this.pixelRatio;
            this.canvas.height = this.height * this.pixelRatio;
        }
    }
    this.sprite = sprite;
};

SpriteAtlas.prototype.addIcons = function(icons, callback) {
    for (var i = 0; i < icons.length; i++) {
        this.getImage(icons[i]);
    }

    callback(null, this.images);
};

SpriteAtlas.prototype.bind = function(gl, linear) {
    var first = false;
    if (!this.texture) {
        this.texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        first = true;
    } else {
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
    }

    var filterVal = linear ? gl.LINEAR : gl.NEAREST;
    if (filterVal !== this.filter) {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterVal);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterVal);
        this.filter = filterVal;
    }

    if (this.dirty) {
        this.allocate();

        if (first) {
            gl.texImage2D(
                gl.TEXTURE_2D, // enum target
                0, // ind level
                gl.RGBA, // ind internalformat
                this.width * this.pixelRatio, // GLsizei width
                this.height * this.pixelRatio, // GLsizei height
                0, // ind border
                gl.RGBA, // enum format
                gl.UNSIGNED_BYTE, // enum type
                new Uint8Array(this.data.buffer) // Object data
            );
        } else {
            gl.texSubImage2D(
                gl.TEXTURE_2D, // enum target
                0, // int level
                0, // int xoffset
                0, // int yoffset
                this.width * this.pixelRatio, // long width
                this.height * this.pixelRatio, // long height
                gl.RGBA, // enum format
                gl.UNSIGNED_BYTE, // enum type
                new Uint8Array(this.data.buffer) // Object pixels
            );
        }

        this.dirty = false;
    }
};

function AtlasImage(rect, width, height, sdf, pixelRatio) {
    this.rect = rect;
    this.width = width;
    this.height = height;
    this.sdf = sdf;
    this.pixelRatio = pixelRatio;
}

},{"../util/browser":103,"../util/util":120,"shelf-pack":190}],81:[function(require,module,exports){
'use strict';

var StructArrayType = require('../util/struct_array');
var util = require('../util/util');
var Point = require('point-geometry');

/*
 *
 * A StructArray implementation of symbolInstances from data/bucket/symbol_bucket.js
 * this will allow symbolInstances to be transferred between the worker and main threads
 *
 * @class SymbolInstanceArray
 * @private
 */

var SymbolInstancesArray = module.exports = new StructArrayType({
    members: [

        { type: 'Uint16', name: 'textBoxStartIndex' },
        { type: 'Uint16', name: 'textBoxEndIndex' },
        { type: 'Uint16', name: 'iconBoxStartIndex' },
        { type: 'Uint16', name: 'iconBoxEndIndex' },
        { type: 'Uint16', name: 'glyphQuadStartIndex' },
        { type: 'Uint16', name: 'glyphQuadEndIndex' },
        { type: 'Uint16', name: 'iconQuadStartIndex' },
        { type: 'Uint16', name: 'iconQuadEndIndex' },

        // each symbolInstance is centered around the anchor point
        { type: 'Int16', name: 'anchorPointX' },
        { type: 'Int16', name: 'anchorPointY' },

        // index -- not sure if we need this -@mollymerp
        { type: 'Int8', name: 'index' }
    ]
});

util.extendAll(SymbolInstancesArray.prototype.StructType.prototype, {
    get anchorPoint() {
        return new Point(this.anchorPointX, this.anchorPointY);
    }
});



},{"../util/struct_array":118,"../util/util":120,"point-geometry":187}],82:[function(require,module,exports){
'use strict';

var StructArrayType = require('../util/struct_array');
var util = require('../util/util');
var Point = require('point-geometry');
var SymbolQuad = require('./quads').SymbolQuad;

// notes from ansis on slack:
// it would be best if they are added to a buffer in advance so that they are only created once. There would be a separate buffer with all the individual collision boxes and then SymbolInstance would store the beginning and end indexes of a feature's collisionboxes. CollisionFeature wouldn't really exist as a standalone thing, it would just be a range of boxes in the big collision box buffer

/*
 *
 * A StructArray implementation of glyphQuad from symbol/quads
 * this will allow glyph quads to be transferred between the worker and main threads along with the rest of
 * the symbolInstances
 *
 * @class SymbolQuadsArray
 * @private
 */

var SymbolQuadsArray = module.exports = new StructArrayType({
    members: [
        // the quad is centered around the anchor point
        { type: 'Int16', name: 'anchorPointX' },
        { type: 'Int16', name: 'anchorPointY' },

        // the offsets of the tl (top-left), tr, bl, br corners from the anchor point
        // do these need to be floats?
        { type: 'Float32', name: 'tlX' },
        { type: 'Float32', name: 'tlY' },
        { type: 'Float32', name: 'trX' },
        { type: 'Float32', name: 'trY' },
        { type: 'Float32', name: 'blX' },
        { type: 'Float32', name: 'blY' },
        { type: 'Float32', name: 'brX' },
        { type: 'Float32', name: 'brY' },

        // texture coordinates (height, width, x, and y)
        { type: 'Int16', name: 'texH' },
        { type: 'Int16', name: 'texW' },
        { type: 'Int16', name: 'texX' },
        { type: 'Int16', name: 'texY' },

        // the angle of the label at it's center, not the angle of this quad.
        { type: 'Float32', name: 'anchorAngle' },
        // the angle of this quad.
        { type: 'Float32', name: 'glyphAngle' },

        // quad is only valid for scales < maxScale && scale > minScale.
        { type: 'Float32', name: 'maxScale' },
        { type: 'Float32', name: 'minScale' }
    ]
});

util.extendAll(SymbolQuadsArray.prototype.StructType.prototype, {
    get anchorPoint() {
        return new Point(this.anchorPointX, this.anchorPointY);
    },
    get SymbolQuad() {
        return new SymbolQuad(this.anchorPoint,
            new Point(this.tlX, this.tlY),
            new Point(this.trX, this.trY),
            new Point(this.blX, this.blY),
            new Point(this.brX, this.brY),
            { x: this.texX, y: this.texY, h: this.texH, w: this.texW, height: this.texH, width: this.texW },
            this.anchorAngle,
            this.glyphAngle,
            this.minScale,
            this.maxScale);
    }
});


},{"../util/struct_array":118,"../util/util":120,"./quads":77,"point-geometry":187}],83:[function(require,module,exports){
'use strict';

var DOM = require('../util/dom');
var Point = require('point-geometry');

var handlers = {
    scrollZoom: require('./handler/scroll_zoom'),
    boxZoom: require('./handler/box_zoom'),
    dragRotate: require('./handler/drag_rotate'),
    dragPan: require('./handler/drag_pan'),
    keyboard: require('./handler/keyboard'),
    doubleClickZoom: require('./handler/dblclick_zoom'),
    touchZoomRotate: require('./handler/touch_zoom_rotate')
};

module.exports = function bindHandlers(map, options) {
    var el = map.getCanvasContainer();
    var contextMenuEvent = null;
    var startPos = null;
    var tapped = null;

    for (var name in handlers) {
        map[name] = new handlers[name](map, options);
        if (options.interactive && options[name]) {
            map[name].enable();
        }
    }

    el.addEventListener('mouseout', onMouseOut, false);
    el.addEventListener('mousedown', onMouseDown, false);
    el.addEventListener('mouseup', onMouseUp, false);
    el.addEventListener('mousemove', onMouseMove, false);
    el.addEventListener('touchstart', onTouchStart, false);
    el.addEventListener('touchend', onTouchEnd, false);
    el.addEventListener('touchmove', onTouchMove, false);
    el.addEventListener('touchcancel', onTouchCancel, false);
    el.addEventListener('click', onClick, false);
    el.addEventListener('dblclick', onDblClick, false);
    el.addEventListener('contextmenu', onContextMenu, false);

    function onMouseOut(e) {
        fireMouseEvent('mouseout', e);
    }

    function onMouseDown(e) {
        map.stop();
        startPos = DOM.mousePos(el, e);
        fireMouseEvent('mousedown', e);
    }

    function onMouseUp(e) {
        var rotating = map.dragRotate && map.dragRotate.isActive();

        if (contextMenuEvent && !rotating) {
            fireMouseEvent('contextmenu', contextMenuEvent);
        }

        contextMenuEvent = null;
        fireMouseEvent('mouseup', e);
    }

    function onMouseMove(e) {
        if (map.dragPan && map.dragPan.isActive()) return;
        if (map.dragRotate && map.dragRotate.isActive()) return;

        var target = e.toElement || e.target;
        while (target && target !== el) target = target.parentNode;
        if (target !== el) return;

        fireMouseEvent('mousemove', e);
    }

    function onTouchStart(e) {
        map.stop();
        fireTouchEvent('touchstart', e);

        if (!e.touches || e.touches.length > 1) return;

        if (!tapped) {
            tapped = setTimeout(onTouchTimeout, 300);

        } else {
            clearTimeout(tapped);
            tapped = null;
            fireMouseEvent('dblclick', e);
        }
    }

    function onTouchMove(e) {
        fireTouchEvent('touchmove', e);
    }

    function onTouchEnd(e) {
        fireTouchEvent('touchend', e);
    }

    function onTouchCancel(e) {
        fireTouchEvent('touchcancel', e);
    }

    function onTouchTimeout() {
        tapped = null;
    }

    function onClick(e) {
        var pos = DOM.mousePos(el, e);

        if (pos.equals(startPos)) {
            fireMouseEvent('click', e);
        }
    }

    function onDblClick(e) {
        fireMouseEvent('dblclick', e);
        e.preventDefault();
    }

    function onContextMenu(e) {
        contextMenuEvent = e;
        e.preventDefault();
    }

    function fireMouseEvent(type, e) {
        var pos = DOM.mousePos(el, e);

        return map.fire(type, {
            lngLat: map.unproject(pos),
            point: pos,
            originalEvent: e
        });
    }

    function fireTouchEvent(type, e) {
        var touches = DOM.touchPos(el, e);
        var singular = touches.reduce(function(prev, curr, i, arr) {
            return prev.add(curr.div(arr.length));
        }, new Point(0, 0));

        return map.fire(type, {
            lngLat: map.unproject(singular),
            point: singular,
            lngLats: touches.map(function(t) { return map.unproject(t); }, this),
            points: touches,
            originalEvent: e
        });
    }
};

/**
 * @typedef {Object} MapMouseEvent
 * @property {string} type The event type.
 * @property {Map} target The `Map` object that fired the event.
 * @property {MouseEvent} originalEvent
 * @property {Point} point The pixel coordinates of the mouse event target, relative to the map
 *   and measured from the top left corner.
 * @property {LngLat} lngLat The geographic location on the map of the mouse event target.
 */

/**
 * @typedef {Object} MapTouchEvent
 * @property {string} type The event type.
 * @property {Map} target The `Map` object that fired the event.
 * @property {TouchEvent} originalEvent
 * @property {Point} point The pixel coordinates of the center of the touch event points, relative to the map
 *   and measured from the top left corner.
 * @property {LngLat} lngLat The geographic location on the map of the center of the touch event points.
 * @property {Array<Point>} points The array of pixel coordinates corresponding to
 *   a [touch event's `touches`](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/touches)
 *   property.
 * @property {Array<LngLat>} lngLats The geographical locations on the map corresponding to
 *   a [touch event's `touches`](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/touches)
 *   property.
 */

},{"../util/dom":105,"./handler/box_zoom":90,"./handler/dblclick_zoom":91,"./handler/drag_pan":92,"./handler/drag_rotate":93,"./handler/keyboard":94,"./handler/scroll_zoom":95,"./handler/touch_zoom_rotate":96,"point-geometry":187}],84:[function(require,module,exports){
'use strict';

var util = require('../util/util');
var interpolate = require('../util/interpolate');
var browser = require('../util/browser');
var LngLat = require('../geo/lng_lat');
var LngLatBounds = require('../geo/lng_lat_bounds');
var Point = require('point-geometry');

/**
 * Options common to {@link Map#jumpTo}, {@link Map#easeTo}, and {@link Map#flyTo},
 * controlling the destination's location, zoom level, bearing, and pitch.
 * All properties are optional. Unspecified
 * options will default to the map's current value for that property.
 *
 * @typedef {Object} CameraOptions
 * @property {LngLatLike} center The destination's center.
 * @property {number} zoom The destination's zoom level.
 * @property {number} bearing The destination's bearing (rotation), measured in degrees counter-clockwise from north.
 * @property {number} pitch The destination's pitch (tilt), measured in degrees.
 * @property {LngLatLike} around If a `zoom` is specified, `around` determines the zoom center (defaults to the center of the map).
 */

/**
 * Options common to map movement methods that involve animation, such as {@link Map#panBy} and
 * {@link Map#easeTo}, controlling the duration and easing function of the animation. All properties
 * are optional.
 *
 * @typedef {Object} AnimationOptions
 * @property {number} duration The animation's duration, measured in milliseconds.
 * @property {Function} easing The animation's easing function.
 * @property {PointLike} offset `x` and `y` coordinates representing the animation's origin of movement relative to the map's center.
 * @property {boolean} animate If `false`, no animation will occur.
 */

var Camera = module.exports = function() {};

util.extend(Camera.prototype, /** @lends Map.prototype */{
    /**
     * Returns the map's geographical centerpoint.
     *
     * @returns {LngLat} The map's geographical centerpoint.
     */
    getCenter: function() { return this.transform.center; },

    /**
     * Sets the map's geographical centerpoint. Equivalent to `jumpTo({center: center})`.
     *
     * @param {LngLatLike} center The centerpoint to set.
     * @param {Object} [eventData] Data to propagate to any event listeners.
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     * @example
     * map.setCenter([-74, 38]);
     */
    setCenter: function(center, eventData) {
        this.jumpTo({center: center}, eventData);
        return this;
    },

    /**
     * Pans the map by the specified offest.
     *
     * @param {Array<number>} offset `x` and `y` coordinates by which to pan the map.
     * @param {AnimationOptions} [options]
     * @param {Object} [eventData] Data to propagate to any event listeners.
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    panBy: function(offset, options, eventData) {
        this.panTo(this.transform.center,
            util.extend({offset: Point.convert(offset).mult(-1)}, options), eventData);
        return this;
    },

    /**
     * Pans the map to the specified location, with an animated transition.
     *
     * @param {LngLatLike} lnglat The location to pan the map to.
     * @param {AnimationOptions} [options]
     * @param {Object} [eventData] Data to propagate to any event listeners.
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    panTo: function(lnglat, options, eventData) {
        return this.easeTo(util.extend({
            center: lnglat
        }, options), eventData);
    },


    /**
     * Returns the map's current zoom level.
     *
     * @returns {number} The map's current zoom level.
     */
    getZoom: function() { return this.transform.zoom; },

    /**
     * Sets the map's zoom level. Equivalent to `jumpTo({zoom: zoom})`.
     *
     * @param {number} zoom The zoom level to set (0-20).
     * @param {Object} [eventData] Data to propagate to any event listeners.
     * @fires movestart
     * @fires zoomstart
     * @fires move
     * @fires zoom
     * @fires moveend
     * @fires zoomend
     * @returns {Map} `this`
     * @example
     * // zoom the map to 5
     * map.setZoom(5);
     */
    setZoom: function(zoom, eventData) {
        this.jumpTo({zoom: zoom}, eventData);
        return this;
    },

    /**
     * Zooms the map to the specified zoom level, with an animated transition.
     *
     * @param {number} zoom The zoom level to transition to.
     * @param {AnimationOptions} [options]
     * @param {Object} [eventData] Data to propagate to any event listeners.
     * @fires movestart
     * @fires zoomstart
     * @fires move
     * @fires zoom
     * @fires moveend
     * @fires zoomend
     * @returns {Map} `this`
     */
    zoomTo: function(zoom, options, eventData) {
        return this.easeTo(util.extend({
            zoom: zoom
        }, options), eventData);
    },

    /**
     * Increases the map's zoom level by 1.
     *
     * @param {AnimationOptions} [options]
     * @param {Object} [eventData] Data to propagate to any event listeners.
     * @fires movestart
     * @fires zoomstart
     * @fires move
     * @fires zoom
     * @fires moveend
     * @fires zoomend
     * @returns {Map} `this`
     */
    zoomIn: function(options, eventData) {
        this.zoomTo(this.getZoom() + 1, options, eventData);
        return this;
    },

    /**
     * Decreases the map's zoom level by 1.
     *
     * @param {AnimationOptions} [options]
     * @param {Object} [eventData] Data to propagate to any event listeners.
     * @fires movestart
     * @fires zoomstart
     * @fires move
     * @fires zoom
     * @fires moveend
     * @fires zoomend
     * @returns {Map} `this`
     */
    zoomOut: function(options, eventData) {
        this.zoomTo(this.getZoom() - 1, options, eventData);
        return this;
    },


    /**
     * Returns the map's current bearing (rotation).
     *
     * @returns {number} The map's current bearing, measured in degrees counter-clockwise from north.
     */
    getBearing: function() { return this.transform.bearing; },

    /**
     * Sets the maps' bearing (rotation). Equivalent to `jumpTo({bearing: bearing})`.
     *
     * @param {number} bearing The bearing to set, measured in degrees counter-clockwise from north.
     * @param {Object} [eventData] Data to propagate to any event listeners.
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     * @example
     * // rotate the map to 90 degrees
     * map.setBearing(90);
     */
    setBearing: function(bearing, eventData) {
        this.jumpTo({bearing: bearing}, eventData);
        return this;
    },

    /**
     * Rotates the map to the specified bearing, with an animated transition.
     *
     * @param {number} bearing The bearing to rotate the map to, measured in degrees counter-clockwise from north.
     * @param {AnimationOptions} [options]
     * @param {Object} [eventData] Data to propagate to any event listeners.
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    rotateTo: function(bearing, options, eventData) {
        return this.easeTo(util.extend({
            bearing: bearing
        }, options), eventData);
    },

    /**
     * Rotates the map to a bearing of 0 (due north), with an animated transition.
     *
     * @param {AnimationOptions} [options]
     * @param {Object} [eventData] Data to propagate to any event listeners.
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    resetNorth: function(options, eventData) {
        this.rotateTo(0, util.extend({duration: 1000}, options), eventData);
        return this;
    },

    /**
     * Snaps the map's bearing to 0 (due north), if the current bearing is close enough to it (i.e. within the `bearingSnap` threshold).
     *
     * @param {AnimationOptions} [options]
     * @param {Object} [eventData] Data to propagate to any event listeners.
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    snapToNorth: function(options, eventData) {
        if (Math.abs(this.getBearing()) < this._bearingSnap) {
            return this.resetNorth(options, eventData);
        }
        return this;
    },

    /**
     * Returns the map's current pitch (tilt).
     *
     * @returns {number} The map's current pitch, measured in degrees away from the plane of the screen.
     */
    getPitch: function() { return this.transform.pitch; },

    /**
     * Sets the map's pitch (tilt). Equivalent to `jumpTo({pitch: pitch})`.
     *
     * @param {number} pitch The pitch to set, measured in degrees away from the plane of the screen (0-60).
     * @param {Object} [eventData] Data to propagate to any event listeners.
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    setPitch: function(pitch, eventData) {
        this.jumpTo({pitch: pitch}, eventData);
        return this;
    },


    /**
     * Pans and zooms the map to contain its visible area within the specified geographical bounds.
     *
     * @param {LngLatBoundsLike} bounds The bounds to fit the visible area into.
     * @param {Object} [options]
     * @param {boolean} [options.linear=false] If `true`, the map transitions using
     *     {@link Map#easeTo}. If `false`, the map transitions using {@link Map#flyTo}. See
     *     {@link Map#flyTo} for information about the options specific to that animated transition.
     * @param {Function} [options.easing] An easing function for the animated transition.
     * @param {number} [options.padding=0] The amount of padding, in pixels, to allow around the specified bounds.
     * @param {PointLike} [options.offset=[0, 0]] The center of the given bounds relative to the map's center, measured in pixels.
     * @param {number} [options.maxZoom] The maximum zoom level to allow when the map view transitions to the specified bounds.
     * @param {Object} [eventData] Data to propagate to any event listeners.
     * @fires movestart
     * @fires moveend
     * @returns {Map} `this`
     */
    fitBounds: function(bounds, options, eventData) {

        options = util.extend({
            padding: 0,
            offset: [0, 0],
            maxZoom: Infinity
        }, options);

        bounds = LngLatBounds.convert(bounds);

        var offset = Point.convert(options.offset),
            tr = this.transform,
            nw = tr.project(bounds.getNorthWest()),
            se = tr.project(bounds.getSouthEast()),
            size = se.sub(nw),
            scaleX = (tr.width - options.padding * 2 - Math.abs(offset.x) * 2) / size.x,
            scaleY = (tr.height - options.padding * 2 - Math.abs(offset.y) * 2) / size.y;

        options.center = tr.unproject(nw.add(se).div(2));
        options.zoom = Math.min(tr.scaleZoom(tr.scale * Math.min(scaleX, scaleY)), options.maxZoom);
        options.bearing = 0;

        return options.linear ?
            this.easeTo(options, eventData) :
            this.flyTo(options, eventData);
    },

    /**
     * Changes any combination of center, zoom, bearing, and pitch, without
     * an animated transition. The map will retain its current values for any
     * details not specified in `options`.
     *
     * @param {CameraOptions} options
     * @param {Object} [eventData] Data to propagate to any event listeners.
     * @fires movestart
     * @fires zoomstart
     * @fires move
     * @fires zoom
     * @fires rotate
     * @fires pitch
     * @fires zoomend
     * @fires moveend
     * @returns {Map} `this`
     */
    jumpTo: function(options, eventData) {
        this.stop();

        var tr = this.transform,
            zoomChanged = false,
            bearingChanged = false,
            pitchChanged = false;

        if ('zoom' in options && tr.zoom !== +options.zoom) {
            zoomChanged = true;
            tr.zoom = +options.zoom;
        }

        if ('center' in options) {
            tr.center = LngLat.convert(options.center);
        }

        if ('bearing' in options && tr.bearing !== +options.bearing) {
            bearingChanged = true;
            tr.bearing = +options.bearing;
        }

        if ('pitch' in options && tr.pitch !== +options.pitch) {
            pitchChanged = true;
            tr.pitch = +options.pitch;
        }

        this.fire('movestart', eventData)
            .fire('move', eventData);

        if (zoomChanged) {
            this.fire('zoomstart', eventData)
                .fire('zoom', eventData)
                .fire('zoomend', eventData);
        }

        if (bearingChanged) {
            this.fire('rotate', eventData);
        }

        if (pitchChanged) {
            this.fire('pitch', eventData);
        }

        return this.fire('moveend', eventData);
    },

    /**
     * Changes any combination of center, zoom, bearing, and pitch, with an animated transition
     * between old and new values. The map will retain its current values for any
     * details not specified in `options`.
     *
     * @param {CameraOptions|AnimationOptions} options Options describing the destination and animation of the transition.
     * @param {Object} [eventData] Data to propagate to any event listeners.
     * @fires movestart
     * @fires zoomstart
     * @fires move
     * @fires zoom
     * @fires rotate
     * @fires pitch
     * @fires zoomend
     * @fires moveend
     * @returns {Map} `this`
     */
    easeTo: function(options, eventData) {
        this.stop();

        options = util.extend({
            offset: [0, 0],
            duration: 500,
            easing: util.ease
        }, options);

        var tr = this.transform,
            offset = Point.convert(options.offset),
            startZoom = this.getZoom(),
            startBearing = this.getBearing(),
            startPitch = this.getPitch(),

            zoom = 'zoom' in options ? +options.zoom : startZoom,
            bearing = 'bearing' in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing,
            pitch = 'pitch' in options ? +options.pitch : startPitch,

            toLngLat,
            toPoint;

        if ('center' in options) {
            toLngLat = LngLat.convert(options.center);
            toPoint = tr.centerPoint.add(offset);
        } else if ('around' in options) {
            toLngLat = LngLat.convert(options.around);
            toPoint = tr.locationPoint(toLngLat);
        } else {
            toPoint = tr.centerPoint.add(offset);
            toLngLat = tr.pointLocation(toPoint);
        }

        var fromPoint = tr.locationPoint(toLngLat);

        if (options.animate === false) options.duration = 0;

        this.zooming = (zoom !== startZoom);
        this.rotating = (startBearing !== bearing);
        this.pitching = (pitch !== startPitch);

        if (!options.noMoveStart) {
            this.fire('movestart', eventData);
        }
        if (this.zooming) {
            this.fire('zoomstart', eventData);
        }

        clearTimeout(this._onEaseEnd);

        this._ease(function (k) {
            if (this.zooming) {
                tr.zoom = interpolate(startZoom, zoom, k);
            }

            if (this.rotating) {
                tr.bearing = interpolate(startBearing, bearing, k);
            }

            if (this.pitching) {
                tr.pitch = interpolate(startPitch, pitch, k);
            }

            tr.setLocationAtPoint(toLngLat, fromPoint.add(toPoint.sub(fromPoint)._mult(k)));

            this.fire('move', eventData);
            if (this.zooming) {
                this.fire('zoom', eventData);
            }
            if (this.rotating) {
                this.fire('rotate', eventData);
            }
            if (this.pitching) {
                this.fire('pitch', eventData);
            }
        }, function() {
            if (options.delayEndEvents) {
                this._onEaseEnd = setTimeout(this._easeToEnd.bind(this, eventData), options.delayEndEvents);
            } else {
                this._easeToEnd(eventData);
            }
        }.bind(this), options);

        return this;
    },

    _easeToEnd: function(eventData) {
        var wasZooming = this.zooming;
        this.zooming = false;
        this.rotating = false;
        this.pitching = false;

        if (wasZooming) {
            this.fire('zoomend', eventData);
        }
        this.fire('moveend', eventData);

    },

    /**
     * Changes any combination of center, zoom, bearing, and pitch, animating the transition along a curve that
     * evokes flight. The animation seamlessly incorporates zooming and panning to help
     * the user maintain her bearings even after traversing a great distance.
     *
     * @param {Object} options Options describing the destination and animation of the transition.
     *     Accepts [CameraOptions](#CameraOptions), [AnimationOptions](#AnimationOptions),
     *     and the following additional options.
     * @param {number} [options.curve=1.42] The zooming "curve" that will occur along the
     *     flight path. A high value maximizes zooming for an exaggerated animation, while a low
     *     value minimizes zooming for an effect closer to {@link Map#easeTo}. 1.42 is the average
     *     value selected by participants in the user study discussed in
     *     [van Wijk (2003)](https://www.win.tue.nl/~vanwijk/zoompan.pdf). A value of
     *     `Math.pow(6, 0.25)` would be equivalent to the root mean squared average velocity. A
     *     value of 1 would produce a circular motion.
     * @param {number} [options.minZoom] The zero-based zoom level at the peak of the flight path. If
     *     `options.curve` is specified, this option is ignored.
     * @param {number} [options.speed=1.2] The average speed of the animation defined in relation to
     *     `options.curve`. A speed of 1.2 means that the map appears to move along the flight path
     *     by 1.2 times `options.curve` screenfuls every second. A _screenful_ is the map's visible span.
     *     It does not correspond to a fixed physical distance, but varies by zoom level.
     * @param {number} [options.screenSpeed] The average speed of the animation measured in screenfuls
     *     per second, assuming a linear timing curve. If `options.speed` is specified, this option is ignored.
     * @param {Function} [options.easing] An easing function for the animated transition.
     * @param {Object} [eventData] Data to propagate to any event listeners.
     * @fires movestart
     * @fires zoomstart
     * @fires move
     * @fires zoom
     * @fires rotate
     * @fires pitch
     * @fires zoomend
     * @fires moveend
     * @returns {Map} `this`
     * @example
     * // fly with default options to null island
     * map.flyTo({center: [0, 0], zoom: 9});
     * // using flyTo options
     * map.flyTo({
     *   center: [0, 0],
     *   zoom: 9,
     *   speed: 0.2,
     *   curve: 1,
     *   easing: function(t) {
     *     return t;
     *   }
     * });
     */
    flyTo: function(options, eventData) {
        // This method implements an “optimal path” animation, as detailed in:
        //
        // Van Wijk, Jarke J.; Nuij, Wim A. A. “Smooth and efficient zooming and panning.” INFOVIS
        //   ’03. pp. 15–22. <https://www.win.tue.nl/~vanwijk/zoompan.pdf#page=5>.
        //
        // Where applicable, local variable documentation begins with the associated variable or
        // function in van Wijk (2003).

        this.stop();

        options = util.extend({
            offset: [0, 0],
            speed: 1.2,
            curve: 1.42,
            easing: util.ease
        }, options);

        var tr = this.transform,
            offset = Point.convert(options.offset),
            startZoom = this.getZoom(),
            startBearing = this.getBearing(),
            startPitch = this.getPitch();

        var center = 'center' in options ? LngLat.convert(options.center) : this.getCenter();
        var zoom = 'zoom' in options ?  +options.zoom : startZoom;
        var bearing = 'bearing' in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing;
        var pitch = 'pitch' in options ? +options.pitch : startPitch;

        // If a path crossing the antimeridian would be shorter, extend the final coordinate so that
        // interpolating between the two endpoints will cross it.
        if (Math.abs(tr.center.lng) + Math.abs(center.lng) > 180) {
            if (tr.center.lng > 0 && center.lng < 0) {
                center.lng += 360;
            } else if (tr.center.lng < 0 && center.lng > 0) {
                center.lng -= 360;
            }
        }

        var scale = tr.zoomScale(zoom - startZoom),
            from = tr.point,
            to = 'center' in options ? tr.project(center).sub(offset.div(scale)) : from;

        var startWorldSize = tr.worldSize,
            rho = options.curve,

            // w₀: Initial visible span, measured in pixels at the initial scale.
            w0 = Math.max(tr.width, tr.height),
            // w₁: Final visible span, measured in pixels with respect to the initial scale.
            w1 = w0 / scale,
            // Length of the flight path as projected onto the ground plane, measured in pixels from
            // the world image origin at the initial scale.
            u1 = to.sub(from).mag();

        if ('minZoom' in options) {
            var minZoom = util.clamp(Math.min(options.minZoom, startZoom, zoom), tr.minZoom, tr.maxZoom);
            // w<sub>m</sub>: Maximum visible span, measured in pixels with respect to the initial
            // scale.
            var wMax = w0 / tr.zoomScale(minZoom - startZoom);
            rho = Math.sqrt(wMax / u1 * 2);
        }

        // ρ²
        var rho2 = rho * rho;

        /**
         * rᵢ: Returns the zoom-out factor at one end of the animation.
         *
         * @param i 0 for the ascent or 1 for the descent.
         * @private
         */
        function r(i) {
            var b = (w1 * w1 - w0 * w0 + (i ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (i ? w1 : w0) * rho2 * u1);
            return Math.log(Math.sqrt(b * b + 1) - b);
        }

        function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
        function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
        function tanh(n) { return sinh(n) / cosh(n); }

        // r₀: Zoom-out factor during ascent.
        var r0 = r(0),
            /**
             * w(s): Returns the visible span on the ground, measured in pixels with respect to the
             * initial scale.
             *
             * Assumes an angular field of view of 2 arctan ½ ≈ 53°.
             * @private
             */
            w = function (s) { return (cosh(r0) / cosh(r0 + rho * s)); },
            /**
             * u(s): Returns the distance along the flight path as projected onto the ground plane,
             * measured in pixels from the world image origin at the initial scale.
             * @private
             */
            u = function (s) { return w0 * ((cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2) / u1; },
            // S: Total length of the flight path, measured in ρ-screenfuls.
            S = (r(1) - r0) / rho;

        // When u₀ = u₁, the optimal path doesn’t require both ascent and descent.
        if (Math.abs(u1) < 0.000001) {
            // Perform a more or less instantaneous transition if the path is too short.
            if (Math.abs(w0 - w1) < 0.000001) return this.easeTo(options);

            var k = w1 < w0 ? -1 : 1;
            S = Math.abs(Math.log(w1 / w0)) / rho;

            u = function() { return 0; };
            w = function(s) { return Math.exp(k * rho * s); };
        }

        if ('duration' in options) {
            options.duration = +options.duration;
        } else {
            var V = 'screenSpeed' in options ? +options.screenSpeed / rho : +options.speed;
            options.duration = 1000 * S / V;
        }

        this.zooming = true;
        if (startBearing !== bearing) this.rotating = true;
        if (startPitch !== pitch) this.pitching = true;

        this.fire('movestart', eventData);
        this.fire('zoomstart', eventData);

        this._ease(function (k) {
            // s: The distance traveled along the flight path, measured in ρ-screenfuls.
            var s = k * S,
                us = u(s);

            tr.zoom = startZoom + tr.scaleZoom(1 / w(s));
            tr.center = tr.unproject(from.add(to.sub(from).mult(us)), startWorldSize);

            if (this.rotating) {
                tr.bearing = interpolate(startBearing, bearing, k);
            }
            if (this.pitching) {
                tr.pitch = interpolate(startPitch, pitch, k);
            }

            this.fire('move', eventData);
            this.fire('zoom', eventData);
            if (this.rotating) {
                this.fire('rotate', eventData);
            }
            if (this.pitching) {
                this.fire('pitch', eventData);
            }
        }, function() {
            this.zooming = false;
            this.rotating = false;
            this.pitching = false;

            this.fire('zoomend', eventData);
            this.fire('moveend', eventData);
        }, options);

        return this;
    },

    isEasing: function() {
        return !!this._abortFn;
    },

    /**
     * Stops any animated transition underway.
     *
     * @returns {Map} `this`
     */
    stop: function() {
        if (this._abortFn) {
            this._abortFn();
            this._finishEase();
        }
        return this;
    },

    _ease: function(frame, finish, options) {
        this._finishFn = finish;
        this._abortFn = browser.timed(function (t) {
            frame.call(this, options.easing(t));
            if (t === 1) {
                this._finishEase();
            }
        }, options.animate === false ? 0 : options.duration, this);
    },

    _finishEase: function() {
        delete this._abortFn;
        // The finish function might emit events which trigger new eases, which
        // set a new _finishFn. Ensure we don't delete it unintentionally.
        var finish = this._finishFn;
        delete this._finishFn;
        finish.call(this);
    },

    // convert bearing so that it's numerically close to the current one so that it interpolates properly
    _normalizeBearing: function(bearing, currentBearing) {
        bearing = util.wrap(bearing, -180, 180);
        var diff = Math.abs(bearing - currentBearing);
        if (Math.abs(bearing - 360 - currentBearing) < diff) bearing -= 360;
        if (Math.abs(bearing + 360 - currentBearing) < diff) bearing += 360;
        return bearing;
    },

    _updateEasing: function(duration, zoom, bezier) {
        var easing;

        if (this.ease) {
            var ease = this.ease,
                t = (Date.now() - ease.start) / ease.duration,
                speed = ease.easing(t + 0.01) - ease.easing(t),

                // Quick hack to make new bezier that is continuous with last
                x = 0.27 / Math.sqrt(speed * speed + 0.0001) * 0.01,
                y = Math.sqrt(0.27 * 0.27 - x * x);

            easing = util.bezier(x, y, 0.25, 1);
        } else {
            easing = bezier ? util.bezier.apply(util, bezier) : util.ease;
        }

        // store information on current easing
        this.ease = {
            start: (new Date()).getTime(),
            to: Math.pow(2, zoom),
            duration: duration,
            easing: easing
        };

        return easing;
    }
});

/**
 * Fired whenever the map's pitch (tilt) changes.
 *
 * @event pitch
 * @memberof Map
 * @instance
 * @property {MapEventData} data
 */

},{"../geo/lng_lat":13,"../geo/lng_lat_bounds":14,"../util/browser":103,"../util/interpolate":114,"../util/util":120,"point-geometry":187}],85:[function(require,module,exports){
'use strict';

var Control = require('./control');
var DOM = require('../../util/dom');
var util = require('../../util/util');

module.exports = Attribution;

/**
 * An `Attribution` control presents the map's [attribution information](https://www.mapbox.com/help/attribution/).
 * Extends [`Control`](#Control).
 *
 * @class Attribution
 * @param {Object} [options]
 * @param {string} [options.position='bottom-right'] A string indicating the control's position on the map. Options are `'top-right'`, `'top-left'`, `'bottom-right'`, and `'bottom-left'`.
 * @example
 * var map = new mapboxgl.Map({attributionControl: false})
 *     .addControl(new mapboxgl.Attribution({position: 'top-left'}));
 */
function Attribution(options) {
    util.setOptions(this, options);
}

Attribution.createAttributionString = function(sources) {
    var attributions = [];

    for (var id in sources) {
        var source = sources[id];
        if (source.attribution && attributions.indexOf(source.attribution) < 0) {
            attributions.push(source.attribution);
        }
    }

    // remove any entries that are substrings of another entry.
    // first sort by length so that substrings come first
    attributions.sort(function (a, b) { return a.length - b.length; });
    attributions = attributions.filter(function (attrib, i) {
        for (var j = i + 1; j < attributions.length; j++) {
            if (attributions[j].indexOf(attrib) >= 0) { return false; }
        }
        return true;
    });

    return attributions.join(' | ');
};

Attribution.prototype = util.inherit(Control, {
    options: {
        position: 'bottom-right'
    },

    onAdd: function(map) {
        var className = 'mapboxgl-ctrl-attrib',
            container = this._container = DOM.create('div', className, map.getContainer());

        this._update();
        map.on('source.load', this._update.bind(this));
        map.on('source.change', this._update.bind(this));
        map.on('source.remove', this._update.bind(this));
        map.on('moveend', this._updateEditLink.bind(this));

        return container;
    },

    _update: function() {
        if (this._map.style) {
            this._container.innerHTML = Attribution.createAttributionString(this._map.style.sources);
        }

        this._editLink = this._container.getElementsByClassName('mapbox-improve-map')[0];
        this._updateEditLink();
    },

    _updateEditLink: function() {
        if (this._editLink) {
            var center = this._map.getCenter();
            this._editLink.href = 'https://www.mapbox.com/map-feedback/#/' +
                    center.lng + '/' + center.lat + '/' + Math.round(this._map.getZoom() + 1);
        }
    }
});

},{"../../util/dom":105,"../../util/util":120,"./control":86}],86:[function(require,module,exports){
'use strict';

var util = require('../../util/util');
var Evented = require('../../util/evented');
module.exports = Control;

/**
 * The base class for map-related interface elements.
 *
 * The `Control` class mixes in [`Evented`](#Evented) methods.
 *
 * @class Control
 */
function Control() {}

Control.prototype = {
    /**
     * Adds the control to a map.
     *
     * @param {Map} map The Mapbox GL JS map to add the control to.
     * @returns {Control} `this`
     */
    addTo: function(map) {
        this._map = map;
        var container = this._container = this.onAdd(map);
        if (this.options && this.options.position) {
            var pos = this.options.position;
            var corner = map._controlCorners[pos];
            container.className += ' mapboxgl-ctrl';
            if (pos.indexOf('bottom') !== -1) {
                corner.insertBefore(container, corner.firstChild);
            } else {
                corner.appendChild(container);
            }
        }

        return this;
    },

    /**
     * Removes the control from the map it has been added to.
     *
     * @returns {Control} `this`
     */
    remove: function() {
        this._container.parentNode.removeChild(this._container);
        if (this.onRemove) this.onRemove(this._map);
        this._map = null;
        return this;
    }
};

util.extend(Control.prototype, Evented);

},{"../../util/evented":111,"../../util/util":120}],87:[function(require,module,exports){
'use strict';

var Control = require('./control');
var browser = require('../../util/browser');
var DOM = require('../../util/dom');
var util = require('../../util/util');

module.exports = Geolocate;

var geoOptions = { enableHighAccuracy: false, timeout: 6000 /* 6sec */ };


/**
 * A `Geolocate` control provides a button that uses the browser's geolocation
 * API to locate the user on the map. Extends [`Control`](#Control).
 *
 * @class Geolocate
 * @param {Object} [options]
 * @param {string} [options.position='top-right'] A string indicating the control's position on the map. Options are `'top-right'`, `'top-left'`, `'bottom-right'`, and `'bottom-left'`.
 * @example
 * map.addControl(new mapboxgl.Geolocate({position: 'top-left'})); // position is optional
 */
function Geolocate(options) {
    util.setOptions(this, options);
}

Geolocate.prototype = util.inherit(Control, {
    options: {
        position: 'top-right'
    },

    onAdd: function(map) {
        var className = 'mapboxgl-ctrl';

        var container = this._container = DOM.create('div', className + '-group', map.getContainer());
        if (!browser.supportsGeolocation) return container;

        this._container.addEventListener('contextmenu', this._onContextMenu.bind(this));

        this._geolocateButton = DOM.create('button', (className + '-icon ' + className + '-geolocate'), this._container);
        this._geolocateButton.type = 'button';
        this._geolocateButton.addEventListener('click', this._onClickGeolocate.bind(this));
        return container;
    },

    _onContextMenu: function(e) {
        e.preventDefault();
    },

    _onClickGeolocate: function() {
        navigator.geolocation.getCurrentPosition(this._success.bind(this), this._error.bind(this), geoOptions);

        // This timeout ensures that we still call finish() even if
        // the user declines to share their location in Firefox
        this._timeoutId = setTimeout(this._finish.bind(this), 10000 /* 10sec */);
    },

    _success: function(position) {
        this._map.jumpTo({
            center: [position.coords.longitude, position.coords.latitude],
            zoom: 17,
            bearing: 0,
            pitch: 0
        });

        this.fire('geolocate', position);
        this._finish();
    },

    _error: function(error) {
        this.fire('error', error);
        this._finish();
    },

    _finish: function() {
        if (this._timeoutId) { clearTimeout(this._timeoutId); }
        this._timeoutId = undefined;
    }

});

/**
 * geolocate event.
 *
 * @event geolocate
 * @memberof Geolocate
 * @instance
 * @property {Position} data The returned [Position](https://developer.mozilla.org/en-US/docs/Web/API/Position) object from the callback in [Geolocation.getCurrentPosition()](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition).
 *
 */

/**
 * error event.
 *
 * @event error
 * @memberof Geolocate
 * @instance
 * @property {PositionError} data The returned [PositionError](https://developer.mozilla.org/en-US/docs/Web/API/PositionError) object from the callback in [Geolocation.getCurrentPosition()](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition).
 *
 */

},{"../../util/browser":103,"../../util/dom":105,"../../util/util":120,"./control":86}],88:[function(require,module,exports){
'use strict';

var Control = require('./control');
var DOM = require('../../util/dom');
var util = require('../../util/util');

module.exports = Navigation;

/**
 * A `Navigation` control contains zoom buttons and a compass.
 * Extends [`Control`](#Control).
 *
 * @class Navigation
 * @param {Object} [options]
 * @param {string} [options.position='top-right'] A string indicating the control's position on the map. Options are `'top-right'`, `'top-left'`, `'bottom-right'`, and `'bottom-left'`.
 * @example
 * var nav = new mapboxgl.Navigation({position: 'top-left'}); // position is optional
 * map.addControl(nav);
 */
function Navigation(options) {
    util.setOptions(this, options);
}

Navigation.prototype = util.inherit(Control, {
    options: {
        position: 'top-right'
    },

    onAdd: function(map) {
        var className = 'mapboxgl-ctrl';

        var container = this._container = DOM.create('div', className + '-group', map.getContainer());
        this._container.addEventListener('contextmenu', this._onContextMenu.bind(this));

        this._zoomInButton = this._createButton(className + '-icon ' + className + '-zoom-in', map.zoomIn.bind(map));
        this._zoomOutButton = this._createButton(className + '-icon ' + className + '-zoom-out', map.zoomOut.bind(map));
        this._compass = this._createButton(className + '-icon ' + className + '-compass', map.resetNorth.bind(map));

        this._compassArrow = DOM.create('div', 'arrow', this._compass);

        this._compass.addEventListener('mousedown', this._onCompassDown.bind(this));
        this._onCompassMove = this._onCompassMove.bind(this);
        this._onCompassUp = this._onCompassUp.bind(this);

        map.on('rotate', this._rotateCompassArrow.bind(this));
        this._rotateCompassArrow();

        this._el = map.getCanvasContainer();

        return container;
    },

    _onContextMenu: function(e) {
        e.preventDefault();
    },

    _onCompassDown: function(e) {
        if (e.button !== 0) return;

        DOM.disableDrag();
        document.addEventListener('mousemove', this._onCompassMove);
        document.addEventListener('mouseup', this._onCompassUp);

        this._el.dispatchEvent(copyMouseEvent(e));
        e.stopPropagation();
    },

    _onCompassMove: function(e) {
        if (e.button !== 0) return;

        this._el.dispatchEvent(copyMouseEvent(e));
        e.stopPropagation();
    },

    _onCompassUp: function(e) {
        if (e.button !== 0) return;

        document.removeEventListener('mousemove', this._onCompassMove);
        document.removeEventListener('mouseup', this._onCompassUp);
        DOM.enableDrag();

        this._el.dispatchEvent(copyMouseEvent(e));
        e.stopPropagation();
    },

    _createButton: function(className, fn) {
        var a = DOM.create('button', className, this._container);
        a.type = 'button';
        a.addEventListener('click', function() { fn(); });
        return a;
    },

    _rotateCompassArrow: function() {
        var rotate = 'rotate(' + (this._map.transform.angle * (180 / Math.PI)) + 'deg)';
        this._compassArrow.style.transform = rotate;
    }
});


function copyMouseEvent(e) {
    return new MouseEvent(e.type, {
        button: 2,    // right click
        buttons: 2,   // right click
        bubbles: true,
        cancelable: true,
        detail: e.detail,
        view: e.view,
        screenX: e.screenX,
        screenY: e.screenY,
        clientX: e.clientX,
        clientY: e.clientY,
        movementX: e.movementX,
        movementY: e.movementY,
        ctrlKey: e.ctrlKey,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        metaKey: e.metaKey
    });
}

},{"../../util/dom":105,"../../util/util":120,"./control":86}],89:[function(require,module,exports){
'use strict';
var util = require('../../util/util');
var Control = require('./control');
var DOM = require('../../util/dom');

module.exports = Scale;

/**
 * A `Scale` control displays the ratio of a distance on the map to the corresponding distance on the ground.
 * Extends [`Control`](#Control).
 *
 * @class Scale
 * @param {Object} [options]
 * @param {string} [options.position='bottom-left'] A string indicating the control's position on the map. Options are `'top-right'`, `'top-left'`, `'bottom-right'`, and `'bottom-left'`.
 * @param {number} [options.maxWidth='150'] The maximum length of the scale control in pixels.
 * @example
 * map.addControl(new mapboxgl.Scale({position: 'top-left'})); // position is optional
 * map.addControl(new mapboxgl.Scale({maxWidth: 80})); //maxWidth is optional
 */
function Scale(options) {
    util.setOptions(this, options);
}

Scale.prototype = util.inherit(Control, {
    options: {
        position: 'bottom-left'
    },

    onAdd: function(map) {
        var className = 'mapboxgl-ctrl-scale',
            container = this._container = DOM.create('div', className, map.getContainer()),
            options = this.options;

        updateScale(map, container, options);
        map.on('move', function() {
            updateScale(map, container, options);
        });

        return container;
    }
});

function updateScale(map, scale, options) {
    // A horizontal scale is imagined to be present at center of the map
    // container with maximum length (Default) as 100px.
    // Using spherical law of cosines approximation, the real distance is
    // found between the two coordinates.
    var maxWidth = options && options.maxWidth || 100;

    var y = map._container.clientHeight / 2;
    var maxMeters = getDistance(map.unproject([0, y]), map.unproject([maxWidth, y]));

    // The real distance corresponding to 100px scale length is rounded off to
    // near pretty number and the scale length for the same is found out.
    var meters = getRoundNum(maxMeters);
    var ratio = meters / maxMeters;
    scale.style.width = maxWidth * ratio + 'px';
    scale.innerHTML = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

}

function getDistance(latlng1, latlng2) {
    // Uses spherical law of cosines approximation.
    var R = 6371000;

    var rad = Math.PI / 180,
        lat1 = latlng1.lat * rad,
        lat2 = latlng2.lat * rad,
        a = Math.sin(lat1) * Math.sin(lat2) +
          Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad);

    var maxMeters = R * Math.acos(Math.min(a, 1));
    return maxMeters;

}

function getRoundNum(num) {
    var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
        d = num / pow10;

    d = d >= 10 ? 10 :
        d >= 5 ? 5 :
        d >= 3 ? 3 :
        d >= 2 ? 2 : 1;

    return pow10 * d;
}

},{"../../util/dom":105,"../../util/util":120,"./control":86}],90:[function(require,module,exports){
'use strict';

var DOM = require('../../util/dom'),
    LngLatBounds = require('../../geo/lng_lat_bounds'),
    util = require('../../util/util');

module.exports = BoxZoomHandler;

/**
 * The `BoxZoomHandler` allows the user to zoom the map to fit within a bounding box.
 * The bounding box is defined by clicking and holding `shift` while dragging the cursor.
 *
 * @class BoxZoomHandler
 * @param {Map} map The Mapbox GL JS map to add the handler to.
 */
function BoxZoomHandler(map) {
    this._map = map;
    this._el = map.getCanvasContainer();
    this._container = map.getContainer();

    util.bindHandlers(this);
}

BoxZoomHandler.prototype = {

    _enabled: false,
    _active: false,

    /**
     * Returns a Boolean indicating whether the "box zoom" interaction is enabled.
     *
     * @returns {boolean} `true` if the "box zoom" interaction is enabled.
     */
    isEnabled: function () {
        return this._enabled;
    },

    /**
     * Returns a Boolean indicating whether the "box zoom" interaction is active, i.e. currently being used.
     *
     * @returns {boolean} `true` if the "box zoom" interaction is active.
     */
    isActive: function () {
        return this._active;
    },

    /**
     * Enables the "box zoom" interaction.
     *
     * @example
     *   map.boxZoom.enable();
     */
    enable: function () {
        if (this.isEnabled()) return;
        this._el.addEventListener('mousedown', this._onMouseDown, false);
        this._enabled = true;
    },

    /**
     * Disables the "box zoom" interaction.
     *
     * @example
     *   map.boxZoom.disable();
     */
    disable: function () {
        if (!this.isEnabled()) return;
        this._el.removeEventListener('mousedown', this._onMouseDown);
        this._enabled = false;
    },

    _onMouseDown: function (e) {
        if (!(e.shiftKey && e.button === 0)) return;

        document.addEventListener('mousemove', this._onMouseMove, false);
        document.addEventListener('keydown', this._onKeyDown, false);
        document.addEventListener('mouseup', this._onMouseUp, false);

        DOM.disableDrag();
        this._startPos = DOM.mousePos(this._el, e);
        this._active = true;
    },

    _onMouseMove: function (e) {
        var p0 = this._startPos,
            p1 = DOM.mousePos(this._el, e);

        if (!this._box) {
            this._box = DOM.create('div', 'mapboxgl-boxzoom', this._container);
            this._container.classList.add('mapboxgl-crosshair');
            this._fireEvent('boxzoomstart', e);
        }

        var minX = Math.min(p0.x, p1.x),
            maxX = Math.max(p0.x, p1.x),
            minY = Math.min(p0.y, p1.y),
            maxY = Math.max(p0.y, p1.y);

        DOM.setTransform(this._box, 'translate(' + minX + 'px,' + minY + 'px)');

        this._box.style.width = (maxX - minX) + 'px';
        this._box.style.height = (maxY - minY) + 'px';
    },

    _onMouseUp: function (e) {
        if (e.button !== 0) return;

        var p0 = this._startPos,
            p1 = DOM.mousePos(this._el, e),
            bounds = new LngLatBounds(this._map.unproject(p0), this._map.unproject(p1));

        this._finish();

        if (p0.x === p1.x && p0.y === p1.y) {
            this._fireEvent('boxzoomcancel', e);
        } else {
            this._map
                .fitBounds(bounds, {linear: true})
                .fire('boxzoomend', { originalEvent: e, boxZoomBounds: bounds });
        }
    },

    _onKeyDown: function (e) {
        if (e.keyCode === 27) {
            this._finish();
            this._fireEvent('boxzoomcancel', e);
        }
    },

    _finish: function () {
        this._active = false;

        document.removeEventListener('mousemove', this._onMouseMove, false);
        document.removeEventListener('keydown', this._onKeyDown, false);
        document.removeEventListener('mouseup', this._onMouseUp, false);

        this._container.classList.remove('mapboxgl-crosshair');

        if (this._box) {
            this._box.parentNode.removeChild(this._box);
            this._box = null;
        }

        DOM.enableDrag();
    },

    _fireEvent: function (type, e) {
        return this._map.fire(type, { originalEvent: e });
    }
};

/**
 * @typedef {Object} MapBoxZoomEvent
 * @property {MouseEvent} originalEvent
 * @property {LngLatBounds} boxZoomBounds The bounding box of the "box zoom" interaction.
 *   This property is only provided for `boxzoomend` events.
 */

/**
 * Fired when a "box zoom" interaction starts. See [`BoxZoomHandler`](#BoxZoomHandler).
 *
 * @event boxzoomstart
 * @memberof Map
 * @instance
 * @property {MapBoxZoomEvent} data
 */

/**
 * Fired when a "box zoom" interaction ends.  See [`BoxZoomHandler`](#BoxZoomHandler).
 *
 * @event boxzoomend
 * @memberof Map
 * @instance
 * @type {Object}
 * @property {MapBoxZoomEvent} data
 */

/**
 * Fired when the user cancels a "box zoom" interaction, or when the bounding box does not meet the minimum size threshold.
 * See [`BoxZoomHandler`](#BoxZoomHandler).
 *
 * @event boxzoomcancel
 * @memberof Map
 * @instance
 * @property {MapBoxZoomEvent} data
 */

},{"../../geo/lng_lat_bounds":14,"../../util/dom":105,"../../util/util":120}],91:[function(require,module,exports){
'use strict';

module.exports = DoubleClickZoomHandler;

/**
 * The `DoubleClickZoomHandler` allows the user to zoom the map at a point by
 * double clicking.
 *
 * @class DoubleClickZoomHandler
 * @param {Map} map The Mapbox GL JS map to add the handler to.
 */
function DoubleClickZoomHandler(map) {
    this._map = map;
    this._onDblClick = this._onDblClick.bind(this);
}

DoubleClickZoomHandler.prototype = {

    _enabled: false,

    /**
     * Returns a Boolean indicating whether the "double click to zoom" interaction is enabled.
     *
     * @returns {boolean} `true` if the "double click to zoom" interaction is enabled.
     */
    isEnabled: function () {
        return this._enabled;
    },

    /**
     * Enables the "double click to zoom" interaction.
     *
     * @example
     * map.doubleClickZoom.enable();
     */
    enable: function () {
        if (this.isEnabled()) return;
        this._map.on('dblclick', this._onDblClick);
        this._enabled = true;
    },

    /**
     * Disables the "double click to zoom" interaction.
     *
     * @example
     * map.doubleClickZoom.disable();
     */
    disable: function () {
        if (!this.isEnabled()) return;
        this._map.off('dblclick', this._onDblClick);
        this._enabled = false;
    },

    _onDblClick: function (e) {
        this._map.zoomTo(
            this._map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1),
            {around: e.lngLat},
            e
        );
    }
};

},{}],92:[function(require,module,exports){
'use strict';

var DOM = require('../../util/dom'),
    util = require('../../util/util');

module.exports = DragPanHandler;

var inertiaLinearity = 0.3,
    inertiaEasing = util.bezier(0, 0, inertiaLinearity, 1),
    inertiaMaxSpeed = 1400, // px/s
    inertiaDeceleration = 2500; // px/s^2


/**
 * The `DragPanHandler` allows the user to pan the map by clicking and dragging
 * the cursor.
 *
 * @class DragPanHandler
 * @param {Map} map The Mapbox GL JS map to add the handler to.
 */
function DragPanHandler(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    util.bindHandlers(this);
}

DragPanHandler.prototype = {

    _enabled: false,
    _active: false,

    /**
     * Returns a Boolean indicating whether the "drag to pan" interaction is enabled.
     *
     * @returns {boolean} `true` if the "drag to pan" interaction is enabled.
     */
    isEnabled: function () {
        return this._enabled;
    },

    /**
     * Returns a Boolean indicating whether the "drag to pan" interaction is active, i.e. currently being used.
     *
     * @returns {boolean} `true` if the "drag to pan" interaction is active.
     */
    isActive: function () {
        return this._active;
    },

    /**
     * Enables the "drag to pan" interaction.
     *
     * @example
     * map.dragPan.enable();
     */
    enable: function () {
        if (this.isEnabled()) return;
        this._el.addEventListener('mousedown', this._onDown);
        this._el.addEventListener('touchstart', this._onDown);
        this._enabled = true;
    },

    /**
     * Disables the "drag to pan" interaction.
     *
     * @example
     * map.dragPan.disable();
     */
    disable: function () {
        if (!this.isEnabled()) return;
        this._el.removeEventListener('mousedown', this._onDown);
        this._el.removeEventListener('touchstart', this._onDown);
        this._enabled = false;
    },

    _onDown: function (e) {
        if (this._ignoreEvent(e)) return;
        if (this.isActive()) return;

        if (e.touches) {
            document.addEventListener('touchmove', this._onMove);
            document.addEventListener('touchend', this._onTouchEnd);
        } else {
            document.addEventListener('mousemove', this._onMove);
            document.addEventListener('mouseup', this._onMouseUp);
        }

        this._active = false;
        this._startPos = this._pos = DOM.mousePos(this._el, e);
        this._inertia = [[Date.now(), this._pos]];
    },

    _onMove: function (e) {
        if (this._ignoreEvent(e)) return;

        if (!this.isActive()) {
            this._active = true;
            this._fireEvent('dragstart', e);
            this._fireEvent('movestart', e);
        }

        var pos = DOM.mousePos(this._el, e),
            map = this._map;

        map.stop();
        this._drainInertiaBuffer();
        this._inertia.push([Date.now(), pos]);

        map.transform.setLocationAtPoint(map.transform.pointLocation(this._pos), pos);

        this._fireEvent('drag', e);
        this._fireEvent('move', e);

        this._pos = pos;

        e.preventDefault();
    },

    _onUp: function (e) {
        if (!this.isActive()) return;

        this._active = false;
        this._fireEvent('dragend', e);
        this._drainInertiaBuffer();

        var finish = function() {
            this._fireEvent('moveend', e);
        }.bind(this);

        var inertia = this._inertia;
        if (inertia.length < 2) {
            finish();
            return;
        }

        var last = inertia[inertia.length - 1],
            first = inertia[0],
            flingOffset = last[1].sub(first[1]),
            flingDuration = (last[0] - first[0]) / 1000;

        if (flingDuration === 0 || last[1].equals(first[1])) {
            finish();
            return;
        }

        // calculate px/s velocity & adjust for increased initial animation speed when easing out
        var velocity = flingOffset.mult(inertiaLinearity / flingDuration),
            speed = velocity.mag(); // px/s

        if (speed > inertiaMaxSpeed) {
            speed = inertiaMaxSpeed;
            velocity._unit()._mult(speed);
        }

        var duration = speed / (inertiaDeceleration * inertiaLinearity),
            offset = velocity.mult(-duration / 2);

        this._map.panBy(offset, {
            duration: duration * 1000,
            easing: inertiaEasing,
            noMoveStart: true
        }, { originalEvent: e });
    },

    _onMouseUp: function (e) {
        if (this._ignoreEvent(e)) return;
        this._onUp(e);
        document.removeEventListener('mousemove', this._onMove);
        document.removeEventListener('mouseup', this._onMouseUp);
    },

    _onTouchEnd: function (e) {
        if (this._ignoreEvent(e)) return;
        this._onUp(e);
        document.removeEventListener('touchmove', this._onMove);
        document.removeEventListener('touchend', this._onTouchEnd);
    },

    _fireEvent: function (type, e) {
        return this._map.fire(type, { originalEvent: e });
    },

    _ignoreEvent: function (e) {
        var map = this._map;

        if (map.boxZoom && map.boxZoom.isActive()) return true;
        if (map.dragRotate && map.dragRotate.isActive()) return true;
        if (e.touches) {
            return (e.touches.length > 1);
        } else {
            if (e.ctrlKey) return true;
            var buttons = 1,  // left button
                button = 0;   // left button
            return (e.type === 'mousemove' ? e.buttons & buttons === 0 : e.button !== button);
        }
    },

    _drainInertiaBuffer: function () {
        var inertia = this._inertia,
            now = Date.now(),
            cutoff = 160;   // msec

        while (inertia.length > 0 && now - inertia[0][0] > cutoff) inertia.shift();
    }
};


/**
 * Fired when a "drag to pan" interaction starts. See [`DragPanHandler`](#DragPanHandler).
 *
 * @event dragstart
 * @memberof Map
 * @instance
 * @property {MapMouseEvent | MapTouchEvent} data
 */

/**
 * Fired repeatedly during a "drag to pan" interaction. See [`DragPanHandler`](#DragPanHandler).
 *
 * @event drag
 * @memberof Map
 * @instance
 * @property {MapMouseEvent | MapTouchEvent} data
 */

/**
 * Fired when a "drag to pan" interaction ends. See [`DragPanHandler`](#DragPanHandler).
 *
 * @event dragend
 * @memberof Map
 * @instance
 * @property {MapMouseEvent | MapTouchEvent} data
 */

},{"../../util/dom":105,"../../util/util":120}],93:[function(require,module,exports){
'use strict';

var DOM = require('../../util/dom'),
    Point = require('point-geometry'),
    util = require('../../util/util');

module.exports = DragRotateHandler;

var inertiaLinearity = 0.25,
    inertiaEasing = util.bezier(0, 0, inertiaLinearity, 1),
    inertiaMaxSpeed = 180, // deg/s
    inertiaDeceleration = 720; // deg/s^2


/**
 * The `DragRotateHandler` allows the user to rotate the map by clicking and
 * dragging the cursor while holding the right mouse button or `ctrl` key.
 *
 * @class DragRotateHandler
 * @param {Map} map The Mapbox GL JS map to add the handler to.
 * @param {Object} [options]
 * @param {number} [options.bearingSnap] The threshold, measured in degrees, that determines when the map's
 *   bearing (rotation) will snap to north.
 */
function DragRotateHandler(map, options) {
    this._map = map;
    this._el = map.getCanvasContainer();
    this._bearingSnap = options.bearingSnap;

    util.bindHandlers(this);
}

DragRotateHandler.prototype = {

    _enabled: false,
    _active: false,

    /**
     * Returns a Boolean indicating whether the "drag to rotate" interaction is enabled.
     *
     * @returns {boolean} `true` if the "drag to rotate" interaction is enabled.
     */
    isEnabled: function () {
        return this._enabled;
    },

    /**
     * Returns a Boolean indicating whether the "drag to rotate" interaction is active, i.e. currently being used.
     *
     * @returns {boolean} `true` if the "drag to rotate" interaction is active.
     */
    isActive: function () {
        return this._active;
    },

    /**
     * Enables the "drag to rotate" interaction.
     *
     * @example
     * map.dragRotate.enable();
     */
    enable: function () {
        if (this.isEnabled()) return;
        this._el.addEventListener('mousedown', this._onDown);
        this._enabled = true;
    },

    /**
     * Disables the "drag to rotate" interaction.
     *
     * @example
     * map.dragRotate.disable();
     */
    disable: function () {
        if (!this.isEnabled()) return;
        this._el.removeEventListener('mousedown', this._onDown);
        this._enabled = false;
    },

    _onDown: function (e) {
        if (this._ignoreEvent(e)) return;
        if (this.isActive()) return;

        document.addEventListener('mousemove', this._onMove);
        document.addEventListener('mouseup', this._onUp);

        this._active = false;
        this._inertia = [[Date.now(), this._map.getBearing()]];
        this._startPos = this._pos = DOM.mousePos(this._el, e);
        this._center = this._map.transform.centerPoint;  // Center of rotation

        // If the first click was too close to the center, move the center of rotation by 200 pixels
        // in the direction of the click.
        var startToCenter = this._startPos.sub(this._center),
            startToCenterDist = startToCenter.mag();

        if (startToCenterDist < 200) {
            this._center = this._startPos.add(new Point(-200, 0)._rotate(startToCenter.angle()));
        }

        e.preventDefault();
    },

    _onMove: function (e) {
        if (this._ignoreEvent(e)) return;

        if (!this.isActive()) {
            this._active = true;
            this._fireEvent('rotatestart', e);
            this._fireEvent('movestart', e);
        }

        var map = this._map;
        map.stop();

        var p1 = this._pos,
            p2 = DOM.mousePos(this._el, e),
            center = this._center,
            bearingDiff = p1.sub(center).angleWith(p2.sub(center)) / Math.PI * 180,
            bearing = map.getBearing() - bearingDiff,
            inertia = this._inertia,
            last = inertia[inertia.length - 1];

        this._drainInertiaBuffer();
        inertia.push([Date.now(), map._normalizeBearing(bearing, last[1])]);

        map.transform.bearing = bearing;

        this._fireEvent('rotate', e);
        this._fireEvent('move', e);

        this._pos = p2;
    },

    _onUp: function (e) {
        if (this._ignoreEvent(e)) return;
        document.removeEventListener('mousemove', this._onMove);
        document.removeEventListener('mouseup', this._onUp);

        if (!this.isActive()) return;

        this._active = false;
        this._fireEvent('rotateend', e);
        this._drainInertiaBuffer();

        var map = this._map,
            mapBearing = map.getBearing(),
            inertia = this._inertia;

        var finish = function() {
            if (Math.abs(mapBearing) < this._bearingSnap) {
                map.resetNorth({noMoveStart: true}, { originalEvent: e });
            } else {
                this._fireEvent('moveend', e);
            }
        }.bind(this);

        if (inertia.length < 2) {
            finish();
            return;
        }

        var first = inertia[0],
            last = inertia[inertia.length - 1],
            previous = inertia[inertia.length - 2],
            bearing = map._normalizeBearing(mapBearing, previous[1]),
            flingDiff = last[1] - first[1],
            sign = flingDiff < 0 ? -1 : 1,
            flingDuration = (last[0] - first[0]) / 1000;

        if (flingDiff === 0 || flingDuration === 0) {
            finish();
            return;
        }

        var speed = Math.abs(flingDiff * (inertiaLinearity / flingDuration));  // deg/s
        if (speed > inertiaMaxSpeed) {
            speed = inertiaMaxSpeed;
        }

        var duration = speed / (inertiaDeceleration * inertiaLinearity),
            offset = sign * speed * (duration / 2);

        bearing += offset;

        if (Math.abs(map._normalizeBearing(bearing, 0)) < this._bearingSnap) {
            bearing = map._normalizeBearing(0, bearing);
        }

        map.rotateTo(bearing, {
            duration: duration * 1000,
            easing: inertiaEasing,
            noMoveStart: true
        }, { originalEvent: e });
    },

    _fireEvent: function (type, e) {
        return this._map.fire(type, { originalEvent: e });
    },

    _ignoreEvent: function (e) {
        var map = this._map;

        if (map.boxZoom && map.boxZoom.isActive()) return true;
        if (map.dragPan && map.dragPan.isActive()) return true;
        if (e.touches) {
            return (e.touches.length > 1);
        } else {
            var buttons = (e.ctrlKey ? 1 : 2),  // ? ctrl+left button : right button
                button = (e.ctrlKey ? 0 : 2);   // ? ctrl+left button : right button
            return (e.type === 'mousemove' ? e.buttons & buttons === 0 : e.button !== button);
        }
    },

    _drainInertiaBuffer: function () {
        var inertia = this._inertia,
            now = Date.now(),
            cutoff = 160;   //msec

        while (inertia.length > 0 && now - inertia[0][0] > cutoff)
            inertia.shift();
    }

};


/**
 * Fired when a "drag to rotate" interaction starts. See [`DragRotateHandler`](#DragRotateHandler).
 *
 * @event rotatestart
 * @memberof Map
 * @instance
 * @property {MapMouseEvent | MapTouchEvent} data
 */

/**
 * Fired repeatedly during a "drag to rotate" interaction. See [`DragRotateHandler`](#DragRotateHandler).
 *
 * @event rotate
 * @memberof Map
 * @instance
 * @property {MapMouseEvent | MapTouchEvent} data
 */

/**
 * Fired when a "drag to rotate" interaction ends. See [`DragRotateHandler`](#DragRotateHandler).
 *
 * @event rotateend
 * @memberof Map
 * @instance
 * @property {MapMouseEvent | MapTouchEvent} data
 */

},{"../../util/dom":105,"../../util/util":120,"point-geometry":187}],94:[function(require,module,exports){
'use strict';

module.exports = KeyboardHandler;


var panDelta = 80,
    rotateDelta = 2,
    pitchDelta = 5;

/**
 * The `KeyboardHandler` allows the user to zoom, rotate, and pan the map using
 * the following keyboard shortcuts:
 *
 * - `=` / `+`: Increase the zoom level by 1.
 * - `Shift-=` / `Shift-+`: Increase the zoom level by 2.
 * - `-`: Decrease the zoom level by 1.
 * - `Shift--`: Decrease the zoom level by 2.
 * - Arrow keys: Pan by 80 pixels.
 * - `Shift+⇢`: Increase the rotation by 2 degrees.
 * - `Shift+⇠`: Decrease the rotation by 2 degrees.
 * - `Shift+⇡`: Increase the pitch by 5 degrees.
 * - `Shift+⇣`: Decrease the pitch by 5 degrees.
 *
 * @class KeyboardHandler
 * @param {Map} map The Mapbox GL JS map to add the handler to.
 */
function KeyboardHandler(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    this._onKeyDown = this._onKeyDown.bind(this);
}

KeyboardHandler.prototype = {

    _enabled: false,

    /**
     * Returns a Boolean indicating whether keyboard interaction is enabled.
     *
     * @returns {boolean} `true` if keyboard interaction is enabled.
     */
    isEnabled: function () {
        return this._enabled;
    },

    /**
     * Enables keyboard interaction.
     *
     * @example
     * map.keyboard.enable();
     */
    enable: function () {
        if (this.isEnabled()) return;
        this._el.addEventListener('keydown', this._onKeyDown, false);
        this._enabled = true;
    },

    /**
     * Disables keyboard interaction.
     *
     * @example
     * map.keyboard.disable();
     */
    disable: function () {
        if (!this.isEnabled()) return;
        this._el.removeEventListener('keydown', this._onKeyDown);
        this._enabled = false;
    },

    _onKeyDown: function (e) {
        if (e.altKey || e.ctrlKey || e.metaKey) return;

        var map = this._map,
            eventData = { originalEvent: e };

        if (map.isEasing()) return;

        switch (e.keyCode) {
        case 61:
        case 107:
        case 171:
        case 187:
            map.zoomTo(Math.round(map.getZoom()) + (e.shiftKey ? 2 : 1), eventData);
            break;

        case 189:
        case 109:
        case 173:
            map.zoomTo(Math.round(map.getZoom()) - (e.shiftKey ? 2 : 1), eventData);
            break;

        case 37:
            if (e.shiftKey) {
                map.easeTo({ bearing: map.getBearing() - rotateDelta }, eventData);
            } else {
                e.preventDefault();
                map.panBy([-panDelta, 0], eventData);
            }
            break;

        case 39:
            if (e.shiftKey) {
                map.easeTo({ bearing: map.getBearing() + rotateDelta }, eventData);
            } else {
                e.preventDefault();
                map.panBy([panDelta, 0], eventData);
            }
            break;

        case 38:
            if (e.shiftKey) {
                map.easeTo({ pitch: map.getPitch() + pitchDelta }, eventData);
            } else {
                e.preventDefault();
                map.panBy([0, -panDelta], eventData);
            }
            break;

        case 40:
            if (e.shiftKey) {
                map.easeTo({ pitch: Math.max(map.getPitch() - pitchDelta, 0) }, eventData);
            } else {
                e.preventDefault();
                map.panBy([0, panDelta], eventData);
            }
            break;
        }
    }
};

},{}],95:[function(require,module,exports){
'use strict';

var DOM = require('../../util/dom'),
    browser = require('../../util/browser'),
    util = require('../../util/util');

module.exports = ScrollZoomHandler;


var ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '',
    firefox = ua.indexOf('firefox') !== -1,
    safari = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') === -1;


/**
 * The `ScrollZoomHandler` allows the user to zoom the map by scrolling.
 *
 * @class ScrollZoomHandler
 * @param {Map} map The Mapbox GL JS map to add the handler to.
 */
function ScrollZoomHandler(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    util.bindHandlers(this);
}

ScrollZoomHandler.prototype = {

    _enabled: false,

    /**
     * Returns a Boolean indicating whether the "scroll to zoom" interaction is enabled.
     *
     * @returns {boolean} `true` if the "scroll to zoom" interaction is enabled.
     */
    isEnabled: function () {
        return this._enabled;
    },

    /**
     * Enables the "scroll to zoom" interaction.
     *
     * @example
     *   map.scrollZoom.enable();
     */
    enable: function () {
        if (this.isEnabled()) return;
        this._el.addEventListener('wheel', this._onWheel, false);
        this._el.addEventListener('mousewheel', this._onWheel, false);
        this._enabled = true;
    },

    /**
     * Disables the "scroll to zoom" interaction.
     *
     * @example
     *   map.scrollZoom.disable();
     */
    disable: function () {
        if (!this.isEnabled()) return;
        this._el.removeEventListener('wheel', this._onWheel);
        this._el.removeEventListener('mousewheel', this._onWheel);
        this._enabled = false;
    },

    _onWheel: function (e) {
        var value;

        if (e.type === 'wheel') {
            value = e.deltaY;
            // Firefox doubles the values on retina screens...
            if (firefox && e.deltaMode === window.WheelEvent.DOM_DELTA_PIXEL) value /= browser.devicePixelRatio;
            if (e.deltaMode === window.WheelEvent.DOM_DELTA_LINE) value *= 40;

        } else if (e.type === 'mousewheel') {
            value = -e.wheelDeltaY;
            if (safari) value = value / 3;
        }

        var now = browser.now(),
            timeDelta = now - (this._time || 0);

        this._pos = DOM.mousePos(this._el, e);
        this._time = now;

        if (value !== 0 && (value % 4.000244140625) === 0) {
            // This one is definitely a mouse wheel event.
            this._type = 'wheel';
            // Normalize this value to match trackpad.
            value = Math.floor(value / 4);

        } else if (value !== 0 && Math.abs(value) < 4) {
            // This one is definitely a trackpad event because it is so small.
            this._type = 'trackpad';

        } else if (timeDelta > 400) {
            // This is likely a new scroll action.
            this._type = null;
            this._lastValue = value;

            // Start a timeout in case this was a singular event, and dely it by up to 40ms.
            this._timeout = setTimeout(this._onTimeout, 40);

        } else if (!this._type) {
            // This is a repeating event, but we don't know the type of event just yet.
            // If the delta per time is small, we assume it's a fast trackpad; otherwise we switch into wheel mode.
            this._type = (Math.abs(timeDelta * value) < 200) ? 'trackpad' : 'wheel';

            // Make sure our delayed event isn't fired again, because we accumulate
            // the previous event (which was less than 40ms ago) into this event.
            if (this._timeout) {
                clearTimeout(this._timeout);
                this._timeout = null;
                value += this._lastValue;
            }
        }

        // Slow down zoom if shift key is held for more precise zooming
        if (e.shiftKey && value) value = value / 4;

        // Only fire the callback if we actually know what type of scrolling device the user uses.
        if (this._type) this._zoom(-value, e);

        e.preventDefault();
    },

    _onTimeout: function () {
        this._type = 'wheel';
        this._zoom(-this._lastValue);
    },

    _zoom: function (delta, e) {
        if (delta === 0) return;
        var map = this._map;

        // Scale by sigmoid of scroll wheel delta.
        var scale = 2 / (1 + Math.exp(-Math.abs(delta / 100)));
        if (delta < 0 && scale !== 0) scale = 1 / scale;

        var fromScale = map.ease ? map.ease.to : map.transform.scale,
            targetZoom = map.transform.scaleZoom(fromScale * scale);

        map.zoomTo(targetZoom, {
            duration: 0,
            around: map.unproject(this._pos),
            delayEndEvents: 200
        }, { originalEvent: e });
    }
};


/**
 * Fired just before the map begins a transition from one zoom level to another,
 * as the result of either user interaction or methods such as [Map#flyTo](#Map#flyTo).
 *
 * @event zoomstart
 * @memberof Map
 * @instance
 * @property {MapMouseEvent | MapTouchEvent} data
 */

/**
 * Fired repeatedly during an animated transition from one zoom level to another,
 * as the result of either user interaction or methods such as [Map#flyTo](#Map#flyTo).
 *
 * @event zoom
 * @memberof Map
 * @instance
 * @property {MapMouseEvent | MapTouchEvent} data
 */

/**
 * Fired just after the map completes a transition from one zoom level to another,
 * as the result of either user interaction or methods such as [Map#flyTo](#Map#flyTo).
 *
 * @event zoomend
 * @memberof Map
 * @instance
 * @property {MapMouseEvent | MapTouchEvent} data
 */

},{"../../util/browser":103,"../../util/dom":105,"../../util/util":120}],96:[function(require,module,exports){
'use strict';

var DOM = require('../../util/dom'),
    util = require('../../util/util');

module.exports = TouchZoomRotateHandler;

var inertiaLinearity = 0.15,
    inertiaEasing = util.bezier(0, 0, inertiaLinearity, 1),
    inertiaDeceleration = 12, // scale / s^2
    inertiaMaxSpeed = 2.5, // scale / s
    significantScaleThreshold = 0.15,
    significantRotateThreshold = 4;


/**
 * The `TouchZoomRotateHandler` allows the user to zoom and rotate the map by
 * pinching on a touchscreen.
 *
 * @class TouchZoomRotateHandler
 * @param {Map} map The Mapbox GL JS map to add the handler to.
 */
function TouchZoomRotateHandler(map) {
    this._map = map;
    this._el = map.getCanvasContainer();

    util.bindHandlers(this);
}

TouchZoomRotateHandler.prototype = {

    _enabled: false,

    /**
     * Returns a Boolean indicating whether the "pinch to rotate and zoom" interaction is enabled.
     *
     * @returns {boolean} `true` if the "pinch to rotate and zoom" interaction is enabled.
     */
    isEnabled: function () {
        return this._enabled;
    },

    /**
     * Enables the "pinch to rotate and zoom" interaction.
     *
     * @example
     *   map.touchZoomRotate.enable();
     */
    enable: function () {
        if (this.isEnabled()) return;
        this._el.addEventListener('touchstart', this._onStart, false);
        this._enabled = true;
    },

    /**
     * Disables the "pinch to rotate and zoom" interaction.
     *
     * @example
     *   map.touchZoomRotate.disable();
     */
    disable: function () {
        if (!this.isEnabled()) return;
        this._el.removeEventListener('touchstart', this._onStart);
        this._enabled = false;
    },

    /**
     * Disables the "pinch to rotate" interaction, leaving the "pinch to zoom"
     * interaction enabled.
     *
     * @example
     *   map.touchZoomRotate.disableRotation();
     */
    disableRotation: function() {
        this._rotationDisabled = true;
    },

    /**
     * Enables the "pinch to rotate" interaction.
     *
     * @example
     *   map.touchZoomRotate.enable();
     *   map.touchZoomRotate.enableRotation();
     */
    enableRotation: function() {
        this._rotationDisabled = false;
    },

    _onStart: function (e) {
        if (e.touches.length !== 2) return;

        var p0 = DOM.mousePos(this._el, e.touches[0]),
            p1 = DOM.mousePos(this._el, e.touches[1]);

        this._startVec = p0.sub(p1);
        this._startScale = this._map.transform.scale;
        this._startBearing = this._map.transform.bearing;
        this._gestureIntent = undefined;
        this._inertia = [];

        document.addEventListener('touchmove', this._onMove, false);
        document.addEventListener('touchend', this._onEnd, false);
    },

    _onMove: function (e) {
        if (e.touches.length !== 2) return;

        var p0 = DOM.mousePos(this._el, e.touches[0]),
            p1 = DOM.mousePos(this._el, e.touches[1]),
            p = p0.add(p1).div(2),
            vec = p0.sub(p1),
            scale = vec.mag() / this._startVec.mag(),
            bearing = this._rotationDisabled ? 0 : vec.angleWith(this._startVec) * 180 / Math.PI,
            map = this._map;

        // Determine 'intent' by whichever threshold is surpassed first,
        // then keep that state for the duration of this gesture.
        if (!this._gestureIntent) {
            var scalingSignificantly = (Math.abs(1 - scale) > significantScaleThreshold),
                rotatingSignificantly = (Math.abs(bearing) > significantRotateThreshold);

            if (rotatingSignificantly) {
                this._gestureIntent = 'rotate';
            } else if (scalingSignificantly) {
                this._gestureIntent = 'zoom';
            }

            if (this._gestureIntent) {
                this._startVec = vec;
                this._startScale = map.transform.scale;
                this._startBearing = map.transform.bearing;
            }

        } else {
            var param = { duration: 0, around: map.unproject(p) };

            if (this._gestureIntent === 'rotate') {
                param.bearing = this._startBearing + bearing;
            }
            if (this._gestureIntent === 'zoom' || this._gestureIntent === 'rotate') {
                param.zoom = map.transform.scaleZoom(this._startScale * scale);
            }

            map.stop();
            this._drainInertiaBuffer();
            this._inertia.push([Date.now(), scale, p]);

            map.easeTo(param, { originalEvent: e });
        }

        e.preventDefault();
    },

    _onEnd: function (e) {
        document.removeEventListener('touchmove', this._onMove);
        document.removeEventListener('touchend', this._onEnd);
        this._drainInertiaBuffer();

        var inertia = this._inertia,
            map = this._map;

        if (inertia.length < 2) {
            map.snapToNorth({}, { originalEvent: e });
            return;
        }

        var last = inertia[inertia.length - 1],
            first = inertia[0],
            lastScale = map.transform.scaleZoom(this._startScale * last[1]),
            firstScale = map.transform.scaleZoom(this._startScale * first[1]),
            scaleOffset = lastScale - firstScale,
            scaleDuration = (last[0] - first[0]) / 1000,
            p = last[2];

        if (scaleDuration === 0 || lastScale === firstScale) {
            map.snapToNorth({}, { originalEvent: e });
            return;
        }

        // calculate scale/s speed and adjust for increased initial animation speed when easing
        var speed = scaleOffset * inertiaLinearity / scaleDuration; // scale/s

        if (Math.abs(speed) > inertiaMaxSpeed) {
            if (speed > 0) {
                speed = inertiaMaxSpeed;
            } else {
                speed = -inertiaMaxSpeed;
            }
        }

        var duration = Math.abs(speed / (inertiaDeceleration * inertiaLinearity)) * 1000,
            targetScale = lastScale + speed * duration / 2000;

        if (targetScale < 0) {
            targetScale = 0;
        }

        map.easeTo({
            zoom: targetScale,
            duration: duration,
            easing: inertiaEasing,
            around: map.unproject(p)
        }, { originalEvent: e });
    },

    _drainInertiaBuffer: function() {
        var inertia = this._inertia,
            now = Date.now(),
            cutoff = 160; // msec

        while (inertia.length > 2 && now - inertia[0][0] > cutoff) inertia.shift();
    }
};

},{"../../util/dom":105,"../../util/util":120}],97:[function(require,module,exports){
'use strict';

/*
 * Adds the map's position to its page's location hash.
 * Passed as an option to the map object.
 *
 * @class mapboxgl.Hash
 * @returns {Hash} `this`
 */
module.exports = Hash;

var util = require('../util/util');

function Hash() {
    util.bindAll([
        '_onHashChange',
        '_updateHash'
    ], this);
}

Hash.prototype = {
    /*
     * Map element to listen for coordinate changes
     *
     * @param {Object} map
     * @returns {Hash} `this`
     */
    addTo: function(map) {
        this._map = map;
        window.addEventListener('hashchange', this._onHashChange, false);
        this._map.on('moveend', this._updateHash);
        return this;
    },

    /*
     * Removes hash
     *
     * @returns {Popup} `this`
     */
    remove: function() {
        window.removeEventListener('hashchange', this._onHashChange, false);
        this._map.off('moveend', this._updateHash);
        delete this._map;
        return this;
    },

    _onHashChange: function() {
        var loc = location.hash.replace('#', '').split('/');
        if (loc.length >= 3) {
            this._map.jumpTo({
                center: [+loc[2], +loc[1]],
                zoom: +loc[0],
                bearing: +(loc[3] || 0)
            });
            return true;
        }
        return false;
    },

    _updateHash: function() {
        var center = this._map.getCenter(),
            zoom = this._map.getZoom(),
            bearing = this._map.getBearing(),
            precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2)),

            hash = '#' + (Math.round(zoom * 100) / 100) +
                '/' + center.lat.toFixed(precision) +
                '/' + center.lng.toFixed(precision) +
                (bearing ? '/' + (Math.round(bearing * 10) / 10) : '');

        window.history.replaceState('', '', hash);
    }
};

},{"../util/util":120}],98:[function(require,module,exports){
'use strict';

var Canvas = require('../util/canvas');
var util = require('../util/util');
var browser = require('../util/browser');
var window = require('../util/browser').window;
var Evented = require('../util/evented');
var DOM = require('../util/dom');

var Style = require('../style/style');
var AnimationLoop = require('../style/animation_loop');
var Painter = require('../render/painter');

var Transform = require('../geo/transform');
var Hash = require('./hash');

var bindHandlers = require('./bind_handlers');

var Camera = require('./camera');
var LngLat = require('../geo/lng_lat');
var LngLatBounds = require('../geo/lng_lat_bounds');
var Point = require('point-geometry');
var Attribution = require('./control/attribution');
var parseColor = require('../style/parse_color');


var defaultMinZoom = 0;
var defaultMaxZoom = 20;
var defaultOptions = {
    center: [0, 0],
    zoom: 0,
    bearing: 0,
    pitch: 0,

    light: {
        lightAnchor: 'viewport',
        lightDirection: [-0.5, -0.3, 1.0],
        lightColor: 'rgba(1,1,1,0.75)'
    },

    minZoom: defaultMinZoom,
    maxZoom: defaultMaxZoom,

    interactive: true,

    scrollZoom: true,
    boxZoom: true,
    dragRotate: true,
    dragPan: true,
    keyboard: true,
    doubleClickZoom: true,
    touchZoomRotate: true,

    bearingSnap: 7,

    hash: false,

    attributionControl: true,

    failIfMajorPerformanceCaveat: false,
    preserveDrawingBuffer: false,

    trackResize: true,
    workerCount: Math.max(browser.hardwareConcurrency - 1, 1)
};

/**
 * The `Map` object represents the map on your page. It exposes methods
 * and properties that enable you to programmatically change the map,
 * and fires events as users interact with it.
 *
 * You create a `Map` by specifying a `container` and other options.
 * Then Mapbox GL JS initializes the map on the page and returns your `Map`
 * object.
 *
 * The `Map` class mixes in [`Evented`](#Evented) methods.
 *
 * @class Map
 * @param {Object} options
 * @param {HTMLElement|string} options.container The HTML element in which Mapbox GL JS will render the map, or the element's string `id`.
 * @param {number} [options.minZoom=0] The minimum zoom level of the map (1-20).
 * @param {number} [options.maxZoom=20] The maximum zoom level of the map (1-20).
 * @param {Object|string} [options.style] The map's Mapbox style. This must be an a JSON object conforming to
 * the schema described in the [Mapbox Style Specification](https://mapbox.com/mapbox-gl-style-spec/), or a URL to
 * such JSON.
 *
 * To load a style from the Mapbox API, you can use a URL of the form `mapbox://styles/:owner/:style`,
 * where `:owner` is your Mapbox account name and `:style` is the style ID. Or you can use one of the following
 * [the predefined Mapbox styles](https://www.mapbox.com/maps/):
 *
 *  * `mapbox://styles/mapbox/streets-v9`
 *  * `mapbox://styles/mapbox/outdoors-v9`
 *  * `mapbox://styles/mapbox/light-v9`
 *  * `mapbox://styles/mapbox/dark-v9`
 *  * `mapbox://styles/mapbox/satellite-v9`
 *  * `mapbox://styles/mapbox/satellite-streets-v9`
 *
 * @param {boolean} [options.hash=false] If `true`, the map's position (zoom, center latitude, center longitude, and bearing) will be synced with the hash fragment of the page's URL.
 *   For example, `http://path/to/my/page.html#2.59/39.26/53.07/-24.1`.
 * @param {boolean} [options.interactive=true] If `false`, no mouse, touch, or keyboard listeners will be attached to the map, so it will not respond to interaction.
 * @param {number} [options.bearingSnap=7] The threshold, measured in degrees, that determines when the map's
 *   bearing (rotation) will snap to north. For example, with a `bearingSnap` of 7, if the user rotates
 *   the map within 7 degrees of north, the map will automatically snap to exact north.
 * @param {Array<string>} [options.classes] Mapbox style class names with which to initialize the map.
 *   Keep in mind that these classes are used for controlling a style layer's paint properties, so are *not* reflected
 *   in an HTML element's `class` attribute. To learn more about Mapbox style classes, read about
 *   [Layers](https://www.mapbox.com/mapbox-gl-style-spec/#layers) in the style specification.
 * @param {boolean} [options.attributionControl=true] If `true`, an [Attribution](#Attribution) control will be added to the map.
 * @param {boolean} [options.failIfMajorPerformanceCaveat=false] If `true`, map creation will fail if the performance of Mapbox
 *   GL JS would be dramatically worse than expected (i.e. a software renderer would be used).
 * @param {boolean} [options.preserveDrawingBuffer=false] If `true`, the map's canvas can be exported to a PNG using `map.getCanvas().toDataURL()`. This is `false` by default as a performance optimization.
 * @param {LngLatBoundsLike} [options.maxBounds] If set, the map will be constrained to the given bounds.
 * @param {boolean} [options.scrollZoom=true] If `true`, the "scroll to zoom" interaction is enabled (see [`ScrollZoomHandler`](#ScrollZoomHandler)).
 * @param {boolean} [options.boxZoom=true] If `true`, the "box zoom" interaction is enabled (see [`BoxZoomHandler`](#BoxZoomHandler)).
 * @param {boolean} [options.dragRotate=true] If `true`, the "drag to rotate" interaction is enabled (see [`DragRotateHandler`](#DragRotateHandler)).
 * @param {boolean} [options.dragPan=true] If `true`, the "drag to pan" interaction is enabled (see [`DragPanHandler`](#DragPanHandler)).
 * @param {boolean} [options.keyboard=true] If `true`, keyboard shortcuts are enabled (see [`KeyboardHandler`](#KeyboardHandler)).
 * @param {boolean} [options.doubleClickZoom=true] If `true`, the "double click to zoom" interaction is enabled (see [`DoubleClickZoomHandler`](#DoubleClickZoomHandler)).
 * @param {boolean} [options.touchZoomRotate=true] If `true`, the "pinch to rotate and zoom" interaction is enabled (see [`TouchZoomRotateHandler`](#TouchZoomRotateHandler)).
 * @param {boolean} [options.trackResize=true]  If `true`, the map will automatically resize when the browser window resizes.
 * @param {LngLatLike} [options.center=[0, 0]] The inital geographical centerpoint of the map. If `center` is not specified in the constructor options, Mapbox GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `[0, 0]`.
 * @param {number} [options.zoom=0] The initial zoom level of the map. If `zoom` is not specified in the constructor options, Mapbox GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `0`.
 * @param {number} [options.bearing=0] The initial bearing (rotation) of the map, measured in degrees counter-clockwise from north. If `bearing` is not specified in the constructor options, Mapbox GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `0`.
 * @param {number} [options.pitch=0] The initial pitch (tilt) of the map, measured in degrees away from the plane of the screen (0-60). If `pitch` is not specified in the constructor options, Mapbox GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `0`.
 * @param {number} [options.workerCount=navigator.hardwareConcurrency - 1] The number of WebWorkers that Mapbox GL JS should use to process vector tile data.
 * @example
 * var map = new mapboxgl.Map({
 *   container: 'map',
 *   center: [-122.420679, 37.772537],
 *   zoom: 13,
 *   style: style_object,
 *   hash: true
 * });
 */
var Map = module.exports = function(options) {

    options = util.extend({}, defaultOptions, options);

    if (options.workerCount < 1) {
        throw new Error('workerCount must an integer greater than or equal to 1.');
    }

    this._interactive = options.interactive;
    this._failIfMajorPerformanceCaveat = options.failIfMajorPerformanceCaveat;
    this._preserveDrawingBuffer = options.preserveDrawingBuffer;
    this._trackResize = options.trackResize;
    this._workerCount = options.workerCount;
    this._bearingSnap = options.bearingSnap;

    if (typeof options.container === 'string') {
        this._container = document.getElementById(options.container);
    } else {s
        this._container = options.container;
    }

    this.animationLoop = new AnimationLoop();
    this.transform = new Transform(options.minZoom, options.maxZoom);

    if (options.maxBounds) {
        this.setMaxBounds(options.maxBounds);
    }

    util.bindAll([
        '_forwardStyleEvent',
        '_forwardSourceEvent',
        '_forwardLayerEvent',
        '_forwardTileEvent',
        '_onStyleLoad',
        '_onStyleChange',
        '_onSourceAdd',
        '_onSourceRemove',
        '_onSourceUpdate',
        '_onWindowOnline',
        '_onWindowResize',
        '_update',
        '_render'
    ], this);

    this._setupContainer();
    this._setupPainter();

    this.on('move', this._update.bind(this, false));
    this.on('zoom', this._update.bind(this, true));
    this.on('moveend', function() {
        this.animationLoop.set(300); // text fading
        this._rerender();
    }.bind(this));

    if (typeof window !== 'undefined') {
        window.addEventListener('online', this._onWindowOnline, false);
        window.addEventListener('resize', this._onWindowResize, false);
    }

    bindHandlers(this, options);

    this._hash = options.hash && (new Hash()).addTo(this);
    // don't set position from options if set through hash
    if (!this._hash || !this._hash._onHashChange()) {
        this.jumpTo({
            center: options.center,
            zoom: options.zoom,
            bearing: options.bearing,
            pitch: options.pitch
        });
    }

    this.stacks = {};
    this._classes = [];

    this.resize();

    if (options.classes) this.setClasses(options.classes);
    if (options.style) this.setStyle(options.style);

    var _map = this;
    this.style.on('load', function() {
        _map._setLightOptions(util.extend(options.light, _map.style._light));
    });

    if (options.attributionControl) this.addControl(new Attribution(options.attributionControl));

    var fireError = this.fire.bind(this, 'error');
    this.on('style.error', fireError);
    this.on('source.error', fireError);
    this.on('tile.error', fireError);
    this.on('layer.error', fireError);
};

util.extend(Map.prototype, Evented);
util.extend(Map.prototype, Camera.prototype);
util.extend(Map.prototype, /** @lends Map.prototype */{

    /**
     * Adds a [`Control`](#Control) to the map, calling `control.addTo(this)`.
     *
     * @param {Control} control The [`Control`](#Control) to add.
     * @returns {Map} `this`
     */
    addControl: function(control) {
        control.addTo(this);
        return this;
    },

    /**
     * Adds a Mapbox style class to the map.
     *
     * Keep in mind that these classes are used for controlling a style layer's paint properties, so are *not* reflected
     * in an HTML element's `class` attribute. To learn more about Mapbox style classes, read about
     * [Layers](https://www.mapbox.com/mapbox-gl-style-spec/#layers) in the style specification.
     *
     * @param {string} klass The style class to add.
     * @param {StyleOptions} [options]
     * @fires change
     * @returns {Map} `this`
     */
    addClass: function(klass, options) {
        if (this._classes.indexOf(klass) >= 0 || klass === '') return this;
        this._classes.push(klass);
        this._classOptions = options;

        if (this.style) this.style.updateClasses();
        return this._update(true);
    },

    /**
     * Removes a Mapbox style class from the map.
     *
     * @param {string} klass The style class to remove.
     * @param {StyleOptions} [options]
     * @fires change
     * @returns {Map} `this`
     */
    removeClass: function(klass, options) {
        var i = this._classes.indexOf(klass);
        if (i < 0 || klass === '') return this;
        this._classes.splice(i, 1);
        this._classOptions = options;

        if (this.style) this.style.updateClasses();
        return this._update(true);
    },

    /**
     * Replaces the map's existing Mapbox style classes with a new array of classes.
     *
     * @param {Array<string>} klasses The style classes to set.
     * @param {StyleOptions} [options]
     * @fires change
     * @returns {Map} `this`
     */
    setClasses: function(klasses, options) {
        var uniqueClasses = {};
        for (var i = 0; i < klasses.length; i++) {
            if (klasses[i] !== '') uniqueClasses[klasses[i]] = true;
        }
        this._classes = Object.keys(uniqueClasses);
        this._classOptions = options;

        if (this.style) this.style.updateClasses();
        return this._update(true);
    },

    /**
     * Returns a Boolean indicating whether the map has the
     * specified Mapbox style class.
     *
     * @param {string} klass The style class to test.
     * @returns {boolean} `true` if the map has the specified style class.
     */
    hasClass: function(klass) {
        return this._classes.indexOf(klass) >= 0;
    },

    /**
     * Returns the map's Mapbox style classes.
     *
     * @returns {Array<string>} The map's style classes.
     */
    getClasses: function() {
        return this._classes;
    },

    /**
     * Resizes the map according to the dimensions of its
     * `container` element.
     *
     * This method must be called after the map's `container` is resized by another script,
     * or when the map is shown after being initially hidden with CSS.
     *
     * @returns {Map} `this`
     */
    resize: function() {
        var width = 0, height = 0;

        if (this._container) {
            width = this._container.offsetWidth || 400;
            height = this._container.offsetHeight || 300;
        }

        this._canvas.resize(width, height);
        this.transform.resize(width, height);
        this.painter.resize(width, height);

        return this
            .fire('movestart')
            .fire('move')
            .fire('resize')
            .fire('moveend');
    },

    /**
     * Returns the map's geographical bounds.
     *
     * @returns {LngLatBounds} The map's geographical bounds.
     */
    getBounds: function() {
        var bounds = new LngLatBounds(
            this.transform.pointLocation(new Point(0, 0)),
            this.transform.pointLocation(this.transform.size));

        if (this.transform.angle || this.transform.pitch) {
            bounds.extend(this.transform.pointLocation(new Point(this.transform.size.x, 0)));
            bounds.extend(this.transform.pointLocation(new Point(0, this.transform.size.y)));
        }

        return bounds;
    },

    /**
     * Sets or clears the map's geographical bounds.
     *
     * Pan and zoom operations are constrained within these bounds.
     * If a pan or zoom is performed that would
     * display regions outside these bounds, the map will
     * instead display a position and zoom level
     * as close as possible to the operation's request while still
     * remaining within the bounds.
     *
     * @param {LngLatBoundsLike | null | undefined} lnglatbounds The maximum bounds to set. If `null` or `undefined` is provided, the function removes the map's maximum bounds.
     * @returns {Map} `this`
     */
    setMaxBounds: function (lnglatbounds) {
        if (lnglatbounds) {
            var b = LngLatBounds.convert(lnglatbounds);
            this.transform.lngRange = [b.getWest(), b.getEast()];
            this.transform.latRange = [b.getSouth(), b.getNorth()];
            this.transform._constrain();
            this._update();
        } else if (lnglatbounds === null || lnglatbounds === undefined) {
            this.transform.lngRange = [];
            this.transform.latRange = [];
            this._update();
        }
        return this;

    },
    /**
     * Sets or clears the map's minimum zoom level.
     * If the map's current zoom level is lower than the new minimum,
     * the map will zoom to the new minimum.
     *
     * @param {?number} minZoom The minimum zoom level to set (0-20).
     *   If `null` or `undefined` is provided, the function removes the current minimum zoom (i.e. sets it to 0).
     * @returns {Map} `this`
     */
    setMinZoom: function(minZoom) {

        minZoom = minZoom === null || minZoom === undefined ? defaultMinZoom : minZoom;

        if (minZoom >= defaultMinZoom && minZoom <= this.transform.maxZoom) {
            this.transform.minZoom = minZoom;
            this._update();

            if (this.getZoom() < minZoom) this.setZoom(minZoom);

            return this;

        } else throw new Error('minZoom must be between ' + defaultMinZoom + ' and the current maxZoom, inclusive');
    },

    /**
     * Sets or clears the map's maximum zoom level.
     * If the map's current zoom level is higher than the new maximum,
     * the map will zoom to the new maximum.
     *
     * @param {?number} maxZoom The maximum zoom level to set (0-20).
     *   If `null` or `undefined` is provided, the function removes the current maximum zoom (sets it to 20).
     * @returns {Map} `this`
     */
    setMaxZoom: function(maxZoom) {

        maxZoom = maxZoom === null || maxZoom === undefined ? defaultMaxZoom : maxZoom;

        if (maxZoom >= this.transform.minZoom && maxZoom <= defaultMaxZoom) {
            this.transform.maxZoom = maxZoom;
            this._update();

            if (this.getZoom() > maxZoom) this.setZoom(maxZoom);

            return this;

        } else throw new Error('maxZoom must be between the current minZoom and ' + defaultMaxZoom + ', inclusive');
    },
    /**
     * Set light color (for use in extrusions).
     *
     * @param {Color} lightColor Color with which to light extrusions.
     * @returns {Map} `this`
     */
    setLightColor: function(lightColor) {
        this.painter.setLighting({
            lightColor: parseColor(lightColor)
        });

        return this;
    },
    /**
     * Set light color (for use in extrusions).
     *
     * @param {Array<number>} lightDirection Array of three values representing light direction x,y,z.
     * @returns {Map} `this`
     */
    setLightDirection: function(lightDirection) {
        if (Array.isArray(lightDirection) && lightDirection.length === 3 &&
            lightDirection.every(function(i) { return typeof i === 'number'; })) {
            this.painter.setLighting({
                lightDirection: {
                    x: lightDirection[0],
                    y: lightDirection[1],
                    z: lightDirection[2]
                }
            });
        } else throw new Error('light.lightDirection must be an array of three numbers');
        // TODO should we do more specific bounds checking on these numbers? probably

        return this;
    },
    /**
     * Set light color (for use in extrusions).
     *
     * @param {String} lightAnchor Anchor for extrusion lighting. One of `map`, `viewport`.
     * @returns {Map} `this`
     */
    setLightAnchor: function(lightAnchor) {
        if (lightAnchor === 'map' || lightAnchor === 'viewport') {
            this.painter.setLighting({
                lightAnchor: lightAnchor
            });
        } else throw new Error('light.lightAnchor must be one of: `map`, `viewport`');

        return this;
    },
    /**
     * Set all light properties.
     *
     * @param {Object} lightOptions Object containing any light subproperties.
     * @returns {Map} `this`
     */
    _setLightOptions: function(opts) {
        this.setLightAnchor(opts.lightAnchor);
        this.setLightColor(opts.lightColor);
        this.setLightDirection(opts.lightDirection);

        return this;
    },
    /**
     * Returns a [`Point`](#Point) representing pixel coordinates, relative to the map's `container`,
     * that correspond to the specified geographical location.
     *
     * @param {LngLatLike} lnglat The geographical location to project.
     * @returns {Point} The [`Point`](#Point) corresponding to `lnglat`, relative to the map's `container`.
     */
    project: function(lnglat) {
        return this.transform.locationPoint(LngLat.convert(lnglat));
    },

    /**
     * Returns a [`LngLat`](#LngLat) representing geographical coordinates that correspond
     * to the specified pixel coordinates.
     *
     * @param {PointLike} point The pixel coordinates to unproject.
     * @returns {LngLat} The [`LngLat`](#LngLat) corresponding to `point`.
     */
    unproject: function(point) {
        return this.transform.pointLocation(Point.convert(point));
    },

    /**
     * Returns an array of [GeoJSON](http://geojson.org/)
     * [Feature objects](http://geojson.org/geojson-spec.html#feature-objects)
     * representing visible features that satisfy the query parameters.
     *
     * @param {PointLike|Array<PointLike>} [geometry] - The geometry of the query region:
     * either a single point or southwest and northeast points describing a bounding box.
     * Omitting this parameter (i.e. calling [`Map#queryRenderedFeatures`](#Map#queryRenderedFeatures) with zero arguments,
     * or with only a `parameters` argument) is equivalent to passing a bounding box encompassing the entire
     * map viewport.
     * @param {Object} [parameters]
     * @param {Array<string>} [parameters.layers] An array of style layer IDs for the query to inspect.
     *   Only features within these layers will be returned. If this parameter is undefined, all layers will be checked.
     * @param {Array} [parameters.filter] A [filter](https://www.mapbox.com/mapbox-gl-style-spec/#types-filter)
     *   to limit query results.
     *
     * @returns {Array<Object>} An array of [GeoJSON](http://geojson.org/)
     * [feature objects](http://geojson.org/geojson-spec.html#feature-objects).
     *
     * The `properties` value of each returned feature object contains the properties of its source feature. For GeoJSON sources, only
     * string and numeric property values are supported (i.e. `null`, `Array`, and `Object` values are not supported).
     *
     * Each feature includes a top-level `layer` property whose value is an object representing the style layer to
     * which the feature belongs. Layout and paint properties in this object contain values which are fully evaluated
     * for the given zoom level and feature.
     *
     * Only visible features are returned. The topmost rendered feature appears first in the returned array, and
     * subsequent features are sorted by descending z-order. Features that are rendered multiple times (due to wrapping
     * across the antimeridian at low zoom levels) are returned only once (though subject to the following caveat).
     *
     * Because features come from tiled vector data or GeoJSON data that is converted to tiles internally, feature
     * geometries are clipped at tile boundaries and, as a result, features may appear multiple times in query
     * results when they span multiple tiles. For example, suppose
     * there is a highway running through the bounding rectangle of a query. The results of the query will be those
     * parts of the highway that lie within the map tiles covering the bounding rectangle, even if the highway extends
     * into other tiles, and the portion of the highway within each map tile will be returned as a separate feature.
     *
     * @example
     * // Find all features at a point
     * var features = map.queryRenderedFeatures(
     *   [20, 35],
     *   { layers: ['my-layer-name'] }
     * );
     *
     * @example
     * // Find all features within a static bounding box
     * var features = map.queryRenderedFeatures(
     *   [[10, 20], [30, 50]],
     *   { layers: ['my-layer-name'] }
     * );
     *
     * @example
     * // Find all features within a bounding box around a point
     * var width = 10;
     * var height = 20;
     * var features = map.queryRenderedFeatures([
     *   [point.x - width / 2, point.y - height / 2],
     *   [point.x + width / 2, point.y + height / 2]
     * ], { layers: ['my-layer-name'] });
     *
     * @example
     * // Query all rendered features from a single layer
     * var features = map.queryRenderedFeatures({ layers: ['my-layer-name'] });
     */
    queryRenderedFeatures: function() {
        var params = {};
        var geometry;

        if (arguments.length === 2) {
            geometry = arguments[0];
            params = arguments[1];
        } else if (arguments.length === 1 && isPointLike(arguments[0])) {
            geometry = arguments[0];
        } else if (arguments.length === 1) {
            params = arguments[0];
        }

        return this.style.queryRenderedFeatures(
            this._makeQueryGeometry(geometry),
            params,
            this.transform.zoom,
            this.transform.angle
        );

        function isPointLike(input) {
            return input instanceof Point || Array.isArray(input);
        }
    },

    _makeQueryGeometry: function(pointOrBox) {
        if (pointOrBox === undefined) {
            // bounds was omitted: use full viewport
            pointOrBox = [
                Point.convert([0, 0]),
                Point.convert([this.transform.width, this.transform.height])
            ];
        }

        var queryGeometry;
        var isPoint = pointOrBox instanceof Point || typeof pointOrBox[0] === 'number';

        if (isPoint) {
            var point = Point.convert(pointOrBox);
            queryGeometry = [point];
        } else {
            var box = [Point.convert(pointOrBox[0]), Point.convert(pointOrBox[1])];
            queryGeometry = [
                box[0],
                new Point(box[1].x, box[0].y),
                box[1],
                new Point(box[0].x, box[1].y),
                box[0]
            ];
        }

        queryGeometry = queryGeometry.map(function(p) {
            return this.transform.pointCoordinate(p);
        }.bind(this));

        return queryGeometry;
    },

    /**
     * Returns an array of [GeoJSON](http://geojson.org/)
     * [Feature objects](http://geojson.org/geojson-spec.html#feature-objects)
     * representing features within the specified vector tile or GeoJSON source that satisfy the query parameters.
     *
     * @param {string} sourceID The ID of the vector tile or GeoJSON source to query.
     * @param {Object} parameters
     * @param {string} [parameters.sourceLayer] The name of the vector tile layer to query. *For vector tile
     *   sources, this parameter is required.* For GeoJSON sources, it is ignored.
     * @param {Array} [parameters.filter] A [filter](https://www.mapbox.com/mapbox-gl-style-spec/#types-filter)
     *   to limit query results.
     *
     * @returns {Array<Object>} An array of [GeoJSON](http://geojson.org/)
     * [Feature objects](http://geojson.org/geojson-spec.html#feature-objects).
     *
     * In contrast to [`Map#queryRenderedFeatures`](#Map#queryRenderedFeatures), this function
     * returns all features matching the query parameters,
     * whether or not they are rendered by the current style (i.e. visible). The domain of the query includes all currently-loaded
     * vector tiles and GeoJSON source tiles: this function does not check tiles outside the currently
     * visible viewport.
     *
     * Because features come from tiled vector data or GeoJSON data that is converted to tiles internally, feature
     * geometries are clipped at tile boundaries and, as a result, features may appear multiple times in query
     * results when they span multiple tiles. For example, suppose
     * there is a highway running through the bounding rectangle of a query. The results of the query will be those
     * parts of the highway that lie within the map tiles covering the bounding rectangle, even if the highway extends
     * into other tiles, and the portion of the highway within each map tile will be returned as a separate feature.
     */
    querySourceFeatures: function(sourceID, params) {
        return this.style.querySourceFeatures(sourceID, params);
    },

    /**
     * Replaces the map's Mapbox style object with a new value.
     *
     * @param {Object|string} style A JSON object conforming to the schema described in the
     *   [Mapbox Style Specification](https://mapbox.com/mapbox-gl-style-spec/), or a URL to such JSON.
     * @returns {Map} `this`
     */
    setStyle: function(style) {
        if (this.style) {
            this.style
                .off('load', this._onStyleLoad)
                .off('error', this._forwardStyleEvent)
                .off('change', this._onStyleChange)
                .off('source.add', this._onSourceAdd)
                .off('source.remove', this._onSourceRemove)
                .off('source.load', this._onSourceUpdate)
                .off('source.error', this._forwardSourceEvent)
                .off('source.change', this._onSourceUpdate)
                .off('layer.add', this._forwardLayerEvent)
                .off('layer.remove', this._forwardLayerEvent)
                .off('layer.error', this._forwardLayerEvent)
                .off('tile.add', this._forwardTileEvent)
                .off('tile.remove', this._forwardTileEvent)
                .off('tile.load', this._update)
                .off('tile.error', this._forwardTileEvent)
                .off('tile.stats', this._forwardTileEvent)
                ._remove();

            this.off('rotate', this.style._redoPlacement);
            this.off('pitch', this.style._redoPlacement);
        }

        if (!style) {
            this.style = null;
            return this;
        } else if (style instanceof Style) {
            this.style = style;
        } else {
            this.style = new Style(style, this.animationLoop, this._workerCount);
        }

        this.style
            .on('load', this._onStyleLoad)
            .on('error', this._forwardStyleEvent)
            .on('change', this._onStyleChange)
            .on('source.add', this._onSourceAdd)
            .on('source.remove', this._onSourceRemove)
            .on('source.load', this._onSourceUpdate)
            .on('source.error', this._forwardSourceEvent)
            .on('source.change', this._onSourceUpdate)
            .on('layer.add', this._forwardLayerEvent)
            .on('layer.remove', this._forwardLayerEvent)
            .on('layer.error', this._forwardLayerEvent)
            .on('tile.add', this._forwardTileEvent)
            .on('tile.remove', this._forwardTileEvent)
            .on('tile.load', this._update)
            .on('tile.error', this._forwardTileEvent)
            .on('tile.stats', this._forwardTileEvent);

        this.on('rotate', this.style._redoPlacement);
        this.on('pitch', this.style._redoPlacement);

        return this;
    },

    /**
     * Returns the map's Mapbox style object, which can be used to recreate the map's style.
     *
     * @returns {Object} The map's style object.
     */
    getStyle: function() {
        if (this.style) {
            return this.style.serialize();
        }
    },

    /**
     * Adds a source to the map's style.
     *
     * @param {string} id The ID of the source to add. Must not conflict with existing sources.
     * @param {Object} source The source object, conforming to the
     * Mapbox Style Specification's [source definition](https://www.mapbox.com/mapbox-gl-style-spec/#sources).
     * @param {string} source.type The source type, which must be either one of the core Mapbox GL source types defined in the style specification or a custom type that has been added to the map with {@link Map#addSourceType}.
     * @fires source.add
     * @returns {Map} `this`
     */
    addSource: function(id, source) {
        this.style.addSource(id, source);
        this._update(true);
        return this;
    },

    /**
     * Adds a [custom source type](#Custom Sources), making it available for use with
     * {@link Map#addSource}.
     * @private
     * @param {string} name The name of the source type; source definition objects use this name in the `{type: ...}` field.
     * @param {Function} SourceType A {@link Source} constructor.
     * @param {Function} callback Called when the source type is ready or with an error argument if there is an error.
     */
    addSourceType: function (name, SourceType, callback) {
        return this.style.addSourceType(name, SourceType, callback);
    },

    /**
     * Removes a source from the map's style.
     *
     * @param {string} id The ID of the source to remove.
     * @fires source.remove
     * @returns {Map} `this`
     */
    removeSource: function(id) {
        this.style.removeSource(id);
        this._update(true);
        return this;
    },

    /**
     * Returns the source with the specified ID in the map's style.
     *
     * @param {string} id The ID of the source to get.
     * @returns {?Object} The style source with the specified ID, or `undefined`
     *   if the ID corresponds to no existing sources.
     */
    getSource: function(id) {
        return this.style.getSource(id);
    },

    /**
     * Adds a [Mapbox style layer](https://www.mapbox.com/mapbox-gl-style-spec/#layers)
     * to the map's style.
     *
     * A layer defines styling for data from a specified source.
     *
     * @param {Object} layer The style layer to add, conforming to the Mapbox Style Specification's
     *   [layer definition](https://www.mapbox.com/mapbox-gl-style-spec/#layers).
     * @param {string} [before] The ID of an existing layer to insert the new layer before.
     *   If this argument is omitted, the layer will be appended to the end of the layers array.
     * @fires layer.add
     * @returns {Map} `this`
     */
    addLayer: function(layer, before) {
        this.style.addLayer(layer, before);
        this._update(true);
        return this;
    },

    /**
     * Removes a layer from the map's style.
     *
     * Also removes any layers which refer to the specified layer via a
     * [`ref` property](https://www.mapbox.com/mapbox-gl-style-spec/#layer-ref).
     *
     * @param {string} id The ID of the layer to remove.
     * @throws {Error} if no layer with the specified `id` exists.
     * @fires layer.remove
     * @returns {Map} `this`
     */
    removeLayer: function(id) {
        this.style.removeLayer(id);
        this._update(true);
        return this;
    },

    /**
     * Returns the layer with the specified ID in the map's style.
     *
     * @param {string} id The ID of the layer to get.
     * @returns {?Object} The layer with the specified ID, or `undefined`
     *   if the ID corresponds to no existing layers.
     */
    getLayer: function(id) {
        return this.style.getLayer(id);
    },

    /**
     * Sets the filter for the specified style layer.
     *
     * @param {string} layer The ID of the layer to which the filter will be applied.
     * @param {Array} filter The filter, conforming to the Mapbox Style Specification's
     *   [filter definition](https://www.mapbox.com/mapbox-gl-style-spec/#types-filter).
     * @returns {Map} `this`
     * @example
     * map.setFilter('my-layer', ['==', 'name', 'USA']);
     */
    setFilter: function(layer, filter) {
        this.style.setFilter(layer, filter);
        this._update(true);
        return this;
    },

    /**
     * Sets the zoom extent for the specified style layer.
     *
     * @param {string} layerId The ID of the layer to which the zoom extent will be applied.
     * @param {number} minzoom The minimum zoom to set (0-20).
     * @param {number} maxzoom The maximum zoom to set (0-20).
     * @returns {Map} `this`
     * @example
     * map.setLayerZoomRange('my-layer', 2, 5);
     */
    setLayerZoomRange: function(layerId, minzoom, maxzoom) {
        this.style.setLayerZoomRange(layerId, minzoom, maxzoom);
        this._update(true);
        return this;
    },

    /**
     * Returns the filter applied to the specified style layer.
     *
     * @param {string} layer The ID of the style layer whose filter to get.
     * @returns {Array} The layer's filter.
     */
    getFilter: function(layer) {
        return this.style.getFilter(layer);
    },

    /**
     * Sets the value of a paint property in the specified style layer.
     *
     * @param {string} layer The ID of the layer to set the paint property in.
     * @param {string} name The name of the paint property to set.
     * @param {*} value The value of the paint propery to set.
     *   Must be of a type appropriate for the property, as defined in the [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/).
     * @param {string=} klass A style class specifier for the paint property.
     * @returns {Map} `this`
     * @example
     * map.setPaintProperty('my-layer', 'fill-color', '#faafee');
     */
    setPaintProperty: function(layer, name, value, klass) {
        this.style.setPaintProperty(layer, name, value, klass);
        this._update(true);
        return this;
    },

    /**
     * Returns the value of a paint property in the specified style layer.
     *
     * @param {string} layer The ID of the layer to get the paint property from.
     * @param {string} name The name of a paint property to get.
     * @param {string=} klass A class specifier for the paint property.
     * @returns {*} The value of the specified paint property.
     */
    getPaintProperty: function(layer, name, klass) {
        return this.style.getPaintProperty(layer, name, klass);
    },

    /**
     * Sets the value of a layout property in the specified style layer.
     *
     * @param {string} layer The ID of the layer to set the layout property in.
     * @param {string} name The name of the layout property to set.
     * @param {*} value The value of the layout propery. Must be of a type appropriate for the property, as defined in the [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/).
     * @returns {Map} `this`
     * @example
     * map.setLayoutProperty('my-layer', 'visibility', 'none');
     */
    setLayoutProperty: function(layer, name, value) {
        this.style.setLayoutProperty(layer, name, value);
        this._update(true);
        return this;
    },

    /**
     * Returns the value of a layout property in the specified style layer.
     *
     * @param {string} layer The ID of the layer to get the layout property from.
     * @param {string} name The name of the layout property to get.
     * @returns {*} The value of the specified layout property.
     */
    getLayoutProperty: function(layer, name) {
        return this.style.getLayoutProperty(layer, name);
    },

    /**
     * Returns the map's containing HTML element.
     *
     * @returns {HTMLElement} The map's container.
     */
    getContainer: function() {
        return this._container;
    },

    /**
     * Returns the HTML element containing the map's `<canvas>` element.
     *
     * If you want to add non-GL overlays to the map, you should append them to this element.
     *
     * This is the element to which event bindings for map interactivity (such as panning and zooming) are
     * attached. It will receive bubbled events from child elements such as the `<canvas>`, but not from
     * map controls.
     *
     * @returns {HTMLElement} The container of the map's `<canvas>`.
     */
    getCanvasContainer: function() {
        return this._canvasContainer;
    },

    /**
     * Returns the map's `<canvas>` element.
     *
     * @returns {HTMLCanvasElement} The map's `<canvas>` element.
     */
    getCanvas: function() {
        return this._canvas.getElement();
    },

    _setupContainer: function() {
        var container = this._container;
        container.classList.add('mapboxgl-map');

        var canvasContainer = this._canvasContainer = DOM.create('div', 'mapboxgl-canvas-container', container);
        if (this._interactive) {
            canvasContainer.classList.add('mapboxgl-interactive');
        }
        this._canvas = new Canvas(this, canvasContainer);

        var controlContainer = this._controlContainer = DOM.create('div', 'mapboxgl-control-container', container);
        var corners = this._controlCorners = {};
        ['top-left', 'top-right', 'bottom-left', 'bottom-right'].forEach(function (pos) {
            corners[pos] = DOM.create('div', 'mapboxgl-ctrl-' + pos, controlContainer);
        });
    },

    _setupPainter: function() {
        var gl = this._canvas.getWebGLContext({
            failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
            preserveDrawingBuffer: this._preserveDrawingBuffer
        });

        if (!gl) {
            this.fire('error', { error: new Error('Failed to initialize WebGL') });
            return;
        }

        this.painter = new Painter(gl, this.transform);
    },

    /**
     * Fired when the WebGL context is lost.
     *
     * @event webglcontextlost
     * @memberof Map
     * @instance
     * @type {Object}
     * @property {WebGLContextEvent} originalEvent The original DOM event.
     */
    _contextLost: function(event) {
        event.preventDefault();
        if (this._frameId) {
            browser.cancelFrame(this._frameId);
        }
        this.fire('webglcontextlost', {originalEvent: event});
    },

    /**
     * Fired when the WebGL context is restored.
     *
     * @event webglcontextrestored
     * @memberof Map
     * @instance
     * @type {Object}
     * @property {WebGLContextEvent} originalEvent The original DOM event.
     */
    _contextRestored: function(event) {
        this._setupPainter();
        this.resize();
        this._update();
        this.fire('webglcontextrestored', {originalEvent: event});
    },

    /**
     * Returns a Boolean indicating whether the map is fully loaded.
     *
     * Returns `false` if the style is not yet fully loaded,
     * or if there has been a change to the sources or style that
     * has not yet fully loaded.
     *
     * @returns {boolean} A Boolean indicating whether the map is fully loaded.
     */
    loaded: function() {
        if (this._styleDirty || this._sourcesDirty)
            return false;
        if (!this.style || !this.style.loaded())
            return false;
        return true;
    },

    /**
     * Update this map's style and sources, and re-render the map.
     *
     * @param {boolean} updateStyle mark the map's style for reprocessing as
     * well as its sources
     * @returns {Map} this
     * @private
     */
    _update: function(updateStyle) {
        if (!this.style) return this;

        this._styleDirty = this._styleDirty || updateStyle;
        this._sourcesDirty = true;

        this._rerender();

        return this;
    },

    /**
     * Call when a (re-)render of the map is required, e.g. when the
     * user panned or zoomed,f or new data is available.
     * @returns {Map} this
     * @private
     */
    _render: function() {
        try {
            if (this.style && this._styleDirty) {
                this._styleDirty = false;
                this.style.update(this._classes, this._classOptions);
                this._classOptions = null;
                this.style._recalculate(this.transform.zoom);
            }

            if (this.style && this._sourcesDirty) {
                this._sourcesDirty = false;
                this.style._updateSources(this.transform);
            }

            this.painter.render(this.style, {
                debug: this.showTileBoundaries,
                showOverdrawInspector: this._showOverdrawInspector,
                vertices: this.vertices,
                rotating: this.rotating,
                zooming: this.zooming
            });

            this.fire('render');

            if (this.loaded() && !this._loaded) {
                this._loaded = true;
                this.fire('load');
            }

            this._frameId = null;

            if (!this.animationLoop.stopped()) {
                this._styleDirty = true;
            }

            if (this._sourcesDirty || this._repaint || this._styleDirty) {
                this._rerender();
            }

        } catch (error) {
            this.fire('error', {error: error});
        }

        return this;
    },

    /**
     * Destroys the map's underlying resources, including web workers and DOM elements.
     *
     * After calling this method, you must not call any other methods on the map.
     */
    remove: function() {
        if (this._hash) this._hash.remove();
        browser.cancelFrame(this._frameId);
        this.setStyle(null);
        if (typeof window !== 'undefined') {
            window.removeEventListener('resize', this._onWindowResize, false);
        }
        var extension = this.painter.gl.getExtension('WEBGL_lose_context');
        if (extension) extension.loseContext();
        removeNode(this._canvasContainer);
        removeNode(this._controlContainer);
        this._container.classList.remove('mapboxgl-map');
    },

    _rerender: function() {
        if (this.style && !this._frameId) {
            this._frameId = browser.frame(this._render);
        }
    },

    _forwardStyleEvent: function(e) {
        this.fire('style.' + e.type, util.extend({style: e.target}, e));
    },

    _forwardSourceEvent: function(e) {
        this.fire(e.type, util.extend({style: e.target}, e));
    },

    _forwardLayerEvent: function(e) {
        this.fire(e.type, util.extend({style: e.target}, e));
    },

    _forwardTileEvent: function(e) {
        this.fire(e.type, util.extend({style: e.target}, e));
    },

    _onStyleLoad: function(e) {
        if (this.transform.unmodified) {
            this.jumpTo(this.style.stylesheet);
        }
        this.style.update(this._classes, {transition: false});
        this._forwardStyleEvent(e);
    },

    _onStyleChange: function(e) {
        this._update(true);
        this._forwardStyleEvent(e);
    },

    _onSourceAdd: function(e) {
        var source = e.source;
        if (source.onAdd)
            source.onAdd(this);
        this._forwardSourceEvent(e);
    },

    _onSourceRemove: function(e) {
        var source = e.source;
        if (source.onRemove)
            source.onRemove(this);
        this._forwardSourceEvent(e);
    },

    _onSourceUpdate: function(e) {
        this._update();
        this._forwardSourceEvent(e);
    },

    _onWindowOnline: function() {
        this._update();
    },

    _onWindowResize: function() {
        if (this._trackResize) {
            this.stop().resize()._update();
        }
    }
});

util.extendAll(Map.prototype, /** @lends Map.prototype */{

    /**
     * Gets and sets a Boolean indicating whether the map will render an outline
     * around each tile. These tile boundaries are useful for debugging.
     *
     * @name showTileBoundaries
     * @type {boolean}
     * @instance
     * @memberof Map
     */
    _showTileBoundaries: false,
    get showTileBoundaries() { return this._showTileBoundaries; },
    set showTileBoundaries(value) {
        if (this._showTileBoundaries === value) return;
        this._showTileBoundaries = value;
        this._update();
    },

    /**
     * Gets and sets a Boolean indicating whether the map will render boxes
     * around all symbols in the data source, revealing which symbols
     * were rendered or which were hidden due to collisions.
     * This information is useful for debugging.
     *
     * @name showCollisionBoxes
     * @type {boolean}
     * @instance
     * @memberof Map
     */
    _showCollisionBoxes: false,
    get showCollisionBoxes() { return this._showCollisionBoxes; },
    set showCollisionBoxes(value) {
        if (this._showCollisionBoxes === value) return;
        this._showCollisionBoxes = value;
        this.style._redoPlacement();
    },

    /*
     * Gets and sets a Boolean indicating whether the map should color-code
     * each fragment to show how many times it has been shaded.
     * White fragments have been shaded 8 or more times.
     * Black fragments have been shaded 0 times.
     * This information is useful for debugging.
     *
     * @name showOverdraw
     * @type {boolean}
     * @instance
     * @memberof Map
     */
    _showOverdrawInspector: false,
    get showOverdrawInspector() { return this._showOverdrawInspector; },
    set showOverdrawInspector(value) {
        if (this._showOverdrawInspector === value) return;
        this._showOverdrawInspector = value;
        this._update();
    },

    /**
     * Gets and sets a Boolean indicating whether the map will
     * continuously repaint. This information is useful for analyzing performance.
     *
     * @name repaint
     * @type {boolean}
     * @instance
     * @memberof Map
     */
    _repaint: false,
    get repaint() { return this._repaint; },
    set repaint(value) { this._repaint = value; this._update(); },

    // show vertices
    _vertices: false,
    get vertices() { return this._vertices; },
    set vertices(value) { this._vertices = value; this._update(); }
});

function removeNode(node) {
    if (node.parentNode) {
        node.parentNode.removeChild(node);
    }
}

/**
 * A [`LngLat`](#LngLat) object or an array of two numbers representing longitude and latitude.
 *
 * @typedef {(LngLat | Array<number>)} LngLatLike
 * @example
 * var v1 = new mapboxgl.LngLat(-122.420679, 37.772537);
 * var v2 = [-122.420679, 37.772537];
 */

/**
 * A [`LngLatBounds`](#LngLatBounds) object or an array of [`LngLatLike`](#LngLatLike) objects.
 *
 * @typedef {(LngLatBounds | Array<LngLatLike>)} LngLatBoundsLike
 * @example
 * var v1 = new mapboxgl.LngLatBounds(
 *   new mapboxgl.LngLat(-73.9876, 40.7661),
 *   new mapboxgl.LngLat(-73.9397, 40.8002)
 * );
 * var v2 = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002])
 * var v3 = [[-73.9876, 40.7661], [-73.9397, 40.8002]];
 */

/**
 * A [`Point` geometry](https://github.com/mapbox/point-geometry) object, which has
 * `x` and `y` properties representing coordinates.
 *
 * @typedef {Object} Point
 */

/**
 * A [`Point`](#Point) or an array of two numbers representing `x` and `y` coordinates.
 *
 * @typedef {(Point | Array<number>)} PointLike
 */

/**
 * Options common to {@link Map#addClass}, {@link Map#removeClass},
 * and {@link Map#setClasses}, controlling
 * whether or not to smoothly transition property changes triggered by a class change.
 *
 * @typedef {Object} StyleOptions
 * @property {boolean} transition If `true`, property changes will smootly transition.
 */

/**
 * Fired whenever the map is drawn to the screen, as the result of
 *
 * - a change to the map's position, zoom, pitch, or bearing
 * - a change to the map's style
 * - a change to a GeoJSON source
 * - the loading of a vector tile, GeoJSON file, glyph, or sprite
 *
 * @event render
 * @memberof Map
 * @instance
 */

/**
 * Fired when a point device (usually a mouse) leaves the map's canvas.
 *
 * @event mouseout
 * @memberof Map
 * @instance
 * @property {MapMouseEvent} data
 */

/**
 * Fired when a pointing device (usually a mouse) is pressed within the map.
 *
 * @event mousedown
 * @memberof Map
 * @instance
 * @property {MapMouseEvent} data
 */

/**
 * Fired when a pointing device (usually a mouse) is released within the map.
 *
 * @event mouseup
 * @memberof Map
 * @instance
 * @property {MapMouseEvent} data
 */

/**
 * Fired when a pointing device (usually a mouse) is moved within the map.
 *
 * @event mousemove
 * @memberof Map
 * @instance
 * @property {MapMouseEvent} data
 */

/**
 * Fired when a touch point is placed on the map.
 *
 * @event touchstart
 * @memberof Map
 * @instance
 * @property {MapTouchEvent} data
 */

/**
 * Fired when a touch point is removed from the map.
 *
 * @event touchend
 * @memberof Map
 * @instance
 * @property {MapTouchEvent} data
 */

/**
 * Fired when a touch point is moved within the map.
 *
 * @event touchmove
 * @memberof Map
 * @instance
 * @property {MapTouchEvent} data
 */

/**
 * Fired when a touch point has been disrupted.
 *
 * @event touchcancel
 * @memberof Map
 * @instance
 * @property {MapTouchEvent} data
 */

/**
 * Fired when a pointing device (usually a mouse) is pressed and released at the same point on the map.
 *
 * @event click
 * @memberof Map
 * @instance
 * @property {MapMouseEvent} data
 */

/**
 * Fired when a pointing device (usually a mouse) is clicked twice at the same point on the map.
 *
 * @event dblclick
 * @memberof Map
 * @instance
 * @property {MapMouseEvent} data
 */

/**
 * Fired when the right button of the mouse is clicked or the context menu key is pressed within the map.
 *
 * @event contextmenu
 * @memberof Map
 * @instance
 * @property {MapMouseEvent} data
 */

/**
 * Fired immediately after all necessary resources have been downloaded
 * and the first visually complete rendering of the map has occurred.
 *
 * @event load
 * @memberof Map
 * @instance
 * @type {Object}
 */

/**
 * Fired just before the map begins a transition from one
 * view to another, as the result of either user interaction or methods such as [Map#jumpTo](#Map#jumpTo).
 *
 * @event movestart
 * @memberof Map
 * @instance
 * @property {MapMouseEvent | MapTouchEvent} data
 */

/**
 * Fired repeatedly during an animated transition from one view to
 * another, as the result of either user interaction or methods such as [Map#flyTo](#Map#flyTo).
 *
 * @event move
 * @memberof Map
 * @instance
 * @property {MapMouseEvent | MapTouchEvent} data
 */

/**
 * Fired just after the map completes a transition from one
 * view to another, as the result of either user interaction or methods such as [Map#jumpTo](#Map#jumpTo).
 *
 * @event moveend
 * @memberof Map
 * @instance
 * @property {MapMouseEvent | MapTouchEvent} data
 */

 /**
  * Fired if any error occurs. This is GL JS's primary error reporting
  * mechanism. We use an event instead of `throw` to better accommodate
  * asyncronous operations. If no listeners are bound to the `error` event, the
  * error will be printed to the console.
  *
  * @event error
  * @memberof Map
  * @instance
  * @property {{error: {message: string}}} data
  */

},{"../geo/lng_lat":13,"../geo/lng_lat_bounds":14,"../geo/transform":15,"../render/painter":30,"../style/animation_loop":50,"../style/parse_color":52,"../style/style":53,"../util/browser":103,"../util/canvas":104,"../util/dom":105,"../util/evented":111,"../util/util":120,"./bind_handlers":83,"./camera":84,"./control/attribution":85,"./hash":97,"point-geometry":187}],99:[function(require,module,exports){
/* eslint-disable */
'use strict';

module.exports = Marker;

var DOM = require('../util/dom');
var LngLat = require('../geo/lng_lat');
var Point = require('point-geometry');

/**
 * Creates a marker component
 * @class Marker
 * @param {HTMLElement=} element DOM element to use as a marker (creates a div element by default)
 * @param {Object=} options
 * @param {PointLike=} options.offset The offset in pixels as a [`PointLike`](#PointLike) object to apply relative to the element's top left corner. Negatives indicate left and up.
 * @example
 * var marker = new mapboxgl.Marker()
 *   .setLngLat([30.5, 50.5])
 *   .addTo(map);
 */
function Marker(element, options) {
    if (!element) {
        element = DOM.create('div');
    }
    element.classList.add('mapboxgl-marker');
    this._el = element;

    this._offset = Point.convert(options && options.offset || [0, 0]);

    this._update = this._update.bind(this);
}

Marker.prototype = {
    /**
     * Attaches the marker to a map
     * @param {Map} map
     * @returns {Marker} `this`
     */
    addTo: function(map) {
        this.remove();
        this._map = map;
        map.getCanvasContainer().appendChild(this._el);
        map.on('move', this._update);
        this._update();
        return this;
    },

    /**
     * Removes the marker from a map
     * @example
     * var marker = new mapboxgl.Marker().addTo(map);
     * marker.remove();
     * @returns {Marker} `this`
     */
    remove: function() {
        if (this._map) {
            this._map.off('move', this._update);
            this._map = null;
        }
        var parent = this._el.parentNode;
        if (parent) parent.removeChild(this._el);
        return this;
    },

    /**
     * Get the marker's geographical location
     * @returns {LngLat}
     */
    getLngLat: function() {
        return this._lngLat;
    },

    /**
     * Set the marker's geographical position and move it.
     * @param {LngLat} lnglat
     * @returns {Marker} `this`
     */
    setLngLat: function(lnglat) {
        this._lngLat = LngLat.convert(lnglat);
        this._update();
        return this;
    },

    getElement: function() {
        return this._el;
    },

    _update: function() {
        if (!this._map) return;
        var pos = this._map.project(this._lngLat)._add(this._offset);
        DOM.setTransform(this._el, 'translate(' + pos.x + 'px,' + pos.y + 'px)');
    }
};

},{"../geo/lng_lat":13,"../util/dom":105,"point-geometry":187}],100:[function(require,module,exports){
'use strict';

module.exports = Popup;

var util = require('../util/util');
var Evented = require('../util/evented');
var DOM = require('../util/dom');
var LngLat = require('../geo/lng_lat');

/**
 * A popup component.
 *
 * @class Popup
 * @param {Object} [options]
 * @param {boolean} [options.closeButton=true] If `true`, a close button will appear in the
 *   top right corner of the popup.
 * @param {boolean} [options.closeOnClick=true] If `true`, the popup will closed when the
 *   map is clicked.
 * @param {string} options.anchor - A string indicating the popup's location relative to
 *   the coordinate set via [Popup#setLngLat](#Popup#setLngLat).
 *   Options are `'top'`, `'bottom'`, `'left'`, `'right'`, `'top-left'`,
 * `'top-right'`, `'bottom-left'`, and `'bottom-right'`.
 * @example
 * var popup = new mapboxgl.Popup()
 *   .setLngLat(e.lngLat)
 *   .setHTML("<h1>Hello World!</h1>")
 *   .addTo(map);
 */
function Popup(options) {
    util.setOptions(this, options);
    util.bindAll([
        '_update',
        '_onClickClose'],
        this);
}

Popup.prototype = util.inherit(Evented, /** @lends Popup.prototype */{
    options: {
        closeButton: true,
        closeOnClick: true
    },

    /**
     * Adds the popup to a map.
     *
     * @param {Map} map The Mapbox GL JS map to add the popup to.
     * @returns {Popup} `this`
     */
    addTo: function(map) {
        this._map = map;
        this._map.on('move', this._update);
        if (this.options.closeOnClick) {
            this._map.on('click', this._onClickClose);
        }
        this._update();
        return this;
    },

    /**
     * Removes the popup from the map it has been added to.
     *
     * @example
     * var popup = new mapboxgl.Popup().addTo(map);
     * popup.remove();
     * @returns {Popup} `this`
     */
    remove: function() {
        if (this._content && this._content.parentNode) {
            this._content.parentNode.removeChild(this._content);
        }

        if (this._container) {
            this._container.parentNode.removeChild(this._container);
            delete this._container;
        }

        if (this._map) {
            this._map.off('move', this._update);
            this._map.off('click', this._onClickClose);
            delete this._map;
        }

        /**
         * Fired when the popup is closed manually or programatically.
         *
         * @event close
         * @memberof Popup
         * @instance
         * @type {Object}
         * @property {Popup} popup object that was closed
         */
        this.fire('close');

        return this;
    },

    /**
     * Returns the geographical location of the popup's anchor.
     *
     * @returns {LngLat} The geographical location of the popup's anchor.
     */
    getLngLat: function() {
        return this._lngLat;
    },

    /**
     * Sets the geographical location of the popup's anchor, and moves the popup to it.
     *
     * @param {LngLatLike} lnglat The geographical location to set as the popup's anchor.
     * @returns {Popup} `this`
     */
    setLngLat: function(lnglat) {
        this._lngLat = LngLat.convert(lnglat);
        this._update();
        return this;
    },

    /**
     * Sets the popup's content to a string of text.
     *
     * This function creates a [Text](https://developer.mozilla.org/en-US/docs/Web/API/Text) node in the DOM,
     * so it cannot insert raw HTML. Use this method for security against XSS
     * if the popup content is user-provided.
     *
     * @param {string} text Textual content for the popup.
     * @returns {Popup} `this`
     * @example
     * var popup = new mapboxgl.Popup()
     *   .setLngLat(e.lngLat)
     *   .setText('Hello, world!')
     *   .addTo(map);
     */
    setText: function(text) {
        return this.setDOMContent(document.createTextNode(text));
    },

    /**
     * Sets the popup's content to the HTML provided as a string.
     *
     * @param {string} html A string representing HTML content for the popup.
     * @returns {Popup} `this`
     */
    setHTML: function(html) {
        var frag = document.createDocumentFragment();
        var temp = document.createElement('body'), child;
        temp.innerHTML = html;
        while (true) {
            child = temp.firstChild;
            if (!child) break;
            frag.appendChild(child);
        }

        return this.setDOMContent(frag);
    },

    /**
     * Sets the popup's content to the element provided as a DOM node.
     *
     * @param {Node} htmlNode A DOM node to be used as content for the popup.
     * @returns {Popup} `this`
     * @example
     * // create an element with the popup content
     * var div = document.createElement('div');
     * div.innerHTML = 'Hello, world!';
     * var popup = new mapboxgl.Popup()
     *   .setLngLat(e.lngLat)
     *   .setDOMContent(div)
     *   .addTo(map);
     */
    setDOMContent: function(htmlNode) {
        this._createContent();
        this._content.appendChild(htmlNode);
        this._update();
        return this;
    },

    _createContent: function() {
        if (this._content && this._content.parentNode) {
            this._content.parentNode.removeChild(this._content);
        }

        this._content = DOM.create('div', 'mapboxgl-popup-content', this._container);

        if (this.options.closeButton) {
            this._closeButton = DOM.create('button', 'mapboxgl-popup-close-button', this._content);
            this._closeButton.type = 'button';
            this._closeButton.innerHTML = '&#215;';
            this._closeButton.addEventListener('click', this._onClickClose);
        }
    },

    _update: function() {
        if (!this._map || !this._lngLat || !this._content) { return; }

        if (!this._container) {
            this._container = DOM.create('div', 'mapboxgl-popup', this._map.getContainer());
            this._tip       = DOM.create('div', 'mapboxgl-popup-tip', this._container);
            this._container.appendChild(this._content);
        }

        var pos = this._map.project(this._lngLat).round(),
            anchor = this.options.anchor;

        if (!anchor) {
            var width = this._container.offsetWidth,
                height = this._container.offsetHeight;

            if (pos.y < height) {
                anchor = ['top'];
            } else if (pos.y > this._map.transform.height - height) {
                anchor = ['bottom'];
            } else {
                anchor = [];
            }

            if (pos.x < width / 2) {
                anchor.push('left');
            } else if (pos.x > this._map.transform.width - width / 2) {
                anchor.push('right');
            }

            if (anchor.length === 0) {
                anchor = 'bottom';
            } else {
                anchor = anchor.join('-');
            }
        }

        var anchorTranslate = {
            'top': 'translate(-50%,0)',
            'top-left': 'translate(0,0)',
            'top-right': 'translate(-100%,0)',
            'bottom': 'translate(-50%,-100%)',
            'bottom-left': 'translate(0,-100%)',
            'bottom-right': 'translate(-100%,-100%)',
            'left': 'translate(0,-50%)',
            'right': 'translate(-100%,-50%)'
        };

        var classList = this._container.classList;
        for (var key in anchorTranslate) {
            classList.remove('mapboxgl-popup-anchor-' + key);
        }
        classList.add('mapboxgl-popup-anchor-' + anchor);

        DOM.setTransform(this._container, anchorTranslate[anchor] + ' translate(' + pos.x + 'px,' + pos.y + 'px)');
    },

    _onClickClose: function() {
        this.remove();
    }
});

},{"../geo/lng_lat":13,"../util/dom":105,"../util/evented":111,"../util/util":120}],101:[function(require,module,exports){
'use strict';

module.exports = Actor;

/**
 * An implementation of the [Actor design pattern](http://en.wikipedia.org/wiki/Actor_model)
 * that maintains the relationship between asynchronous tasks and the objects
 * that spin them off - in this case, tasks like parsing parts of styles,
 * owned by the styles
 *
 * @param {WebWorker} target
 * @param {WebWorker} parent
 * @private
 */
function Actor(target, parent) {
    this.target = target;
    this.parent = parent;
    this.callbacks = {};
    this.callbackID = 0;
    this.receive = this.receive.bind(this);
    this.target.addEventListener('message', this.receive, false);
}

Actor.prototype.receive = function(message) {
    var data = message.data,
        id = data.id,
        callback;

    if (data.type === '<response>') {
        callback = this.callbacks[data.id];
        delete this.callbacks[data.id];
        if (callback) callback(data.error || null, data.data);
    } else if (typeof data.id !== 'undefined' && this.parent[data.type]) {
        // data.type == 'load tile', 'remove tile', etc.
        this.parent[data.type](data.data, done.bind(this));
    } else if (typeof data.id !== 'undefined' && this.parent.workerSources) {
        // data.type == sourcetype.method
        var keys = data.type.split('.');
        this.parent.workerSources[keys[0]][keys[1]](data.data, done.bind(this));
    } else {
        this.parent[data.type](data.data);
    }

    function done(err, data, buffers) {
        this.postMessage({
            type: '<response>',
            id: String(id),
            error: err ? String(err) : null,
            data: data
        }, buffers);
    }
};

Actor.prototype.send = function(type, data, callback, buffers) {
    var id = null;
    if (callback) this.callbacks[id = this.callbackID++] = callback;
    this.postMessage({ type: type, id: String(id), data: data }, buffers);
};

/**
 * Wrapped postMessage API that abstracts around IE's lack of
 * `transferList` support.
 *
 * @param {Object} message
 * @param {Object} transferList
 * @private
 */
Actor.prototype.postMessage = function(message, transferList) {
    this.target.postMessage(message, transferList);
};

},{}],102:[function(require,module,exports){
'use strict';

exports.getJSON = function(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.setRequestHeader('Accept', 'application/json');
    xhr.onerror = function(e) {
        callback(e);
    };
    xhr.onload = function() {
        if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
            var data;
            try {
                data = JSON.parse(xhr.response);
            } catch (err) {
                return callback(err);
            }
            callback(null, data);
        } else {
            callback(new Error(xhr.statusText));
        }
    };
    xhr.send();
    return xhr;
};

exports.getArrayBuffer = function(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onerror = function(e) {
        callback(e);
    };
    xhr.onload = function() {
        if (xhr.status >= 200 && xhr.status < 300 && xhr.response) {
            callback(null, xhr.response);
        } else {
            callback(new Error(xhr.statusText));
        }
    };
    xhr.send();
    return xhr;
};

function sameOrigin(url) {
    var a = document.createElement('a');
    a.href = url;
    return a.protocol === document.location.protocol && a.host === document.location.host;
}

exports.getImage = function(url, callback) {
    return exports.getArrayBuffer(url, function(err, imgData) {
        if (err) return callback(err);
        var img = new Image();
        img.onload = function() {
            callback(null, img);
            (window.URL || window.webkitURL).revokeObjectURL(img.src);
        };
        var blob = new Blob([new Uint8Array(imgData)], { type: 'image/png' });
        img.src = (window.URL || window.webkitURL).createObjectURL(blob);
        img.getData = function() {
            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            context.drawImage(img, 0, 0);
            return context.getImageData(0, 0, img.width, img.height).data;
        };
        return img;
    });
};

exports.getVideo = function(urls, callback) {
    var video = document.createElement('video');
    video.onloadstart = function() {
        callback(null, video);
    };
    for (var i = 0; i < urls.length; i++) {
        var s = document.createElement('source');
        if (!sameOrigin(urls[i])) {
            video.crossOrigin = 'Anonymous';
        }
        s.src = urls[i];
        video.appendChild(s);
    }
    video.getData = function() { return video; };
    return video;
};

},{}],103:[function(require,module,exports){
'use strict';

/**
 * Unlike js/util/browser.js, this code is written with the expectation
 * of a browser environment with a global 'window' object
 * @module browser
 * @private
 */

exports.window = window;

/**
 * Provides a function that outputs milliseconds: either performance.now()
 * or a fallback to Date.now()
 */
module.exports.now = (function() {
    if (window.performance &&
        window.performance.now) {
        return window.performance.now.bind(window.performance);
    } else {
        return Date.now.bind(Date);
    }
}());

var frame = window.requestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.msRequestAnimationFrame;

exports.frame = function(fn) {
    return frame(fn);
};

var cancel = window.cancelAnimationFrame ||
    window.mozCancelAnimationFrame ||
    window.webkitCancelAnimationFrame ||
    window.msCancelAnimationFrame;

exports.cancelFrame = function(id) {
    cancel(id);
};

exports.timed = function (fn, dur, ctx) {
    if (!dur) {
        fn.call(ctx, 1);
        return null;
    }

    var abort = false,
        start = module.exports.now();

    function tick(now) {
        if (abort) return;
        now = module.exports.now();

        if (now >= start + dur) {
            fn.call(ctx, 1);
        } else {
            fn.call(ctx, (now - start) / dur);
            exports.frame(tick);
        }
    }

    exports.frame(tick);

    return function() { abort = true; };
};

/**
 * Test if the current browser supports Mapbox GL JS
 * @param {Object} options
 * @param {boolean} [options.failIfMajorPerformanceCaveat=false] Return `false`
 *   if the performance of Mapbox GL JS would be dramatically worse than
 *   expected (i.e. a software renderer would be used)
 * @return {boolean}
 */
exports.supported = require('mapbox-gl-supported');

exports.hardwareConcurrency = navigator.hardwareConcurrency || 4;

Object.defineProperty(exports, 'devicePixelRatio', {
    get: function() { return window.devicePixelRatio; }
});

exports.supportsWebp = false;

var webpImgTest = document.createElement('img');
webpImgTest.onload = function() {
    exports.supportsWebp = true;
};
webpImgTest.src = 'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=';

exports.supportsGeolocation = !!navigator.geolocation;

},{"mapbox-gl-supported":183}],104:[function(require,module,exports){
'use strict';

var util = require('../util');
var isSupported = require('mapbox-gl-supported');

module.exports = Canvas;

function Canvas(parent, container) {
    this.canvas = document.createElement('canvas');

    if (parent && container) {
        this.canvas.style.position = 'absolute';
        this.canvas.classList.add('mapboxgl-canvas');
        this.canvas.addEventListener('webglcontextlost', parent._contextLost.bind(parent), false);
        this.canvas.addEventListener('webglcontextrestored', parent._contextRestored.bind(parent), false);
        this.canvas.setAttribute('tabindex', 0);
        container.appendChild(this.canvas);
    }
}

Canvas.prototype.resize = function(width, height) {
    var pixelRatio = window.devicePixelRatio || 1;

    // Request the required canvas size taking the pixelratio into account.
    this.canvas.width = pixelRatio * width;
    this.canvas.height = pixelRatio * height;

    // Maintain the same canvas size, potentially downscaling it for HiDPI displays
    this.canvas.style.width = width + 'px';
    this.canvas.style.height = height + 'px';
};

Canvas.prototype.getWebGLContext = function(attributes) {
    attributes = util.extend({}, attributes, isSupported.webGLContextAttributes);

    return this.canvas.getContext('webgl', attributes) ||
        this.canvas.getContext('experimental-webgl', attributes);
};

Canvas.prototype.getElement = function() {
    return this.canvas;
};

},{"../util":120,"mapbox-gl-supported":183}],105:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

exports.create = function (tagName, className, container) {
    var el = document.createElement(tagName);
    if (className) el.className = className;
    if (container) container.appendChild(el);
    return el;
};

var docStyle = document.documentElement.style;

function testProp(props) {
    for (var i = 0; i < props.length; i++) {
        if (props[i] in docStyle) {
            return props[i];
        }
    }
}

var selectProp = testProp(['userSelect', 'MozUserSelect', 'WebkitUserSelect', 'msUserSelect']),
    userSelect;
exports.disableDrag = function () {
    if (selectProp) {
        userSelect = docStyle[selectProp];
        docStyle[selectProp] = 'none';
    }
};
exports.enableDrag = function () {
    if (selectProp) {
        docStyle[selectProp] = userSelect;
    }
};

var transformProp = testProp(['transform', 'WebkitTransform']);
exports.setTransform = function(el, value) {
    el.style[transformProp] = value;
};

// Suppress the next click, but only if it's immediate.
function suppressClick(e) {
    e.preventDefault();
    e.stopPropagation();
    window.removeEventListener('click', suppressClick, true);
}
exports.suppressClick = function() {
    window.addEventListener('click', suppressClick, true);
    window.setTimeout(function() {
        window.removeEventListener('click', suppressClick, true);
    }, 0);
};

exports.mousePos = function (el, e) {
    var rect = el.getBoundingClientRect();
    e = e.touches ? e.touches[0] : e;
    return new Point(
        e.clientX - rect.left - el.clientLeft,
        e.clientY - rect.top - el.clientTop
    );
};

exports.touchPos = function (el, e) {
    var rect = el.getBoundingClientRect(),
        points = [];
    for (var i = 0; i < e.touches.length; i++) {
        points.push(new Point(
            e.touches[i].clientX - rect.left - el.clientLeft,
            e.touches[i].clientY - rect.top - el.clientTop
        ));
    }
    return points;
};

},{"point-geometry":187}],106:[function(require,module,exports){
'use strict';
var WebWorkify = require('webworkify');

module.exports = function () {
    return new WebWorkify(require('../../source/worker'));
};

},{"../../source/worker":48,"webworkify":205}],107:[function(require,module,exports){
'use strict';

var quickselect = require('quickselect');
var calculateSignedArea = require('./util').calculateSignedArea;

// classifies an array of rings into polygons with outer rings and holes
module.exports = function classifyRings(rings, maxRings) {
    var len = rings.length;

    if (len <= 1) return [rings];

    var polygons = [],
        polygon,
        ccw;

    for (var i = 0; i < len; i++) {
        var area = calculateSignedArea(rings[i]);
        if (area === 0) continue;

        rings[i].area = Math.abs(area);

        if (ccw === undefined) ccw = area < 0;

        if (ccw === area < 0) {
            if (polygon) polygons.push(polygon);
            polygon = [rings[i]];

        } else {
            polygon.push(rings[i]);
        }
    }
    if (polygon) polygons.push(polygon);

    // Earcut performance degrages with the # of rings in a polygon. For this
    // reason, we limit strip out all but the `maxRings` largest rings.
    if (maxRings > 1) {
        for (var j = 0; j < polygons.length; j++) {
            if (polygons[j].length <= maxRings) continue;
            quickselect(polygons[j], maxRings, 1, polygons[j].length - 1, compareAreas);
            polygons[j] = polygons[j].slice(0, maxRings);
        }
    }

    return polygons;
};

function compareAreas(a, b) {
    return b.area - a.area;
}

},{"./util":120,"quickselect":188}],108:[function(require,module,exports){
'use strict';

module.exports = {
    API_URL: 'https://api.mapbox.com',
    REQUIRE_ACCESS_TOKEN: true
};

},{}],109:[function(require,module,exports){
'use strict';

var assert = require('assert');

module.exports = DictionaryCoder;

function DictionaryCoder(strings) {
    this._stringToNumber = {};
    this._numberToString = [];
    for (var i = 0; i < strings.length; i++) {
        var string = strings[i];
        this._stringToNumber[string] = i;
        this._numberToString[i] = string;
    }
}

DictionaryCoder.prototype.encode = function(string) {
    assert(string in this._stringToNumber);
    return this._stringToNumber[string];
};

DictionaryCoder.prototype.decode = function(n) {
    assert(n < this._numberToString.length);
    return this._numberToString[n];
};

},{"assert":122}],110:[function(require,module,exports){
'use strict';

var util = require('./util');
var Actor = require('./actor');
var WebWorker = require('./web_worker');

module.exports = Dispatcher;

/**
 * Responsible for sending messages from a {@link Source} to an associated
 * {@link WorkerSource}.
 *
 * @interface Dispatcher
 * @private
 */
function Dispatcher(length, parent) {
    this.actors = [];
    this.currentActor = 0;
    for (var i = 0; i < length; i++) {
        var worker = new WebWorker();
        var actor = new Actor(worker, parent);
        actor.name = "Worker " + i;
        this.actors.push(actor);
    }
}

Dispatcher.prototype = {
    /**
     * Broadcast a message to all Workers.
     * @method
     * @name broadcast
     * @param {string} type
     * @param {object} data
     * @param {Function} callback
     * @memberof Dispatcher
     * @instance
     */
    broadcast: function(type, data, cb) {
        cb = cb || function () {};
        util.asyncAll(this.actors, function (actor, done) {
            actor.send(type, data, done);
        }, cb);
    },

    /**
     * Send a message to a Worker.
     * @method
     * @name send
     * @param {string} type
     * @param {object} data
     * @param {Function} callback
     * @param {number|undefined} [targetID] The ID of the Worker to which to send this message. Omit to allow the dispatcher to choose.
     * @returns {number} The ID of the worker to which the message was sent.
     * @memberof Dispatcher
     * @instance
     */
    send: function(type, data, callback, targetID, buffers) {
        if (typeof targetID !== 'number' || isNaN(targetID)) {
            // Use round robin to send requests to web workers.
            targetID = this.currentActor = (this.currentActor + 1) % this.actors.length;
        }

        this.actors[targetID].send(type, data, callback, buffers);
        return targetID;
    },

    remove: function() {
        for (var i = 0; i < this.actors.length; i++) {
            this.actors[i].target.terminate();
        }
        this.actors = [];
    }
};

},{"./actor":101,"./util":120,"./web_worker":106}],111:[function(require,module,exports){
'use strict';

var util = require('./util');

/**
 * Methods mixed in to other classes for event capabilities.
 *
 * @mixin Evented
 */
var Evented = {

    /**
     * Adds a listener to a specified event type.
     *
     * @param {string} type The event type to add a listen for.
     * @param {Function} listener The function to be called when the event is fired.
     *   The listener function is called with the data object passed to `fire`,
     *   extended with `target` and `type` properties.
     * @returns {Object} `this`
     */
    on: function(type, listener) {
        this._events = this._events || {};
        this._events[type] = this._events[type] || [];
        this._events[type].push(listener);

        return this;
    },

    /**
     * Removes a previously registered event listener.
     *
     * @param {string} [type] The event type to remove listeners for.
     *   If none is specified, listeners will be removed for all event types.
     * @param {Function} [listener] The listener function to remove.
     *   If none is specified, all listeners will be removed for the event type.
     * @returns {Object} `this`
     */
    off: function(type, listener) {
        if (!type) {
            // clear all listeners if no arguments specified
            delete this._events;
            return this;
        }

        if (!this.listens(type)) return this;

        if (listener) {
            var idx = this._events[type].indexOf(listener);
            if (idx >= 0) {
                this._events[type].splice(idx, 1);
            }
            if (!this._events[type].length) {
                delete this._events[type];
            }
        } else {
            delete this._events[type];
        }

        return this;
    },

    /**
     * Adds a listener that will be called only once to a specified event type.
     *
     * The listener will be called first time the event fires after the listener is registered.
     *
     * @param {string} type The event type to listen for.
     * @param {Function} listener The function to be called when the event is fired the first time.
     * @returns {Object} `this`
     */
    once: function(type, listener) {
        var wrapper = function(data) {
            this.off(type, wrapper);
            listener.call(this, data);
        }.bind(this);
        this.on(type, wrapper);
        return this;
    },

    /**
     * Fires an event of the specified type.
     *
     * @param {string} type The type of event to fire.
     * @param {Object} [data] Data to be passed to any listeners.
     * @returns {Object} `this`
     */
    fire: function(type, data) {
        if (!this.listens(type)) {
            // To ensure that no error events are dropped, print them to the
            // console if they have no listeners.
            if (util.endsWith(type, 'error')) {
                console.error((data && data.error) || data || 'Empty error event');
            }
            return this;
        }

        data = util.extend({}, data);
        util.extend(data, {type: type, target: this});

        // make sure adding/removing listeners inside other listeners won't cause infinite loop
        var listeners = this._events[type].slice();

        for (var i = 0; i < listeners.length; i++) {
            listeners[i].call(this, data);
        }

        return this;
    },

    /**
     * Returns a Boolean indicating whether any listeners are registered for a specified event type.
     *
     * @param {string} type The event type to check.
     * @returns {boolean} `true` if there is at least one registered listener for specified event type.
     */
    listens: function(type) {
        return !!(this._events && this._events[type]);
    }
};

module.exports = Evented;

},{"./util":120}],112:[function(require,module,exports){
'use strict';
var Queue = require('tinyqueue');
var Point = require('point-geometry');
var distToSegmentSquared = require('./intersection_tests').distToSegmentSquared;

/**
 * Finds an approximation of a polygon's Pole Of Inaccessibiliy https://en.wikipedia.org/wiki/Pole_of_inaccessibility
 * This is a copy of http://github.com/mapbox/polylabel adapted to use Points
 *
 * @param {Array<Array<Point>>} List of polygon rings first item in array is the outer ring followed optionally by the list of holes, should be an element of the result of util/classify_rings
 * @param {number} [precision=1] Specified in input coordinate units. If 0 returns after first run, if > 0 repeatedly narrows the search space until the radius of the area searched for the best pole is less than precision
 * @param {bool} [debug=false] Print some statistics to the console during execution
 *
 * @returns {Point} Pole of Inaccessibiliy.
 */
module.exports = function (polygonRings, precision, debug) {
    precision = precision || 1.0;

    // find the bounding box of the outer ring
    var minX, minY, maxX, maxY;
    var outerRing = polygonRings[0];
    for (var i = 0; i < outerRing.length; i++) {
        var p = outerRing[i];
        if (!i || p.x < minX) minX = p.x;
        if (!i || p.y < minY) minY = p.y;
        if (!i || p.x > maxX) maxX = p.x;
        if (!i || p.y > maxY) maxY = p.y;
    }

    var width = maxX - minX;
    var height = maxY - minY;
    var cellSize = Math.min(width, height);
    var h = cellSize / 2;

    // a priority queue of cells in order of their "potential" (max distance to polygon)
    var cellQueue = new Queue(null, compareMax);

    // cover polygon with initial cells
    for (var x = minX; x < maxX; x += cellSize) {
        for (var y = minY; y < maxY; y += cellSize) {
            cellQueue.push(new Cell(x + h, y + h, h, polygonRings));
        }
    }

    // take centroid as the first best guess
    var bestCell = getCentroidCell(polygonRings);
    var numProbes = cellQueue.length;

    while (cellQueue.length) {
        // pick the most promising cell from the queue
        var cell = cellQueue.pop();

        // update the best cell if we found a better one
        if (cell.d > bestCell.d) {
            bestCell = cell;
            if (debug) console.log('found best %d after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);
        }

        // do not drill down further if there's no chance of a better solution
        if (cell.max - bestCell.d <= precision) continue;

        // split the cell into four cells
        h = cell.h / 2;
        cellQueue.push(new Cell(cell.p.x - h, cell.p.y - h, h, polygonRings));
        cellQueue.push(new Cell(cell.p.x + h, cell.p.y - h, h, polygonRings));
        cellQueue.push(new Cell(cell.p.x - h, cell.p.y + h, h, polygonRings));
        cellQueue.push(new Cell(cell.p.x + h, cell.p.y + h, h, polygonRings));
        numProbes += 4;
    }

    if (debug) {
        console.log('num probes: ' + numProbes);
        console.log('best distance: ' + bestCell.d);
    }

    return bestCell.p;
};

function compareMax(a, b) {
    return b.max - a.max;
}

function Cell(x, y, h, polygon) {
    this.p = new Point(x, y);
    this.h = h; // half the cell size
    this.d = pointToPolygonDist(this.p, polygon); // distance from cell center to polygon
    this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell
}

// signed distance from point to polygon outline (negative if point is outside)
function pointToPolygonDist(p, polygon) {
    var inside = false;
    var minDistSq = Infinity;

    for (var k = 0; k < polygon.length; k++) {
        var ring = polygon[k];

        for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {
            var a = ring[i];
            var b = ring[j];

            if ((a.y > p.y !== b.y > p.y) &&
                (p.x < (b.x - a.x) * (p.y - a.y) / (b.y - a.y) + a.x)) inside = !inside;

            minDistSq = Math.min(minDistSq, distToSegmentSquared(p, a, b));
        }
    }

    return (inside ? 1 : -1) * Math.sqrt(minDistSq);
}

// get polygon centroid
function getCentroidCell(polygon) {
    var area = 0;
    var x = 0;
    var y = 0;
    var points = polygon[0];
    for (var i = 0, len = points.length, j = len - 1; i < len; j = i++) {
        var a = points[i];
        var b = points[j];
        var f = a.x * b.y - b.x * a.y;
        x += (a.x + b.x) * f;
        y += (a.y + b.y) * f;
        area += f * 3;
    }
    return new Cell(x / area, y / area, 0, polygon);
}

},{"./intersection_tests":115,"point-geometry":187,"tinyqueue":196}],113:[function(require,module,exports){
'use strict';

module.exports = Glyphs;

function Glyphs(pbf, end) {
    this.stacks = pbf.readFields(readFontstacks, [], end);
}

function readFontstacks(tag, stacks, pbf) {
    if (tag === 1) {
        var fontstack = pbf.readMessage(readFontstack, {glyphs: {}});
        stacks.push(fontstack);
    }
}

function readFontstack(tag, fontstack, pbf) {
    if (tag === 1) fontstack.name = pbf.readString();
    else if (tag === 2) fontstack.range = pbf.readString();
    else if (tag === 3) {
        var glyph = pbf.readMessage(readGlyph, {});
        fontstack.glyphs[glyph.id] = glyph;
    }
}

function readGlyph(tag, glyph, pbf) {
    if (tag === 1) glyph.id = pbf.readVarint();
    else if (tag === 2) glyph.bitmap = pbf.readBytes();
    else if (tag === 3) glyph.width = pbf.readVarint();
    else if (tag === 4) glyph.height = pbf.readVarint();
    else if (tag === 5) glyph.left = pbf.readSVarint();
    else if (tag === 6) glyph.top = pbf.readSVarint();
    else if (tag === 7) glyph.advance = pbf.readVarint();
}

},{}],114:[function(require,module,exports){
'use strict';

module.exports = interpolate;

function interpolate(a, b, t) {
    return (a * (1 - t)) + (b * t);
}

interpolate.number = interpolate;

interpolate.vec2 = function(from, to, t) {
    return [
        interpolate(from[0], to[0], t),
        interpolate(from[1], to[1], t)
    ];
};

/*
 * Interpolate between two colors given as 4-element arrays.
 *
 * @param {Color} from
 * @param {Color} to
 * @param {number} t interpolation factor between 0 and 1
 * @returns {Color} interpolated color
 */
interpolate.color = function(from, to, t) {
    return [
        interpolate(from[0], to[0], t),
        interpolate(from[1], to[1], t),
        interpolate(from[2], to[2], t),
        interpolate(from[3], to[3], t)
    ];
};

interpolate.array = function(from, to, t) {
    return from.map(function(d, i) {
        return interpolate(d, to[i], t);
    });
};

},{}],115:[function(require,module,exports){
'use strict';

var isCounterClockwise = require('./util').isCounterClockwise;

module.exports = {
    multiPolygonIntersectsBufferedMultiPoint: multiPolygonIntersectsBufferedMultiPoint,
    multiPolygonIntersectsMultiPolygon: multiPolygonIntersectsMultiPolygon,
    multiPolygonIntersectsBufferedMultiLine: multiPolygonIntersectsBufferedMultiLine,
    distToSegmentSquared: distToSegmentSquared
};

function multiPolygonIntersectsBufferedMultiPoint(multiPolygon, rings, radius) {
    for (var j = 0; j < multiPolygon.length; j++) {
        var polygon = multiPolygon[j];
        for (var i = 0; i < rings.length; i++) {
            var ring = rings[i];
            for (var k = 0; k < ring.length; k++) {
                var point = ring[k];
                if (polygonContainsPoint(polygon, point)) return true;
                if (pointIntersectsBufferedLine(point, polygon, radius)) return true;
            }
        }
    }
    return false;
}

function multiPolygonIntersectsMultiPolygon(multiPolygonA, multiPolygonB) {

    if (multiPolygonA.length === 1 && multiPolygonA[0].length === 1) {
        return multiPolygonContainsPoint(multiPolygonB, multiPolygonA[0][0]);
    }

    for (var m = 0; m < multiPolygonB.length; m++) {
        var ring = multiPolygonB[m];
        for (var n = 0; n < ring.length; n++) {
            if (multiPolygonContainsPoint(multiPolygonA, ring[n])) return true;
        }
    }

    for (var j = 0; j < multiPolygonA.length; j++) {
        var polygon = multiPolygonA[j];
        for (var i = 0; i < polygon.length; i++) {
            if (multiPolygonContainsPoint(multiPolygonB, polygon[i])) return true;
        }

        for (var k = 0; k < multiPolygonB.length; k++) {
            if (lineIntersectsLine(polygon, multiPolygonB[k])) return true;
        }
    }

    return false;
}

function multiPolygonIntersectsBufferedMultiLine(multiPolygon, multiLine, radius) {
    for (var i = 0; i < multiLine.length; i++) {
        var line = multiLine[i];

        for (var j = 0; j < multiPolygon.length; j++) {
            var polygon = multiPolygon[j];

            if (polygon.length >= 3) {
                for (var k = 0; k < line.length; k++) {
                    if (polygonContainsPoint(polygon, line[k])) return true;
                }
            }

            if (lineIntersectsBufferedLine(polygon, line, radius)) return true;
        }
    }
    return false;
}

function lineIntersectsBufferedLine(lineA, lineB, radius) {

    if (lineA.length > 1) {
        if (lineIntersectsLine(lineA, lineB)) return true;

        // Check whether any point in either line is within radius of the other line
        for (var j = 0; j < lineB.length; j++) {
            if (pointIntersectsBufferedLine(lineB[j], lineA, radius)) return true;
        }
    }

    for (var k = 0; k < lineA.length; k++) {
        if (pointIntersectsBufferedLine(lineA[k], lineB, radius)) return true;
    }

    return false;
}

function lineIntersectsLine(lineA, lineB) {
    for (var i = 0; i < lineA.length - 1; i++) {
        var a0 = lineA[i];
        var a1 = lineA[i + 1];
        for (var j = 0; j < lineB.length - 1; j++) {
            var b0 = lineB[j];
            var b1 = lineB[j + 1];
            if (lineSegmentIntersectsLineSegment(a0, a1, b0, b1)) return true;
        }
    }
    return false;
}

function lineSegmentIntersectsLineSegment(a0, a1, b0, b1) {
    return isCounterClockwise(a0, b0, b1) !== isCounterClockwise(a1, b0, b1) &&
        isCounterClockwise(a0, a1, b0) !== isCounterClockwise(a0, a1, b1);
}

function pointIntersectsBufferedLine(p, line, radius) {
    var radiusSquared = radius * radius;

    if (line.length === 1) return p.distSqr(line[0]) < radiusSquared;

    for (var i = 1; i < line.length; i++) {
        // Find line segments that have a distance <= radius^2 to p
        // In that case, we treat the line as "containing point p".
        var v = line[i - 1], w = line[i];
        if (distToSegmentSquared(p, v, w) < radiusSquared) return true;
    }
    return false;
}

// Code from http://stackoverflow.com/a/1501725/331379.
function distToSegmentSquared(p, v, w) {
    var l2 = v.distSqr(w);
    if (l2 === 0) return p.distSqr(v);
    var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    if (t < 0) return p.distSqr(v);
    if (t > 1) return p.distSqr(w);
    return p.distSqr(w.sub(v)._mult(t)._add(v));
}

// point in polygon ray casting algorithm
function multiPolygonContainsPoint(rings, p) {
    var c = false,
        ring, p1, p2;

    for (var k = 0; k < rings.length; k++) {
        ring = rings[k];
        for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
            p1 = ring[i];
            p2 = ring[j];
            if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
                c = !c;
            }
        }
    }
    return c;
}

function polygonContainsPoint(ring, p) {
    var c = false;
    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        var p1 = ring[i];
        var p2 = ring[j];
        if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
            c = !c;
        }
    }
    return c;
}

},{"./util":120}],116:[function(require,module,exports){
'use strict';

module.exports = LRUCache;

/**
 * A [least-recently-used cache](http://en.wikipedia.org/wiki/Cache_algorithms)
 * with hash lookup made possible by keeping a list of keys in parallel to
 * an array of dictionary of values
 *
 * @param {number} max number of permitted values
 * @param {Function} onRemove callback called with items when they expire
 * @private
 */
function LRUCache(max, onRemove) {
    this.max = max;
    this.onRemove = onRemove;
    this.reset();
}

/**
 * Clear the cache
 *
 * @returns {LRUCache} this cache
 * @private
 */
LRUCache.prototype.reset = function() {
    for (var key in this.data) {
        this.onRemove(this.data[key]);
    }

    this.data = {};
    this.order = [];

    return this;
};

/**
 * Add a key, value combination to the cache, trimming its size if this pushes
 * it over max length.
 *
 * @param {string} key lookup key for the item
 * @param {*} data any value
 *
 * @returns {LRUCache} this cache
 * @private
 */
LRUCache.prototype.add = function(key, data) {

    if (this.has(key)) {
        this.order.splice(this.order.indexOf(key), 1);
        this.data[key] = data;
        this.order.push(key);

    } else {
        this.data[key] = data;
        this.order.push(key);

        if (this.order.length > this.max) {
            var removedData = this.get(this.order[0]);
            if (removedData) this.onRemove(removedData);
        }
    }

    return this;
};

/**
 * Determine whether the value attached to `key` is present
 *
 * @param {string} key the key to be looked-up
 * @returns {boolean} whether the cache has this value
 * @private
 */
LRUCache.prototype.has = function(key) {
    return key in this.data;
};

/**
 * List all keys in the cache
 *
 * @returns {Array<string>} an array of keys in this cache.
 * @private
 */
LRUCache.prototype.keys = function() {
    return this.order;
};

/**
 * Get the value attached to a specific key. If the key is not found,
 * returns `null`
 *
 * @param {string} key the key to look up
 * @returns {*} the data, or null if it isn't found
 * @private
 */
LRUCache.prototype.get = function(key) {
    if (!this.has(key)) { return null; }

    var data = this.data[key];

    delete this.data[key];
    this.order.splice(this.order.indexOf(key), 1);

    return data;
};

/**
 * Change the max size of the cache.
 *
 * @param {number} max the max size of the cache
 * @returns {LRUCache} this cache
 * @private
 */
LRUCache.prototype.setMaxSize = function(max) {
    this.max = max;

    while (this.order.length > this.max) {
        var removedData = this.get(this.order[0]);
        if (removedData) this.onRemove(removedData);
    }

    return this;
};

},{}],117:[function(require,module,exports){
'use strict';

var config = require('./config');
var browser = require('./browser');
var URL = require('url');
var util = require('./util');

function normalizeURL(url, pathPrefix, accessToken) {
    accessToken = accessToken || config.ACCESS_TOKEN;

    if (!accessToken && config.REQUIRE_ACCESS_TOKEN) {
        throw new Error('An API access token is required to use Mapbox GL. ' +
            'See https://www.mapbox.com/developers/api/#access-tokens');
    }

    url = url.replace(/^mapbox:\/\//, config.API_URL + pathPrefix);
    url += url.indexOf('?') !== -1 ? '&access_token=' : '?access_token=';

    if (config.REQUIRE_ACCESS_TOKEN) {
        if (accessToken[0] === 's') {
            throw new Error('Use a public access token (pk.*) with Mapbox GL JS, not a secret access token (sk.*). ' +
                'See https://www.mapbox.com/developers/api/#access-tokens');
        }

        url += accessToken;
    }

    return url;
}

module.exports.normalizeStyleURL = function(url, accessToken) {
    var urlObject = URL.parse(url);

    if (urlObject.protocol !== 'mapbox:') {
        return url;
    } else {
        return normalizeURL(
            'mapbox:/' + urlObject.pathname + formatQuery(urlObject.query),
            '/styles/v1/',
            accessToken
        );
    }
};

module.exports.normalizeSourceURL = function(url, accessToken) {
    var urlObject = URL.parse(url);

    if (urlObject.protocol !== 'mapbox:') {
        return url;
    } else {
        // TileJSON requests need a secure flag appended to their URLs so
        // that the server knows to send SSL-ified resource references.
        return normalizeURL(
            url + '.json',
            '/v4/',
            accessToken
        ) + '&secure';
    }

};

module.exports.normalizeGlyphsURL = function(url, accessToken) {
    var urlObject = URL.parse(url);

    if (urlObject.protocol !== 'mapbox:') {
        return url;
    } else {
        var user = urlObject.pathname.split('/')[1];
        return normalizeURL(
            'mapbox://' + user + '/{fontstack}/{range}.pbf' + formatQuery(urlObject.query),
            '/fonts/v1/',
            accessToken
        );
    }
};

module.exports.normalizeSpriteURL = function(url, format, extension, accessToken) {
    var urlObject = URL.parse(url);

    if (urlObject.protocol !== 'mapbox:') {
        urlObject.pathname += format + extension;
        return URL.format(urlObject);
    } else {
        return normalizeURL(
            'mapbox:/' + urlObject.pathname + '/sprite' + format + extension + formatQuery(urlObject.query),
            '/styles/v1/',
            accessToken
        );
    }
};

module.exports.normalizeTileURL = function(tileURL, sourceURL, tileSize) {
    var tileURLObject = URL.parse(tileURL, true);
    if (!sourceURL) return tileURL;
    var sourceURLObject = URL.parse(sourceURL);
    if (sourceURLObject.protocol !== 'mapbox:') return tileURL;

    // The v4 mapbox tile API supports 512x512 image tiles only when @2x
    // is appended to the tile URL. If `tileSize: 512` is specified for
    // a Mapbox raster source force the @2x suffix even if a non hidpi
    // device.

    var extension = browser.supportsWebp ? '.webp' : '$1';
    var resolution = (browser.devicePixelRatio >= 2 || tileSize === 512) ? '@2x' : '';

    return URL.format({
        protocol: tileURLObject.protocol,
        hostname: tileURLObject.hostname,
        pathname: tileURLObject.pathname.replace(/(\.(?:png|jpg)\d*)/, resolution + extension),
        query: replaceTempAccessToken(tileURLObject.query)
    });
};

function formatQuery(query) {
    return (query ? '?' + query : '');
}

function replaceTempAccessToken(query) {
    if (query.access_token && query.access_token.slice(0, 3) === 'tk.') {
        return util.extend({}, query, {
            'access_token': config.ACCESS_TOKEN
        });
    } else {
        return query;
    }
}

},{"./browser":103,"./config":108,"./util":120,"url":130}],118:[function(require,module,exports){
'use strict';

// Note: all "sizes" are measured in bytes

var assert = require('assert');

module.exports = StructArrayType;

var viewTypes = {
    'Int8': Int8Array,
    'Uint8': Uint8Array,
    'Uint8Clamped': Uint8ClampedArray,
    'Int16': Int16Array,
    'Uint16': Uint16Array,
    'Int32': Int32Array,
    'Uint32': Uint32Array,
    'Float32': Float32Array,
    'Float64': Float64Array
};

/**
 * @typedef StructMember
 * @private
 * @property {string} name
 * @property {string} type
 * @property {number} components
 */

var structArrayTypeCache = {};

/**
 * `StructArrayType` is used to create new `StructArray` types.
 *
 * `StructArray` provides an abstraction over `ArrayBuffer` and `TypedArray` making it behave like
 * an array of typed structs. A StructArray is comprised of elements. Each element has a set of
 * members that are defined when the `StructArrayType` is created.
 *
 * StructArrays useful for creating large arrays that:
 * - can be transferred from workers as a Transferable object
 * - can be copied cheaply
 * - use less memory for lower-precision members
 * - can be used as buffers in WebGL.
 *
 * @class StructArrayType
 * @param {Array.<StructMember>}
 * @param options
 * @param {number} options.alignment Use `4` to align members to 4 byte boundaries. Default is 1.
 *
 * @example
 *
 * var PointArrayType = new StructArrayType({
 *  members: [
 *      { type: 'Int16', name: 'x' },
 *      { type: 'Int16', name: 'y' }
 *  ]});
 *
 *  var pointArray = new PointArrayType();
 *  pointArray.emplaceBack(10, 15);
 *  pointArray.emplaceBack(20, 35);
 *
 *  point = pointArray.get(0);
 *  assert(point.x === 10);
 *  assert(point.y === 15);
 *
 * @private
 */
function StructArrayType(options) {

    var key = JSON.stringify(options);
    if (structArrayTypeCache[key]) {
        return structArrayTypeCache[key];
    }

    if (options.alignment === undefined) options.alignment = 1;

    function StructType() {
        Struct.apply(this, arguments);
    }

    StructType.prototype = Object.create(Struct.prototype);

    var offset = 0;
    var maxSize = 0;
    var usedTypes = ['Uint8'];

    StructType.prototype.members = options.members.map(function(member) {
        member = {
            name: member.name,
            type: member.type,
            components: member.components || 1
        };

        assert(member.name.length);
        assert(member.type in viewTypes);

        if (usedTypes.indexOf(member.type) < 0) usedTypes.push(member.type);

        var typeSize = sizeOf(member.type);
        maxSize = Math.max(maxSize, typeSize);
        member.offset = offset = align(offset, Math.max(options.alignment, typeSize));

        for (var c = 0; c < member.components; c++) {
            Object.defineProperty(StructType.prototype, member.name + (member.components === 1 ? '' : c), {
                get: createGetter(member, c),
                set: createSetter(member, c)
            });
        }

        offset += typeSize * member.components;

        return member;
    });

    StructType.prototype.alignment = options.alignment;
    StructType.prototype.size = align(offset, Math.max(maxSize, options.alignment));

    function StructArrayType() {
        StructArray.apply(this, arguments);
        this.members = StructType.prototype.members;
    }

    StructArrayType.serialize = serializeStructArrayType;

    StructArrayType.prototype = Object.create(StructArray.prototype);
    StructArrayType.prototype.StructType = StructType;
    StructArrayType.prototype.bytesPerElement = StructType.prototype.size;
    StructArrayType.prototype.emplaceBack = createEmplaceBack(StructType.prototype.members, StructType.prototype.size);
    StructArrayType.prototype._usedTypes = usedTypes;


    structArrayTypeCache[key] = StructArrayType;

    return StructArrayType;
}

/**
 * Serialize the StructArray type. This serializes the *type* not an instance of the type.
 * @private
 */
function serializeStructArrayType() {
    return {
        members: this.prototype.StructType.prototype.members,
        alignment: this.prototype.StructType.prototype.alignment,
        bytesPerElement: this.prototype.bytesPerElement
    };
}


function align(offset, size) {
    return Math.ceil(offset / size) * size;
}

function sizeOf(type) {
    return viewTypes[type].BYTES_PER_ELEMENT;
}

function getArrayViewName(type) {
    return type.toLowerCase();
}


/*
 * > I saw major perf gains by shortening the source of these generated methods (i.e. renaming
 * > elementIndex to i) (likely due to v8 inlining heuristics).
 * - lucaswoj
 */
function createEmplaceBack(members, bytesPerElement) {
    var usedTypeSizes = [];
    var argNames = [];
    var body = '' +
    'var i = this.length;\n' +
    'this.resize(this.length + 1);\n';

    for (var m = 0; m < members.length; m++) {
        var member = members[m];
        var size = sizeOf(member.type);

        // array offsets to the end of current data for each type size
        // var o{SIZE} = i * ROUNDED(bytesPerElement / size);
        if (usedTypeSizes.indexOf(size) < 0) {
            usedTypeSizes.push(size);
            body += 'var o' + size.toFixed(0) + ' = i * ' + (bytesPerElement / size).toFixed(0) + ';\n';
        }

        for (var c = 0; c < member.components; c++) {
            // arguments v0, v1, v2, ... are, in order, the components of
            // member 0, then the components of member 1, etc.
            var argName = 'v' + argNames.length;
            // The index for `member` component `c` into the appropriate type array is:
            // this.{TYPE}[o{SIZE} + MEMBER_OFFSET + {c}] = v{X}
            // where MEMBER_OFFSET = ROUND(member.offset / size) is the per-element
            // offset of this member into the array
            var index = 'o' + size.toFixed(0) + ' + ' + (member.offset / size + c).toFixed(0);
            body += 'this.' + getArrayViewName(member.type) + '[' + index + '] = ' + argName + ';\n';
            argNames.push(argName);
        }
    }

    body += 'return i;';

    return new Function(argNames, body);
}

function createMemberComponentString(member, component) {
    var elementOffset = 'this._pos' + sizeOf(member.type).toFixed(0);
    var componentOffset = (member.offset / sizeOf(member.type) + component).toFixed(0);
    var index = elementOffset + ' + ' + componentOffset;
    return 'this._structArray.' + getArrayViewName(member.type) + '[' + index + ']';

}

function createGetter(member, c) {
    return new Function([], 'return ' + createMemberComponentString(member, c) + ';');
}

function createSetter(member, c) {
    return new Function(['x'], createMemberComponentString(member, c) + ' = x;');
}

/**
 * @class Struct
 * @param {StructArray} structArray The StructArray the struct is stored in
 * @param {number} index The index of the struct in the StructArray.
 * @private
 */
function Struct(structArray, index) {
    this._structArray = structArray;
    this._pos1 = index * this.size;
    this._pos2 = this._pos1 / 2;
    this._pos4 = this._pos1 / 4;
    this._pos8 = this._pos1 / 8;
}

/**
 * @class StructArray
 * The StructArray class is inherited by the custom StructArrayType classes created with
 * `new StructArrayType(members, options)`.
 * @private
 */
function StructArray(serialized) {
    if (serialized !== undefined) {
    // Create from an serialized StructArray
        this.arrayBuffer = serialized.arrayBuffer;
        this.length = serialized.length;
        this.capacity = this.arrayBuffer.byteLength / this.bytesPerElement;
        this._refreshViews();

    // Create a new StructArray
    } else {
        this.capacity = -1;
        this.resize(0);
    }
}

/**
 * @property {number}
 * @private
 * @readonly
 */
StructArray.prototype.DEFAULT_CAPACITY = 128;

/**
 * @property {number}
 * @private
 * @readonly
 */
StructArray.prototype.RESIZE_MULTIPLIER = 5;

/**
 * Serialize this StructArray instance
 * @private
 */
StructArray.prototype.serialize = function() {
    this.trim();
    return {
        length: this.length,
        arrayBuffer: this.arrayBuffer
    };
};

/**
 * Return the Struct at the given location in the array.
 * @private
 * @param {number} index The index of the element.
 */
StructArray.prototype.get = function(index) {
    return new this.StructType(this, index);
};

/**
 * Resize the array to discard unused capacity.
 * @private
 */
StructArray.prototype.trim = function() {
    if (this.length !== this.capacity) {
        this.capacity = this.length;
        this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement);
        this._refreshViews();
    }
};

/**
 * Resize the array.
 * If `n` is greater than the current length then additional elements with undefined values are added.
 * If `n` is less than the current length then the array will be reduced to the first `n` elements.
 * @param {number} n The new size of the array.
 */
StructArray.prototype.resize = function(n) {
    this.length = n;
    if (n > this.capacity) {
        this.capacity = Math.max(n, Math.floor(this.capacity * this.RESIZE_MULTIPLIER), this.DEFAULT_CAPACITY);
        this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);

        var oldUint8Array = this.uint8;
        this._refreshViews();
        if (oldUint8Array) this.uint8.set(oldUint8Array);
    }
};

/**
 * Create TypedArray views for the current ArrayBuffer.
 * @private
 */
StructArray.prototype._refreshViews = function() {
    for (var t = 0; t < this._usedTypes.length; t++) {
        var type = this._usedTypes[t];
        this[getArrayViewName(type)] = new viewTypes[type](this.arrayBuffer);
    }
};

/**
 * Output the `StructArray` between indices `startIndex` and `endIndex` as an array of `StructTypes` to enable sorting
 * @param {number} startIndex
 * @param {number} endIndex
 * @private
 */
StructArray.prototype.toArray = function(startIndex, endIndex) {
    var array = [];

    for (var i = startIndex; i < endIndex; i++) {
        var struct = this.get(i);
        array.push(struct);
    }

    return array;
};

},{"assert":122}],119:[function(require,module,exports){
'use strict';

module.exports = resolveTokens;

/**
 * Replace tokens in a string template with values in an object
 *
 * @param {Object} properties a key/value relationship between tokens and replacements
 * @param {string} text the template string
 * @returns {string} the template with tokens replaced
 * @private
 */
function resolveTokens(properties, text) {
    return text.replace(/{([^{}]+)}/g, function(match, key) {
        return key in properties ? properties[key] : '';
    });
}

},{}],120:[function(require,module,exports){
'use strict';

var UnitBezier = require('unitbezier');
var Coordinate = require('../geo/coordinate');

/**
 * Given a value `t` that varies between 0 and 1, return
 * an interpolation function that eases between 0 and 1 in a pleasing
 * cubic in-out fashion.
 *
 * @param {number} t input
 * @returns {number} input
 * @private
 */
exports.easeCubicInOut = function (t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t,
        t3 = t2 * t;
    return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
};

/**
 * Given given (x, y), (x1, y1) control points for a bezier curve,
 * return a function that interpolates along that curve.
 *
 * @param {number} p1x control point 1 x coordinate
 * @param {number} p1y control point 1 y coordinate
 * @param {number} p2x control point 2 x coordinate
 * @param {number} p2y control point 2 y coordinate
 * @returns {Function} interpolator: receives number value, returns
 * number value.
 * @private
 */
exports.bezier = function(p1x, p1y, p2x, p2y) {
    var bezier = new UnitBezier(p1x, p1y, p2x, p2y);
    return function(t) {
        return bezier.solve(t);
    };
};

/**
 * A default bezier-curve powered easing function with
 * control points (0.25, 0.1) and (0.25, 1)
 *
 * @param {number} t
 * @returns {number} output
 * @private
 */
exports.ease = exports.bezier(0.25, 0.1, 0.25, 1);

/**
 * constrain n to the given range via min + max
 *
 * @param {number} n value
 * @param {number} min the minimum value to be returned
 * @param {number} max the maximum value to be returned
 * @returns {number} the clamped value
 * @private
 */
exports.clamp = function (n, min, max) {
    return Math.min(max, Math.max(min, n));
};

/*
 * constrain n to the given range, excluding the minimum, via modular arithmetic
 * @param {number} n value
 * @param {number} min the minimum value to be returned, exclusive
 * @param {number} max the maximum value to be returned, inclusive
 * @returns {number} constrained number
 * @private
 */
exports.wrap = function (n, min, max) {
    var d = max - min;
    var w = ((n - min) % d + d) % d + min;
    return (w === min) ? max : w;
};

/*
 * return the first non-null and non-undefined argument to this function.
 * @returns {*} argument
 * @private
 */
exports.coalesce = function() {
    for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (arg !== null && arg !== undefined)
            return arg;
    }
};

/*
 * Call an asynchronous function on an array of arguments,
 * calling `callback` with the completed results of all calls.
 *
 * @param {Array<*>} array input to each call of the async function.
 * @param {Function} fn an async function with signature (data, callback)
 * @param {Function} callback a callback run after all async work is done.
 * called with an array, containing the results of each async call.
 * @returns {undefined}
 * @private
 */
exports.asyncAll = function (array, fn, callback) {
    if (!array.length) { return callback(null, []); }
    var remaining = array.length;
    var results = new Array(array.length);
    var error = null;
    array.forEach(function (item, i) {
        fn(item, function (err, result) {
            if (err) error = err;
            results[i] = result;
            if (--remaining === 0) callback(error, results);
        });
    });
};

/*
 * Compute the difference between the keys in one object and the keys
 * in another object.
 *
 * @param {Object} obj
 * @param {Object} other
 * @returns {Array<string>} keys difference
 * @private
 */
exports.keysDifference = function (obj, other) {
    var difference = [];
    for (var i in obj) {
        if (!(i in other)) {
            difference.push(i);
        }
    }
    return difference;
};

/**
 * Given a destination object and optionally many source objects,
 * copy all properties from the source objects into the destination.
 * The last source object given overrides properties from previous
 * source objects.
 * @param {Object} dest destination object
 * @param {...Object} sources sources from which properties are pulled
 * @returns {Object} dest
 * @private
 */
exports.extend = function (dest) {
    for (var i = 1; i < arguments.length; i++) {
        var src = arguments[i];
        for (var k in src) {
            dest[k] = src[k];
        }
    }
    return dest;
};

/**
 * Extend a destination object with all properties of the src object,
 * using defineProperty instead of simple assignment.
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 * @private
 */
exports.extendAll = function (dest, src) {
    for (var i in src) {
        Object.defineProperty(dest, i, Object.getOwnPropertyDescriptor(src, i));
    }
    return dest;
};

/**
 * Extend a parent's prototype with all properties in a properties
 * object.
 *
 * @param {Object} parent
 * @param {Object} props
 * @returns {Object}
 * @private
 */
exports.inherit = function (parent, props) {
    var parentProto = typeof parent === 'function' ? parent.prototype : parent,
        proto = Object.create(parentProto);
    exports.extendAll(proto, props);
    return proto;
};

/**
 * Given an object and a number of properties as strings, return version
 * of that object with only those properties.
 *
 * @param {Object} src the object
 * @param {Array<string>} properties an array of property names chosen
 * to appear on the resulting object.
 * @returns {Object} object with limited properties.
 * @example
 * var foo = { name: 'Charlie', age: 10 };
 * var justName = pick(foo, ['name']);
 * // justName = { name: 'Charlie' }
 * @private
 */
exports.pick = function (src, properties) {
    var result = {};
    for (var i = 0; i < properties.length; i++) {
        var k = properties[i];
        if (k in src) {
            result[k] = src[k];
        }
    }
    return result;
};

var id = 1;

/**
 * Return a unique numeric id, starting at 1 and incrementing with
 * each call.
 *
 * @returns {number} unique numeric id.
 * @private
 */
exports.uniqueId = function () {
    return id++;
};

/**
 * Create a version of `fn` that is only called `time` milliseconds
 * after its last invocation
 *
 * @param {Function} fn the function to be debounced
 * @param {number} time millseconds after which the function will be invoked
 * @returns {Function} debounced function
 * @private
 */
exports.debounce = function(fn, time) {
    var timer, args;

    return function() {
        args = arguments;
        clearTimeout(timer);

        timer = setTimeout(function() {
            fn.apply(null, args);
        }, time);
    };
};

/**
 * Given an array of member function names as strings, replace all of them
 * with bound versions that will always refer to `context` as `this`. This
 * is useful for classes where otherwise event bindings would reassign
 * `this` to the evented object or some other value: this lets you ensure
 * the `this` value always.
 *
 * @param {Array<string>} fns list of member function names
 * @param {*} context the context value
 * @returns {undefined} changes functions in-place
 * @example
 * function MyClass() {
 *   bindAll(['ontimer'], this);
 *   this.name = 'Tom';
 * }
 * MyClass.prototype.ontimer = function() {
 *   alert(this.name);
 * };
 * var myClass = new MyClass();
 * setTimeout(myClass.ontimer, 100);
 * @private
 */
exports.bindAll = function(fns, context) {
    fns.forEach(function(fn) {
        if (!context[fn]) { return; }
        context[fn] = context[fn].bind(context);
    });
};

/**
 * Given a class, bind all of the methods that look like handlers: that
 * begin with _on, and bind them to the class.
 *
 * @param {Object} context an object with methods
 * @private
 */
exports.bindHandlers = function(context) {
    for (var i in context) {
        if (typeof context[i] === 'function' && i.indexOf('_on') === 0) {
            context[i] = context[i].bind(context);
        }
    }
};

/**
 * Set the 'options' property on `obj` with properties
 * from the `options` argument. Properties in the `options`
 * object will override existing properties.
 *
 * @param {Object} obj destination object
 * @param {Object} options object of override options
 * @returns {Object} derived options object.
 * @private
 */
exports.setOptions = function(obj, options) {
    if (!obj.hasOwnProperty('options')) {
        obj.options = obj.options ? Object.create(obj.options) : {};
    }
    for (var i in options) {
        obj.options[i] = options[i];
    }
    return obj.options;
};

/**
 * Given a list of coordinates, get their center as a coordinate.
 * @param {Array<Coordinate>} coords
 * @returns {Coordinate} centerpoint
 * @private
 */
exports.getCoordinatesCenter = function(coords) {
    var minX = Infinity;
    var minY = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;

    for (var i = 0; i < coords.length; i++) {
        minX = Math.min(minX, coords[i].column);
        minY = Math.min(minY, coords[i].row);
        maxX = Math.max(maxX, coords[i].column);
        maxY = Math.max(maxY, coords[i].row);
    }

    var dx = maxX - minX;
    var dy = maxY - minY;
    var dMax = Math.max(dx, dy);
    return new Coordinate((minX + maxX) / 2, (minY + maxY) / 2, 0)
        .zoomTo(Math.floor(-Math.log(dMax) / Math.LN2));
};

/**
 * Determine if a string ends with a particular substring
 * @param {string} string
 * @param {string} suffix
 * @returns {boolean}
 * @private
 */
exports.endsWith = function(string, suffix) {
    return string.indexOf(suffix, string.length - suffix.length) !== -1;
};

/**
 * Determine if a string starts with a particular substring
 * @param {string} string
 * @param {string} prefix
 * @returns {boolean}
 * @private
 */
exports.startsWith = function(string, prefix) {
    return string.indexOf(prefix) === 0;
};

/**
 * Create an object by mapping all the values of an existing object while
 * preserving their keys.
 * @param {Object} input
 * @param {Function} iterator
 * @returns {Object}
 * @private
 */
exports.mapObject = function(input, iterator, context) {
    var output = {};
    for (var key in input) {
        output[key] = iterator.call(context || this, input[key], key, input);
    }
    return output;
};

/**
 * Create an object by filtering out values of an existing object
 * @param {Object} input
 * @param {Function} iterator
 * @returns {Object}
 * @private
 */
exports.filterObject = function(input, iterator, context) {
    var output = {};
    for (var key in input) {
        if (iterator.call(context || this, input[key], key, input)) {
            output[key] = input[key];
        }
    }
    return output;
};

/**
 * Deeply compares two object literals.
 * @param {Object} obj1
 * @param {Object} obj2
 * @returns {boolean}
 * @private
 */
exports.deepEqual = function deepEqual(a, b) {
    if (Array.isArray(a)) {
        if (!Array.isArray(b) || a.length !== b.length) return false;
        for (var i = 0; i < a.length; i++) {
            if (!deepEqual(a[i], b[i])) return false;
        }
        return true;
    }
    if (typeof a === 'object' && a !== null && b !== null) {
        if (!(typeof b === 'object')) return false;
        var keys = Object.keys(a);
        if (keys.length !== Object.keys(b).length) return false;
        for (var key in a) {
            if (!deepEqual(a[key], b[key])) return false;
        }
        return true;
    }
    return a === b;
};

/**
 * Deeply clones two objects.
 * @param {Object} obj1
 * @param {Object} obj2
 * @returns {boolean}
 * @private
 */
exports.clone = function deepEqual(input) {
    if (Array.isArray(input)) {
        return input.map(exports.clone);
    } else if (typeof input === 'object') {
        return exports.mapObject(input, exports.clone);
    } else {
        return input;
    }
};

/**
 * Check if two arrays have at least one common element.
 * @param {Array} a
 * @param {Array} b
 * @returns {boolean}
 * @private
 */
exports.arraysIntersect = function(a, b) {
    for (var l = 0; l < a.length; l++) {
        if (b.indexOf(a[l]) >= 0) return true;
    }
    return false;
};

var warnOnceHistory = {};
exports.warnOnce = function(message) {
    if (!warnOnceHistory[message]) {
        // console isn't defined in some WebWorkers, see #2558
        if (typeof console !== "undefined") console.warn(message);
        warnOnceHistory[message] = true;
    }
};

/**
 * Indicates if the provided Points are in a counter clockwise (true) or clockwise (false) order
 *
 * @param {Point} a
 * @param {Point} b
 * @param {Point} c
 *
 * @returns {boolean} true for a counter clockwise set of points
 */
// http://bryceboe.com/2006/10/23/line-segment-intersection-algorithm/
exports.isCounterClockwise = function(a, b, c) {
    return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);
};

/**
 * Returns the signed area for the polygon ring.  Postive areas are exterior rings and
 * have a clockwise winding.  Negative areas are interior rings and have a counter clockwise
 * ordering.
 *
 * @param {Array<Point>} ring - Exterior or interior ring
 *
 * @returns {number}
 */
exports.calculateSignedArea = function(ring) {
    var sum = 0;
    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
        p1 = ring[i];
        p2 = ring[j];
        sum += (p2.x - p1.x) * (p1.y + p2.y);
    }
    return sum;
};

/**
 * Detects closed polygons, first + last point are equal
 * @param {Array<Point>} points array of points
 *
 * @return {boolean} true if the points are a closed polygon
 */
exports.isClosedPolygon = function(points) {
    // If it is 2 points that are the same then it is a point
    // If it is 3 points with start and end the same then it is a line
    if (points.length < 4)
        return false;

    var p1 = points[0];
    var p2 = points[points.length - 1];

    if (Math.abs(p1.x - p2.x) > 0 ||
        Math.abs(p1.y - p2.y) > 0) {
        return false;
    }

    // polygon simplification can produce polygons with zero area and more than 3 points
    return (Math.abs(exports.calculateSignedArea(points)) > 0.01);
};

},{"../geo/coordinate":12,"unitbezier":197}],121:[function(require,module,exports){
'use strict';

module.exports = Feature;

function Feature(vectorTileFeature, z, x, y) {
    this._vectorTileFeature = vectorTileFeature;
    vectorTileFeature._z = z;
    vectorTileFeature._x = x;
    vectorTileFeature._y = y;

    this.properties = vectorTileFeature.properties;

    if (vectorTileFeature.id != null) {
        this.id = vectorTileFeature.id;
    }
}

Feature.prototype = {
    type: "Feature",

    get geometry() {
        if (this._geometry === undefined) {
            this._geometry = this._vectorTileFeature.toGeoJSON(
                this._vectorTileFeature._x,
                this._vectorTileFeature._y,
                this._vectorTileFeature._z).geometry;
        }
        return this._geometry;
    },

    set geometry(g) {
        this._geometry = g;
    },

    toJSON: function() {
        var json = {};
        for (var i in this) {
            if (i === '_geometry' || i === '_vectorTileFeature' || i === 'toJSON') continue;
            json[i] = this[i];
        }
        return json;
    }
};

},{}],122:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && !isFinite(value)) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) {
    return a === b;
  }
  var aIsArgs = isArguments(a),
      bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  var ka = objectKeys(a),
      kb = objectKeys(b),
      key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":133}],123:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],124:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":125}],125:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

(function () {
  try {
    cachedSetTimeout = setTimeout;
  } catch (e) {
    cachedSetTimeout = function () {
      throw new Error('setTimeout is not defined');
    }
  }
  try {
    cachedClearTimeout = clearTimeout;
  } catch (e) {
    cachedClearTimeout = function () {
      throw new Error('clearTimeout is not defined');
    }
  }
} ())
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = cachedSetTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    cachedClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        cachedSetTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],126:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],127:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],128:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],129:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":127,"./encode":128}],130:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":131,"punycode":126,"querystring":129}],131:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],132:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],133:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":132,"_process":125,"inherits":123}],134:[function(require,module,exports){
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.

// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
  "transparent": [0,0,0,0], "aliceblue": [240,248,255,1],
  "antiquewhite": [250,235,215,1], "aqua": [0,255,255,1],
  "aquamarine": [127,255,212,1], "azure": [240,255,255,1],
  "beige": [245,245,220,1], "bisque": [255,228,196,1],
  "black": [0,0,0,1], "blanchedalmond": [255,235,205,1],
  "blue": [0,0,255,1], "blueviolet": [138,43,226,1],
  "brown": [165,42,42,1], "burlywood": [222,184,135,1],
  "cadetblue": [95,158,160,1], "chartreuse": [127,255,0,1],
  "chocolate": [210,105,30,1], "coral": [255,127,80,1],
  "cornflowerblue": [100,149,237,1], "cornsilk": [255,248,220,1],
  "crimson": [220,20,60,1], "cyan": [0,255,255,1],
  "darkblue": [0,0,139,1], "darkcyan": [0,139,139,1],
  "darkgoldenrod": [184,134,11,1], "darkgray": [169,169,169,1],
  "darkgreen": [0,100,0,1], "darkgrey": [169,169,169,1],
  "darkkhaki": [189,183,107,1], "darkmagenta": [139,0,139,1],
  "darkolivegreen": [85,107,47,1], "darkorange": [255,140,0,1],
  "darkorchid": [153,50,204,1], "darkred": [139,0,0,1],
  "darksalmon": [233,150,122,1], "darkseagreen": [143,188,143,1],
  "darkslateblue": [72,61,139,1], "darkslategray": [47,79,79,1],
  "darkslategrey": [47,79,79,1], "darkturquoise": [0,206,209,1],
  "darkviolet": [148,0,211,1], "deeppink": [255,20,147,1],
  "deepskyblue": [0,191,255,1], "dimgray": [105,105,105,1],
  "dimgrey": [105,105,105,1], "dodgerblue": [30,144,255,1],
  "firebrick": [178,34,34,1], "floralwhite": [255,250,240,1],
  "forestgreen": [34,139,34,1], "fuchsia": [255,0,255,1],
  "gainsboro": [220,220,220,1], "ghostwhite": [248,248,255,1],
  "gold": [255,215,0,1], "goldenrod": [218,165,32,1],
  "gray": [128,128,128,1], "green": [0,128,0,1],
  "greenyellow": [173,255,47,1], "grey": [128,128,128,1],
  "honeydew": [240,255,240,1], "hotpink": [255,105,180,1],
  "indianred": [205,92,92,1], "indigo": [75,0,130,1],
  "ivory": [255,255,240,1], "khaki": [240,230,140,1],
  "lavender": [230,230,250,1], "lavenderblush": [255,240,245,1],
  "lawngreen": [124,252,0,1], "lemonchiffon": [255,250,205,1],
  "lightblue": [173,216,230,1], "lightcoral": [240,128,128,1],
  "lightcyan": [224,255,255,1], "lightgoldenrodyellow": [250,250,210,1],
  "lightgray": [211,211,211,1], "lightgreen": [144,238,144,1],
  "lightgrey": [211,211,211,1], "lightpink": [255,182,193,1],
  "lightsalmon": [255,160,122,1], "lightseagreen": [32,178,170,1],
  "lightskyblue": [135,206,250,1], "lightslategray": [119,136,153,1],
  "lightslategrey": [119,136,153,1], "lightsteelblue": [176,196,222,1],
  "lightyellow": [255,255,224,1], "lime": [0,255,0,1],
  "limegreen": [50,205,50,1], "linen": [250,240,230,1],
  "magenta": [255,0,255,1], "maroon": [128,0,0,1],
  "mediumaquamarine": [102,205,170,1], "mediumblue": [0,0,205,1],
  "mediumorchid": [186,85,211,1], "mediumpurple": [147,112,219,1],
  "mediumseagreen": [60,179,113,1], "mediumslateblue": [123,104,238,1],
  "mediumspringgreen": [0,250,154,1], "mediumturquoise": [72,209,204,1],
  "mediumvioletred": [199,21,133,1], "midnightblue": [25,25,112,1],
  "mintcream": [245,255,250,1], "mistyrose": [255,228,225,1],
  "moccasin": [255,228,181,1], "navajowhite": [255,222,173,1],
  "navy": [0,0,128,1], "oldlace": [253,245,230,1],
  "olive": [128,128,0,1], "olivedrab": [107,142,35,1],
  "orange": [255,165,0,1], "orangered": [255,69,0,1],
  "orchid": [218,112,214,1], "palegoldenrod": [238,232,170,1],
  "palegreen": [152,251,152,1], "paleturquoise": [175,238,238,1],
  "palevioletred": [219,112,147,1], "papayawhip": [255,239,213,1],
  "peachpuff": [255,218,185,1], "peru": [205,133,63,1],
  "pink": [255,192,203,1], "plum": [221,160,221,1],
  "powderblue": [176,224,230,1], "purple": [128,0,128,1],
  "red": [255,0,0,1], "rosybrown": [188,143,143,1],
  "royalblue": [65,105,225,1], "saddlebrown": [139,69,19,1],
  "salmon": [250,128,114,1], "sandybrown": [244,164,96,1],
  "seagreen": [46,139,87,1], "seashell": [255,245,238,1],
  "sienna": [160,82,45,1], "silver": [192,192,192,1],
  "skyblue": [135,206,235,1], "slateblue": [106,90,205,1],
  "slategray": [112,128,144,1], "slategrey": [112,128,144,1],
  "snow": [255,250,250,1], "springgreen": [0,255,127,1],
  "steelblue": [70,130,180,1], "tan": [210,180,140,1],
  "teal": [0,128,128,1], "thistle": [216,191,216,1],
  "tomato": [255,99,71,1], "turquoise": [64,224,208,1],
  "violet": [238,130,238,1], "wheat": [245,222,179,1],
  "white": [255,255,255,1], "whitesmoke": [245,245,245,1],
  "yellow": [255,255,0,1], "yellowgreen": [154,205,50,1]}

function clamp_css_byte(i) {  // Clamp to integer 0 .. 255.
  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
  return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.
  return f < 0 ? 0 : f > 1 ? 1 : f;
}

function parse_css_int(str) {  // int or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_byte(parseFloat(str) / 100 * 255);
  return clamp_css_byte(parseInt(str));
}

function parse_css_float(str) {  // float or percentage.
  if (str[str.length - 1] === '%')
    return clamp_css_float(parseFloat(str) / 100);
  return clamp_css_float(parseFloat(str));
}

function css_hue_to_rgb(m1, m2, h) {
  if (h < 0) h += 1;
  else if (h > 1) h -= 1;

  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
  if (h * 2 < 1) return m2;
  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;
  return m1;
}

function parseCSSColor(css_str) {
  // Remove all whitespace, not compliant, but should just be more accepting.
  var str = css_str.replace(/ /g, '').toLowerCase();

  // Color keywords (and transparent) lookup.
  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.

  // #abc and #abc123 syntax.
  if (str[0] === '#') {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.
      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
              (iv & 0xf0) | ((iv & 0xf0) >> 4),
              (iv & 0xf) | ((iv & 0xf) << 4),
              1];
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.
      return [(iv & 0xff0000) >> 16,
              (iv & 0xff00) >> 8,
              iv & 0xff,
              1];
    }

    return null;
  }

  var op = str.indexOf('('), ep = str.indexOf(')');
  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op+1, ep-(op+1)).split(',');
    var alpha = 1;  // To allow case fallthrough.
    switch (fname) {
      case 'rgba':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'rgb':
        if (params.length !== 3) return null;
        return [parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha];
      case 'hsla':
        if (params.length !== 4) return null;
        alpha = parse_css_float(params.pop());
        // Fall through.
      case 'hsl':
        if (params.length !== 3) return null;
        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
        // NOTE(deanm): According to the CSS spec s/l should only be
        // percentages, but we don't bother and let float or percentage.
        var s = parse_css_float(params[1]);
        var l = parse_css_float(params[2]);
        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        var m1 = l * 2 - m2;
        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),
                alpha];
      default:
        return null;
    }
  }

  return null;
}

try { exports.parseCSSColor = parseCSSColor } catch(e) { }

},{}],135:[function(require,module,exports){
'use strict';

module.exports = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode) return triangles;

    var minX, minY, maxX, maxY, x, y, size;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and size are later used to transform coords into integers for z-order calculation
        size = Math.max(maxX - minX, maxY - minY);
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, size);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) return null;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && size) indexCurve(ear, minX, minY, size);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, size, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, size);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, size) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, size),
        maxZ = zOrder(maxTX, maxTY, minX, minY, size);

    // first look for points inside the triangle in increasing z-order
    var p = ear.nextZ;

    while (p && p.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.nextZ;
    }

    // then look for points in decreasing z-order
    p = ear.prevZ;

    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, size) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, size);
                earcutLinked(c, triangles, dim, minX, minY, size);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, size) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }

            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize === 0) {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                } else if (qSize === 0 || !q) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else if (p.z <= q.z) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and size of the data bounding box
function zOrder(x, y, minX, minY, size) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) / size;
    y = 32767 * (y - minY) / size;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};

},{}],136:[function(require,module,exports){
'use strict';

module.exports = createFilter;

var types = ['Unknown', 'Point', 'LineString', 'Polygon'];

/**
 * Given a filter expressed as nested arrays, return a new function
 * that evaluates whether a given feature (with a .properties or .tags property)
 * passes its test.
 *
 * @param {Array} filter mapbox gl filter
 * @returns {Function} filter-evaluating function
 */
function createFilter(filter) {
    return new Function('f', 'var p = (f && f.properties || {}); return ' + compile(filter));
}

function compile(filter) {
    if (!filter) return 'true';
    var op = filter[0];
    if (filter.length <= 1) return op === 'any' ? 'false' : 'true';
    var str =
        op === '==' ? compileComparisonOp(filter[1], filter[2], '===', false) :
        op === '!=' ? compileComparisonOp(filter[1], filter[2], '!==', false) :
        op === '<' ||
        op === '>' ||
        op === '<=' ||
        op === '>=' ? compileComparisonOp(filter[1], filter[2], op, true) :
        op === 'any' ? compileLogicalOp(filter.slice(1), '||') :
        op === 'all' ? compileLogicalOp(filter.slice(1), '&&') :
        op === 'none' ? compileNegation(compileLogicalOp(filter.slice(1), '||')) :
        op === 'in' ? compileInOp(filter[1], filter.slice(2)) :
        op === '!in' ? compileNegation(compileInOp(filter[1], filter.slice(2))) :
        op === 'has' ? compileHasOp(filter[1]) :
        op === '!has' ? compileNegation(compileHasOp([filter[1]])) :
        'true';
    return '(' + str + ')';
}

function compilePropertyReference(property) {
    return property === '$type' ? 'f.type' : 'p[' + JSON.stringify(property) + ']';
}

function compileComparisonOp(property, value, op, checkType) {
    var left = compilePropertyReference(property);
    var right = property === '$type' ? types.indexOf(value) : JSON.stringify(value);
    return (checkType ? 'typeof ' + left + '=== typeof ' + right + '&&' : '') + left + op + right;
}

function compileLogicalOp(expressions, op) {
    return expressions.map(compile).join(op);
}

function compileInOp(property, values) {
    if (property === '$type') values = values.map(function(value) { return types.indexOf(value); });
    var left = JSON.stringify(values.sort(compare));
    var right = compilePropertyReference(property);

    if (values.length <= 200) return left + '.indexOf(' + right + ') !== -1';

    return 'function(v, a, i, j) {' +
        'while (i <= j) { var m = (i + j) >> 1;' +
        '    if (a[m] === v) return true; if (a[m] > v) j = m - 1; else i = m + 1;' +
        '}' +
    'return false; }(' + right + ', ' + left + ',0,' + (values.length - 1) + ')';
}

function compileHasOp(property) {
    return JSON.stringify(property) + ' in p';
}

function compileNegation(expression) {
    return '!(' + expression + ')';
}

// Comparison function to sort numbers and strings
function compare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

},{}],137:[function(require,module,exports){
var geojsonArea = require('geojson-area');

module.exports = rewind;

function rewind(gj, outer) {
    switch ((gj && gj.type) || null) {
        case 'FeatureCollection':
            gj.features = gj.features.map(curryOuter(rewind, outer));
            return gj;
        case 'Feature':
            gj.geometry = rewind(gj.geometry, outer);
            return gj;
        case 'Polygon':
        case 'MultiPolygon':
            return correct(gj, outer);
        default:
            return gj;
    }
}

function curryOuter(a, b) {
    return function(_) { return a(_, b); };
}

function correct(_, outer) {
    if (_.type === 'Polygon') {
        _.coordinates = correctRings(_.coordinates, outer);
    } else if (_.type === 'MultiPolygon') {
        _.coordinates = _.coordinates.map(curryOuter(correctRings, outer));
    }
    return _;
}

function correctRings(_, outer) {
    outer = !!outer;
    _[0] = wind(_[0], !outer);
    for (var i = 1; i < _.length; i++) {
        _[i] = wind(_[i], outer);
    }
    return _;
}

function wind(_, dir) {
    return cw(_) === dir ? _ : _.reverse();
}

function cw(_) {
    return geojsonArea.ring(_) >= 0;
}

},{"geojson-area":138}],138:[function(require,module,exports){
var wgs84 = require('wgs84');

module.exports.geometry = geometry;
module.exports.ring = ringArea;

function geometry(_) {
    if (_.type === 'Polygon') return polygonArea(_.coordinates);
    else if (_.type === 'MultiPolygon') {
        var area = 0;
        for (var i = 0; i < _.coordinates.length; i++) {
            area += polygonArea(_.coordinates[i]);
        }
        return area;
    } else {
        return null;
    }
}

function polygonArea(coords) {
    var area = 0;
    if (coords && coords.length > 0) {
        area += Math.abs(ringArea(coords[0]));
        for (var i = 1; i < coords.length; i++) {
            area -= Math.abs(ringArea(coords[i]));
        }
    }
    return area;
}

/**
 * Calculate the approximate area of the polygon were it projected onto
 *     the earth.  Note that this area will be positive if ring is oriented
 *     clockwise, otherwise it will be negative.
 *
 * Reference:
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
 *
 * Returns:
 * {float} The approximate signed geodesic area of the polygon in square
 *     meters.
 */

function ringArea(coords) {
    var area = 0;

    if (coords.length > 2) {
        var p1, p2;
        for (var i = 0; i < coords.length - 1; i++) {
            p1 = coords[i];
            p2 = coords[i + 1];
            area += rad(p2[0] - p1[0]) * (2 + Math.sin(rad(p1[1])) + Math.sin(rad(p2[1])));
        }

        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
    }

    return area;
}

function rad(_) {
    return _ * Math.PI / 180;
}

},{"wgs84":139}],139:[function(require,module,exports){
module.exports.RADIUS = 6378137;
module.exports.FLATTENING = 1/298.257223563;
module.exports.POLAR_RADIUS = 6356752.3142;

},{}],140:[function(require,module,exports){
'use strict';

module.exports = clip;

/* clip features between two axis-parallel lines:
 *     |        |
 *  ___|___     |     /
 * /   |   \____|____/
 *     |        |
 */

function clip(features, scale, k1, k2, axis, intersect, minAll, maxAll) {

    k1 /= scale;
    k2 /= scale;

    if (minAll >= k1 && maxAll <= k2) return features; // trivial accept
    else if (minAll > k2 || maxAll < k1) return null; // trivial reject

    var clipped = [];

    for (var i = 0; i < features.length; i++) {

        var feature = features[i],
            geometry = feature.geometry,
            type = feature.type,
            min, max;

        min = feature.min[axis];
        max = feature.max[axis];

        if (min >= k1 && max <= k2) { // trivial accept
            clipped.push(feature);
            continue;
        } else if (min > k2 || max < k1) continue; // trivial reject

        var slices = type === 1 ?
                clipPoints(geometry, k1, k2, axis) :
                clipGeometry(geometry, k1, k2, axis, intersect, type === 3);

        if (slices.length) {
            // if a feature got clipped, it will likely get clipped on the next zoom level as well,
            // so there's no need to recalculate bboxes
            clipped.push({
                geometry: slices,
                type: type,
                tags: features[i].tags || null,
                min: feature.min,
                max: feature.max
            });
        }
    }

    return clipped.length ? clipped : null;
}

function clipPoints(geometry, k1, k2, axis) {
    var slice = [];

    for (var i = 0; i < geometry.length; i++) {
        var a = geometry[i],
            ak = a[axis];

        if (ak >= k1 && ak <= k2) slice.push(a);
    }
    return slice;
}

function clipGeometry(geometry, k1, k2, axis, intersect, closed) {

    var slices = [];

    for (var i = 0; i < geometry.length; i++) {

        var ak = 0,
            bk = 0,
            b = null,
            points = geometry[i],
            area = points.area,
            dist = points.dist,
            outer = points.outer,
            len = points.length,
            a, j, last;

        var slice = [];

        for (j = 0; j < len - 1; j++) {
            a = b || points[j];
            b = points[j + 1];
            ak = bk || a[axis];
            bk = b[axis];

            if (ak < k1) {

                if ((bk > k2)) { // ---|-----|-->
                    slice.push(intersect(a, b, k1), intersect(a, b, k2));
                    if (!closed) slice = newSlice(slices, slice, area, dist, outer);

                } else if (bk >= k1) slice.push(intersect(a, b, k1)); // ---|-->  |

            } else if (ak > k2) {

                if ((bk < k1)) { // <--|-----|---
                    slice.push(intersect(a, b, k2), intersect(a, b, k1));
                    if (!closed) slice = newSlice(slices, slice, area, dist, outer);

                } else if (bk <= k2) slice.push(intersect(a, b, k2)); // |  <--|---

            } else {

                slice.push(a);

                if (bk < k1) { // <--|---  |
                    slice.push(intersect(a, b, k1));
                    if (!closed) slice = newSlice(slices, slice, area, dist, outer);

                } else if (bk > k2) { // |  ---|-->
                    slice.push(intersect(a, b, k2));
                    if (!closed) slice = newSlice(slices, slice, area, dist, outer);
                }
                // | --> |
            }
        }

        // add the last point
        a = points[len - 1];
        ak = a[axis];
        if (ak >= k1 && ak <= k2) slice.push(a);

        // close the polygon if its endpoints are not the same after clipping

        last = slice[slice.length - 1];
        if (closed && last && (slice[0][0] !== last[0] || slice[0][1] !== last[1])) slice.push(slice[0]);

        // add the final slice
        newSlice(slices, slice, area, dist, outer);
    }

    return slices;
}

function newSlice(slices, slice, area, dist, outer) {
    if (slice.length) {
        // we don't recalculate the area/length of the unclipped geometry because the case where it goes
        // below the visibility threshold as a result of clipping is rare, so we avoid doing unnecessary work
        slice.area = area;
        slice.dist = dist;
        if (outer !== undefined) slice.outer = outer;

        slices.push(slice);
    }
    return [];
}

},{}],141:[function(require,module,exports){
'use strict';

module.exports = convert;

var simplify = require('./simplify');

// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data

function convert(data, tolerance) {
    var features = [];

    if (data.type === 'FeatureCollection') {
        for (var i = 0; i < data.features.length; i++) {
            convertFeature(features, data.features[i], tolerance);
        }
    } else if (data.type === 'Feature') {
        convertFeature(features, data, tolerance);

    } else {
        // single geometry or a geometry collection
        convertFeature(features, {geometry: data}, tolerance);
    }
    return features;
}

function convertFeature(features, feature, tolerance) {
    if (feature.geometry === null) {
        // ignore features with null geometry
        return;
    }

    var geom = feature.geometry,
        type = geom.type,
        coords = geom.coordinates,
        tags = feature.properties,
        i, j, rings, projectedRing;

    if (type === 'Point') {
        features.push(create(tags, 1, [projectPoint(coords)]));

    } else if (type === 'MultiPoint') {
        features.push(create(tags, 1, project(coords)));

    } else if (type === 'LineString') {
        features.push(create(tags, 2, [project(coords, tolerance)]));

    } else if (type === 'MultiLineString' || type === 'Polygon') {
        rings = [];
        for (i = 0; i < coords.length; i++) {
            projectedRing = project(coords[i], tolerance);
            if (type === 'Polygon') projectedRing.outer = (i === 0);
            rings.push(projectedRing);
        }
        features.push(create(tags, type === 'Polygon' ? 3 : 2, rings));

    } else if (type === 'MultiPolygon') {
        rings = [];
        for (i = 0; i < coords.length; i++) {
            for (j = 0; j < coords[i].length; j++) {
                projectedRing = project(coords[i][j], tolerance);
                projectedRing.outer = (j === 0);
                rings.push(projectedRing);
            }
        }
        features.push(create(tags, 3, rings));

    } else if (type === 'GeometryCollection') {
        for (i = 0; i < geom.geometries.length; i++) {
            convertFeature(features, {
                geometry: geom.geometries[i],
                properties: tags
            }, tolerance);
        }

    } else {
        throw new Error('Input data is not a valid GeoJSON object.');
    }
}

function create(tags, type, geometry) {
    var feature = {
        geometry: geometry,
        type: type,
        tags: tags || null,
        min: [2, 1], // initial bbox values;
        max: [-1, 0]  // note that coords are usually in [0..1] range
    };
    calcBBox(feature);
    return feature;
}

function project(lonlats, tolerance) {
    var projected = [];
    for (var i = 0; i < lonlats.length; i++) {
        projected.push(projectPoint(lonlats[i]));
    }
    if (tolerance) {
        simplify(projected, tolerance);
        calcSize(projected);
    }
    return projected;
}

function projectPoint(p) {
    var sin = Math.sin(p[1] * Math.PI / 180),
        x = (p[0] / 360 + 0.5),
        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);

    y = y < 0 ? 0 :
        y > 1 ? 1 : y;

    return [x, y, 0];
}

// calculate area and length of the poly
function calcSize(points) {
    var area = 0,
        dist = 0;

    for (var i = 0, a, b; i < points.length - 1; i++) {
        a = b || points[i];
        b = points[i + 1];

        area += a[0] * b[1] - b[0] * a[1];

        // use Manhattan distance instead of Euclidian one to avoid expensive square root computation
        dist += Math.abs(b[0] - a[0]) + Math.abs(b[1] - a[1]);
    }
    points.area = Math.abs(area / 2);
    points.dist = dist;
}

// calculate the feature bounding box for faster clipping later
function calcBBox(feature) {
    var geometry = feature.geometry,
        min = feature.min,
        max = feature.max;

    if (feature.type === 1) calcRingBBox(min, max, geometry);
    else for (var i = 0; i < geometry.length; i++) calcRingBBox(min, max, geometry[i]);

    return feature;
}

function calcRingBBox(min, max, points) {
    for (var i = 0, p; i < points.length; i++) {
        p = points[i];
        min[0] = Math.min(p[0], min[0]);
        max[0] = Math.max(p[0], max[0]);
        min[1] = Math.min(p[1], min[1]);
        max[1] = Math.max(p[1], max[1]);
    }
}

},{"./simplify":143}],142:[function(require,module,exports){
'use strict';

module.exports = geojsonvt;

var convert = require('./convert'),     // GeoJSON conversion and preprocessing
    transform = require('./transform'), // coordinate transformation
    clip = require('./clip'),           // stripe clipping algorithm
    wrap = require('./wrap'),           // date line processing
    createTile = require('./tile');     // final simplified tile generation


function geojsonvt(data, options) {
    return new GeoJSONVT(data, options);
}

function GeoJSONVT(data, options) {
    options = this.options = extend(Object.create(this.options), options);

    var debug = options.debug;

    if (debug) console.time('preprocess data');

    var z2 = 1 << options.maxZoom, // 2^z
        features = convert(data, options.tolerance / (z2 * options.extent));

    this.tiles = {};
    this.tileCoords = [];

    if (debug) {
        console.timeEnd('preprocess data');
        console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);
        console.time('generate tiles');
        this.stats = {};
        this.total = 0;
    }

    features = wrap(features, options.buffer / options.extent, intersectX);

    // start slicing from the top tile down
    if (features.length) this.splitTile(features, 0, 0, 0);

    if (debug) {
        if (features.length) console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints);
        console.timeEnd('generate tiles');
        console.log('tiles generated:', this.total, JSON.stringify(this.stats));
    }
}

GeoJSONVT.prototype.options = {
    maxZoom: 14,            // max zoom to preserve detail on
    indexMaxZoom: 5,        // max zoom in the tile index
    indexMaxPoints: 100000, // max number of points per tile in the tile index
    solidChildren: false,   // whether to tile solid square tiles further
    tolerance: 3,           // simplification tolerance (higher means simpler)
    extent: 4096,           // tile extent
    buffer: 64,             // tile buffer on each side
    debug: 0                // logging level (0, 1 or 2)
};

GeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {

    var stack = [features, z, x, y],
        options = this.options,
        debug = options.debug,
        solid = null;

    // avoid recursion by using a processing queue
    while (stack.length) {
        y = stack.pop();
        x = stack.pop();
        z = stack.pop();
        features = stack.pop();

        var z2 = 1 << z,
            id = toID(z, x, y),
            tile = this.tiles[id],
            tileTolerance = z === options.maxZoom ? 0 : options.tolerance / (z2 * options.extent);

        if (!tile) {
            if (debug > 1) console.time('creation');

            tile = this.tiles[id] = createTile(features, z2, x, y, tileTolerance, z === options.maxZoom);
            this.tileCoords.push({z: z, x: x, y: y});

            if (debug) {
                if (debug > 1) {
                    console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',
                        z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);
                    console.timeEnd('creation');
                }
                var key = 'z' + z;
                this.stats[key] = (this.stats[key] || 0) + 1;
                this.total++;
            }
        }

        // save reference to original geometry in tile so that we can drill down later if we stop now
        tile.source = features;

        // if it's the first-pass tiling
        if (!cz) {
            // stop tiling if we reached max zoom, or if the tile is too simple
            if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) continue;

        // if a drilldown to a specific tile
        } else {
            // stop tiling if we reached base zoom or our target tile zoom
            if (z === options.maxZoom || z === cz) continue;

            // stop tiling if it's not an ancestor of the target tile
            var m = 1 << (cz - z);
            if (x !== Math.floor(cx / m) || y !== Math.floor(cy / m)) continue;
        }

        // stop tiling if the tile is solid clipped square
        if (!options.solidChildren && isClippedSquare(tile, options.extent, options.buffer)) {
            if (cz) solid = z; // and remember the zoom if we're drilling down
            continue;
        }

        // if we slice further down, no need to keep source geometry
        tile.source = null;

        if (debug > 1) console.time('clipping');

        // values we'll use for clipping
        var k1 = 0.5 * options.buffer / options.extent,
            k2 = 0.5 - k1,
            k3 = 0.5 + k1,
            k4 = 1 + k1,
            tl, bl, tr, br, left, right;

        tl = bl = tr = br = null;

        left  = clip(features, z2, x - k1, x + k3, 0, intersectX, tile.min[0], tile.max[0]);
        right = clip(features, z2, x + k2, x + k4, 0, intersectX, tile.min[0], tile.max[0]);

        if (left) {
            tl = clip(left, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
            bl = clip(left, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
        }

        if (right) {
            tr = clip(right, z2, y - k1, y + k3, 1, intersectY, tile.min[1], tile.max[1]);
            br = clip(right, z2, y + k2, y + k4, 1, intersectY, tile.min[1], tile.max[1]);
        }

        if (debug > 1) console.timeEnd('clipping');

        if (tl) stack.push(tl, z + 1, x * 2,     y * 2);
        if (bl) stack.push(bl, z + 1, x * 2,     y * 2 + 1);
        if (tr) stack.push(tr, z + 1, x * 2 + 1, y * 2);
        if (br) stack.push(br, z + 1, x * 2 + 1, y * 2 + 1);
    }

    return solid;
};

GeoJSONVT.prototype.getTile = function (z, x, y) {
    var options = this.options,
        extent = options.extent,
        debug = options.debug;

    var z2 = 1 << z;
    x = ((x % z2) + z2) % z2; // wrap tile x coordinate

    var id = toID(z, x, y);
    if (this.tiles[id]) return transform.tile(this.tiles[id], extent);

    if (debug > 1) console.log('drilling down to z%d-%d-%d', z, x, y);

    var z0 = z,
        x0 = x,
        y0 = y,
        parent;

    while (!parent && z0 > 0) {
        z0--;
        x0 = Math.floor(x0 / 2);
        y0 = Math.floor(y0 / 2);
        parent = this.tiles[toID(z0, x0, y0)];
    }

    if (!parent || !parent.source) return null;

    // if we found a parent tile containing the original geometry, we can drill down from it
    if (debug > 1) console.log('found parent tile z%d-%d-%d', z0, x0, y0);

    // it parent tile is a solid clipped square, return it instead since it's identical
    if (isClippedSquare(parent, extent, options.buffer)) return transform.tile(parent, extent);

    if (debug > 1) console.time('drilling down');
    var solid = this.splitTile(parent.source, z0, x0, y0, z, x, y);
    if (debug > 1) console.timeEnd('drilling down');

    // one of the parent tiles was a solid clipped square
    if (solid !== null) {
        var m = 1 << (z - solid);
        id = toID(solid, Math.floor(x / m), Math.floor(y / m));
    }

    return this.tiles[id] ? transform.tile(this.tiles[id], extent) : null;
};

function toID(z, x, y) {
    return (((1 << z) * y + x) * 32) + z;
}

function intersectX(a, b, x) {
    return [x, (x - a[0]) * (b[1] - a[1]) / (b[0] - a[0]) + a[1], 1];
}
function intersectY(a, b, y) {
    return [(y - a[1]) * (b[0] - a[0]) / (b[1] - a[1]) + a[0], y, 1];
}

function extend(dest, src) {
    for (var i in src) dest[i] = src[i];
    return dest;
}

// checks whether a tile is a whole-area fill after clipping; if it is, there's no sense slicing it further
function isClippedSquare(tile, extent, buffer) {

    var features = tile.source;
    if (features.length !== 1) return false;

    var feature = features[0];
    if (feature.type !== 3 || feature.geometry.length > 1) return false;

    var len = feature.geometry[0].length;
    if (len !== 5) return false;

    for (var i = 0; i < len; i++) {
        var p = transform.point(feature.geometry[0][i], extent, tile.z2, tile.x, tile.y);
        if ((p[0] !== -buffer && p[0] !== extent + buffer) ||
            (p[1] !== -buffer && p[1] !== extent + buffer)) return false;
    }

    return true;
}

},{"./clip":140,"./convert":141,"./tile":144,"./transform":145,"./wrap":146}],143:[function(require,module,exports){
'use strict';

module.exports = simplify;

// calculate simplification data using optimized Douglas-Peucker algorithm

function simplify(points, tolerance) {

    var sqTolerance = tolerance * tolerance,
        len = points.length,
        first = 0,
        last = len - 1,
        stack = [],
        i, maxSqDist, sqDist, index;

    // always retain the endpoints (1 is the max value)
    points[first][2] = 1;
    points[last][2] = 1;

    // avoid recursion by using a stack
    while (last) {

        maxSqDist = 0;

        for (i = first + 1; i < last; i++) {
            sqDist = getSqSegDist(points[i], points[first], points[last]);

            if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
            }
        }

        if (maxSqDist > sqTolerance) {
            points[index][2] = maxSqDist; // save the point importance in squared pixels as a z coordinate
            stack.push(first);
            stack.push(index);
            first = index;

        } else {
            last = stack.pop();
            first = stack.pop();
        }
    }
}

// square distance from a point to a segment
function getSqSegDist(p, a, b) {

    var x = a[0], y = a[1],
        bx = b[0], by = b[1],
        px = p[0], py = p[1],
        dx = bx - x,
        dy = by - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = bx;
            y = by;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = px - x;
    dy = py - y;

    return dx * dx + dy * dy;
}

},{}],144:[function(require,module,exports){
'use strict';

module.exports = createTile;

function createTile(features, z2, tx, ty, tolerance, noSimplify) {
    var tile = {
        features: [],
        numPoints: 0,
        numSimplified: 0,
        numFeatures: 0,
        source: null,
        x: tx,
        y: ty,
        z2: z2,
        transformed: false,
        min: [2, 1],
        max: [-1, 0]
    };
    for (var i = 0; i < features.length; i++) {
        tile.numFeatures++;
        addFeature(tile, features[i], tolerance, noSimplify);

        var min = features[i].min,
            max = features[i].max;

        if (min[0] < tile.min[0]) tile.min[0] = min[0];
        if (min[1] < tile.min[1]) tile.min[1] = min[1];
        if (max[0] > tile.max[0]) tile.max[0] = max[0];
        if (max[1] > tile.max[1]) tile.max[1] = max[1];
    }
    return tile;
}

function addFeature(tile, feature, tolerance, noSimplify) {

    var geom = feature.geometry,
        type = feature.type,
        simplified = [],
        sqTolerance = tolerance * tolerance,
        i, j, ring, p;

    if (type === 1) {
        for (i = 0; i < geom.length; i++) {
            simplified.push(geom[i]);
            tile.numPoints++;
            tile.numSimplified++;
        }

    } else {

        // simplify and transform projected coordinates for tile geometry
        for (i = 0; i < geom.length; i++) {
            ring = geom[i];

            // filter out tiny polylines & polygons
            if (!noSimplify && ((type === 2 && ring.dist < tolerance) ||
                                (type === 3 && ring.area < sqTolerance))) {
                tile.numPoints += ring.length;
                continue;
            }

            var simplifiedRing = [];

            for (j = 0; j < ring.length; j++) {
                p = ring[j];
                // keep points with importance > tolerance
                if (noSimplify || p[2] > sqTolerance) {
                    simplifiedRing.push(p);
                    tile.numSimplified++;
                }
                tile.numPoints++;
            }

            if (type === 3) rewind(simplifiedRing, ring.outer);

            simplified.push(simplifiedRing);
        }
    }

    if (simplified.length) {
        tile.features.push({
            geometry: simplified,
            type: type,
            tags: feature.tags || null
        });
    }
}

function rewind(ring, clockwise) {
    var area = signedArea(ring);
    if (area < 0 === clockwise) ring.reverse();
}

function signedArea(ring) {
    var sum = 0;
    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
        p1 = ring[i];
        p2 = ring[j];
        sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);
    }
    return sum;
}

},{}],145:[function(require,module,exports){
'use strict';

exports.tile = transformTile;
exports.point = transformPoint;

// Transforms the coordinates of each feature in the given tile from
// mercator-projected space into (extent x extent) tile space.
function transformTile(tile, extent) {
    if (tile.transformed) return tile;

    var z2 = tile.z2,
        tx = tile.x,
        ty = tile.y,
        i, j, k;

    for (i = 0; i < tile.features.length; i++) {
        var feature = tile.features[i],
            geom = feature.geometry,
            type = feature.type;

        if (type === 1) {
            for (j = 0; j < geom.length; j++) geom[j] = transformPoint(geom[j], extent, z2, tx, ty);

        } else {
            for (j = 0; j < geom.length; j++) {
                var ring = geom[j];
                for (k = 0; k < ring.length; k++) ring[k] = transformPoint(ring[k], extent, z2, tx, ty);
            }
        }
    }

    tile.transformed = true;

    return tile;
}

function transformPoint(p, extent, z2, tx, ty) {
    var x = Math.round(extent * (p[0] * z2 - tx)),
        y = Math.round(extent * (p[1] * z2 - ty));
    return [x, y];
}

},{}],146:[function(require,module,exports){
'use strict';

var clip = require('./clip');

module.exports = wrap;

function wrap(features, buffer, intersectX) {
    var merged = features,
        left  = clip(features, 1, -1 - buffer, buffer,     0, intersectX, -1, 2), // left world copy
        right = clip(features, 1,  1 - buffer, 2 + buffer, 0, intersectX, -1, 2); // right world copy

    if (left || right) {
        merged = clip(features, 1, -buffer, 1 + buffer, 0, intersectX, -1, 2); // center world copy

        if (left) merged = shiftFeatureCoords(left, 1).concat(merged); // merge left into center
        if (right) merged = merged.concat(shiftFeatureCoords(right, -1)); // merge right into center
    }

    return merged;
}

function shiftFeatureCoords(features, offset) {
    var newFeatures = [];

    for (var i = 0; i < features.length; i++) {
        var feature = features[i],
            type = feature.type;

        var newGeometry;

        if (type === 1) {
            newGeometry = shiftCoords(feature.geometry, offset);
        } else {
            newGeometry = [];
            for (var j = 0; j < feature.geometry.length; j++) {
                newGeometry.push(shiftCoords(feature.geometry[j], offset));
            }
        }

        newFeatures.push({
            geometry: newGeometry,
            type: type,
            tags: feature.tags,
            min: [feature.min[0] + offset, feature.min[1]],
            max: [feature.max[0] + offset, feature.max[1]]
        });
    }

    return newFeatures;
}

function shiftCoords(points, offset) {
    var newPoints = [];
    newPoints.area = points.area;
    newPoints.dist = points.dist;

    for (var i = 0; i < points.length; i++) {
        newPoints.push([points[i][0] + offset, points[i][1], points[i][2]]);
    }
    return newPoints;
}

},{"./clip":140}],147:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.2
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER

exports.glMatrix = require("./gl-matrix/common.js");
exports.mat2 = require("./gl-matrix/mat2.js");
exports.mat2d = require("./gl-matrix/mat2d.js");
exports.mat3 = require("./gl-matrix/mat3.js");
exports.mat4 = require("./gl-matrix/mat4.js");
exports.quat = require("./gl-matrix/quat.js");
exports.vec2 = require("./gl-matrix/vec2.js");
exports.vec3 = require("./gl-matrix/vec3.js");
exports.vec4 = require("./gl-matrix/vec4.js");
},{"./gl-matrix/common.js":148,"./gl-matrix/mat2.js":149,"./gl-matrix/mat2d.js":150,"./gl-matrix/mat3.js":151,"./gl-matrix/mat4.js":152,"./gl-matrix/quat.js":153,"./gl-matrix/vec2.js":154,"./gl-matrix/vec3.js":155,"./gl-matrix/vec4.js":156}],148:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

// Configuration Constants
glMatrix.EPSILON = 0.000001;
glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
glMatrix.RANDOM = Math.random;
glMatrix.ENABLE_SIMD = false;

// Capability detection
glMatrix.SIMD_AVAILABLE = (glMatrix.ARRAY_TYPE === Float32Array) && ('SIMD' in this);
glMatrix.USE_SIMD = glMatrix.ENABLE_SIMD && glMatrix.SIMD_AVAILABLE;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    glMatrix.ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
glMatrix.equals = function(a, b) {
	return Math.abs(a - b) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
}

module.exports = glMatrix;

},{}],149:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x2 Matrix
 * @name mat2
 */
var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
mat2.fromValues = function(m00, m01, m10, m11) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
};

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
mat2.set = function(out, m00, m01, m10, m11) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
};


/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }

    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.fromRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
mat2.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) {
    L[2] = a[2]/a[0];
    U[0] = a[0];
    U[1] = a[1];
    U[3] = a[3] - L[2] * U[1];
    return [L, D, U];
};

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link mat2.subtract}
 * @function
 */
mat2.sub = mat2.subtract;

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
mat2.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
mat2.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

module.exports = mat2;

},{"./common.js":148}],150:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x3 Matrix
 * @name mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */
var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
mat2d.fromValues = function(a, b, c, d, tx, ty) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
};

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
mat2d.set = function(out, a, b, c, d, tx, ty) {
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
mat2d.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
mat2d.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
};

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    return out;
};

/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
mat2d.sub = mat2d.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
mat2d.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    return out;
};

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
mat2d.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2d.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2d.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)));
};

module.exports = mat2d;

},{"./common.js":148}],151:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3x3 Matrix
 * @name mat3
 */
var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
mat3.fromValues = function(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
mat3.set = function(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }

    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
mat3.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);

    out[0] = c;
    out[1] = s;
    out[2] = 0;

    out[3] = -s;
    out[4] = c;
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
mat3.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;

    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' +
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
};

/**
 * Alias for {@link mat3.subtract}
 * @function
 */
mat3.sub = mat3.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
mat3.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
};

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
mat3.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    return out;
};

/*
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] &&
           a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&
           a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = a[6], b7 = b[7], b8 = b[8];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)));
};


module.exports = mat3;

},{"./common.js":148}],152:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4x4 Matrix
 * @name mat4
 */
var mat4 = {
  scalar: {},
  SIMD: {},
};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
mat4.fromValues = function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
mat4.set = function(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};


/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }

    return out;
};

/**
 * Transpose the values of a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.transpose = function(out, a) {
    var a0, a1, a2, a3,
        tmp01, tmp23,
        out0, out1, out2, out3;

    a0 = SIMD.Float32x4.load(a, 0);
    a1 = SIMD.Float32x4.load(a, 4);
    a2 = SIMD.Float32x4.load(a, 8);
    a3 = SIMD.Float32x4.load(a, 12);

    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
    out0  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
    out1  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
    SIMD.Float32x4.store(out, 0,  out0);
    SIMD.Float32x4.store(out, 4,  out1);

    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
    out2  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
    out3  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
    SIMD.Float32x4.store(out, 8,  out2);
    SIMD.Float32x4.store(out, 12, out3);

    return out;
};

/**
 * Transpse a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = glMatrix.USE_SIMD ? mat4.SIMD.transpose : mat4.scalar.transpose;

/**
 * Inverts a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Inverts a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.invert = function(out, a) {
  var row0, row1, row2, row3,
      tmp1,
      minor0, minor1, minor2, minor3,
      det,
      a0 = SIMD.Float32x4.load(a, 0),
      a1 = SIMD.Float32x4.load(a, 4),
      a2 = SIMD.Float32x4.load(a, 8),
      a3 = SIMD.Float32x4.load(a, 12);

  // Compute matrix adjugate
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

  tmp1   = SIMD.Float32x4.mul(row2, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.mul(row1, tmp1);
  minor1 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row1, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
  minor3 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
  minor2 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row0, row1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

  // Compute matrix determinant
  det   = SIMD.Float32x4.mul(row0, minor0);
  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 2, 3, 0, 1), det);
  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 1, 0, 3, 2), det);
  tmp1  = SIMD.Float32x4.reciprocalApproximation(det);
  det   = SIMD.Float32x4.sub(
               SIMD.Float32x4.add(tmp1, tmp1),
               SIMD.Float32x4.mul(det, SIMD.Float32x4.mul(tmp1, tmp1)));
  det   = SIMD.Float32x4.swizzle(det, 0, 0, 0, 0);
  if (!det) {
      return null;
  }

  // Compute matrix inverse
  SIMD.Float32x4.store(out, 0,  SIMD.Float32x4.mul(det, minor0));
  SIMD.Float32x4.store(out, 4,  SIMD.Float32x4.mul(det, minor1));
  SIMD.Float32x4.store(out, 8,  SIMD.Float32x4.mul(det, minor2));
  SIMD.Float32x4.store(out, 12, SIMD.Float32x4.mul(det, minor3));
  return out;
}

/**
 * Inverts a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = glMatrix.USE_SIMD ? mat4.SIMD.invert : mat4.scalar.invert;

/**
 * Calculates the adjugate of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the adjugate of a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.adjoint = function(out, a) {
  var a0, a1, a2, a3;
  var row0, row1, row2, row3;
  var tmp1;
  var minor0, minor1, minor2, minor3;

  var a0 = SIMD.Float32x4.load(a, 0);
  var a1 = SIMD.Float32x4.load(a, 4);
  var a2 = SIMD.Float32x4.load(a, 8);
  var a3 = SIMD.Float32x4.load(a, 12);

  // Transpose the source matrix.  Sort of.  Not a true transpose operation
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);

  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

  tmp1   = SIMD.Float32x4.mul(row2, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.mul(row1, tmp1);
  minor1 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row1, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
  minor3 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
  minor2 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row0, row1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

  SIMD.Float32x4.store(out, 0,  minor0);
  SIMD.Float32x4.store(out, 4,  minor1);
  SIMD.Float32x4.store(out, 8,  minor2);
  SIMD.Float32x4.store(out, 12, minor3);
  return out;
};

/**
 * Calculates the adjugate of a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
 mat4.adjoint = glMatrix.USE_SIMD ? mat4.SIMD.adjoint : mat4.scalar.adjoint;

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's explicitly using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand, must be a Float32Array
 * @param {mat4} b the second operand, must be a Float32Array
 * @returns {mat4} out
 */
mat4.SIMD.multiply = function (out, a, b) {
    var a0 = SIMD.Float32x4.load(a, 0);
    var a1 = SIMD.Float32x4.load(a, 4);
    var a2 = SIMD.Float32x4.load(a, 8);
    var a3 = SIMD.Float32x4.load(a, 12);

    var b0 = SIMD.Float32x4.load(b, 0);
    var out0 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 2, 2, 2, 2), a2),
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 0, out0);

    var b1 = SIMD.Float32x4.load(b, 4);
    var out1 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 2, 2, 2, 2), a2),
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 4, out1);

    var b2 = SIMD.Float32x4.load(b, 8);
    var out2 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 2, 2, 2, 2), a2),
                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 8, out2);

    var b3 = SIMD.Float32x4.load(b, 12);
    var out3 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 1, 1, 1, 1), a1),
                        SIMD.Float32x4.add(
                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 2, 2, 2, 2), a2),
                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 12, out3);

    return out;
};

/**
 * Multiplies two mat4's explicitly not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.scalar.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Multiplies two mat4's using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = glMatrix.USE_SIMD ? mat4.SIMD.multiply : mat4.scalar.multiply;

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.scalar.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Translates a mat4 by the given vector using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.SIMD.translate = function (out, a, v) {
    var a0 = SIMD.Float32x4.load(a, 0),
        a1 = SIMD.Float32x4.load(a, 4),
        a2 = SIMD.Float32x4.load(a, 8),
        a3 = SIMD.Float32x4.load(a, 12),
        vec = SIMD.Float32x4(v[0], v[1], v[2] , 0);

    if (a !== out) {
        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
        out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
        out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
    }

    a0 = SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0));
    a1 = SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1));
    a2 = SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2));

    var t0 = SIMD.Float32x4.add(a0, SIMD.Float32x4.add(a1, SIMD.Float32x4.add(a2, a3)));
    SIMD.Float32x4.store(out, 12, t0);

    return out;
};

/**
 * Translates a mat4 by the given vector using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = glMatrix.USE_SIMD ? mat4.SIMD.translate : mat4.scalar.translate;

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scalar.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.SIMD.scale = function(out, a, v) {
    var a0, a1, a2;
    var vec = SIMD.Float32x4(v[0], v[1], v[2], 0);

    a0 = SIMD.Float32x4.load(a, 0);
    SIMD.Float32x4.store(
        out, 0, SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0)));

    a1 = SIMD.Float32x4.load(a, 4);
    SIMD.Float32x4.store(
        out, 4, SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1)));

    a2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(
        out, 8, SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2)));

    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 */
mat4.scale = glMatrix.USE_SIMD ? mat4.SIMD.scale : mat4.scalar.scale;

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateX = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
      out[0]  = a[0];
      out[1]  = a[1];
      out[2]  = a[2];
      out[3]  = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_1 = SIMD.Float32x4.load(a, 4);
    var a_2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(out, 4,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_2, s)));
    SIMD.Float32x4.store(out, 8,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_2, c), SIMD.Float32x4.mul(a_1, s)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis using SIMD if availabe and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = glMatrix.USE_SIMD ? mat4.SIMD.rotateX : mat4.scalar.rotateX;

/**
 * Rotates a matrix by the given angle around the Y axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateY = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_0 = SIMD.Float32x4.load(a, 0);
    var a_2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(out, 0,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_2, s)));
    SIMD.Float32x4.store(out, 8,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, s), SIMD.Float32x4.mul(a_2, c)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis if SIMD available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
 mat4.rotateY = glMatrix.USE_SIMD ? mat4.SIMD.rotateY : mat4.scalar.rotateY;

/**
 * Rotates a matrix by the given angle around the Z axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateZ = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_0 = SIMD.Float32x4.load(a, 0);
    var a_1 = SIMD.Float32x4.load(a, 4);
    SIMD.Float32x4.store(out, 0,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_1, s)));
    SIMD.Float32x4.store(out, 4,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_0, s)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis if SIMD available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
 mat4.rotateZ = glMatrix.USE_SIMD ? mat4.SIMD.rotateZ : mat4.scalar.rotateZ;

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
mat4.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.fromRotation = function(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromXRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = 1;
    out[1]  = 0;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromYRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = 0;
    out[2]  = -s;
    out[3]  = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromZRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = s;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
mat4.getTranslation = function (out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
};

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
mat4.getRotation = function (out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  var trace = mat[0] + mat[5] + mat[10];
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S;
    out[2] = (mat[1] - mat[4]) / S;
  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) {
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S;
    out[2] = (mat[8] + mat[2]) / S;
  } else if (mat[5] > mat[10]) {
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S;
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S;
  } else {
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScale = function (out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2,
        sx = s[0],
        sy = s[1],
        sz = s[2];

    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
  // Quaternion math
  var x = q[0], y = q[1], z = q[2], w = q[3],
      x2 = x + x,
      y2 = y + y,
      z2 = z + z,

      xx = x * x2,
      xy = x * y2,
      xz = x * z2,
      yy = y * y2,
      yz = y * z2,
      zz = z * z2,
      wx = w * x2,
      wy = w * y2,
      wz = w * z2,

      sx = s[0],
      sy = s[1],
      sz = s[2],

      ox = o[0],
      oy = o[1],
      oz = o[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;

  return out;
};

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspectiveFromFieldOfView = function (out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
        Math.abs(eyey - centery) < glMatrix.EPSILON &&
        Math.abs(eyez - centerz) < glMatrix.EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
};

/**
 * Alias for {@link mat4.subtract}
 * @function
 */
mat4.sub = mat4.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
mat4.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
};

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
mat4.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    out[9] = a[9] + (b[9] * scale);
    out[10] = a[10] + (b[10] * scale);
    out[11] = a[11] + (b[11] * scale);
    out[12] = a[12] + (b[12] * scale);
    out[13] = a[13] + (b[13] * scale);
    out[14] = a[14] + (b[14] * scale);
    out[15] = a[15] + (b[15] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] &&
           a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] &&
           a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
           a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.equals = function (a, b) {
    var a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3],
        a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7],
        a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11],
        a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];

    var b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3],
        b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7],
        b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11],
        b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
            Math.abs(a9 - b9) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
            Math.abs(a10 - b10) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
            Math.abs(a11 - b11) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
            Math.abs(a12 - b12) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
            Math.abs(a13 - b13) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
            Math.abs(a14 - b14) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
            Math.abs(a15 - b15) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a15), Math.abs(b15)));
};



module.exports = mat4;

},{"./common.js":148}],153:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");
var mat3 = require("./mat3.js");
var vec3 = require("./vec3.js");
var vec4 = require("./vec4.js");

/**
 * @class Quaternion
 * @name quat
 */
var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
quat.getAxisAngle = function(out_axis, q) {
    var rad = Math.acos(q[3]) * 2.0;
    var s = Math.sin(rad / 2.0);
    if (s != 0.0) {
        out_axis[0] = q[0] / s;
        out_axis[1] = q[1] / s;
        out_axis[2] = q[2] / s;
    } else {
        // If s is zero, return any axis (no rotation - axis does not matter)
        out_axis[0] = 1;
        out_axis[1] = 0;
        out_axis[2] = 0;
    }
    return rad;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5;

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5;

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5;

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {
        // "from" and "to" quaternions are very close
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;

    return out;
};

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
quat.sqlerp = (function () {
  var temp1 = quat.create();
  var temp2 = quat.create();

  return function (out, a, b, c, d, t) {
    quat.slerp(temp1, a, d, t);
    quat.slerp(temp2, b, c, t);
    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));

    return out;
  };
}());

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;

    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[5]-m[7])*fRoot;
        out[1] = (m[6]-m[2])*fRoot;
        out[2] = (m[1]-m[3])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;

        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }

    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.exactEquals = vec4.exactEquals;

/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.equals = vec4.equals;

module.exports = quat;

},{"./common.js":148,"./mat3.js":151,"./vec3.js":155,"./vec4.js":156}],154:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */
var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
vec2.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
};

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
vec2.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
vec2.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
vec2.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }

        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }

        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1];
    var b0 = b[0], b1 = b[1];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)));
};

module.exports = vec2;

},{"./common.js":148}],155:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */
var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
vec3.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
};

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
vec3.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
};

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
vec3.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
vec3.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.hermite = function (out, a, b, c, d, t) {
  var factorTimes2 = t * t,
      factor1 = factorTimes2 * (2 * t - 3) + 1,
      factor2 = factorTimes2 * (t - 2) + t,
      factor3 = factorTimes2 * (t - 1),
      factor4 = factorTimes2 * (3 - 2 * t);

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
};

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.bezier = function (out, a, b, c, d, t) {
  var inverseFactor = 1 - t,
      inverseFactorTimesTwo = inverseFactor * inverseFactor,
      factorTimes2 = t * t,
      factor1 = inverseFactorTimesTwo * inverseFactor,
      factor2 = 3 * t * inverseFactorTimesTwo,
      factor3 = 3 * factorTimes2 * inverseFactor,
      factor4 = factorTimes2 * t;

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    var z = (glMatrix.RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);

  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];

  	return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];

  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];

  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }

        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }

        return a;
    };
})();

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
vec3.angle = function(a, b) {

    var tempA = vec3.fromValues(a[0], a[1], a[2]);
    var tempB = vec3.fromValues(b[0], b[1], b[2]);

    vec3.normalize(tempA, tempA);
    vec3.normalize(tempB, tempB);

    var cosine = vec3.dot(tempA, tempB);

    if(cosine > 1.0){
        return 0;
    } else {
        return Math.acos(cosine);
    }
};

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)));
};

module.exports = vec3;

},{"./common.js":148}],156:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */
var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
vec4.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
};

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
vec4.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
};

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
vec4.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
vec4.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = x * len;
        out[1] = y * len;
        out[2] = z * len;
        out[3] = w * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = glMatrix.RANDOM();
    out[1] = glMatrix.RANDOM();
    out[2] = glMatrix.RANDOM();
    out[3] = glMatrix.RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }

        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }

        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

module.exports = vec4;

},{"./common.js":148}],157:[function(require,module,exports){
'use strict';

module.exports = GridIndex;

var NUM_PARAMS = 3;

function GridIndex(extent, n, padding) {
    var cells = this.cells = [];

    if (extent instanceof ArrayBuffer) {
        this.arrayBuffer = extent;
        var array = new Int32Array(this.arrayBuffer);
        extent = array[0];
        n = array[1];
        padding = array[2];

        this.d = n + 2 * padding;
        for (var k = 0; k < this.d * this.d; k++) {
            var start = array[NUM_PARAMS + k];
            var end = array[NUM_PARAMS + k + 1];
            cells.push(start === end ?
                    null :
                    array.subarray(start, end));
        }
        var keysOffset = array[NUM_PARAMS + cells.length];
        var bboxesOffset = array[NUM_PARAMS + cells.length + 1];
        this.keys = array.subarray(keysOffset, bboxesOffset);
        this.bboxes = array.subarray(bboxesOffset);

        this.insert = this._insertReadonly;

    } else {
        this.d = n + 2 * padding;
        for (var i = 0; i < this.d * this.d; i++) {
            cells.push([]);
        }
        this.keys = [];
        this.bboxes = [];
    }

    this.n = n;
    this.extent = extent;
    this.padding = padding;
    this.scale = n / extent;
    this.uid = 0;

    var p = (padding / n) * extent;
    this.min = -p;
    this.max = extent + p;
}


GridIndex.prototype.insert = function(key, x1, y1, x2, y2) {
    this._forEachCell(x1, y1, x2, y2, this._insertCell, this.uid++);
    this.keys.push(key);
    this.bboxes.push(x1);
    this.bboxes.push(y1);
    this.bboxes.push(x2);
    this.bboxes.push(y2);
};

GridIndex.prototype._insertReadonly = function() {
    throw 'Cannot insert into a GridIndex created from an ArrayBuffer.';
};

GridIndex.prototype._insertCell = function(x1, y1, x2, y2, cellIndex, uid) {
    this.cells[cellIndex].push(uid);
};

GridIndex.prototype.query = function(x1, y1, x2, y2) {
    var min = this.min;
    var max = this.max;
    if (x1 <= min && y1 <= min && max <= x2 && max <= y2) {
        return this.keys.slice();

    } else {
        var result = [];
        var seenUids = {};
        this._forEachCell(x1, y1, x2, y2, this._queryCell, result, seenUids);
        return result;
    }
};

GridIndex.prototype._queryCell = function(x1, y1, x2, y2, cellIndex, result, seenUids) {
    var cell = this.cells[cellIndex];
    if (cell !== null) {
        var keys = this.keys;
        var bboxes = this.bboxes;
        for (var u = 0; u < cell.length; u++) {
            var uid = cell[u];
            if (seenUids[uid] === undefined) {
                var offset = uid * 4;
                if ((x1 <= bboxes[offset + 2]) &&
                    (y1 <= bboxes[offset + 3]) &&
                    (x2 >= bboxes[offset + 0]) &&
                    (y2 >= bboxes[offset + 1])) {
                    seenUids[uid] = true;
                    result.push(keys[uid]);
                } else {
                    seenUids[uid] = false;
                }
            }
        }
    }
};

GridIndex.prototype._forEachCell = function(x1, y1, x2, y2, fn, arg1, arg2) {
    var cx1 = this._convertToCellCoord(x1);
    var cy1 = this._convertToCellCoord(y1);
    var cx2 = this._convertToCellCoord(x2);
    var cy2 = this._convertToCellCoord(y2);
    for (var x = cx1; x <= cx2; x++) {
        for (var y = cy1; y <= cy2; y++) {
            var cellIndex = this.d * y + x;
            if (fn.call(this, x1, y1, x2, y2, cellIndex, arg1, arg2)) return;
        }
    }
};

GridIndex.prototype._convertToCellCoord = function(x) {
    return Math.max(0, Math.min(this.d - 1, Math.floor(x * this.scale) + this.padding));
};

GridIndex.prototype.toArrayBuffer = function() {
    if (this.arrayBuffer) return this.arrayBuffer;

    var cells = this.cells;

    var metadataLength = NUM_PARAMS + this.cells.length + 1 + 1;
    var totalCellLength = 0;
    for (var i = 0; i < this.cells.length; i++) {
        totalCellLength += this.cells[i].length;
    }

    var array = new Int32Array(metadataLength + totalCellLength + this.keys.length + this.bboxes.length);
    array[0] = this.extent;
    array[1] = this.n;
    array[2] = this.padding;

    var offset = metadataLength;
    for (var k = 0; k < cells.length; k++) {
        var cell = cells[k];
        array[NUM_PARAMS + k] = offset;
        array.set(cell, offset);
        offset += cell.length;
    }

    array[NUM_PARAMS + cells.length] = offset;
    array.set(this.keys, offset);
    offset += this.keys.length;

    array[NUM_PARAMS + cells.length + 1] = offset;
    array.set(this.bboxes, offset);
    offset += this.bboxes.length;

    return array.buffer;
};

},{}],158:[function(require,module,exports){
'use strict';

function createFunction(parameters, defaultType) {
    var fun;

    if (!isFunctionDefinition(parameters)) {
        fun = function() { return parameters; };
        fun.isFeatureConstant = true;
        fun.isZoomConstant = true;

    } else {
        var zoomAndFeatureDependent = typeof parameters.stops[0][0] === 'object';
        var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
        var zoomDependent = zoomAndFeatureDependent || !featureDependent;
        var type = parameters.type || defaultType || 'exponential';

        var innerFun;
        if (type === 'exponential') {
            innerFun = evaluateExponentialFunction;
        } else if (type === 'interval') {
            innerFun = evaluateIntervalFunction;
        } else if (type === 'categorical') {
            innerFun = evaluateCategoricalFunction;
        } else {
            throw new Error('Unknown function type "' + type + '"');
        }

        if (zoomAndFeatureDependent) {
            var featureFunctions = {};
            var featureFunctionStops = [];
            for (var s = 0; s < parameters.stops.length; s++) {
                var stop = parameters.stops[s];
                if (featureFunctions[stop[0].zoom] === undefined) {
                    featureFunctions[stop[0].zoom] = {
                        zoom: stop[0].zoom,
                        type: parameters.type,
                        property: parameters.property,
                        stops: []
                    };
                }
                featureFunctions[stop[0].zoom].stops.push([stop[0].value, stop[1]]);
            }

            for (var z in featureFunctions) {
                featureFunctionStops.push([featureFunctions[z].zoom, createFunction(featureFunctions[z])]);
            }
            fun = function(zoom, feature) {
                return evaluateExponentialFunction({ stops: featureFunctionStops, base: parameters.base }, zoom)(zoom, feature);
            };
            fun.isFeatureConstant = false;
            fun.isZoomConstant = false;

        } else if (zoomDependent) {
            fun = function(zoom) {
                return innerFun(parameters, zoom);
            };
            fun.isFeatureConstant = true;
            fun.isZoomConstant = false;
        } else {
            fun = function(zoom, feature) {
                return innerFun(parameters, feature[parameters.property]);
            };
            fun.isFeatureConstant = false;
            fun.isZoomConstant = true;
        }
    }

    return fun;
}

function evaluateCategoricalFunction(parameters, input) {
    for (var i = 0; i < parameters.stops.length; i++) {
        if (input === parameters.stops[i][0]) {
            return parameters.stops[i][1];
        }
    }
    return parameters.stops[0][1];
}

function evaluateIntervalFunction(parameters, input) {
    for (var i = 0; i < parameters.stops.length; i++) {
        if (input < parameters.stops[i][0]) break;
    }
    return parameters.stops[Math.max(i - 1, 0)][1];
}

function evaluateExponentialFunction(parameters, input) {
    var base = parameters.base !== undefined ? parameters.base : 1;

    var i = 0;
    while (true) {
        if (i >= parameters.stops.length) break;
        else if (input <= parameters.stops[i][0]) break;
        else i++;
    }

    if (i === 0) {
        return parameters.stops[i][1];

    } else if (i === parameters.stops.length) {
        return parameters.stops[i - 1][1];

    } else {
        return interpolate(
            input,
            base,
            parameters.stops[i - 1][0],
            parameters.stops[i][0],
            parameters.stops[i - 1][1],
            parameters.stops[i][1]
        );
    }
}


function interpolate(input, base, inputLower, inputUpper, outputLower, outputUpper) {
    if (typeof outputLower === 'function') {
        return function() {
            var evaluatedLower = outputLower.apply(undefined, arguments);
            var evaluatedUpper = outputUpper.apply(undefined, arguments);
            return interpolate(input, base, inputLower, inputUpper, evaluatedLower, evaluatedUpper);
        };
    } else if (outputLower.length) {
        return interpolateArray(input, base, inputLower, inputUpper, outputLower, outputUpper);
    } else {
        return interpolateNumber(input, base, inputLower, inputUpper, outputLower, outputUpper);
    }
}

function interpolateNumber(input, base, inputLower, inputUpper, outputLower, outputUpper) {
    var difference =  inputUpper - inputLower;
    var progress = input - inputLower;

    var ratio;
    if (base === 1) {
        ratio = progress / difference;
    } else {
        ratio = (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
    }

    return (outputLower * (1 - ratio)) + (outputUpper * ratio);
}

function interpolateArray(input, base, inputLower, inputUpper, outputLower, outputUpper) {
    var output = [];
    for (var i = 0; i < outputLower.length; i++) {
        output[i] = interpolateNumber(input, base, inputLower, inputUpper, outputLower[i], outputUpper[i]);
    }
    return output;
}

function isFunctionDefinition(value) {
    return typeof value === 'object' && value.stops;
}


module.exports.isFunctionDefinition = isFunctionDefinition;

module.exports.interpolated = function(parameters) {
    return createFunction(parameters, 'exponential');
};

module.exports['piecewise-constant'] = function(parameters) {
    return createFunction(parameters, 'interval');
};

},{}],159:[function(require,module,exports){

var path = require('path');

// readFileSync calls must be written out long-form for brfs.
module.exports = {
  debug: {
    fragmentSource: "#ifdef GL_ES\nprecision mediump float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nuniform lowp vec4 u_color;\n\nvoid main() {\n    gl_FragColor = u_color;\n}\n",
    vertexSource: "#ifdef GL_ES\nprecision highp float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nattribute vec2 a_pos;\n\nuniform mat4 u_matrix;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, step(32767.0, a_pos.x), 1);\n}\n"
  },
  fill: {
    fragmentSource: "#ifdef GL_ES\nprecision mediump float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\n#pragma mapbox: define lowp vec4 color\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp vec4 color\n    #pragma mapbox: initialize lowp float opacity\n\n    gl_FragColor = color * opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
    vertexSource: "#ifdef GL_ES\nprecision highp float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nattribute vec2 a_pos;\n\nuniform mat4 u_matrix;\n\n#pragma mapbox: define lowp vec4 color\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp vec4 color\n    #pragma mapbox: initialize lowp float opacity\n\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n}\n"
  },
  extrusion: {
      fragmentSource: "#ifdef GL_ES\nprecision mediump float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nvarying vec4 v_color;\n#ifdef MAPBOX_GL_JS\n#pragma mapbox: define lowp float minH\n#pragma mapbox: define lowp float maxH\n#endif\n#pragma mapbox: define lowp vec4 color\n\nvoid main() {\n#ifdef MAPBOX_GL_JS\n    #pragma mapbox: initialize lowp float minH\n    #pragma mapbox: initialize lowp float maxH\n#endif\n    #pragma mapbox: initialize lowp vec4 color\n\n    gl_FragColor = v_color;\n}\n",
      vertexSource: "#ifdef GL_ES\nprecision highp float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nattribute vec3 a_pos;\nattribute vec3 a_normal;\nattribute float a_edgedistance;\nuniform mat4 u_matrix;\nuniform vec3 u_lightdir;\nuniform vec4 u_shadow;\nuniform lowp vec4 u_outline_color;\nvarying vec4 v_color;\n\n#ifndef MAPBOX_GL_JS\nattribute float minH;\nattribute float maxH;\n#else\n#pragma mapbox: define lowp float minH\n#pragma mapbox: define lowp float maxH\n#endif\n\n#pragma mapbox: define lowp vec4 color\n\nvoid main() {\n#ifdef MAPBOX_GL_JS\n    #pragma mapbox: initialize lowp float minH\n    #pragma mapbox: initialize lowp float maxH\n#endif\n    #pragma mapbox: initialize lowp vec4 color\n\n    float ed = a_edgedistance; // use each attrib in order to not trip a VAO assert\n    float t = mod(a_normal.x, 2.0);\n    //1.0的话就是按照3d的进行绘制，\n    //-1.0的话就按照2d只能被属性界面和地图control界面上的2d，3d切换按钮改变\n    //-2.0的话按照2d，但是可以被属性界面和地图control界面上的2d，3d切换按钮改变\n\n    if(minH >= 0.0){\n        if(a_pos.z < 0.0){\n            gl_Position = u_matrix * vec4(a_pos.xy, 3.0*maxH, 1);\n        }else{\n            gl_Position = u_matrix * vec4(a_pos, 1);\n        }\n    }else{\n        gl_Position = u_matrix * vec4(a_pos.xy, 0.01, 1);\n    }\n\n#ifdef OUTLINE\n    #ifdef DEFAULT_COLOR\n    v_color = color;\n    #else\n    v_color = u_outline_color;\n    #endif\n#else\n    v_color = color;\n#endif\n\n    float directional = clamp(dot(a_normal / 32768.0, u_lightdir), 0.0, 1.0);\n    float shadow = clamp((0.3 - directional) / 7.0, 0.0, 0.3);\n    directional = mix(0.7, 1.0, directional * 2.0 * (0.2 +\n        pow(t * clamp(maxH / 150.0, 0.0, 1.0), 0.25)\n    ) / 1.2);\n\n    v_color.rgb *= directional;\n\n    v_color += shadow * u_shadow;\n}\n"
  },
  extrusionpattern: {
      fragmentSource: "#ifdef GL_ES\nprecision mediump float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nuniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform float u_mix;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec4 v_shadow;\nvarying float v_directional;\n\n#ifdef MAPBOX_GL_JS\n#pragma mapbox: define lowp float minH\n#pragma mapbox: define lowp float maxH\n#endif\n#pragma mapbox: define lowp vec4 color\n\nvoid main() {\n#ifdef MAPBOX_GL_JS\n    #pragma mapbox: initialize lowp float minH\n    #pragma mapbox: initialize lowp float maxH\n#endif\n    #pragma mapbox: initialize lowp vec4 color\n\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a, u_pattern_br_a, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b, u_pattern_br_b, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    vec4 mixedColor = mix(color1, color2, u_mix);\n    mixedColor.rgb *= v_directional;\n\n    gl_FragColor = (mixedColor + v_shadow);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
      vertexSource: "#ifdef GL_ES\nprecision highp float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nuniform mat4 u_matrix;\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pixel_coord_upper;\nuniform vec2 u_pixel_coord_lower;\nuniform float u_scale_a;\nuniform float u_scale_b;\nuniform float u_tile_units_to_pixels;\nuniform float u_height_factor;\n\nuniform vec3 u_lightdir;\nuniform vec4 u_shadow;\n\nattribute vec2 a_pos;\nattribute vec3 a_normal;\nattribute float a_edgedistance;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec4 v_shadow;\nvarying float v_directional;\n\n#ifndef MAPBOX_GL_JS\nattribute float minH;\nattribute float maxH;\n#else\n#pragma mapbox: define lowp float minH\n#pragma mapbox: define lowp float maxH\n#endif\n\n#pragma mapbox: define lowp vec4 color\n\nvoid main() {\n#ifdef MAPBOX_GL_JS\n    #pragma mapbox: initialize lowp float minH\n    #pragma mapbox: initialize lowp float maxH\n#endif\n    #pragma mapbox: initialize lowp vec4 color\n\n    float t = mod(a_normal.x, 2.0);\n    float z = t > 0.0 ? maxH : minH;\n\n    gl_Position = u_matrix * vec4(a_pos, z, 1);\n\n    vec2 scaled_size_a = u_scale_a * u_pattern_size_a;\n    vec2 scaled_size_b = u_scale_b * u_pattern_size_b;\n\n    // the following offset calculation is duplicated from the regular pattern shader:\n    vec2 offset_a = mod(mod(mod(u_pixel_coord_upper, scaled_size_a) * 256.0, scaled_size_a) * 256.0 + u_pixel_coord_lower, scaled_size_a);\n    vec2 offset_b = mod(mod(mod(u_pixel_coord_upper, scaled_size_b) * 256.0, scaled_size_b) * 256.0 + u_pixel_coord_lower, scaled_size_b);\n\n    if (a_normal.x == 1.0 && a_normal.y == 0.0 && a_normal.z == 16384.0) {\n        // extrusion top\n        v_pos_a = (u_tile_units_to_pixels * a_pos + offset_a) / scaled_size_a;\n        v_pos_b = (u_tile_units_to_pixels * a_pos + offset_b) / scaled_size_b;\n    } else {\n        // extrusion side\n        float hf = z * u_height_factor;\n\n        v_pos_a = (u_tile_units_to_pixels * vec2(a_edgedistance, hf) + offset_a) / scaled_size_a;\n        v_pos_b = (u_tile_units_to_pixels * vec2(a_edgedistance, hf) + offset_b) / scaled_size_b;\n    }\n\n    float directional = clamp(dot(a_normal / 32768.0, u_lightdir), 0.0, 1.0);\n    float shadow = clamp((0.3 - directional) / 7.0, 0.0, 0.3);\n    directional = mix(0.7, 1.0, directional * 2.0 * (0.2 + t) / 1.2);\n\n    v_shadow = shadow * u_shadow;\n    v_directional = directional;\n}\n"
  },
  extrusiontexture: {
      fragmentSource: "#ifdef GL_ES\nprecision mediump float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nuniform sampler2D u_texture;\nuniform float u_opacity;\n\nvarying vec2 v_pos;\n\n// TODO here we'll probably want to add ability to fade in...\n// #ifndef MAPBOX_GL_JS\n// varying vec2 v_pos;\n// #else\n// uniform float u_opacity0;\n// uniform float u_opacity1;\n// uniform sampler2D u_image0;\n// uniform sampler2D u_image1;\n// varying vec2 v_pos0;\n// varying vec2 v_pos1;\n// #endif\n\nvoid main() {\n    gl_FragColor = texture2D(u_texture, v_pos) * u_opacity;\n}\n",
      vertexSource: "#ifdef GL_ES\nprecision highp float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nuniform mat4 u_matrix;\nuniform int u_xdim;\nuniform int u_ydim;\nattribute vec2 a_pos;\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n\n    v_pos.x = a_pos.x / float(u_xdim);\n    v_pos.y = 1.0 - a_pos.y / float(u_ydim);\n}\n"
  },
  circle: {
    fragmentSource: "#ifdef GL_ES\nprecision mediump float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\n#pragma mapbox: define lowp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n\nvarying vec2 v_extrude;\nvarying lowp float v_antialiasblur;\n\nvoid main() {\n    #pragma mapbox: initialize lowp vec4 color\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n\n    float t = smoothstep(1.0 - max(blur, v_antialiasblur), 1.0, length(v_extrude));\n    gl_FragColor = color * (1.0 - t) * opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
    vertexSource: "#ifdef GL_ES\nprecision highp float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nuniform mat4 u_matrix;\nuniform bool u_scale_with_map;\nuniform vec2 u_extrude_scale;\nuniform float u_devicepixelratio;\n\nattribute vec2 a_pos;\n\n#pragma mapbox: define lowp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n\nvarying vec2 v_extrude;\nvarying lowp float v_antialiasblur;\n\nvoid main(void) {\n    #pragma mapbox: initialize lowp vec4 color\n    #pragma mapbox: initialize mediump float radius\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n\n    // unencode the extrusion vector that we snuck into the a_pos vector\n    v_extrude = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\n\n    vec2 extrude = v_extrude * radius * u_extrude_scale;\n    // multiply a_pos by 0.5, since we had it * 2 in order to sneak\n    // in extrusion data\n    gl_Position = u_matrix * vec4(floor(a_pos * 0.5), 0, 1);\n\n    if (u_scale_with_map) {\n        gl_Position.xy += extrude;\n    } else {\n        gl_Position.xy += extrude * gl_Position.w;\n    }\n\n    // This is a minimum blur distance that serves as a faux-antialiasing for\n    // the circle. since blur is a ratio of the circle's size and the intent is\n    // to keep the blur at roughly 1px, the two are inversely related.\n    v_antialiasblur = 1.0 / u_devicepixelratio / radius;\n}\n"
  },
  line: {
    fragmentSource: "#ifdef GL_ES\nprecision mediump float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nuniform lowp float u_opacity;\nuniform float u_blur;\n\n#pragma mapbox: define lowp vec4 color\n\nvarying vec2 v_linewidth;\nvarying vec2 v_normal;\nvarying float v_gamma_scale;\n\nvoid main() {\n    #pragma mapbox: initialize lowp vec4 color\n\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * v_linewidth.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_linewidth.t) or when fading out\n    // (v_linewidth.s)\n    float blur = u_blur * v_gamma_scale;\n    float alpha = clamp(min(dist - (v_linewidth.t - blur), v_linewidth.s - dist) / blur, 0.0, 1.0);\n\n    gl_FragColor = color * (alpha * u_opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
    vertexSource: "#ifdef GL_ES\nprecision highp float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\n// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\nattribute vec2 a_pos;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform mediump float u_ratio;\nuniform mediump float u_linewidth;\nuniform mediump float u_gapwidth;\nuniform mediump float u_antialiasing;\nuniform mediump float u_extra;\nuniform mat2 u_antialiasingmatrix;\nuniform mediump float u_offset;\nuniform mediump float u_blur;\n\nvarying vec2 v_normal;\nvarying vec2 v_linewidth;\nvarying float v_gamma_scale;\n\n#pragma mapbox: define lowp vec4 color\n\nvoid main() {\n    #pragma mapbox: initialize lowp vec4 color\n\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n\n    // We store the texture normals in the most insignificant bit\n    // transform y so that 0 => -1 and 1 => 1\n    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = mod(a_pos, 2.0);\n    normal.y = sign(normal.y - 0.5);\n    v_normal = normal;\n\n    float inset = u_gapwidth + (u_gapwidth > 0.0 ? u_antialiasing : 0.0);\n    float outset = u_gapwidth + u_linewidth * (u_gapwidth > 0.0 ? 2.0 : 1.0) + u_antialiasing;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec2 dist = outset * a_extrude * scale;\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset = u_offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    // Remove the texture normal bit of the position before scaling it with the\n    // model/view matrix.\n    gl_Position = u_matrix * vec4(floor(a_pos * 0.5) + (offset + dist) / u_ratio, 0.0, 1.0);\n\n    // position of y on the screen\n    float y = gl_Position.y / gl_Position.w;\n\n    // how much features are squished in the y direction by the tilt\n    float squish_scale = length(a_extrude) / length(u_antialiasingmatrix * a_extrude);\n\n    // how much features are squished in all directions by the perspectiveness\n    float perspective_scale = 1.0 / (1.0 - min(y * u_extra, 0.9));\n\n    v_linewidth = vec2(outset, inset);\n    v_gamma_scale = perspective_scale * squish_scale;\n}\n"
  },
  linepattern: {
    fragmentSource: "#ifdef GL_ES\nprecision mediump float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nuniform float u_blur;\n\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform float u_fade;\nuniform float u_opacity;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_normal;\nvarying vec2 v_linewidth;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\nvoid main() {\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * v_linewidth.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_linewidth.t) or when fading out\n    // (v_linewidth.s)\n    float blur = u_blur * v_gamma_scale;\n    float alpha = clamp(min(dist - (v_linewidth.t - blur), v_linewidth.s - dist) / blur, 0.0, 1.0);\n\n    float x_a = mod(v_linesofar / u_pattern_size_a.x, 1.0);\n    float x_b = mod(v_linesofar / u_pattern_size_b.x, 1.0);\n    float y_a = 0.5 + (v_normal.y * v_linewidth.s / u_pattern_size_a.y);\n    float y_b = 0.5 + (v_normal.y * v_linewidth.s / u_pattern_size_b.y);\n    vec2 pos_a = mix(u_pattern_tl_a, u_pattern_br_a, vec2(x_a, y_a));\n    vec2 pos_b = mix(u_pattern_tl_b, u_pattern_br_b, vec2(x_b, y_b));\n\n    vec4 color = mix(texture2D(u_image, pos_a), texture2D(u_image, pos_b), u_fade);\n\n    alpha *= u_opacity;\n\n    gl_FragColor = color * alpha;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
    vertexSource: "#ifdef GL_ES\nprecision highp float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\n// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\n// We scale the distance before adding it to the buffers so that we can store\n// long distances for long segments. Use this value to unscale the distance.\n#define LINE_DISTANCE_SCALE 2.0\n\nattribute vec2 a_pos;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform mediump float u_ratio;\nuniform mediump float u_linewidth;\nuniform mediump float u_gapwidth;\nuniform mediump float u_antialiasing;\nuniform mediump float u_extra;\nuniform mat2 u_antialiasingmatrix;\nuniform mediump float u_offset;\n\nvarying vec2 v_normal;\nvarying vec2 v_linewidth;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\nvoid main() {\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n    float a_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * LINE_DISTANCE_SCALE;\n\n    // We store the texture normals in the most insignificant bit\n    // transform y so that 0 => -1 and 1 => 1\n    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = mod(a_pos, 2.0);\n    normal.y = sign(normal.y - 0.5);\n    v_normal = normal;\n\n    float inset = u_gapwidth + (u_gapwidth > 0.0 ? u_antialiasing : 0.0);\n    float outset = u_gapwidth + u_linewidth * (u_gapwidth > 0.0 ? 2.0 : 1.0) + u_antialiasing;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec2 dist = outset * a_extrude * scale;\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset = u_offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    // Remove the texture normal bit of the position before scaling it with the\n    // model/view matrix.\n    gl_Position = u_matrix * vec4(floor(a_pos * 0.5) + (offset + dist) / u_ratio, 0.0, 1.0);\n    v_linesofar = a_linesofar;\n\n    // position of y on the screen\n    float y = gl_Position.y / gl_Position.w;\n\n    // how much features are squished in the y direction by the tilt\n    float squish_scale = length(a_extrude) / length(u_antialiasingmatrix * a_extrude);\n\n    // how much features are squished in all directions by the perspectiveness\n    float perspective_scale = 1.0 / (1.0 - min(y * u_extra, 0.9));\n\n    v_linewidth = vec2(outset, inset);\n    v_gamma_scale = perspective_scale * squish_scale;\n}\n"
  },
  linesdfpattern: {
    fragmentSource: "#ifdef GL_ES\nprecision mediump float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nuniform lowp float u_opacity;\n\nuniform float u_blur;\nuniform sampler2D u_image;\nuniform float u_sdfgamma;\nuniform float u_mix;\n\nvarying vec2 v_normal;\nvarying vec2 v_linewidth;\nvarying vec2 v_tex_a;\nvarying vec2 v_tex_b;\nvarying float v_gamma_scale;\n\n#pragma mapbox: define lowp vec4 color\n\nvoid main() {\n    #pragma mapbox: initialize lowp vec4 color\n\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * v_linewidth.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_linewidth.t) or when fading out\n    // (v_linewidth.s)\n    float blur = u_blur * v_gamma_scale;\n    float alpha = clamp(min(dist - (v_linewidth.t - blur), v_linewidth.s - dist) / blur, 0.0, 1.0);\n\n    float sdfdist_a = texture2D(u_image, v_tex_a).a;\n    float sdfdist_b = texture2D(u_image, v_tex_b).a;\n    float sdfdist = mix(sdfdist_a, sdfdist_b, u_mix);\n    alpha *= smoothstep(0.5 - u_sdfgamma, 0.5 + u_sdfgamma, sdfdist);\n\n    gl_FragColor = color * (alpha * u_opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
    vertexSource: "#ifdef GL_ES\nprecision highp float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\n// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\n// We scale the distance before adding it to the buffers so that we can store\n// long distances for long segments. Use this value to unscale the distance.\n#define LINE_DISTANCE_SCALE 2.0\n\nattribute vec2 a_pos;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform mediump float u_ratio;\nuniform mediump float u_linewidth;\nuniform mediump float u_gapwidth;\nuniform mediump float u_antialiasing;\nuniform vec2 u_patternscale_a;\nuniform float u_tex_y_a;\nuniform vec2 u_patternscale_b;\nuniform float u_tex_y_b;\nuniform float u_extra;\nuniform mat2 u_antialiasingmatrix;\nuniform mediump float u_offset;\n\nvarying vec2 v_normal;\nvarying vec2 v_linewidth;\nvarying vec2 v_tex_a;\nvarying vec2 v_tex_b;\nvarying float v_gamma_scale;\n\n#pragma mapbox: define lowp vec4 color\n\nvoid main() {\n    #pragma mapbox: initialize lowp vec4 color\n\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n    float a_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * LINE_DISTANCE_SCALE;\n\n    // We store the texture normals in the most insignificant bit\n    // transform y so that 0 => -1 and 1 => 1\n    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = mod(a_pos, 2.0);\n    normal.y = sign(normal.y - 0.5);\n    v_normal = normal;\n\n    float inset = u_gapwidth + (u_gapwidth > 0.0 ? u_antialiasing : 0.0);\n    float outset = u_gapwidth + u_linewidth * (u_gapwidth > 0.0 ? 2.0 : 1.0) + u_antialiasing;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec2 dist = outset * a_extrude * scale;\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset = u_offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    // Remove the texture normal bit of the position before scaling it with the\n    // model/view matrix.\n    gl_Position = u_matrix * vec4(floor(a_pos * 0.5) + (offset + dist) / u_ratio, 0.0, 1.0);\n\n    v_tex_a = vec2(a_linesofar * u_patternscale_a.x, normal.y * u_patternscale_a.y + u_tex_y_a);\n    v_tex_b = vec2(a_linesofar * u_patternscale_b.x, normal.y * u_patternscale_b.y + u_tex_y_b);\n\n    // position of y on the screen\n    float y = gl_Position.y / gl_Position.w;\n\n    // how much features are squished in the y direction by the tilt\n    float squish_scale = length(a_extrude) / length(u_antialiasingmatrix * a_extrude);\n\n    // how much features are squished in all directions by the perspectiveness\n    float perspective_scale = 1.0 / (1.0 - min(y * u_extra, 0.9));\n\n    v_linewidth = vec2(outset, inset);\n    v_gamma_scale = perspective_scale * squish_scale;\n}\n"
  },
  outline: {
    fragmentSource: "#ifdef GL_ES\nprecision mediump float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\n#pragma mapbox: define lowp vec4 outline_color\n#pragma mapbox: define lowp float opacity\n\nvarying vec2 v_pos;\n\nvoid main() {\n    #pragma mapbox: initialize lowp vec4 outline_color\n    #pragma mapbox: initialize lowp float opacity\n\n    float dist = length(v_pos - gl_FragCoord.xy);\n    float alpha = smoothstep(1.0, 0.0, dist);\n    gl_FragColor = outline_color * (alpha * opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
    vertexSource: "#ifdef GL_ES\nprecision highp float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nattribute vec2 a_pos;\n\nuniform mat4 u_matrix;\nuniform vec2 u_world;\n\nvarying vec2 v_pos;\n\n#pragma mapbox: define lowp vec4 outline_color\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp vec4 outline_color\n    #pragma mapbox: initialize lowp float opacity\n\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos = (gl_Position.xy / gl_Position.w + 1.0) / 2.0 * u_world;\n}\n"
  },
  outlinepattern: {
    fragmentSource: "#ifdef GL_ES\nprecision mediump float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nuniform float u_opacity;\nuniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform float u_mix;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec2 v_pos;\n\nvoid main() {\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a, u_pattern_br_a, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b, u_pattern_br_b, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    // find distance to outline for alpha interpolation\n\n    float dist = length(v_pos - gl_FragCoord.xy);\n    float alpha = smoothstep(1.0, 0.0, dist);\n    \n\n    gl_FragColor = mix(color1, color2, u_mix) * alpha * u_opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
    vertexSource: "#ifdef GL_ES\nprecision highp float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pixel_coord_upper;\nuniform vec2 u_pixel_coord_lower;\nuniform float u_scale_a;\nuniform float u_scale_b;\nuniform float u_tile_units_to_pixels;\n\nattribute vec2 a_pos;\n\nuniform mat4 u_matrix;\nuniform vec2 u_world;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    vec2 scaled_size_a = u_scale_a * u_pattern_size_a;\n    vec2 scaled_size_b = u_scale_b * u_pattern_size_b;\n\n    // the correct offset needs to be calculated.\n    //\n    // The offset depends on how many pixels are between the world origin and\n    // the edge of the tile:\n    // vec2 offset = mod(pixel_coord, size)\n    //\n    // At high zoom levels there are a ton of pixels between the world origin\n    // and the edge of the tile. The glsl spec only guarantees 16 bits of\n    // precision for highp floats. We need more than that.\n    //\n    // The pixel_coord is passed in as two 16 bit values:\n    // pixel_coord_upper = floor(pixel_coord / 2^16)\n    // pixel_coord_lower = mod(pixel_coord, 2^16)\n    //\n    // The offset is calculated in a series of steps that should preserve this precision:\n    vec2 offset_a = mod(mod(mod(u_pixel_coord_upper, scaled_size_a) * 256.0, scaled_size_a) * 256.0 + u_pixel_coord_lower, scaled_size_a);\n    vec2 offset_b = mod(mod(mod(u_pixel_coord_upper, scaled_size_b) * 256.0, scaled_size_b) * 256.0 + u_pixel_coord_lower, scaled_size_b);\n\n    v_pos_a = (u_tile_units_to_pixels * a_pos + offset_a) / scaled_size_a;\n    v_pos_b = (u_tile_units_to_pixels * a_pos + offset_b) / scaled_size_b;\n\n    v_pos = (gl_Position.xy / gl_Position.w + 1.0) / 2.0 * u_world;\n}\n"
  },
  pattern: {
    fragmentSource: "#ifdef GL_ES\nprecision mediump float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nuniform float u_opacity;\nuniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform float u_mix;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\nvoid main() {\n\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a, u_pattern_br_a, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b, u_pattern_br_b, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    gl_FragColor = mix(color1, color2, u_mix) * u_opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
    vertexSource: "#ifdef GL_ES\nprecision highp float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nuniform mat4 u_matrix;\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pixel_coord_upper;\nuniform vec2 u_pixel_coord_lower;\nuniform float u_scale_a;\nuniform float u_scale_b;\nuniform float u_tile_units_to_pixels;\n\nattribute vec2 a_pos;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    vec2 scaled_size_a = u_scale_a * u_pattern_size_a;\n    vec2 scaled_size_b = u_scale_b * u_pattern_size_b;\n\n    // the correct offset needs to be calculated.\n    //\n    // The offset depends on how many pixels are between the world origin and\n    // the edge of the tile:\n    // vec2 offset = mod(pixel_coord, size)\n    //\n    // At high zoom levels there are a ton of pixels between the world origin\n    // and the edge of the tile. The glsl spec only guarantees 16 bits of\n    // precision for highp floats. We need more than that.\n    //\n    // The pixel_coord is passed in as two 16 bit values:\n    // pixel_coord_upper = floor(pixel_coord / 2^16)\n    // pixel_coord_lower = mod(pixel_coord, 2^16)\n    //\n    // The offset is calculated in a series of steps that should preserve this precision:\n    vec2 offset_a = mod(mod(mod(u_pixel_coord_upper, scaled_size_a) * 256.0, scaled_size_a) * 256.0 + u_pixel_coord_lower, scaled_size_a);\n    vec2 offset_b = mod(mod(mod(u_pixel_coord_upper, scaled_size_b) * 256.0, scaled_size_b) * 256.0 + u_pixel_coord_lower, scaled_size_b);\n\n    v_pos_a = (u_tile_units_to_pixels * a_pos + offset_a) / scaled_size_a;\n    v_pos_b = (u_tile_units_to_pixels * a_pos + offset_b) / scaled_size_b;\n}\n"
  },
  raster: {
    fragmentSource: "#ifdef GL_ES\nprecision mediump float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nuniform float u_opacity0;\nuniform float u_opacity1;\nuniform sampler2D u_image0;\nuniform sampler2D u_image1;\nvarying vec2 v_pos0;\nvarying vec2 v_pos1;\n\nuniform float u_brightness_low;\nuniform float u_brightness_high;\n\nuniform float u_saturation_factor;\nuniform float u_contrast_factor;\nuniform vec3 u_spin_weights;\n\nvoid main() {\n\n    // read and cross-fade colors from the main and parent tiles\n    vec4 color0 = texture2D(u_image0, v_pos0);\n    vec4 color1 = texture2D(u_image1, v_pos1);\n    vec4 color = color0 * u_opacity0 + color1 * u_opacity1;\n    vec3 rgb = color.rgb;\n\n    // spin\n    rgb = vec3(\n        dot(rgb, u_spin_weights.xyz),\n        dot(rgb, u_spin_weights.zxy),\n        dot(rgb, u_spin_weights.yzx));\n\n    // saturation\n    float average = (color.r + color.g + color.b) / 3.0;\n    rgb += (average - rgb) * u_saturation_factor;\n\n    // contrast\n    rgb = (rgb - 0.5) * u_contrast_factor + 0.5;\n\n    // brightness\n    vec3 u_high_vec = vec3(u_brightness_low, u_brightness_low, u_brightness_low);\n    vec3 u_low_vec = vec3(u_brightness_high, u_brightness_high, u_brightness_high);\n\n    gl_FragColor = vec4(mix(u_high_vec, u_low_vec, rgb), color.a);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
    vertexSource: "#ifdef GL_ES\nprecision highp float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nuniform mat4 u_matrix;\nuniform vec2 u_tl_parent;\nuniform float u_scale_parent;\nuniform float u_buffer_scale;\n\nattribute vec2 a_pos;\nattribute vec2 a_texture_pos;\n\nvarying vec2 v_pos0;\nvarying vec2 v_pos1;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos0 = (((a_texture_pos / 32767.0) - 0.5) / u_buffer_scale ) + 0.5;\n    v_pos1 = (v_pos0 * u_scale_parent) + u_tl_parent;\n}\n"
  },
  icon: {
    fragmentSource: "#ifdef GL_ES\nprecision mediump float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nuniform sampler2D u_texture;\nuniform sampler2D u_fadetexture;\nuniform lowp float u_opacity;\n\nvarying vec2 v_tex;\nvarying vec2 v_fade_tex;\n\nvoid main() {\n    lowp float alpha = texture2D(u_fadetexture, v_fade_tex).a * u_opacity;\n    gl_FragColor = texture2D(u_texture, v_tex) * alpha;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
    vertexSource: "#ifdef GL_ES\nprecision highp float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_texture_pos;\nattribute vec4 a_data;\n\n\n// matrix is for the vertex position.\nuniform mat4 u_matrix;\n\nuniform mediump float u_zoom;\nuniform bool u_rotate_with_map;\nuniform vec2 u_extrude_scale;\n\nuniform vec2 u_texsize;\n\nvarying vec2 v_tex;\nvarying vec2 v_fade_tex;\n\nvoid main() {\n    vec2 a_tex = a_texture_pos.xy;\n    mediump float a_labelminzoom = a_data[0];\n    mediump vec2 a_zoom = a_data.pq;\n    mediump float a_minzoom = a_zoom[0];\n    mediump float a_maxzoom = a_zoom[1];\n\n    // u_zoom is the current zoom level adjusted for the change in font size\n    mediump float z = 2.0 - step(a_minzoom, u_zoom) - (1.0 - step(a_maxzoom, u_zoom));\n\n    vec2 extrude = u_extrude_scale * (a_offset / 64.0);\n    if (u_rotate_with_map) {\n        gl_Position = u_matrix * vec4(a_pos + extrude, 0, 1);\n        gl_Position.z += z * gl_Position.w;\n    } else {\n        gl_Position = u_matrix * vec4(a_pos, 0, 1) + vec4(extrude, 0, 0);\n    }\n\n    v_tex = a_tex / u_texsize;\n    v_fade_tex = vec2(a_labelminzoom / 255.0, 0.0);\n}\n"
  },
  sdf: {
    fragmentSource: "#ifdef GL_ES\nprecision mediump float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nuniform sampler2D u_texture;\nuniform sampler2D u_fadetexture;\nuniform lowp vec4 u_color;\nuniform lowp float u_opacity;\nuniform lowp float u_buffer;\nuniform lowp float u_gamma;\n\nvarying vec2 v_tex;\nvarying vec2 v_fade_tex;\nvarying float v_gamma_scale;\n\nvoid main() {\n    lowp float dist = texture2D(u_texture, v_tex).a;\n    lowp float fade_alpha = texture2D(u_fadetexture, v_fade_tex).a;\n    lowp float gamma = u_gamma * v_gamma_scale;\n    lowp float alpha = smoothstep(u_buffer - gamma, u_buffer + gamma, dist) * fade_alpha;\n\n    gl_FragColor = u_color * (alpha * u_opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",
    vertexSource: "#ifdef GL_ES\nprecision highp float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nconst float PI = 3.141592653589793;\n\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_texture_pos;\nattribute vec4 a_data;\n\n\n// matrix is for the vertex position.\nuniform mat4 u_matrix;\n\nuniform mediump float u_zoom;\nuniform bool u_rotate_with_map;\nuniform bool u_pitch_with_map;\nuniform mediump float u_pitch;\nuniform mediump float u_bearing;\nuniform mediump float u_aspect_ratio;\nuniform vec2 u_extrude_scale;\n\nuniform vec2 u_texsize;\n\nvarying vec2 v_tex;\nvarying vec2 v_fade_tex;\nvarying float v_gamma_scale;\n\nvoid main() {\n    vec2 a_tex = a_texture_pos.xy;\n    mediump float a_labelminzoom = a_data[0];\n    mediump vec2 a_zoom = a_data.pq;\n    mediump float a_minzoom = a_zoom[0];\n    mediump float a_maxzoom = a_zoom[1];\n\n    // u_zoom is the current zoom level adjusted for the change in font size\n    mediump float z = 2.0 - step(a_minzoom, u_zoom) - (1.0 - step(a_maxzoom, u_zoom));\n\n    // pitch-alignment: map\n    // rotation-alignment: map | viewport\n    if (u_pitch_with_map) {\n        lowp float angle = u_rotate_with_map ? (a_data[1] / 256.0 * 2.0 * PI) : u_bearing;\n        lowp float asin = sin(angle);\n        lowp float acos = cos(angle);\n        mat2 RotationMatrix = mat2(acos, asin, -1.0 * asin, acos);\n        vec2 offset = RotationMatrix * a_offset;\n        vec2 extrude = u_extrude_scale * (offset / 64.0);\n        gl_Position = u_matrix * vec4(a_pos + extrude, 0, 1);\n        gl_Position.z += z * gl_Position.w;\n    // pitch-alignment: viewport\n    // rotation-alignment: map\n    } else if (u_rotate_with_map) {\n        // foreshortening factor to apply on pitched maps\n        // as a label goes from horizontal <=> vertical in angle\n        // it goes from 0% foreshortening to up to around 70% foreshortening\n        lowp float pitchfactor = 1.0 - cos(u_pitch * sin(u_pitch * 0.75));\n\n        lowp float lineangle = a_data[1] / 256.0 * 2.0 * PI;\n\n        // use the lineangle to position points a,b along the line\n        // project the points and calculate the label angle in projected space\n        // this calculation allows labels to be rendered unskewed on pitched maps\n        vec4 a = u_matrix * vec4(a_pos, 0, 1);\n        vec4 b = u_matrix * vec4(a_pos + vec2(cos(lineangle),sin(lineangle)), 0, 1);\n        lowp float angle = atan((b[1]/b[3] - a[1]/a[3])/u_aspect_ratio, b[0]/b[3] - a[0]/a[3]);\n        lowp float asin = sin(angle);\n        lowp float acos = cos(angle);\n        mat2 RotationMatrix = mat2(acos, -1.0 * asin, asin, acos);\n\n        vec2 offset = RotationMatrix * (vec2((1.0-pitchfactor)+(pitchfactor*cos(angle*2.0)), 1.0) * a_offset);\n        vec2 extrude = u_extrude_scale * (offset / 64.0);\n        gl_Position = u_matrix * vec4(a_pos, 0, 1) + vec4(extrude, 0, 0);\n        gl_Position.z += z * gl_Position.w;\n    // pitch-alignment: viewport\n    // rotation-alignment: viewport\n    } else {\n        vec2 extrude = u_extrude_scale * (a_offset / 64.0);\n        gl_Position = u_matrix * vec4(a_pos, 0, 1) + vec4(extrude, 0, 0);\n    }\n\n    v_gamma_scale = (gl_Position.w - 0.5);\n\n    v_tex = a_tex / u_texsize;\n    v_fade_tex = vec2(a_labelminzoom / 255.0, 0.0);\n}\n"
  },
  collisionbox: {
    fragmentSource: "#ifdef GL_ES\nprecision mediump float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nuniform float u_zoom;\nuniform float u_maxzoom;\n\nvarying float v_max_zoom;\nvarying float v_placement_zoom;\n\nvoid main() {\n\n    float alpha = 0.5;\n\n    gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0) * alpha;\n\n    if (v_placement_zoom > u_zoom) {\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0) * alpha;\n    }\n\n    if (u_zoom >= v_max_zoom) {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0) * alpha * 0.25;\n    }\n\n    if (v_placement_zoom >= u_maxzoom) {\n        gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0) * alpha * 0.2;\n    }\n}\n",
    vertexSource: "#ifdef GL_ES\nprecision highp float;\n#else\n#define lowp\n#define mediump\n#define highp\n#endif\n\nattribute vec2 a_pos;\nattribute vec2 a_extrude;\nattribute vec2 a_data;\n\nuniform mat4 u_matrix;\nuniform float u_scale;\n\nvarying float v_max_zoom;\nvarying float v_placement_zoom;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos + a_extrude / u_scale, 0.0, 1.0);\n\n    v_max_zoom = a_data.x;\n    v_placement_zoom = a_data.y;\n}\n"
  }
};

module.exports.util = "float evaluate_zoom_function_1(const vec4 values, const float t) {\n    if (t < 1.0) {\n        return mix(values[0], values[1], t);\n    } else if (t < 2.0) {\n        return mix(values[1], values[2], t - 1.0);\n    } else {\n        return mix(values[2], values[3], t - 2.0);\n    }\n}\nvec4 evaluate_zoom_function_4(const vec4 value0, const vec4 value1, const vec4 value2, const vec4 value3, const float t) {\n    if (t < 1.0) {\n        return mix(value0, value1, t);\n    } else if (t < 2.0) {\n        return mix(value1, value2, t - 1.0);\n    } else {\n        return mix(value2, value3, t - 2.0);\n    }\n}\n";

},{"path":124}],160:[function(require,module,exports){
'use strict';

var format = require('util').format;

function ValidationError(key, value /*, message, ...*/) {
    this.message = (
        (key ? key + ': ' : '') +
        format.apply(format, Array.prototype.slice.call(arguments, 2))
    );

    if (value !== null && value !== undefined && value.__line__) {
        this.line = value.__line__;
    }
}

module.exports = ValidationError;

},{"util":133}],161:[function(require,module,exports){
'use strict';

module.exports = function (output) {
    for (var i = 1; i < arguments.length; i++) {
        var input = arguments[i];
        for (var k in input) {
            output[k] = input[k];
        }
    }
    return output;
};

},{}],162:[function(require,module,exports){
'use strict';

module.exports = function getType(val) {
    if (val instanceof Number) {
        return 'number';
    } else if (val instanceof String) {
        return 'string';
    } else if (val instanceof Boolean) {
        return 'boolean';
    } else if (Array.isArray(val)) {
        return 'array';
    } else if (val === null) {
        return 'null';
    } else {
        return typeof val;
    }
};

},{}],163:[function(require,module,exports){
'use strict';

// Turn jsonlint-lines-primitives objects into primitive objects
module.exports = function unbundle(value) {
    if (value instanceof Number || value instanceof String || value instanceof Boolean) {
        return value.valueOf();
    } else {
        return value;
    }
};

},{}],164:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');
var extend = require('../util/extend');

// Main recursive validation function. Tracks:
//
// - key: string representing location of validation in style tree. Used only
//   for more informative error reporting.
// - value: current value from style being evaluated. May be anything from a
//   high level object that needs to be descended into deeper or a simple
//   scalar value.
// - valueSpec: current spec being evaluated. Tracks value.

module.exports = function validate(options) {

    var validateFunction = require('./validate_function');
    var validateObject = require('./validate_object');
    var VALIDATORS = {
        '*': function() {
            return [];
        },
        'array': require('./validate_array'),
        'boolean': require('./validate_boolean'),
        'number': require('./validate_number'),
        'color': require('./validate_color'),
        'constants': require('./validate_constants'),
        'enum': require('./validate_enum'),
        'filter': require('./validate_filter'),
        'function': require('./validate_function'),
        'layer': require('./validate_layer'),
        'object': require('./validate_object'),
        'source': require('./validate_source'),
        'string': require('./validate_string')
    };

    var value = options.value;
    var valueSpec = options.valueSpec;
    var key = options.key;
    var styleSpec = options.styleSpec;
    var style = options.style;

    if (getType(value) === 'string' && value[0] === '@') {
        if (styleSpec.$version > 7) {
            return [new ValidationError(key, value, 'constants have been deprecated as of v8')];
        }
        if (!(value in style.constants)) {
            return [new ValidationError(key, value, 'constant "%s" not found', value)];
        }
        options = extend({}, options, { value: style.constants[value] });
    }

    if (valueSpec.function && getType(value) === 'object') {
        return validateFunction(options);

    } else if (valueSpec.type && VALIDATORS[valueSpec.type]) {
        return VALIDATORS[valueSpec.type](options);

    } else {
        return validateObject(extend({}, options, {
            valueSpec: valueSpec.type ? styleSpec[valueSpec.type] : valueSpec
        }));
    }
};

},{"../error/validation_error":160,"../util/extend":161,"../util/get_type":162,"./validate_array":165,"./validate_boolean":166,"./validate_color":167,"./validate_constants":168,"./validate_enum":169,"./validate_filter":170,"./validate_function":171,"./validate_layer":173,"./validate_number":175,"./validate_object":176,"./validate_source":178,"./validate_string":179}],165:[function(require,module,exports){
'use strict';

var getType = require('../util/get_type');
var validate = require('./validate');
var ValidationError = require('../error/validation_error');

module.exports = function validateArray(options) {
    var array = options.value;
    var arraySpec = options.valueSpec;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var key = options.key;
    var validateArrayElement = options.arrayElementValidator || validate;

    if (getType(array) !== 'array') {
        return [new ValidationError(key, array, 'array expected, %s found', getType(array))];
    }

    if (arraySpec.length && array.length !== arraySpec.length) {
        return [new ValidationError(key, array, 'array length %d expected, length %d found', arraySpec.length, array.length)];
    }

    if (arraySpec['min-length'] && array.length < arraySpec['min-length']) {
        return [new ValidationError(key, array, 'array length at least %d expected, length %d found', arraySpec['min-length'], array.length)];
    }

    var arrayElementSpec = {
        "type": arraySpec.value
    };

    if (styleSpec.$version < 7) {
        arrayElementSpec.function = arraySpec.function;
    }

    if (getType(arraySpec.value) === 'object') {
        arrayElementSpec = arraySpec.value;
    }

    var errors = [];
    for (var i = 0; i < array.length; i++) {
        errors = errors.concat(validateArrayElement({
            array: array,
            arrayIndex: i,
            value: array[i],
            valueSpec: arrayElementSpec,
            style: style,
            styleSpec: styleSpec,
            key: key + '[' + i + ']'
        }));
    }
    return errors;
};

},{"../error/validation_error":160,"../util/get_type":162,"./validate":164}],166:[function(require,module,exports){
'use strict';

var getType = require('../util/get_type');
var ValidationError = require('../error/validation_error');

module.exports = function validateBoolean(options) {
    var value = options.value;
    var key = options.key;
    var type = getType(value);

    if (type !== 'boolean') {
        return [new ValidationError(key, value, 'boolean expected, %s found', type)];
    }

    return [];
};

},{"../error/validation_error":160,"../util/get_type":162}],167:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');
var parseCSSColor = require('csscolorparser').parseCSSColor;

module.exports = function validateColor(options) {
    var key = options.key;
    var value = options.value;
    var type = getType(value);

    if (type !== 'string') {
        return [new ValidationError(key, value, 'color expected, %s found', type)];
    }

    if (parseCSSColor(value) === null) {
        return [new ValidationError(key, value, 'color expected, "%s" found', value)];
    }

    return [];
};

},{"../error/validation_error":160,"../util/get_type":162,"csscolorparser":134}],168:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');

module.exports = function validateConstants(options) {
    var key = options.key;
    var constants = options.value;
    var styleSpec = options.styleSpec;

    if (styleSpec.$version > 7) {
        if (constants) {
            return [new ValidationError(key, constants, 'constants have been deprecated as of v8')];
        } else {
            return [];
        }
    } else {
        var type = getType(constants);
        if (type !== 'object') {
            return [new ValidationError(key, constants, 'object expected, %s found', type)];
        }

        var errors = [];
        for (var constantName in constants) {
            if (constantName[0] !== '@') {
                errors.push(new ValidationError(key + '.' + constantName, constants[constantName], 'constants must start with "@"'));
            }
        }
        return errors;
    }

};

},{"../error/validation_error":160,"../util/get_type":162}],169:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var unbundle = require('../util/unbundle_jsonlint');

module.exports = function validateEnum(options) {
    var key = options.key;
    var value = options.value;
    var valueSpec = options.valueSpec;
    var errors = [];

    if (valueSpec.values.indexOf(unbundle(value)) === -1) {
        errors.push(new ValidationError(key, value, 'expected one of [%s], %s found', valueSpec.values.join(', '), value));
    }
    return errors;
};

},{"../error/validation_error":160,"../util/unbundle_jsonlint":163}],170:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var validateEnum = require('./validate_enum');
var getType = require('../util/get_type');
var unbundle = require('../util/unbundle_jsonlint');

module.exports = function validateFilter(options) {
    var value = options.value;
    var key = options.key;
    var styleSpec = options.styleSpec;
    var type;

    var errors = [];

    if (getType(value) !== 'array') {
        return [new ValidationError(key, value, 'array expected, %s found', getType(value))];
    }

    if (value.length < 1) {
        return [new ValidationError(key, value, 'filter array must have at least 1 element')];
    }

    errors = errors.concat(validateEnum({
        key: key + '[0]',
        value: value[0],
        valueSpec: styleSpec.filter_operator,
        style: options.style,
        styleSpec: options.styleSpec
    }));

    switch (unbundle(value[0])) {
        case '<':
        case '<=':
        case '>':
        case '>=':
            if (value.length >= 2 && value[1] == '$type') {
                errors.push(new ValidationError(key, value, '"$type" cannot be use with operator "%s"', value[0]));
            }
        /* falls through */
        case '==':
        case '!=':
            if (value.length != 3) {
                errors.push(new ValidationError(key, value, 'filter array for operator "%s" must have 3 elements', value[0]));
            }
        /* falls through */
        case 'in':
        case '!in':
            if (value.length >= 2) {
                type = getType(value[1]);
                if (type !== 'string') {
                    errors.push(new ValidationError(key + '[1]', value[1], 'string expected, %s found', type));
                } else if (value[1][0] === '@') {
                    errors.push(new ValidationError(key + '[1]', value[1], 'filter key cannot be a constant'));
                }
            }
            for (var i = 2; i < value.length; i++) {
                type = getType(value[i]);
                if (value[1] == '$type') {
                    errors = errors.concat(validateEnum({
                        key: key + '[' + i + ']',
                        value: value[i],
                        valueSpec: styleSpec.geometry_type,
                        style: options.style,
                        styleSpec: options.styleSpec
                    }));
                } else if (type === 'string' && value[i][0] === '@') {
                    errors.push(new ValidationError(key + '[' + i + ']', value[i], 'filter value cannot be a constant'));
                } else if (type !== 'string' && type !== 'number' && type !== 'boolean') {
                    errors.push(new ValidationError(key + '[' + i + ']', value[i], 'string, number, or boolean expected, %s found', type));
                }
            }
            break;

        case 'any':
        case 'all':
        case 'none':
            for (i = 1; i < value.length; i++) {
                errors = errors.concat(validateFilter({
                    key: key + '[' + i + ']',
                    value: value[i],
                    style: options.style,
                    styleSpec: options.styleSpec
                }));
            }
            break;

        case 'has':
        case '!has':
            type = getType(value[1]);
            if (value.length !== 2) {
                errors.push(new ValidationError(key, value, 'filter array for "%s" operator must have 2 elements', value[0]));
            } else if (type !== 'string') {
                errors.push(new ValidationError(key + '[1]', value[1], 'string expected, %s found', type));
            } else if (value[1][0] === '@') {
                errors.push(new ValidationError(key + '[1]', value[1], 'filter key cannot be a constant'));
            }
            break;

    }

    return errors;
};

},{"../error/validation_error":160,"../util/get_type":162,"../util/unbundle_jsonlint":163,"./validate_enum":169}],171:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');
var validate = require('./validate');
var validateObject = require('./validate_object');
var validateArray = require('./validate_array');
var validateNumber = require('./validate_number');

module.exports = function validateFunction(options) {
    var functionValueSpec = options.valueSpec;
    var stopKeyType;

    var isPropertyFunction = options.value.property !== undefined || stopKeyType === 'object';
    var isZoomFunction = options.value.property === undefined || stopKeyType === 'object';

    var errors = validateObject({
        key: options.key,
        value: options.value,
        valueSpec: options.styleSpec.function,
        style: options.style,
        styleSpec: options.styleSpec,
        objectElementValidators: { stops: validateFunctionStops }
    });

    if (options.styleSpec.$version >= 8) {
       if (isPropertyFunction && !options.valueSpec['property-function']) {
           errors.push(new ValidationError(options.key, options.value, 'property functions not supported'));
       } else if (isZoomFunction && !options.valueSpec['zoom-function']) {
           errors.push(new ValidationError(options.key, options.value, 'zoom functions not supported'));
       }
    }

    return errors;

    function validateFunctionStops(options) {
        var errors = [];
        var value = options.value;

        errors = errors.concat(validateArray({
            key: options.key,
            value: value,
            valueSpec: options.valueSpec,
            style: options.style,
            styleSpec: options.styleSpec,
            arrayElementValidator: validateFunctionStop
        }));

        if (getType(value) === 'array' && value.length === 0) {
            errors.push(new ValidationError(options.key, value, 'array must have at least one stop'));
        }

        return errors;
    }

    function validateFunctionStop(options) {
        var errors = [];
        var value = options.value;
        var key = options.key;

        if (getType(value) !== 'array') {
            return [new ValidationError(key, value, 'array expected, %s found', getType(value))];
        }

        if (value.length !== 2) {
            return [new ValidationError(key, value, 'array length %d expected, length %d found', 2, value.length)];
        }

        var type = getType(value[0]);
        if (!stopKeyType) stopKeyType = type;
        if (type !== stopKeyType) {
            return [new ValidationError(key, value, '%s stop key type must match previous stop key type %s', type, stopKeyType)];
        }

        if (type === 'object') {
            if (value[0].zoom === undefined) {
                return [new ValidationError(key, value, 'object stop key must have zoom')];
            }
            if (value[0].value === undefined) {
                return [new ValidationError(key, value, 'object stop key must have value')];
            }
            errors = errors.concat(validateObject({
                key: key + '[0]',
                value: value[0],
                valueSpec: { zoom: {} },
                style: options.style,
                styleSpec: options.styleSpec,
                objectElementValidators: { zoom: validateNumber, value: validateValue }
            }));
        } else {
            errors = errors.concat((isZoomFunction ? validateNumber : validateValue)({
                key: key + '[0]',
                value: value[0],
                valueSpec: {},
                style: options.style,
                styleSpec: options.styleSpec
            }));
        }

        errors = errors.concat(validate({
            key: key + '[1]',
            value: value[1],
            valueSpec: functionValueSpec,
            style: options.style,
            styleSpec: options.styleSpec
        }));

        if (getType(value[0]) === 'number') {
            if (functionValueSpec.function === 'piecewise-constant' && value[0] % 1 !== 0) {
                errors.push(new ValidationError(key + '[0]', value[0], 'zoom level for piecewise-constant functions must be an integer'));
            }

            if (options.arrayIndex !== 0) {
                if (value[0] < options.array[options.arrayIndex - 1][0]) {
                    errors.push(new ValidationError(key + '[0]', value[0], 'array stops must appear in ascending order'));
                }
            }
        }

        return errors;
    }

    function validateValue(options) {
        var errors = [];
        var type = getType(options.value);
        if (type !== 'number' && type !== 'string' && type !== 'array') {
            errors.push(new ValidationError(options.key, options.value, 'property value must be a number, string or array'));
        }
        return errors;
    }

};

},{"../error/validation_error":160,"../util/get_type":162,"./validate":164,"./validate_array":165,"./validate_number":175,"./validate_object":176}],172:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var validateString = require('./validate_string');

module.exports = function(options) {
    var value = options.value;
    var key = options.key;

    var errors = validateString(options);
    if (errors.length) return errors;

    if (value.indexOf('{fontstack}') === -1) {
        errors.push(new ValidationError(key, value, '"glyphs" url must include a "{fontstack}" token'));
    }

    if (value.indexOf('{range}') === -1) {
        errors.push(new ValidationError(key, value, '"glyphs" url must include a "{range}" token'));
    }

    return errors;
};

},{"../error/validation_error":160,"./validate_string":179}],173:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var unbundle = require('../util/unbundle_jsonlint');
var validateObject = require('./validate_object');
var validateFilter = require('./validate_filter');
var validatePaintProperty = require('./validate_paint_property');
var validateLayoutProperty = require('./validate_layout_property');
var extend = require('../util/extend');

module.exports = function validateLayer(options) {
    var errors = [];

    var layer = options.value;
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;

    if (!layer.type && !layer.ref) {
        errors.push(new ValidationError(key, layer, 'either "type" or "ref" is required'));
    }
    var type = unbundle(layer.type);
    var ref = unbundle(layer.ref);

    if (layer.id) {
        for (var i = 0; i < options.arrayIndex; i++) {
            var otherLayer = style.layers[i];
            if (unbundle(otherLayer.id) === unbundle(layer.id)) {
                errors.push(new ValidationError(key, layer.id, 'duplicate layer id "%s", previously used at line %d', layer.id, otherLayer.id.__line__));
            }
        }
    }

    if ('ref' in layer) {
        ['type', 'source', 'source-layer', 'filter', 'layout'].forEach(function (p) {
            if (p in layer) {
                errors.push(new ValidationError(key, layer[p], '"%s" is prohibited for ref layers', p));
            }
        });

        var parent;

        style.layers.forEach(function(layer) {
            if (layer.id == ref) parent = layer;
        });

        if (!parent) {
            errors.push(new ValidationError(key, layer.ref, 'ref layer "%s" not found', ref));
        } else if (parent.ref) {
            errors.push(new ValidationError(key, layer.ref, 'ref cannot reference another ref layer'));
        } else {
            type = unbundle(parent.type);
        }
    } else if (type !== 'background') {
        if (!layer.source) {
            errors.push(new ValidationError(key, layer, 'missing required property "source"'));
        } else {
            var source = style.sources && style.sources[layer.source];
            if (!source) {
                errors.push(new ValidationError(key, layer.source, 'source "%s" not found', layer.source));
            } else if (source.type == 'vector' && type == 'raster') {
                errors.push(new ValidationError(key, layer.source, 'layer "%s" requires a raster source', layer.id));
            } else if (source.type == 'raster' && type != 'raster') {
                errors.push(new ValidationError(key, layer.source, 'layer "%s" requires a vector source', layer.id));
            } else if (source.type == 'vector' && !layer['source-layer']) {
                errors.push(new ValidationError(key, layer, 'layer "%s" must specify a "source-layer"', layer.id));
            }
        }
    }

    errors = errors.concat(validateObject({
        key: key,
        value: layer,
        valueSpec: styleSpec.layer,
        style: options.style,
        styleSpec: options.styleSpec,
        objectElementValidators: {
            filter: validateFilter,
            layout: function(options) {
                return validateObject({
                    layer: layer,
                    key: options.key,
                    value: options.value,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    objectElementValidators: {
                        '*': function(options) {
                            return validateLayoutProperty(extend({layerType: type}, options));
                        }
                    }
                });
            },
            paint: function(options) {
                return validateObject({
                    layer: layer,
                    key: options.key,
                    value: options.value,
                    style: options.style,
                    styleSpec: options.styleSpec,
                    objectElementValidators: {
                        '*': function(options) {
                            return validatePaintProperty(extend({layerType: type}, options));
                        }
                    }
                });
            }
        }
    }));

    return errors;
};

},{"../error/validation_error":160,"../util/extend":161,"../util/unbundle_jsonlint":163,"./validate_filter":170,"./validate_layout_property":174,"./validate_object":176,"./validate_paint_property":177}],174:[function(require,module,exports){
'use strict';

var validate = require('./validate');
var ValidationError = require('../error/validation_error');

module.exports = function validateLayoutProperty(options) {
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var value = options.value;
    var propertyKey = options.objectKey;
    var layerSpec = styleSpec['layout_' + options.layerType];

    if (options.valueSpec || layerSpec[propertyKey]) {
        var errors = [];

        if (options.layerType === 'symbol') {
            if (propertyKey === 'icon-image' && style && !style.sprite) {
                errors.push(new ValidationError(key, value, 'use of "icon-image" requires a style "sprite" property'));
            } else if (propertyKey === 'text-field' && style && !style.glyphs) {
                errors.push(new ValidationError(key, value, 'use of "text-field" requires a style "glyphs" property'));
            }
        }

        return errors.concat(validate({
            key: options.key,
            value: value,
            valueSpec: options.valueSpec || layerSpec[propertyKey],
            style: style,
            styleSpec: styleSpec
        }));

    } else {
        return [new ValidationError(key, value, 'unknown property "%s"', propertyKey)];
    }

};

},{"../error/validation_error":160,"./validate":164}],175:[function(require,module,exports){
'use strict';

var getType = require('../util/get_type');
var ValidationError = require('../error/validation_error');

module.exports = function validateNumber(options) {
    var key = options.key;
    var value = options.value;
    var valueSpec = options.valueSpec;
    var type = getType(value);

    if (type !== 'number') {
        return [new ValidationError(key, value, 'number expected, %s found', type)];
    }

    if ('minimum' in valueSpec && value < valueSpec.minimum) {
        return [new ValidationError(key, value, '%s is less than the minimum value %s', value, valueSpec.minimum)];
    }

    if ('maximum' in valueSpec && value > valueSpec.maximum) {
        return [new ValidationError(key, value, '%s is greater than the maximum value %s', value, valueSpec.maximum)];
    }

    return [];
};

},{"../error/validation_error":160,"../util/get_type":162}],176:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var getType = require('../util/get_type');
var validate = require('./validate');

module.exports = function validateObject(options) {
    var key = options.key;
    var object = options.value;
    var valueSpec = options.valueSpec;
    var objectElementValidators = options.objectElementValidators || {};
    var style = options.style;
    var styleSpec = options.styleSpec;
    var errors = [];

    var type = getType(object);
    if (type !== 'object') {
        return [new ValidationError(key, object, 'object expected, %s found', type)];
    }

    for (var objectKey in object) {
        var valueSpecKey = objectKey.split('.')[0]; // treat 'paint.*' as 'paint'
        var objectElementSpec = valueSpec && (valueSpec[valueSpecKey] || valueSpec['*']);
        var objectElementValidator = objectElementValidators[valueSpecKey] || objectElementValidators['*'];

        if (objectElementSpec || objectElementValidator) {
            errors = errors.concat((objectElementValidator || validate)({
                key: (key ? key + '.' : key) + objectKey,
                value: object[objectKey],
                valueSpec: objectElementSpec,
                style: style,
                styleSpec: styleSpec,
                object: object,
                objectKey: objectKey
            }));

        // tolerate root-level extra keys & arbitrary layer properties
        // TODO remove this layer-specific logic
        } else if (key !== '' && key.split('.').length !== 1) {
            errors.push(new ValidationError(key, object[objectKey], 'unknown property "%s"', objectKey));
        }
    }

    for (valueSpecKey in valueSpec) {
        if (valueSpec[valueSpecKey].required && valueSpec[valueSpecKey]['default'] === undefined && object[valueSpecKey] === undefined) {
            errors.push(new ValidationError(key, object, 'missing required property "%s"', valueSpecKey));
        }
    }

    return errors;
};

},{"../error/validation_error":160,"../util/get_type":162,"./validate":164}],177:[function(require,module,exports){
'use strict';

var validate = require('./validate');
var ValidationError = require('../error/validation_error');

module.exports = function validatePaintProperty(options) {
    var key = options.key;
    var style = options.style;
    var styleSpec = options.styleSpec;
    var value = options.value;
    var propertyKey = options.objectKey;
    var layerSpec = styleSpec['paint_' + options.layerType];

    var transitionMatch = propertyKey.match(/^(.*)-transition$/);

    if (transitionMatch && layerSpec[transitionMatch[1]] && layerSpec[transitionMatch[1]].transition) {
        return validate({
            key: key,
            value: value,
            valueSpec: styleSpec.transition,
            style: style,
            styleSpec: styleSpec
        });

    } else if (options.valueSpec || layerSpec[propertyKey]) {
        return validate({
            key: options.key,
            value: value,
            valueSpec: options.valueSpec || layerSpec[propertyKey],
            style: style,
            styleSpec: styleSpec
        });

    } else {
        return [new ValidationError(key, value, 'unknown property "%s"', propertyKey)];
    }

};

},{"../error/validation_error":160,"./validate":164}],178:[function(require,module,exports){
'use strict';

var ValidationError = require('../error/validation_error');
var unbundle = require('../util/unbundle_jsonlint');
var validateObject = require('./validate_object');
var validateEnum = require('./validate_enum');

module.exports = function validateSource(options) {
    var value = options.value;
    var key = options.key;
    var styleSpec = options.styleSpec;
    var style = options.style;

    if (!value.type) {
        return [new ValidationError(key, value, '"type" is required')];
    }

    var type = unbundle(value.type);
    switch (type) {
        case 'vector':
        case 'raster':
            var errors = [];
            errors = errors.concat(validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_tile,
                style: options.style,
                styleSpec: styleSpec
            }));
            if ('url' in value) {
                for (var prop in value) {
                    if (['type', 'url', 'tileSize'].indexOf(prop) < 0) {
                        errors.push(new ValidationError(key + '.' + prop, value[prop], 'a source with a "url" property may not include a "%s" property', prop));
                    }
                }
            }
            return errors;

        case 'geojson':
            return validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_geojson,
                style: style,
                styleSpec: styleSpec
            });

        case 'video':
            return validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_video,
                style: style,
                styleSpec: styleSpec
            });

        case 'image':
            return validateObject({
                key: key,
                value: value,
                valueSpec: styleSpec.source_image,
                style: style,
                styleSpec: styleSpec
            });

        default:
            return validateEnum({
                key: key + '.type',
                value: value.type,
                valueSpec: {values: ['vector', 'raster', 'geojson', 'video', 'image']},
                style: style,
                styleSpec: styleSpec
            });
    }
};

},{"../error/validation_error":160,"../util/unbundle_jsonlint":163,"./validate_enum":169,"./validate_object":176}],179:[function(require,module,exports){
'use strict';

var getType = require('../util/get_type');
var ValidationError = require('../error/validation_error');

module.exports = function validateString(options) {
    var value = options.value;
    var key = options.key;
    var type = getType(value);

    if (type !== 'string') {
        return [new ValidationError(key, value, 'string expected, %s found', type)];
    }

    return [];
};

},{"../error/validation_error":160,"../util/get_type":162}],180:[function(require,module,exports){
'use strict';

var validateConstants = require('./validate/validate_constants');
var validate = require('./validate/validate');
var latestStyleSpec = require('../reference/latest.min');
var validateGlyphsURL = require('./validate/validate_glyphs_url');

/**
 * Validate a Mapbox GL style against the style specification. This entrypoint,
 * `mapbox-gl-style-spec/lib/validate_style.min`, is designed to produce as
 * small a browserify bundle as possible by omitting unnecessary functionality
 * and legacy style specifications.
 *
 * @param {Object} style The style to be validated.
 * @param {Object} [styleSpec] The style specification to validate against.
 *     If omitted, the latest style spec is used.
 * @returns {Array<ValidationError>}
 * @example
 *   var validate = require('mapbox-gl-style-spec/lib/validate_style.min');
 *   var errors = validate(style);
 */
function validateStyleMin(style, styleSpec) {
    styleSpec = styleSpec || latestStyleSpec;

    var errors = [];

    errors = errors.concat(validate({
        key: '',
        value: style,
        valueSpec: styleSpec.$root,
        styleSpec: styleSpec,
        style: style,
        objectElementValidators: {
            glyphs: validateGlyphsURL
        }
    }));

    if (styleSpec.$version > 7 && style.constants) {
        errors = errors.concat(validateConstants({
            key: 'constants',
            value: style.constants,
            style: style,
            styleSpec: styleSpec
        }));
    }

    return sortErrors(errors);
}

validateStyleMin.source = wrapCleanErrors(require('./validate/validate_source'));
validateStyleMin.layer = wrapCleanErrors(require('./validate/validate_layer'));
validateStyleMin.filter = wrapCleanErrors(require('./validate/validate_filter'));
validateStyleMin.paintProperty = wrapCleanErrors(require('./validate/validate_paint_property'));
validateStyleMin.layoutProperty = wrapCleanErrors(require('./validate/validate_layout_property'));

function sortErrors(errors) {
    return [].concat(errors).sort(function (a, b) {
        return a.line - b.line;
    });
}

function wrapCleanErrors(inner) {
    return function() {
        return sortErrors(inner.apply(this, arguments));
    };
}

module.exports = validateStyleMin;

},{"../reference/latest.min":181,"./validate/validate":164,"./validate/validate_constants":168,"./validate/validate_filter":170,"./validate/validate_glyphs_url":172,"./validate/validate_layer":173,"./validate/validate_layout_property":174,"./validate/validate_paint_property":177,"./validate/validate_source":178}],181:[function(require,module,exports){
module.exports = require('./v8.min.json');

},{"./v8.min.json":182}],182:[function(require,module,exports){
module.exports={"sources":{"*":{"type":"source","doc":"Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For GeoJSON and video sources, a URL must be provided."}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds","doc":"Time allotted for transitions to complete."},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds","doc":"Length of time before a transition begins."}},"$version":8,"source":["source_tile","source_geojson","source_video","source_image"],"source_tile":{"type":{"required":true,"type":"enum","values":["vector","raster"],"doc":"The data type of the tile source."},"url":{"type":"string","doc":"A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<mapid>`."},"tiles":{"type":"array","value":"string","doc":"An array of one or more tile source URLs, as in the TileJSON spec."},"minzoom":{"type":"number","default":0,"doc":"Minimum zoom level for which tiles are available, as in the TileJSON spec."},"maxzoom":{"type":"number","default":22,"doc":"Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."},"tileSize":{"type":"number","default":512,"units":"pixels","doc":"The minimum visual size to display tiles for this layer. Only configurable for raster layers."},"*":{"type":"*","doc":"Other keys to configure the data source."}},"source_geojson":{"type":{"required":true,"type":"enum","values":["geojson"],"doc":"The data type of the GeoJSON source."},"data":{"type":"*","doc":"A URL to a GeoJSON file, or inline GeoJSON."},"maxzoom":{"type":"number","default":14,"doc":"Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels)."},"buffer":{"type":"number","default":64,"doc":"Tile buffer size on each side (higher means fewer rendering artifacts near tile edges but slower performance)."},"tolerance":{"type":"number","default":3,"doc":"Douglas-Peucker simplification tolerance (higher means simpler geometries and faster performance)."},"cluster":{"type":"boolean","default":false,"doc":"If the data is a collection of point features, setting this to true clusters the points by radius into groups."},"clusterRadius":{"type":"number","default":400,"doc":"Radius of each cluster when clustering points, relative to 4096 tile."},"clusterMaxZoom":{"type":"number","doc":"Max zoom to cluster points on. Defaults to one zoom less than maxzoom (so that last zoom features are not clustered)."}},"source_video":{"type":{"required":true,"type":"enum","values":["video"],"doc":"The data type of the video source."},"urls":{"required":true,"type":"array","value":"string","doc":"URLs to video content in order of preferred format."},"coordinates":{"required":true,"doc":"Corners of video specified in longitude, latitude pairs.","type":"array","length":4,"value":{"type":"array","length":2,"value":"number","doc":"A single longitude, latitude pair."}}},"source_image":{"type":{"required":true,"type":"enum","values":["image"],"doc":"The data type of the image source."},"url":{"required":true,"type":"string","doc":"URL that points to an image"},"coordinates":{"required":true,"doc":"Corners of image specified in longitude, latitude pairs.","type":"array","length":4,"value":{"type":"array","length":2,"value":"number","doc":"A single longitude, latitude pair."}}},"layer":{"id":{"type":"string","doc":"Unique layer name.","required":true},"type":{"type":"enum","values":["fill","line","symbol","circle","raster","background","extrusion"],"doc":"Rendering type of this layer."},"metadata":{"type":"*","doc":"Arbitrary properties useful to track with the layer, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."},"ref":{"type":"string","doc":"References another layer to copy `type`, `source`, `source-layer`, `minzoom`, `maxzoom`, `filter`, and `layout` properties from. This allows the layers to share processing and be more efficient."},"source":{"type":"string","doc":"Name of a source description to be used for this layer."},"source-layer":{"type":"string","doc":"Layer to use from a vector tile source. Required if the source supports multiple layers."},"minzoom":{"type":"number","minimum":0,"maximum":22,"doc":"The minimum zoom level on which the layer gets parsed and appears on."},"maxzoom":{"type":"number","minimum":0,"maximum":22,"doc":"The maximum zoom level on which the layer gets parsed and appears on."},"interactive":{"type":"boolean","doc":"Enable querying of feature data from this layer for interactivity.","default":false},"filter":{"type":"filter","doc":"A expression specifying conditions on source features. Only features that match the filter are displayed."},"layout":{"type":"layout","doc":"Layout properties for the layer."},"paint":{"type":"paint","doc":"Default paint properties for this layer."},"paint.*":{"type":"paint","doc":"Class-specific paint properties for this layer. The class name is the part after the first dot."}},"layout":["layout_fill","layout_line","layout_circle","layout_symbol","layout_raster","layout_background","layout_extrusion"],"layout_background":{"visibility":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":["visible","none"],"default":"visible","doc":"The display of this layer. `none` hides this layer.","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}}},"layout_fill":{"visibility":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":["visible","none"],"default":"visible","doc":"The display of this layer. `none` hides this layer.","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}}},"layout_extrusion":{"visibility":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":["visible","none"],"default":"visible","doc":"The display of this layer. `none` hides this layer."}},"layout_circle":{"visibility":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":["visible","none"],"default":"visible","doc":"The display of this layer. `none` hides this layer.","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}}},"layout_line":{"line-cap":{"type":"enum","function":"piecewise-constant","zoom-function":true,"property-function":true,"values":["butt","round","square"],"default":"butt","doc":"The display of line endings.","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"line-join":{"type":"enum","function":"piecewise-constant","zoom-function":true,"property-function":true,"values":["bevel","round","miter"],"default":"miter","doc":"The display of lines when joining.","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"line-miter-limit":{"type":"number","default":2,"function":"interpolated","zoom-function":true,"property-function":true,"doc":"Used to automatically convert miter joins to bevel joins for sharp angles.","requires":[{"line-join":"miter"}],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"line-round-limit":{"type":"number","default":1.05,"function":"interpolated","zoom-function":true,"property-function":true,"doc":"Used to automatically convert round joins to miter joins for shallow angles.","requires":[{"line-join":"round"}],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"visibility":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":["visible","none"],"default":"visible","doc":"The display of this layer. `none` hides this layer.","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}}},"layout_symbol":{"symbol-placement":{"type":"enum","function":"piecewise-constant","zoom-function":true,"property-function":true,"values":["point","line"],"default":"point","doc":"Label placement relative to its geometry. `line` can only be used on LineStrings and Polygons.","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"symbol-spacing":{"type":"number","default":250,"minimum":1,"function":"interpolated","zoom-function":true,"property-function":true,"units":"pixels","doc":"Distance between two symbol anchors.","requires":[{"symbol-placement":"line"}],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"symbol-avoid-edges":{"type":"boolean","function":"piecewise-constant","zoom-function":true,"property-function":true,"default":false,"doc":"If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don't have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer.","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"icon-allow-overlap":{"type":"boolean","function":"piecewise-constant","zoom-function":true,"property-function":true,"default":false,"doc":"If true, the icon will be visible even if it collides with other previously drawn symbols.","requires":["icon-image"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"icon-ignore-placement":{"type":"boolean","function":"piecewise-constant","zoom-function":true,"property-function":true,"default":false,"doc":"If true, other symbols can be visible even if they collide with the icon.","requires":["icon-image"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"icon-optional":{"type":"boolean","function":"piecewise-constant","zoom-function":true,"property-function":true,"default":false,"doc":"If true, text will display without their corresponding icons when the icon collides with other symbols and the text does not.","requires":["icon-image","text-field"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"icon-rotation-alignment":{"type":"enum","function":"piecewise-constant","zoom-function":true,"property-function":true,"values":["map","viewport"],"default":"viewport","doc":"Orientation of icon when map is rotated.","requires":["icon-image"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"icon-size":{"type":"number","default":1,"minimum":0,"function":"interpolated","zoom-function":true,"property-function":true,"doc":"Scale factor for icon. 1 is original size, 3 triples the size.","requires":["icon-image"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"icon-text-fit":{"type":"enum","function":"piecewise-constant","zoom-function":true,"property-function":false,"values":["none","both","width","height"],"default":"none","doc":"Position and scale an icon by the its corresponding text.","requires":["icon-image","text-field"],"sdk-support":{"basic":{"js":"0.21.0"}}},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","function":"interpolated","zoom-function":true,"property-function":true,"doc":"Size of padding area around the text-fit size in clockwise order: top, right, bottom, left.","requires":["icon-image","icon-text-fit","text-field"],"sdk-support":{"basic":{"js":"0.21.0"}}},"icon-image":{"type":"string","function":"piecewise-constant","zoom-function":true,"property-function":true,"doc":"A string with {tokens} replaced, referencing the data property to pull from.","tokens":true,"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"icon-rotate":{"type":"number","default":0,"period":360,"function":"interpolated","zoom-function":true,"property-function":true,"units":"degrees","doc":"Rotates the icon clockwise.","requires":["icon-image"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"},"property-function":{"js":"0.21.0"}}},"icon-padding":{"type":"number","default":2,"minimum":0,"function":"interpolated","zoom-function":true,"property-function":true,"units":"pixels","doc":"Size of the additional area around the icon bounding box used for detecting symbol collisions.","requires":["icon-image"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"icon-keep-upright":{"type":"boolean","function":"piecewise-constant","zoom-function":true,"property-function":true,"default":false,"doc":"If true, the icon may be flipped to prevent it from being rendered upside-down.","requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":"line"}],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","zoom-function":true,"property-function":true,"doc":"Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up.","requires":["icon-image"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-pitch-alignment":{"type":"enum","function":"piecewise-constant","zoom-function":true,"property-function":true,"values":["map","viewport"],"doc":"Aligns text to the plane of the `viewport` or the `map` when the map is pitched. Matches `text-rotation-alignment` if unspecified.","requires":["text-field"],"sdk-support":{"basic":{"js":"0.21.0"}}},"text-rotation-alignment":{"type":"enum","function":"piecewise-constant","zoom-function":true,"property-function":true,"values":["map","viewport"],"default":"viewport","doc":"Orientation of text when map is rotated.","requires":["text-field"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-field":{"type":"string","function":"piecewise-constant","zoom-function":true,"property-function":true,"default":"","tokens":true,"doc":"Value to use for a text label. Feature properties are specified using tokens like {field_name}.","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-font":{"type":"array","value":"string","function":"piecewise-constant","zoom-function":true,"property-function":true,"default":["Open Sans Regular","Arial Unicode MS Regular"],"doc":"Font stack to use for displaying text.","requires":["text-field"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","function":"interpolated","zoom-function":true,"property-function":true,"doc":"Font size.","requires":["text-field"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"em","function":"interpolated","zoom-function":true,"property-function":true,"doc":"The maximum line width for text wrapping.","requires":["text-field"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-line-height":{"type":"number","default":1.2,"units":"em","function":"interpolated","zoom-function":true,"property-function":true,"doc":"Text leading value for multi-line text.","requires":["text-field"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-letter-spacing":{"type":"number","default":0,"units":"em","function":"interpolated","zoom-function":true,"property-function":true,"doc":"Text tracking amount.","requires":["text-field"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-justify":{"type":"enum","function":"piecewise-constant","zoom-function":true,"property-function":true,"values":["left","center","right"],"default":"center","doc":"Text justification options.","requires":["text-field"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-anchor":{"type":"enum","function":"piecewise-constant","zoom-function":true,"property-function":true,"values":["center","left","right","top","bottom","top-left","top-right","bottom-left","bottom-right"],"default":"center","doc":"Part of the text placed closest to the anchor.","requires":["text-field"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-max-angle":{"type":"number","default":45,"units":"degrees","function":"interpolated","zoom-function":true,"property-function":true,"doc":"Maximum angle change between adjacent characters.","requires":["text-field",{"symbol-placement":"line"}],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","function":"interpolated","zoom-function":true,"property-function":true,"doc":"Rotates the text clockwise.","requires":["text-field"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","function":"interpolated","zoom-function":true,"property-function":true,"doc":"Size of the additional area around the text bounding box used for detecting symbol collisions.","requires":["text-field"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-keep-upright":{"type":"boolean","function":"piecewise-constant","zoom-function":true,"property-function":true,"default":true,"doc":"If true, the text may be flipped vertically to prevent it from being rendered upside-down.","requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":"line"}],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-transform":{"type":"enum","function":"piecewise-constant","zoom-function":true,"property-function":true,"values":["none","uppercase","lowercase"],"default":"none","doc":"Specifies how to capitalize text, similar to the CSS `text-transform` property.","requires":["text-field"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-offset":{"type":"array","doc":"Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up.","value":"number","units":"ems","function":"interpolated","zoom-function":true,"property-function":true,"length":2,"default":[0,0],"requires":["text-field"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-allow-overlap":{"type":"boolean","function":"piecewise-constant","zoom-function":true,"property-function":true,"default":false,"doc":"If true, the text will be visible even if it collides with other previously drawn symbols.","requires":["text-field"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-ignore-placement":{"type":"boolean","function":"piecewise-constant","zoom-function":true,"property-function":true,"default":false,"doc":"If true, other symbols can be visible even if they collide with the text.","requires":["text-field"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-optional":{"type":"boolean","function":"piecewise-constant","zoom-function":true,"property-function":true,"default":false,"doc":"If true, icons will display without their corresponding text when the text collides with other symbols and the icon does not.","requires":["text-field","icon-image"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"visibility":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":["visible","none"],"default":"visible","doc":"The display of this layer. `none` hides this layer.","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}}},"$root":{"version":{"required":true,"type":"enum","values":[8],"doc":"Style specification version number. Must be 8.","example":8},"name":{"type":"string","doc":"A human-readable name for the style.","example":"Bright"},"metadata":{"type":"*","doc":"Arbitrary properties useful to track with the stylesheet, but do not influence rendering. Properties should be prefixed to avoid collisions, like 'mapbox:'."},"center":{"type":"array","value":"number","doc":"Default map center in longitude and latitude.  The style center will be used only if the map has not been positioned by other means (e.g. map options or user interaction).","example":[-73.9749,40.7736]},"zoom":{"type":"number","doc":"Default zoom level.  The style zoom will be used only if the map has not been positioned by other means (e.g. map options or user interaction).","example":12.5},"bearing":{"type":"number","default":0,"period":360,"units":"degrees","doc":"Default bearing, in degrees.  The style bearing will be used only if the map has not been positioned by other means (e.g. map options or user interaction).","example":29},"pitch":{"type":"number","default":0,"units":"degrees","doc":"Default pitch, in degrees. Zero is perpendicular to the surface.  The style pitch will be used only if the map has not been positioned by other means (e.g. map options or user interaction).","example":50},"light":{"light-anchor":{"type":"enum","default":"viewport","values":["map","viewport"],"doc":"Whether extrusions are lit relative to map or viewport. The light-anchor property will only be used if it has not been set by map options upon initialization.","example":"map"},"light-direction":{"type":"array","value":"number","default":[-0.5,-0.3,1],"doc":"Light direction for lighting extrusions ##TODO##. The light-direction property will only be used if it has not been set by map options upon initialization.","example":[0.5,-0.2,1]},"light-color":{"type":"color","default":"rgba(1,1,1,0.75)","doc":"Color tint for lighting extrusions. The light-color property will only be used if it has not been set by map options upon initialization.","example":"## TODO @nickidlugash what's a good light color?"}},"sources":{"required":true,"type":"sources","doc":"Data source specifications.","example":{"mapbox-streets":{"type":"vector","url":"mapbox://mapbox.mapbox-streets-v6"}}},"sprite":{"type":"string","doc":"A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended. This property is required if any layer uses the 'sprite-image' layout property.","example":"mapbox://sprites/mapbox/bright-v8"},"glyphs":{"type":"string","doc":"A URL template for loading signed-distance-field glyph sets in PBF format. The URL must include `{fontstack}` and `{range}` tokens. This property is required if any layer uses the 'text-field' layout property.","example":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition","doc":"A global transition definition to use as a default across properties.","example":{"duration":300,"delay":0}},"layers":{"required":true,"type":"array","value":"layer","doc":"Layers will be drawn in the order of this array.","example":[{"id":"water","source":"mapbox-streets","source-layer":"water","type":"fill","paint":{"fill-color":"#00ffff"}}]}},"filter":{"type":"array","value":"*","doc":"A filter selects specific features from a layer."},"filter_operator":{"type":"enum","values":["==","!=",">",">=","<","<=","in","!in","all","any","none","has","!has"],"doc":"The filter operator."},"geometry_type":{"type":"enum","values":["Point","LineString","Polygon"],"doc":"The geometry type for the filter to select."},"color_operation":{"type":"enum","values":["lighten","saturate","spin","fade","mix"],"doc":"A color operation to apply."},"function":{"stops":{"type":"array","required":true,"doc":"An array of stops.","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0,"doc":"The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."},"property":{"type":"string","doc":"The name of a global property or feature property to use as the function input.","default":"$zoom"},"type":{"type":"enum","values":["exponential","interval","categorical"],"doc":"The interpolation strategy to use in function evaluation.","default":"exponential"}},"function_stop":{"type":"array","minimum":0,"maximum":22,"value":["number","color"],"length":2,"doc":"Zoom level and value pair."},"paint":["paint_fill","paint_extrusion","paint_line","paint_circle","paint_symbol","paint_raster","paint_background"],"paint_fill":{"fill-antialias":{"type":"boolean","function":"piecewise-constant","zoom-function":true,"property-function":true,"default":true,"doc":"Whether or not the fill should be antialiased.","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"fill-opacity":{"type":"number","function":"interpolated","zoom-function":true,"property-function":true,"default":1,"minimum":0,"maximum":1,"doc":"The opacity of the entire fill layer. In contrast to the fill-color, this value will also affect the 1px stroke around the fill, if the stroke is used.","transition":true,"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"},"property-function":{"js":"0.21.0"}}},"fill-color":{"type":"color","default":"#000000","doc":"The color of the filled part of this layer. This color can be specified as rgba with an alpha component and the color's opacity will not affect the opacity of the 1px stroke, if it is used.","function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"requires":[{"!":"fill-pattern"}],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"},"property-function":{"js":"0.19.0"}}},"fill-outline-color":{"type":"color","doc":"The outline color of the fill. Matches the value of `fill-color` if unspecified.","function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"},"property-function":{"js":"0.19.0"}}},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"units":"pixels","doc":"The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"fill-translate-anchor":{"type":"enum","function":"piecewise-constant","zoom-function":true,"property-function":true,"values":["map","viewport"],"doc":"Control whether the translation is relative to the map (north) or viewport (screen)","default":"map","requires":["fill-translate"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"fill-pattern":{"type":"string","function":"piecewise-constant","zoom-function":true,"property-function":true,"transition":true,"doc":"Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512).","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}}},"paint_extrusion":{"extrusion-antialias":{"type":"boolean","function":"piecewise-constant","zoom-function":true,"property-function":false,"default":true,"doc":"TODO Whether or not the extrusion should be antialiased."},"extrusion-layer-opacity":{"type":"number","function":"interpolated","zoom-function":true,"property-function":false,"default":1,"minimum":0,"maximum":1,"doc":"The opacity of the entire extrusion layer. In contrast to the extrusion-color, this value will also affect the 1px stroke around the extrusion, if the stroke is used.","transition":true},"extrusion-height":{"type":"number","function":"interpolated","zoom-function":true,"property-function":true,"default":3,"minimum":0,"doc":"The height (in ##UNITS##) with which to extrude this layer.","transition":true},"extrusion-min-height":{"type":"number","function":"interpolated","zoom-function":true,"property-function":true,"default":0,"minimum":-2,"doc":"The height (in ##UNITS##) with which to extrude this layer.","transition":true},"extrusion-color":{"type":"color","default":"#000000","doc":"The color of the extruded part of this layer. This color can be specified as rgba with an alpha component and the color's opacity will not affect the opacity of the 1px stroke, if it is used.","function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"requires":[{"!":"extrusion-pattern"}]},"extrusion-outline-color":{"type":"color","doc":"The outline color of the extrusion. Matches the value of `extrusion-color` if unspecified.","function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"requires":[{"!":"extrusion-pattern"},{"extrusion-antialias":true}]},"extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"units":"pixels","doc":"The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively."},"extrusion-translate-anchor":{"type":"enum","function":"piecewise-constant","zoom-function":true,"property-function":true,"values":["map","viewport"],"doc":"Control whether the translation is relative to the map (north) or viewport (screen)","default":"map","requires":["extrusion-translate"]},"extrusion-pattern":{"type":"string","function":"piecewise-constant","zoom-function":true,"property-function":true,"transition":true,"doc":"Name of image in sprite to use for drawing image extrusions. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512)."}},"paint_line":{"line-opacity":{"type":"number","doc":"The opacity at which the line will be drawn.","function":"interpolated","zoom-function":true,"property-function":true,"default":1,"minimum":0,"maximum":1,"transition":true,"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"line-color":{"type":"color","doc":"The color with which the line will be drawn.","default":"#000000","function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"requires":[{"!":"line-pattern"}],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"units":"pixels","doc":"The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"line-translate-anchor":{"type":"enum","function":"piecewise-constant","zoom-function":true,"property-function":true,"values":["map","viewport"],"doc":"Control whether the translation is relative to the map (north) or viewport (screen)","default":"map","requires":["line-translate"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"line-width":{"type":"number","default":1,"minimum":0,"function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"units":"pixels","doc":"Stroke thickness.","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"line-gap-width":{"type":"number","default":0,"minimum":0,"doc":"Draws a line casing outside of a line's actual path. Value indicates the width of the inner gap.","function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"units":"pixels","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"line-offset":{"type":"number","default":0,"doc":"The line's offset. For linear features, a positive value offsets the line to the right, relative to the direction of the line, and a negative value to the left. For polygon features, a positive value results in an inset, and a negative value results in an outset.","function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"units":"pixels","sdk-support":{"basic":{"js":"0.12.1","ios":"3.1.0","android":"3.0.0"}}},"line-blur":{"type":"number","default":0,"minimum":0,"function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"units":"pixels","doc":"Blur applied to the line, in pixels.","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"line-dasharray":{"type":"array","value":"number","function":"piecewise-constant","zoom-function":true,"property-function":true,"doc":"Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width.","minimum":0,"transition":true,"units":"line widths","requires":[{"!":"line-pattern"}],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"line-pattern":{"type":"string","function":"piecewise-constant","zoom-function":true,"property-function":true,"transition":true,"doc":"Name of image in sprite to use for drawing image lines. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512).","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"units":"pixels","doc":"Circle radius.","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"},"property-function":{"js":"0.18.0"}}},"circle-color":{"type":"color","default":"#000000","doc":"The color of the circle.","function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"},"property-function":{"js":"0.18.0"}}},"circle-blur":{"type":"number","default":0,"doc":"Amount to blur the circle. 1 blurs the circle such that only the centerpoint is full opacity.","function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"},"property-function":{"js":"0.20.0"}}},"circle-opacity":{"type":"number","doc":"The opacity at which the circle will be drawn.","default":1,"minimum":0,"maximum":1,"function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"},"property-function":{"js":"0.20.0"}}},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"units":"pixels","doc":"The geometry's offset. Values are [x, y] where negatives indicate left and up, respectively.","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"circle-translate-anchor":{"type":"enum","function":"piecewise-constant","zoom-function":true,"property-function":true,"values":["map","viewport"],"doc":"Control whether the translation is relative to the map (north) or viewport (screen)","default":"map","requires":["circle-translate"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"circle-pitch-scale":{"type":"enum","function":"piecewise-constant","zoom-function":true,"property-function":true,"values":["map","viewport"],"default":"map","doc":"Controls the scaling behavior of the circle when the map is pitched. The value `map` scales circles according to their apparent distance to the camera. The value `viewport` results in no pitch-related scaling.","sdk-support":{"basic":{"js":"0.21.0"}}}},"paint_symbol":{"icon-opacity":{"doc":"The opacity at which the icon will be drawn.","type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"requires":["icon-image"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"icon-color":{"type":"color","default":"#000000","function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"doc":"The color of the icon. This can only be used with sdf icons.","requires":["icon-image"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"doc":"The color of the icon's halo. Icon halos can only be used with sdf icons.","requires":["icon-image"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"icon-halo-width":{"type":"number","default":0,"minimum":0,"function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"units":"pixels","doc":"Distance of halo to the icon outline.","requires":["icon-image"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"units":"pixels","doc":"Fade out the halo towards the outside.","requires":["icon-image"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"units":"pixels","doc":"Distance that the icon's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.","requires":["icon-image"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"icon-translate-anchor":{"type":"enum","function":"piecewise-constant","zoom-function":true,"property-function":true,"values":["map","viewport"],"doc":"Control whether the translation is relative to the map (north) or viewport (screen).","default":"map","requires":["icon-image","icon-translate"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-opacity":{"type":"number","doc":"The opacity at which the text will be drawn.","default":1,"minimum":0,"maximum":1,"function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"requires":["text-field"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-color":{"type":"color","doc":"The color with which the text will be drawn.","default":"#000000","function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"requires":["text-field"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"doc":"The color of the text's halo, which helps it stand out from backgrounds.","requires":["text-field"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-halo-width":{"type":"number","default":0,"minimum":0,"function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"units":"pixels","doc":"Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.","requires":["text-field"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-halo-blur":{"type":"number","default":0,"minimum":0,"function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"units":"pixels","doc":"The halo's fadeout distance towards the outside.","requires":["text-field"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"units":"pixels","doc":"Distance that the text's anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.","requires":["text-field"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"text-translate-anchor":{"type":"enum","function":"piecewise-constant","zoom-function":true,"property-function":true,"values":["map","viewport"],"doc":"Control whether the translation is relative to the map (north) or viewport (screen).","default":"map","requires":["text-field","text-translate"],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}}},"paint_raster":{"raster-opacity":{"type":"number","doc":"The opacity at which the image will be drawn.","default":1,"minimum":0,"maximum":1,"function":"interpolated","zoom-function":true,"transition":true,"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"function":"interpolated","zoom-function":true,"transition":true,"units":"degrees","doc":"Rotates hues around the color wheel.","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"raster-brightness-min":{"type":"number","function":"interpolated","zoom-function":true,"doc":"Increase or reduce the brightness of the image. The value is the minimum brightness.","default":0,"minimum":0,"maximum":1,"transition":true,"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"raster-brightness-max":{"type":"number","function":"interpolated","zoom-function":true,"doc":"Increase or reduce the brightness of the image. The value is the maximum brightness.","default":1,"minimum":0,"maximum":1,"transition":true,"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"raster-saturation":{"type":"number","doc":"Increase or reduce the saturation of the image.","default":0,"minimum":-1,"maximum":1,"function":"interpolated","zoom-function":true,"transition":true,"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"raster-contrast":{"type":"number","doc":"Increase or reduce the contrast of the image.","default":0,"minimum":-1,"maximum":1,"function":"interpolated","zoom-function":true,"transition":true,"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"function":"interpolated","zoom-function":true,"transition":true,"units":"milliseconds","doc":"Fade duration when a new tile is added.","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}}},"paint_background":{"background-color":{"type":"color","default":"#000000","doc":"The color with which the background will be drawn.","function":"interpolated","zoom-function":true,"transition":true,"requires":[{"!":"background-pattern"}],"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"background-pattern":{"type":"string","function":"piecewise-constant","zoom-function":true,"transition":true,"doc":"Name of image in sprite to use for drawing an image background. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512).","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"doc":"The opacity at which the background will be drawn.","function":"interpolated","zoom-function":true,"transition":true,"sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}}},"layout_raster":{"visibility":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":["visible","none"],"default":"visible","doc":"The display of this layer. `none` hides this layer.","sdk-support":{"basic":{"js":"0.10.0","ios":"2.0.0","android":"2.0.1"}}}}}

},{}],183:[function(require,module,exports){
'use strict';

if (typeof module !== 'undefined' && module.exports) {
    module.exports = isSupported;
} else if (window) {
    window.mapboxgl = window.mapboxgl || {};
    window.mapboxgl.supported = isSupported;
}

/**
 * Test whether the current browser supports Mapbox GL JS
 * @param {Object} options
 * @param {boolean} [options.failIfMajorPerformanceCaveat=false] Return `false`
 *   if the performance of Mapbox GL JS would be dramatically worse than
 *   expected (i.e. a software renderer is would be used)
 * @return {boolean}
 */
function isSupported(options) {
    return !!(
        isBrowser() &&
        isArraySupported() &&
        isFunctionSupported() &&
        isObjectSupported() &&
        isJSONSupported() &&
        isWorkerSupported() &&
        isUint8ClampedArraySupported() &&
        isWebGLSupportedCached(options && options.failIfMajorPerformanceCaveat)
    );
}

function isBrowser() {
    return typeof window !== 'undefined' && typeof document !== 'undefined';
}

function isArraySupported() {
    return (
        Array.prototype &&
        Array.prototype.every &&
        Array.prototype.filter &&
        Array.prototype.forEach &&
        Array.prototype.indexOf &&
        Array.prototype.lastIndexOf &&
        Array.prototype.map &&
        Array.prototype.some &&
        Array.prototype.reduce &&
        Array.prototype.reduceRight &&
        Array.isArray
    );
}

function isFunctionSupported() {
    return Function.prototype && Function.prototype.bind;
}

function isObjectSupported() {
    return (
        Object.keys &&
        Object.create &&
        Object.getPrototypeOf &&
        Object.getOwnPropertyNames &&
        Object.isSealed &&
        Object.isFrozen &&
        Object.isExtensible &&
        Object.getOwnPropertyDescriptor &&
        Object.defineProperty &&
        Object.defineProperties &&
        Object.seal &&
        Object.freeze &&
        Object.preventExtensions
    );
}

function isJSONSupported() {
    return 'JSON' in window && 'parse' in JSON && 'stringify' in JSON;
}

function isWorkerSupported() {
    return 'Worker' in window;
}

// IE11 only supports `Uint8ClampedArray` as of version
// [KB2929437](https://support.microsoft.com/en-us/kb/2929437)
function isUint8ClampedArraySupported() {
    return 'Uint8ClampedArray' in window;
}

var isWebGLSupportedCache = {};
function isWebGLSupportedCached(failIfMajorPerformanceCaveat) {

    if (isWebGLSupportedCache[failIfMajorPerformanceCaveat] === undefined) {
        isWebGLSupportedCache[failIfMajorPerformanceCaveat] = isWebGLSupported(failIfMajorPerformanceCaveat);
    }

    return isWebGLSupportedCache[failIfMajorPerformanceCaveat];
}

isSupported.webGLContextAttributes = {
    antialias: false,
    alpha: true,
    stencil: true,
    depth: true
};

function isWebGLSupported(failIfMajorPerformanceCaveat) {

    var canvas = document.createElement('canvas');

    var attributes = Object.create(isSupported.webGLContextAttributes);
    attributes.failIfMajorPerformanceCaveat = failIfMajorPerformanceCaveat;

    if (canvas.probablySupportsContext) {
        return (
            canvas.probablySupportsContext('webgl', attributes) ||
            canvas.probablySupportsContext('experimental-webgl', attributes)
        );

    } else if (canvas.supportsContext) {
        return (
            canvas.supportsContext('webgl', attributes) ||
            canvas.supportsContext('experimental-webgl', attributes)
        );

    } else {
        return (
            canvas.getContext('webgl', attributes) ||
            canvas.getContext('experimental-webgl', attributes)
        );
    }
}

},{}],184:[function(require,module,exports){
'use strict';

// lightweight Buffer shim for pbf browser build
// based on code from github.com/feross/buffer (MIT-licensed)

module.exports = Buffer;

var ieee754 = require('ieee754');

var BufferMethods;

function Buffer(length) {
    var arr;
    if (length && length.length) {
        arr = length;
        length = arr.length;
    }
    var buf = new Uint8Array(length || 0);
    if (arr) buf.set(arr);

    buf.readUInt32LE = BufferMethods.readUInt32LE;
    buf.writeUInt32LE = BufferMethods.writeUInt32LE;
    buf.readInt32LE = BufferMethods.readInt32LE;
    buf.writeInt32LE = BufferMethods.writeInt32LE;
    buf.readFloatLE = BufferMethods.readFloatLE;
    buf.writeFloatLE = BufferMethods.writeFloatLE;
    buf.readDoubleLE = BufferMethods.readDoubleLE;
    buf.writeDoubleLE = BufferMethods.writeDoubleLE;
    buf.toString = BufferMethods.toString;
    buf.write = BufferMethods.write;
    buf.slice = BufferMethods.slice;
    buf.copy = BufferMethods.copy;

    buf._isBuffer = true;
    return buf;
}

var lastStr, lastStrEncoded;

BufferMethods = {
    readUInt32LE: function(pos) {
        return ((this[pos]) |
            (this[pos + 1] << 8) |
            (this[pos + 2] << 16)) +
            (this[pos + 3] * 0x1000000);
    },

    writeUInt32LE: function(val, pos) {
        this[pos] = val;
        this[pos + 1] = (val >>> 8);
        this[pos + 2] = (val >>> 16);
        this[pos + 3] = (val >>> 24);
    },

    readInt32LE: function(pos) {
        return ((this[pos]) |
            (this[pos + 1] << 8) |
            (this[pos + 2] << 16)) +
            (this[pos + 3] << 24);
    },

    readFloatLE:  function(pos) { return ieee754.read(this, pos, true, 23, 4); },
    readDoubleLE: function(pos) { return ieee754.read(this, pos, true, 52, 8); },

    writeFloatLE:  function(val, pos) { return ieee754.write(this, val, pos, true, 23, 4); },
    writeDoubleLE: function(val, pos) { return ieee754.write(this, val, pos, true, 52, 8); },

    toString: function(encoding, start, end) {
        var str = '',
            tmp = '';

        start = start || 0;
        end = Math.min(this.length, end || this.length);

        for (var i = start; i < end; i++) {
            var ch = this[i];
            if (ch <= 0x7F) {
                str += decodeURIComponent(tmp) + String.fromCharCode(ch);
                tmp = '';
            } else {
                tmp += '%' + ch.toString(16);
            }
        }

        str += decodeURIComponent(tmp);

        return str;
    },

    write: function(str, pos) {
        var bytes = str === lastStr ? lastStrEncoded : encodeString(str);
        for (var i = 0; i < bytes.length; i++) {
            this[pos + i] = bytes[i];
        }
    },

    slice: function(start, end) {
        return this.subarray(start, end);
    },

    copy: function(buf, pos) {
        pos = pos || 0;
        for (var i = 0; i < this.length; i++) {
            buf[pos + i] = this[i];
        }
    }
};

BufferMethods.writeInt32LE = BufferMethods.writeUInt32LE;

Buffer.byteLength = function(str) {
    lastStr = str;
    lastStrEncoded = encodeString(str);
    return lastStrEncoded.length;
};

Buffer.isBuffer = function(buf) {
    return !!(buf && buf._isBuffer);
};

function encodeString(str) {
    var length = str.length,
        bytes = [];

    for (var i = 0, c, lead; i < length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {

            if (lead) {
                if (c < 0xDC00) {
                    bytes.push(0xEF, 0xBF, 0xBD);
                    lead = c;
                    continue;

                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }

            } else {
                if (c > 0xDBFF || (i + 1 === length)) bytes.push(0xEF, 0xBF, 0xBD);
                else lead = c;

                continue;
            }

        } else if (lead) {
            bytes.push(0xEF, 0xBF, 0xBD);
            lead = null;
        }

        if (c < 0x80) bytes.push(c);
        else if (c < 0x800) bytes.push(c >> 0x6 | 0xC0, c & 0x3F | 0x80);
        else if (c < 0x10000) bytes.push(c >> 0xC | 0xE0, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
        else bytes.push(c >> 0x12 | 0xF0, c >> 0xC & 0x3F | 0x80, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);
    }
    return bytes;
}

},{"ieee754":186}],185:[function(require,module,exports){
(function (global){
'use strict';

module.exports = Pbf;

var Buffer = global.Buffer || require('./buffer');

function Pbf(buf) {
    this.buf = !Buffer.isBuffer(buf) ? new Buffer(buf || 0) : buf;
    this.pos = 0;
    this.length = this.buf.length;
}

Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32,
    POW_2_63 = Math.pow(2, 63);

Pbf.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        end = end || this.length;

        while (this.pos < end) {
            var val = this.readVarint(),
                tag = val >> 3,
                startPos = this.pos;

            readField(tag, result, this);

            if (this.pos === startPos) this.skip(val);
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        var val = this.buf.readUInt32LE(this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        var val = this.buf.readInt32LE(this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        var val = this.buf.readUInt32LE(this.pos) + this.buf.readUInt32LE(this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        var val = this.buf.readUInt32LE(this.pos) + this.buf.readInt32LE(this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        var val = this.buf.readFloatLE(this.pos);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        var val = this.buf.readDoubleLE(this.pos);
        this.pos += 8;
        return val;
    },

    readVarint: function() {
        var buf = this.buf,
            val, b;

        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;

        return readVarintRemainder(val, this);
    },

    readVarint64: function() {
        var startPos = this.pos,
            val = this.readVarint();

        if (val < POW_2_63) return val;

        var pos = this.pos - 2;
        while (this.buf[pos] === 0xff) pos--;
        if (pos < startPos) pos = startPos;

        val = 0;
        for (var i = 0; i < pos - startPos + 1; i++) {
            var b = ~this.buf[startPos + i] & 0x7f;
            val += i < 4 ? b << i * 7 : b * Math.pow(2, i * 7);
        }

        return -val - 1;
    },

    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        var end = this.readVarint() + this.pos,
            str = this.buf.toString('utf8', this.pos, end);
        this.pos = end;
        return str;
    },

    readBytes: function() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.slice(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readVarint());
        return arr;
    },
    readPackedSVarint: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
    },
    readPackedBoolean: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
    },
    readPackedFloat: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
    },
    readPackedDouble: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
    },
    readPackedFixed32: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
    },
    readPackedSFixed32: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
    },
    readPackedFixed64: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
    },
    readPackedSFixed64: function() {
        var end = this.readVarint() + this.pos, arr = [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
    },

    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error('Unimplemented type: ' + type);
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        var length = this.length || 16;

        while (length < this.pos + min) length *= 2;

        if (length !== this.length) {
            var buf = new Buffer(length);
            this.buf.copy(buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.slice(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        this.buf.writeUInt32LE(val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        this.buf.writeInt32LE(val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        this.buf.writeInt32LE(val & -1, this.pos);
        this.buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        this.buf.writeInt32LE(val & -1, this.pos);
        this.buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val;

        if (val > 0xfffffff) {
            writeBigVarint(val, this);
            return;
        }

        this.realloc(4);

        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] =   (val >>> 7) & 0x7f;
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        var bytes = Buffer.byteLength(str);
        this.writeVarint(bytes);
        this.realloc(bytes);
        this.buf.write(str, this.pos);
        this.pos += bytes;
    },

    writeFloat: function(val) {
        this.realloc(4);
        this.buf.writeFloatLE(val, this.pos);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        this.buf.writeDoubleLE(val, this.pos);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
    },

    writeRawMessage: function(fn, obj) {
        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        if (len >= 0x80) reallocForRawMessage(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
    },

    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },
    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },
    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },
    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },
    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },
    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },
    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },
    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },
    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function readVarintRemainder(val, pbf) {
    var buf = pbf.buf, b;

    b = buf[pbf.pos++]; val += (b & 0x7f) * 0x10000000;         if (b < 0x80) return val;
    b = buf[pbf.pos++]; val += (b & 0x7f) * 0x800000000;        if (b < 0x80) return val;
    b = buf[pbf.pos++]; val += (b & 0x7f) * 0x40000000000;      if (b < 0x80) return val;
    b = buf[pbf.pos++]; val += (b & 0x7f) * 0x2000000000000;    if (b < 0x80) return val;
    b = buf[pbf.pos++]; val += (b & 0x7f) * 0x100000000000000;  if (b < 0x80) return val;
    b = buf[pbf.pos++]; val += (b & 0x7f) * 0x8000000000000000; if (b < 0x80) return val;

    throw new Error('Expected varint not more than 10 bytes');
}

function writeBigVarint(val, pbf) {
    pbf.realloc(10);

    var maxPos = pbf.pos + 10;

    while (val >= 1) {
        if (pbf.pos >= maxPos) throw new Error('Given varint doesn\'t fit into 10 bytes');
        var b = val & 0xff;
        pbf.buf[pbf.pos++] = b | (val >= 0x80 ? 0x80 : 0);
        val /= 0x80;
    }
}

function reallocForRawMessage(startPos, len, pbf) {
    var extraLen =
        len <= 0x3fff ? 1 :
        len <= 0x1fffff ? 2 :
        len <= 0xfffffff ? 3 : Math.ceil(Math.log(len) / (Math.LN2 * 7));

    // if 1 byte isn't enough for encoding message length, shift the data to the right
    pbf.realloc(extraLen);
    for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];
}

function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./buffer":184}],186:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],187:[function(require,module,exports){
'use strict';

module.exports = Point;

function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype = {
    clone: function() { return new Point(this.x, this.y); },

    add:     function(p) { return this.clone()._add(p);     },
    sub:     function(p) { return this.clone()._sub(p);     },
    mult:    function(k) { return this.clone()._mult(k);    },
    div:     function(k) { return this.clone()._div(k);     },
    rotate:  function(a) { return this.clone()._rotate(a);  },
    matMult: function(m) { return this.clone()._matMult(m); },
    unit:    function() { return this.clone()._unit(); },
    perp:    function() { return this.clone()._perp(); },
    round:   function() { return this.clone()._round(); },

    mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    equals: function(p) {
        return this.x === p.x &&
               this.y === p.y;
    },

    dist: function(p) {
        return Math.sqrt(this.distSqr(p));
    },

    distSqr: function(p) {
        var dx = p.x - this.x,
            dy = p.y - this.y;
        return dx * dx + dy * dy;
    },

    angle: function() {
        return Math.atan2(this.y, this.x);
    },

    angleTo: function(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
    },

    angleWith: function(b) {
        return this.angleWithSep(b.x, b.y);
    },

    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin(θ) for θ.
    angleWithSep: function(x, y) {
        return Math.atan2(
            this.x * y - this.y * x,
            this.x * x + this.y * y);
    },

    _matMult: function(m) {
        var x = m[0] * this.x + m[1] * this.y,
            y = m[2] * this.x + m[3] * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _add: function(p) {
        this.x += p.x;
        this.y += p.y;
        return this;
    },

    _sub: function(p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
    },

    _mult: function(k) {
        this.x *= k;
        this.y *= k;
        return this;
    },

    _div: function(k) {
        this.x /= k;
        this.y /= k;
        return this;
    },

    _unit: function() {
        this._div(this.mag());
        return this;
    },

    _perp: function() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
    },

    _rotate: function(angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
};

// constructs Point from an array if necessary
Point.convert = function (a) {
    if (a instanceof Point) {
        return a;
    }
    if (Array.isArray(a)) {
        return new Point(a[0], a[1]);
    }
    return a;
};

},{}],188:[function(require,module,exports){
'use strict';

module.exports = partialSort;

// Floyd-Rivest selection algorithm:
// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];
// The k-th element will have the (k - left + 1)th smallest value in [left, right]

function partialSort(arr, k, left, right, compare) {
    left = left || 0;
    right = right || (arr.length - 1);
    compare = compare || defaultCompare;

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            partialSort(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

},{}],189:[function(require,module,exports){
// Copyright 2014 Simon Lydell
// X11 (“MIT”) Licensed. (See LICENSE.)

void (function(root, factory) {
  if (typeof define === "function" && define.amd) {
    define(factory)
  } else if (typeof exports === "object") {
    module.exports = factory()
  } else {
    root.resolveUrl = factory()
  }
}(this, function() {

  function resolveUrl(/* ...urls */) {
    var numUrls = arguments.length

    if (numUrls === 0) {
      throw new Error("resolveUrl requires at least one argument; got none.")
    }

    var base = document.createElement("base")
    base.href = arguments[0]

    if (numUrls === 1) {
      return base.href
    }

    var head = document.getElementsByTagName("head")[0]
    head.insertBefore(base, head.firstChild)

    var a = document.createElement("a")
    var resolved

    for (var index = 1; index < numUrls; index++) {
      a.href = arguments[index]
      resolved = a.href
      base.href = resolved
    }

    head.removeChild(base)

    return resolved
  }

  return resolveUrl

}));

},{}],190:[function(require,module,exports){
'use strict';

module.exports = ShelfPack;


/**
 * Create a new ShelfPack bin allocator.
 *
 * Uses the Shelf Best Height Fit algorithm from
 * http://clb.demon.fi/files/RectangleBinPack.pdf
 *
 * @class  ShelfPack
 * @param  {number}  [w=64]  Initial width of the sprite
 * @param  {number}  [h=64]  Initial width of the sprite
 * @param  {Object}  [options]
 * @param  {boolean} [options.autoResize=false]  If `true`, the sprite will automatically grow
 * @example
 * var sprite = new ShelfPack(64, 64, { autoResize: false });
 */
function ShelfPack(w, h, options) {
    options = options || {};
    this.w = w || 64;
    this.h = h || 64;
    this.autoResize = !!options.autoResize;
    this.shelves = [];
    this.stats = {};
    this.count = function(h) {
        this.stats[h] = (this.stats[h] | 0) + 1;
    };
}

/**
 * Batch pack multiple bins into the sprite.
 *
 * @param   {Array}   bins Array of requested bins - each object should have `width`, `height` (or `w`, `h`) properties
 * @param   {Object}  [options]
 * @param   {boolean} [options.inPlace=false] If `true`, the supplied bin objects will be updated inplace with `x` and `y` properties
 * @returns {Array}   Array of allocated bins - each bin is an object with `x`, `y`, `w`, `h` properties
 * @example
 * var bins = [
 *     { id: 'a', width: 12, height: 12 },
 *     { id: 'b', width: 12, height: 16 },
 *     { id: 'c', width: 12, height: 24 }
 * ];
 * var results = sprite.pack(bins, { inPlace: false });
 */
ShelfPack.prototype.pack = function(bins, options) {
    bins = [].concat(bins);
    options = options || {};

    var results = [],
        w, h, allocation;

    for (var i = 0; i < bins.length; i++) {
        w = bins[i].w || bins[i].width;
        h = bins[i].h || bins[i].height;
        if (w && h) {
            allocation = this.packOne(w, h);
            if (!allocation) {
                continue;
            }
            if (options.inPlace) {
                bins[i].x = allocation.x;
                bins[i].y = allocation.y;
            }
            results.push(allocation);
        }
    }

    return results;
};

/**
 * Pack a single bin into the sprite.
 *
 * @param   {number}  w   Width of the bin to allocate
 * @param   {number}  h   Height of the bin to allocate
 * @returns {Object}  Allocated bin object with `x`, `y`, `w`, `h` properties, or `null` if allocation failed
 * @example
 * var results = sprite.packOne(12, 16);
 */
ShelfPack.prototype.packOne = function(w, h) {
    var y = 0,
        best = { shelf: -1, waste: Infinity },
        shelf, waste;

    // find the best shelf
    for (var i = 0; i < this.shelves.length; i++) {
        shelf = this.shelves[i];
        y += shelf.h;

        // exactly the right height with width to spare, pack it..
        if (h === shelf.h && w <= shelf.free) {
            this.count(h);
            return shelf.alloc(w, h);
        }
        // not enough height or width, skip it..
        if (h > shelf.h || w > shelf.free) {
            continue;
        }
        // maybe enough height or width, minimize waste..
        if (h < shelf.h && w <= shelf.free) {
            waste = shelf.h - h;
            if (waste < best.waste) {
                best.waste = waste;
                best.shelf = i;
            }
        }
    }

    if (best.shelf !== -1) {
        shelf = this.shelves[best.shelf];
        this.count(h);
        return shelf.alloc(w, h);
    }

    // add shelf..
    if (h <= (this.h - y) && w <= this.w) {
        shelf = new Shelf(y, this.w, h);
        this.shelves.push(shelf);
        this.count(h);
        return shelf.alloc(w, h);
    }

    // no more space..
    // If `autoResize` option is set, grow the sprite as follows:
    //  * double whichever sprite dimension is smaller (`w1` or `h1`)
    //  * if sprite dimensions are equal, grow width before height
    //  * accomodate very large bin requests (big `w` or `h`)
    if (this.autoResize) {
        var h1, h2, w1, w2;

        h1 = h2 = this.h;
        w1 = w2 = this.w;

        if (w1 <= h1 || w > w1) {   // grow width..
            w2 = Math.max(w, w1) * 2;
        }
        if (h1 < w1 || h > h1) {    // grow height..
            h2 = Math.max(h, h1) * 2;
        }

        this.resize(w2, h2);
        return this.packOne(w, h);  // retry
    }

    return null;
};

/**
 * Clear the sprite.
 *
 * @example
 * sprite.clear();
 */
ShelfPack.prototype.clear = function() {
    this.shelves = [];
    this.stats = {};
};

/**
 * Resize the sprite.
 * The resize will fail if the requested dimensions are smaller than the current sprite dimensions.
 *
 * @param   {number}  w  Requested new sprite width
 * @param   {number}  h  Requested new sprite height
 * @returns {boolean} `true` if resize succeeded, `false` if failed
 * @example
 * sprite.resize(256, 256);
 */
ShelfPack.prototype.resize = function(w, h) {
    if (w < this.w || h < this.h) {
        return false;
    }

    this.w = w;
    this.h = h;
    for (var i = 0; i < this.shelves.length; i++) {
        this.shelves[i].resize(w);
    }
    return true;
};



/**
 * Create a new Shelf.
 *
 * @private
 * @class  Shelf
 * @param  {number}  y   Top coordinate of the new shelf
 * @param  {number}  w   Width of the new shelf
 * @param  {number}  h   Height of the new shelf
 * @example
 * var shelf = new Shelf(64, 512, 24);
 */
function Shelf(y, w, h) {
    this.x = 0;
    this.y = y;
    this.w = this.free = w;
    this.h = h;
}

/**
 * Allocate a single bin into the shelf.
 *
 * @private
 * @param   {number}  w   Width of the bin to allocate
 * @param   {number}  h   Height of the bin to allocate
 * @returns {Object}  Allocated bin object with `x`, `y`, `w`, `h` properties, or `null` if allocation failed
 * @example
 * shelf.alloc(12, 16);
 */
Shelf.prototype.alloc = function(w, h) {
    if (w > this.free || h > this.h) {
        return null;
    }
    var x = this.x;
    this.x += w;
    this.free -= w;
    return { x: x, y: this.y, w: w, h: h, width: w, height: h };
};

/**
 * Resize the shelf.
 * The resize will fail if the requested width is smaller than the current shelf width.
 *
 * @private
 * @param   {number}  w  Requested new width of the shelf
 * @returns {boolean} true if resize succeeded, false if failed
 * @example
 * shelf.resize(512);
 */
Shelf.prototype.resize = function(w) {
    if (w < this.w) {
        return false;
    }
    this.free += (w - this.w);
    this.w = w;
    return true;
};

},{}],191:[function(require,module,exports){
'use strict';

var kdbush = require('kdbush');

module.exports = supercluster;

function supercluster(options) {
    return new SuperCluster(options);
}

function SuperCluster(options) {
    this.options = extend(Object.create(this.options), options);
    this.trees = new Array(this.options.maxZoom + 1);
}

SuperCluster.prototype = {
    options: {
        minZoom: 0,   // min zoom to generate clusters on
        maxZoom: 16,  // max zoom level to cluster the points on
        radius: 40,   // cluster radius in pixels
        extent: 512,  // tile extent (radius is calculated relative to it)
        nodeSize: 64, // size of the KD-tree leaf node, affects performance
        log: false    // whether to log timing info
    },

    load: function (points) {
        var log = this.options.log;

        if (log) console.time('total time');

        var timerId = 'prepare ' + points.length + ' points';
        if (log) console.time(timerId);

        this.points = points;

        // generate a cluster object for each point
        var clusters = points.map(createPointCluster);
        if (log) console.timeEnd(timerId);

        // cluster points on max zoom, then cluster the results on previous zoom, etc.;
        // results in a cluster hierarchy across zoom levels
        for (var z = this.options.maxZoom; z >= this.options.minZoom; z--) {
            var now = +Date.now();

            // index input points into a KD-tree
            this.trees[z + 1] = kdbush(clusters, getX, getY, this.options.nodeSize, Float32Array);

            clusters = this._cluster(clusters, z); // create a new set of clusters for the zoom

            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);
        }

        // index top-level clusters
        this.trees[this.options.minZoom] = kdbush(clusters, getX, getY, this.options.nodeSize, Float32Array);

        if (log) console.timeEnd('total time');

        return this;
    },

    getClusters: function (bbox, zoom) {
        var tree = this.trees[this._limitZoom(zoom)];
        var ids = tree.range(lngX(bbox[0]), latY(bbox[3]), lngX(bbox[2]), latY(bbox[1]));
        var clusters = [];
        for (var i = 0; i < ids.length; i++) {
            var c = tree.points[ids[i]];
            clusters.push(c.id !== -1 ? this.points[c.id] : getClusterJSON(c));
        }
        return clusters;
    },

    getTile: function (z, x, y) {
        var z2 = Math.pow(2, z);
        var extent = this.options.extent;
        var p = this.options.radius / extent;
        var tree = this.trees[this._limitZoom(z)];
        var ids = tree.range(
            (x - p) / z2,
            (y - p) / z2,
            (x + 1 + p) / z2,
            (y + 1 + p) / z2);

        if (!ids.length) return null;

        var tile = {
            features: []
        };
        for (var i = 0; i < ids.length; i++) {
            var c = tree.points[ids[i]];
            var feature = {
                type: 1,
                geometry: [[
                    Math.round(extent * (c.x * z2 - x)),
                    Math.round(extent * (c.y * z2 - y))
                ]],
                tags: c.id !== -1 ? this.points[c.id].properties : getClusterProperties(c)
            };
            tile.features.push(feature);
        }
        return tile;
    },

    _limitZoom: function (z) {
        return Math.max(this.options.minZoom, Math.min(z, this.options.maxZoom + 1));
    },

    _cluster: function (points, zoom) {
        var clusters = [];
        var r = this.options.radius / (this.options.extent * Math.pow(2, zoom));

        // loop through each point
        for (var i = 0; i < points.length; i++) {
            var p = points[i];
            // if we've already visited the point at this zoom level, skip it
            if (p.zoom <= zoom) continue;
            p.zoom = zoom;

            // find all nearby points
            var tree = this.trees[zoom + 1];
            var neighborIds = tree.within(p.x, p.y, r);

            var foundNeighbors = false;
            var numPoints = p.numPoints;
            var wx = p.x * numPoints;
            var wy = p.y * numPoints;

            for (var j = 0; j < neighborIds.length; j++) {
                var b = tree.points[neighborIds[j]];
                // filter out neighbors that are too far or already processed
                if (zoom < b.zoom) {
                    foundNeighbors = true;
                    b.zoom = zoom; // save the zoom (so it doesn't get processed twice)
                    wx += b.x * b.numPoints; // accumulate coordinates for calculating weighted center
                    wy += b.y * b.numPoints;
                    numPoints += b.numPoints;
                }
            }

            clusters.push(foundNeighbors ? createCluster(wx / numPoints, wy / numPoints, numPoints, -1) : p);
        }

        return clusters;
    }
};

function createCluster(x, y, numPoints, id) {
    return {
        x: x, // weighted cluster center
        y: y,
        zoom: Infinity, // the last zoom the cluster was processed at
        id: id, // index of the source feature in the original input array
        numPoints: numPoints
    };
}

function createPointCluster(p, i) {
    var coords = p.geometry.coordinates;
    return createCluster(lngX(coords[0]), latY(coords[1]), 1, i);
}

function getClusterJSON(cluster) {
    return {
        type: 'Feature',
        properties: getClusterProperties(cluster),
        geometry: {
            type: 'Point',
            coordinates: [xLng(cluster.x), yLat(cluster.y)]
        }
    };
}

function getClusterProperties(cluster) {
    var count = cluster.numPoints;
    var abbrev = count >= 10000 ? Math.round(count / 1000) + 'k' :
                 count >= 1000 ? (Math.round(count / 100) / 10) + 'k' : count;
    return {
        cluster: true,
        point_count: count,
        point_count_abbreviated: abbrev
    };
}

// longitude/latitude to spherical mercator in [0..1] range
function lngX(lng) {
    return lng / 360 + 0.5;
}
function latY(lat) {
    var sin = Math.sin(lat * Math.PI / 180),
        y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);
    return y < 0 ? 0 :
           y > 1 ? 1 : y;
}

// spherical mercator to longitude/latitude
function xLng(x) {
    return (x - 0.5) * 360;
}
function yLat(y) {
    var y2 = (180 - y * 360) * Math.PI / 180;
    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;
}

function extend(dest, src) {
    for (var id in src) dest[id] = src[id];
    return dest;
}

function getX(p) {
    return p.x;
}
function getY(p) {
    return p.y;
}

},{"kdbush":192}],192:[function(require,module,exports){
'use strict';

var sort = require('./sort');
var range = require('./range');
var within = require('./within');

module.exports = kdbush;

function kdbush(points, getX, getY, nodeSize, ArrayType) {
    return new KDBush(points, getX, getY, nodeSize, ArrayType);
}

function KDBush(points, getX, getY, nodeSize, ArrayType) {
    getX = getX || defaultGetX;
    getY = getY || defaultGetY;
    ArrayType = ArrayType || Array;

    this.nodeSize = nodeSize || 64;
    this.points = points;

    this.ids = new ArrayType(points.length);
    this.coords = new ArrayType(points.length * 2);

    for (var i = 0; i < points.length; i++) {
        this.ids[i] = i;
        this.coords[2 * i] = getX(points[i]);
        this.coords[2 * i + 1] = getY(points[i]);
    }

    sort(this.ids, this.coords, this.nodeSize, 0, this.ids.length - 1, 0);
}

KDBush.prototype = {
    range: function (minX, minY, maxX, maxY) {
        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);
    },

    within: function (x, y, r) {
        return within(this.ids, this.coords, x, y, r, this.nodeSize);
    }
};

function defaultGetX(p) { return p[0]; }
function defaultGetY(p) { return p[1]; }

},{"./range":193,"./sort":194,"./within":195}],193:[function(require,module,exports){
'use strict';

module.exports = range;

function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {
    var stack = [0, ids.length - 1, 0];
    var result = [];
    var x, y;

    while (stack.length) {
        var axis = stack.pop();
        var right = stack.pop();
        var left = stack.pop();

        if (right - left <= nodeSize) {
            for (var i = left; i <= right; i++) {
                x = coords[2 * i];
                y = coords[2 * i + 1];
                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);
            }
            continue;
        }

        var m = Math.floor((left + right) / 2);

        x = coords[2 * m];
        y = coords[2 * m + 1];

        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);

        var nextAxis = (axis + 1) % 2;

        if (axis === 0 ? minX <= x : minY <= y) {
            stack.push(left);
            stack.push(m - 1);
            stack.push(nextAxis);
        }
        if (axis === 0 ? maxX >= x : maxY >= y) {
            stack.push(m + 1);
            stack.push(right);
            stack.push(nextAxis);
        }
    }

    return result;
}

},{}],194:[function(require,module,exports){
'use strict';

module.exports = sortKD;

function sortKD(ids, coords, nodeSize, left, right, depth) {
    if (right - left <= nodeSize) return;

    var m = Math.floor((left + right) / 2);

    select(ids, coords, m, left, right, depth % 2);

    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);
    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);
}

function select(ids, coords, k, left, right, inc) {

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            select(ids, coords, k, newLeft, newRight, inc);
        }

        var t = coords[2 * k + inc];
        var i = left;
        var j = right;

        swapItem(ids, coords, left, k);
        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);

        while (i < j) {
            swapItem(ids, coords, i, j);
            i++;
            j--;
            while (coords[2 * i + inc] < t) i++;
            while (coords[2 * j + inc] > t) j--;
        }

        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);
        else {
            j++;
            swapItem(ids, coords, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swapItem(ids, coords, i, j) {
    swap(ids, i, j);
    swap(coords, 2 * i, 2 * j);
    swap(coords, 2 * i + 1, 2 * j + 1);
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

},{}],195:[function(require,module,exports){
'use strict';

module.exports = within;

function within(ids, coords, qx, qy, r, nodeSize) {
    var stack = [0, ids.length - 1, 0];
    var result = [];
    var r2 = r * r;

    while (stack.length) {
        var axis = stack.pop();
        var right = stack.pop();
        var left = stack.pop();

        if (right - left <= nodeSize) {
            for (var i = left; i <= right; i++) {
                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);
            }
            continue;
        }

        var m = Math.floor((left + right) / 2);

        var x = coords[2 * m];
        var y = coords[2 * m + 1];

        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);

        var nextAxis = (axis + 1) % 2;

        if (axis === 0 ? qx - r <= x : qy - r <= y) {
            stack.push(left);
            stack.push(m - 1);
            stack.push(nextAxis);
        }
        if (axis === 0 ? qx + r >= x : qy + r >= y) {
            stack.push(m + 1);
            stack.push(right);
            stack.push(nextAxis);
        }
    }

    return result;
}

function sqDist(ax, ay, bx, by) {
    var dx = ax - bx;
    var dy = ay - by;
    return dx * dx + dy * dy;
}

},{}],196:[function(require,module,exports){
'use strict';

module.exports = TinyQueue;

function TinyQueue(data, compare) {
    if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);

    this.data = data || [];
    this.length = this.data.length;
    this.compare = compare || defaultCompare;

    if (data) for (var i = Math.floor(this.length / 2); i >= 0; i--) this._down(i);
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

TinyQueue.prototype = {

    push: function (item) {
        this.data.push(item);
        this.length++;
        this._up(this.length - 1);
    },

    pop: function () {
        var top = this.data[0];
        this.data[0] = this.data[this.length - 1];
        this.length--;
        this.data.pop();
        this._down(0);
        return top;
    },

    peek: function () {
        return this.data[0];
    },

    _up: function (pos) {
        var data = this.data,
            compare = this.compare;

        while (pos > 0) {
            var parent = Math.floor((pos - 1) / 2);
            if (compare(data[pos], data[parent]) < 0) {
                swap(data, parent, pos);
                pos = parent;

            } else break;
        }
    },

    _down: function (pos) {
        var data = this.data,
            compare = this.compare,
            len = this.length;

        while (true) {
            var left = 2 * pos + 1,
                right = left + 1,
                min = pos;

            if (left < len && compare(data[left], data[min]) < 0) min = left;
            if (right < len && compare(data[right], data[min]) < 0) min = right;

            if (min === pos) return;

            swap(data, min, pos);
            pos = min;
        }
    }
};

function swap(data, i, j) {
    var tmp = data[i];
    data[i] = data[j];
    data[j] = tmp;
}

},{}],197:[function(require,module,exports){
/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Ported from Webkit
 * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
 */

module.exports = UnitBezier;

function UnitBezier(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    this.cx = 3.0 * p1x;
    this.bx = 3.0 * (p2x - p1x) - this.cx;
    this.ax = 1.0 - this.cx - this.bx;

    this.cy = 3.0 * p1y;
    this.by = 3.0 * (p2y - p1y) - this.cy;
    this.ay = 1.0 - this.cy - this.by;

    this.p1x = p1x;
    this.p1y = p2y;
    this.p2x = p2x;
    this.p2y = p2y;
}

UnitBezier.prototype.sampleCurveX = function(t) {
    // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
    return ((this.ax * t + this.bx) * t + this.cx) * t;
};

UnitBezier.prototype.sampleCurveY = function(t) {
    return ((this.ay * t + this.by) * t + this.cy) * t;
};

UnitBezier.prototype.sampleCurveDerivativeX = function(t) {
    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
};

UnitBezier.prototype.solveCurveX = function(x, epsilon) {
    if (typeof epsilon === 'undefined') epsilon = 1e-6;

    var t0, t1, t2, x2, i;

    // First try a few iterations of Newton's method -- normally very fast.
    for (t2 = x, i = 0; i < 8; i++) {

        x2 = this.sampleCurveX(t2) - x;
        if (Math.abs(x2) < epsilon) return t2;

        var d2 = this.sampleCurveDerivativeX(t2);
        if (Math.abs(d2) < 1e-6) break;

        t2 = t2 - x2 / d2;
    }

    // Fall back to the bisection method for reliability.
    t0 = 0.0;
    t1 = 1.0;
    t2 = x;

    if (t2 < t0) return t0;
    if (t2 > t1) return t1;

    while (t0 < t1) {

        x2 = this.sampleCurveX(t2);
        if (Math.abs(x2 - x) < epsilon) return t2;

        if (x > x2) {
            t0 = t2;
        } else {
            t1 = t2;
        }

        t2 = (t1 - t0) * 0.5 + t0;
    }

    // Failure.
    return t2;
};

UnitBezier.prototype.solve = function(x, epsilon) {
    return this.sampleCurveY(this.solveCurveX(x, epsilon));
};

},{}],198:[function(require,module,exports){
module.exports.VectorTile = require('./lib/vectortile.js');
module.exports.VectorTileFeature = require('./lib/vectortilefeature.js');
module.exports.VectorTileLayer = require('./lib/vectortilelayer.js');

},{"./lib/vectortile.js":199,"./lib/vectortilefeature.js":200,"./lib/vectortilelayer.js":201}],199:[function(require,module,exports){
'use strict';

var VectorTileLayer = require('./vectortilelayer');

module.exports = VectorTile;

function VectorTile(pbf, end) {
    this.layers = pbf.readFields(readTile, {}, end);
}

function readTile(tag, layers, pbf) {
    if (tag === 3) {
        var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length) layers[layer.name] = layer;
    }
}


},{"./vectortilelayer":201}],200:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = VectorTileFeature;

function VectorTileFeature(pbf, end, extent, keys, values) {
    // Public
    this.properties = {};
    this.extent = extent;
    this.type = 0;

    // Private
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;

    pbf.readFields(readFeature, this, end);
}

function readFeature(tag, feature, pbf) {
    if (tag == 1) feature._id = pbf.readVarint();
    else if (tag == 2) readTag(pbf, feature);
    else if (tag == 3) feature.type = pbf.readVarint();
    else if (tag == 4) feature._geometry = pbf.pos;
}

function readTag(pbf, feature) {
    var end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var key = feature._keys[pbf.readVarint()],
            value = feature._values[pbf.readVarint()];
        feature.properties[key] = value;
    }
}

VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

VectorTileFeature.prototype.loadGeometry = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        lines = [],
        line;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();

            if (cmd === 1) { // moveTo
                if (line) lines.push(line);
                line = [];
            }

            line.push(new Point(x, y));

        } else if (cmd === 7) {

            // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90
            if (line) {
                line.push(line[0].clone()); // closePolygon
            }

        } else {
            throw new Error('unknown command ' + cmd);
        }
    }

    if (line) lines.push(line);

    return lines;
};

VectorTileFeature.prototype.bbox = function() {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();
            if (x < x1) x1 = x;
            if (x > x2) x2 = x;
            if (y < y1) y1 = y;
            if (y > y2) y2 = y;

        } else if (cmd !== 7) {
            throw new Error('unknown command ' + cmd);
        }
    }

    return [x1, y1, x2, y2];
};

VectorTileFeature.prototype.toGeoJSON = function(x, y, z) {
    var size = this.extent * Math.pow(2, z),
        x0 = this.extent * x,
        y0 = this.extent * y,
        coords = this.loadGeometry(),
        type = VectorTileFeature.types[this.type],
        i, j;

    function project(line) {
        for (var j = 0; j < line.length; j++) {
            var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;
            line[j] = [
                (p.x + x0) * 360 / size - 180,
                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90
            ];
        }
    }

    switch (this.type) {
    case 1:
        var points = [];
        for (i = 0; i < coords.length; i++) {
            points[i] = coords[i][0];
        }
        coords = points;
        project(coords);
        break;

    case 2:
        for (i = 0; i < coords.length; i++) {
            project(coords[i]);
        }
        break;

    case 3:
        coords = classifyRings(coords);
        for (i = 0; i < coords.length; i++) {
            for (j = 0; j < coords[i].length; j++) {
                project(coords[i][j]);
            }
        }
        break;
    }

    if (coords.length === 1) {
        coords = coords[0];
    } else {
        type = 'Multi' + type;
    }

    var result = {
        type: "Feature",
        geometry: {
            type: type,
            coordinates: coords
        },
        properties: this.properties
    };

    if ('_id' in this) {
        result.id = this._id;
    }

    return result;
};

// classifies an array of rings into polygons with outer rings and holes

function classifyRings(rings) {
    var len = rings.length;

    if (len <= 1) return [rings];

    var polygons = [],
        polygon,
        ccw;

    for (var i = 0; i < len; i++) {
        var area = signedArea(rings[i]);
        if (area === 0) continue;

        if (ccw === undefined) ccw = area < 0;

        if (ccw === area < 0) {
            if (polygon) polygons.push(polygon);
            polygon = [rings[i]];

        } else {
            polygon.push(rings[i]);
        }
    }
    if (polygon) polygons.push(polygon);

    return polygons;
}

function signedArea(ring) {
    var sum = 0;
    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
        p1 = ring[i];
        p2 = ring[j];
        sum += (p2.x - p1.x) * (p1.y + p2.y);
    }
    return sum;
}

},{"point-geometry":187}],201:[function(require,module,exports){
'use strict';

var VectorTileFeature = require('./vectortilefeature.js');

module.exports = VectorTileLayer;

function VectorTileLayer(pbf, end) {
    // Public
    this.version = 1;
    this.name = null;
    this.extent = 4096;
    this.length = 0;

    // Private
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];

    pbf.readFields(readLayer, this, end);

    this.length = this._features.length;
}

function readLayer(tag, layer, pbf) {
    if (tag === 15) layer.version = pbf.readVarint();
    else if (tag === 1) layer.name = pbf.readString();
    else if (tag === 5) layer.extent = pbf.readVarint();
    else if (tag === 2) layer._features.push(pbf.pos);
    else if (tag === 3) layer._keys.push(pbf.readString());
    else if (tag === 4) layer._values.push(readValueMessage(pbf));
}

function readValueMessage(pbf) {
    var value = null,
        end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var tag = pbf.readVarint() >> 3;

        value = tag === 1 ? pbf.readString() :
            tag === 2 ? pbf.readFloat() :
            tag === 3 ? pbf.readDouble() :
            tag === 4 ? pbf.readVarint64() :
            tag === 5 ? pbf.readVarint() :
            tag === 6 ? pbf.readSVarint() :
            tag === 7 ? pbf.readBoolean() : null;
    }

    return value;
}

// return feature `i` from this layer as a `VectorTileFeature`
VectorTileLayer.prototype.feature = function(i) {
    if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');

    this._pbf.pos = this._features[i];

    var end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
};

},{"./vectortilefeature.js":200}],202:[function(require,module,exports){
var Pbf = require('pbf')
var vtpb = require('./vector-tile-pb')
var GeoJSONWrapper = require('./lib/geojson_wrapper')

module.exports = fromVectorTileJs
module.exports.fromVectorTileJs = fromVectorTileJs
module.exports.fromGeojsonVt = fromGeojsonVt
module.exports.GeoJSONWrapper = GeoJSONWrapper

/**
 * Serialize a vector-tile-js-created tile to pbf
 *
 * @param {Object} tile
 * @return {Buffer} uncompressed, pbf-serialized tile data
 */
function fromVectorTileJs (tile) {
  var layers = []
  for (var l in tile.layers) {
    layers.push(prepareLayer(tile.layers[l]))
  }

  var out = new Pbf()
  vtpb.tile.write({ layers: layers }, out)
  return out.finish()
}

/**
 * Serialized a geojson-vt-created tile to pbf.
 *
 * @param {Object} layers - An object mapping layer names to geojson-vt-created vector tile objects
 * @return {Buffer} uncompressed, pbf-serialized tile data
 */
function fromGeojsonVt (layers) {
  var l = {}
  for (var k in layers) {
    l[k] = new GeoJSONWrapper(layers[k].features)
    l[k].name = k
  }
  return fromVectorTileJs({layers: l})
}

/**
 * Prepare the given layer to be serialized by the auto-generated pbf
 * serializer by encoding the feature geometry and properties.
 */
function prepareLayer (layer) {
  var preparedLayer = {
    name: layer.name || '',
    version: layer.version || 1,
    extent: layer.extent || 4096,
    keys: [],
    values: [],
    features: []
  }

  var keycache = {}
  var valuecache = {}

  for (var i = 0; i < layer.length; i++) {
    var feature = layer.feature(i)
    feature.geometry = encodeGeometry(feature.loadGeometry())

    var tags = []
    for (var key in feature.properties) {
      var keyIndex = keycache[key]
      if (typeof keyIndex === 'undefined') {
        preparedLayer.keys.push(key)
        keyIndex = preparedLayer.keys.length - 1
        keycache[key] = keyIndex
      }
      var value = wrapValue(feature.properties[key])
      var valueIndex = valuecache[value.key]
      if (typeof valueIndex === 'undefined') {
        preparedLayer.values.push(value)
        valueIndex = preparedLayer.values.length - 1
        valuecache[value.key] = valueIndex
      }
      tags.push(keyIndex)
      tags.push(valueIndex)
    }

    feature.tags = tags
    preparedLayer.features.push(feature)
  }

  return preparedLayer
}

function command (cmd, length) {
  return (length << 3) + (cmd & 0x7)
}

function zigzag (num) {
  return (num << 1) ^ (num >> 31)
}

/**
 * Encode a polygon's geometry into an array ready to be serialized
 * to mapbox vector tile specified geometry data.
 *
 * @param {Array} Rings, each being an array of [x, y] tile-space coordinates
 * @return {Array} encoded geometry
 */
function encodeGeometry (geometry) {
  var encoded = []
  var x = 0
  var y = 0
  var rings = geometry.length
  for (var r = 0; r < rings; r++) {
    var ring = geometry[r]
    encoded.push(command(1, 1)) // moveto
    for (var i = 0; i < ring.length; i++) {
      if (i === 1) {
        encoded.push(command(2, ring.length - 1)) // lineto
      }
      var dx = ring[i].x - x
      var dy = ring[i].y - y
      encoded.push(zigzag(dx), zigzag(dy))
      x += dx
      y += dy
    }
  }

  return encoded
}

/**
 * Wrap a property value according to its type. The returned object
 * is of the form { xxxx_value: primitiveValue }, which is what the generated
 * protobuf serializer expects.
 */
function wrapValue (value) {
  var result
  var type = typeof value
  if (type === 'string') {
    result = { string_value: value }
  } else if (type === 'boolean') {
    result = { bool_value: value }
  } else if (type === 'number') {
    if (value !== (value | 0)) {
      result = { float_value: value }
    } else if (value < 0) {
      result = { sint_value: value }
    } else {
      result = { uint_value: value }
    }
  } else {
    result = { string_value: '' + value }
  }

  result.key = type + ':' + value
  return result
}

},{"./lib/geojson_wrapper":203,"./vector-tile-pb":204,"pbf":185}],203:[function(require,module,exports){
'use strict'

var Point = require('point-geometry')
var VectorTileFeature = require('vector-tile').VectorTileFeature

module.exports = GeoJSONWrapper

// conform to vectortile api
function GeoJSONWrapper (features) {
  this.features = features
  this.length = features.length
}

GeoJSONWrapper.prototype.feature = function (i) {
  return new FeatureWrapper(this.features[i])
}

function FeatureWrapper (feature) {
  this.type = feature.type
  this.rawGeometry = feature.type === 1 ? [feature.geometry] : feature.geometry
  this.properties = feature.tags
  this.extent = 4096
}

FeatureWrapper.prototype.loadGeometry = function () {
  var rings = this.rawGeometry
  this.geometry = []

  for (var i = 0; i < rings.length; i++) {
    var ring = rings[i]
    var newRing = []
    for (var j = 0; j < ring.length; j++) {
      newRing.push(new Point(ring[j][0], ring[j][1]))
    }
    this.geometry.push(newRing)
  }
  return this.geometry
}

FeatureWrapper.prototype.bbox = function () {
  if (!this.geometry) this.loadGeometry()

  var rings = this.geometry
  var x1 = Infinity
  var x2 = -Infinity
  var y1 = Infinity
  var y2 = -Infinity

  for (var i = 0; i < rings.length; i++) {
    var ring = rings[i]

    for (var j = 0; j < ring.length; j++) {
      var coord = ring[j]

      x1 = Math.min(x1, coord.x)
      x2 = Math.max(x2, coord.x)
      y1 = Math.min(y1, coord.y)
      y2 = Math.max(y2, coord.y)
    }
  }

  return [x1, y1, x2, y2]
}

FeatureWrapper.prototype.toGeoJSON = VectorTileFeature.prototype.toGeoJSON

},{"point-geometry":187,"vector-tile":198}],204:[function(require,module,exports){
'use strict';

// tile ========================================

var tile = exports.tile = {read: readTile, write: writeTile};

tile.GeomType = {
    "Unknown": 0,
    "Point": 1,
    "LineString": 2,
    "Polygon": 3
};

function readTile(pbf, end) {
    return pbf.readFields(readTileField, {"layers": []}, end);
}

function readTileField(tag, tile, pbf) {
    if (tag === 3) tile.layers.push(readLayer(pbf, pbf.readVarint() + pbf.pos));
}

function writeTile(tile, pbf) {
    var i;
    if (tile.layers !== undefined) for (i = 0; i < tile.layers.length; i++) pbf.writeMessage(3, writeLayer, tile.layers[i]);
}

// value ========================================

tile.value = {read: readValue, write: writeValue};

function readValue(pbf, end) {
    return pbf.readFields(readValueField, {}, end);
}

function readValueField(tag, value, pbf) {
    if (tag === 1) value.string_value = pbf.readString();
    else if (tag === 2) value.float_value = pbf.readFloat();
    else if (tag === 3) value.double_value = pbf.readDouble();
    else if (tag === 4) value.int_value = pbf.readVarint();
    else if (tag === 5) value.uint_value = pbf.readVarint();
    else if (tag === 6) value.sint_value = pbf.readSVarint();
    else if (tag === 7) value.bool_value = pbf.readBoolean();
}

function writeValue(value, pbf) {
    if (value.string_value !== undefined) pbf.writeStringField(1, value.string_value);
    if (value.float_value !== undefined) pbf.writeFloatField(2, value.float_value);
    if (value.double_value !== undefined) pbf.writeDoubleField(3, value.double_value);
    if (value.int_value !== undefined) pbf.writeVarintField(4, value.int_value);
    if (value.uint_value !== undefined) pbf.writeVarintField(5, value.uint_value);
    if (value.sint_value !== undefined) pbf.writeSVarintField(6, value.sint_value);
    if (value.bool_value !== undefined) pbf.writeBooleanField(7, value.bool_value);
}

// feature ========================================

tile.feature = {read: readFeature, write: writeFeature};

function readFeature(pbf, end) {
    var feature = pbf.readFields(readFeatureField, {}, end);
    if (feature.type === undefined) feature.type = "Unknown";
    return feature;
}

function readFeatureField(tag, feature, pbf) {
    if (tag === 1) feature.id = pbf.readVarint();
    else if (tag === 2) feature.tags = pbf.readPackedVarint();
    else if (tag === 3) feature.type = pbf.readVarint();
    else if (tag === 4) feature.geometry = pbf.readPackedVarint();
}

function writeFeature(feature, pbf) {
    if (feature.id !== undefined) pbf.writeVarintField(1, feature.id);
    if (feature.tags !== undefined) pbf.writePackedVarint(2, feature.tags);
    if (feature.type !== undefined) pbf.writeVarintField(3, feature.type);
    if (feature.geometry !== undefined) pbf.writePackedVarint(4, feature.geometry);
}

// layer ========================================

tile.layer = {read: readLayer, write: writeLayer};

function readLayer(pbf, end) {
    return pbf.readFields(readLayerField, {"features": [], "keys": [], "values": []}, end);
}

function readLayerField(tag, layer, pbf) {
    if (tag === 15) layer.version = pbf.readVarint();
    else if (tag === 1) layer.name = pbf.readString();
    else if (tag === 2) layer.features.push(readFeature(pbf, pbf.readVarint() + pbf.pos));
    else if (tag === 3) layer.keys.push(pbf.readString());
    else if (tag === 4) layer.values.push(readValue(pbf, pbf.readVarint() + pbf.pos));
    else if (tag === 5) layer.extent = pbf.readVarint();
}

function writeLayer(layer, pbf) {
    if (layer.version !== undefined) pbf.writeVarintField(15, layer.version);
    if (layer.name !== undefined) pbf.writeStringField(1, layer.name);
    var i;
    if (layer.features !== undefined) for (i = 0; i < layer.features.length; i++) pbf.writeMessage(2, writeFeature, layer.features[i]);
    if (layer.keys !== undefined) for (i = 0; i < layer.keys.length; i++) pbf.writeStringField(3, layer.keys[i]);
    if (layer.values !== undefined) for (i = 0; i < layer.values.length; i++) pbf.writeMessage(4, writeValue, layer.values[i]);
    if (layer.extent !== undefined) pbf.writeVarintField(5, layer.extent);
}

},{}],205:[function(require,module,exports){
var bundleFn = arguments[3];
var sources = arguments[4];
var cache = arguments[5];

var stringify = JSON.stringify;

module.exports = function (fn, options) {
    var wkey;
    var cacheKeys = Object.keys(cache);

    for (var i = 0, l = cacheKeys.length; i < l; i++) {
        var key = cacheKeys[i];
        var exp = cache[key].exports;
        // Using babel as a transpiler to use esmodule, the export will always
        // be an object with the default export as a property of it. To ensure
        // the existing api and babel esmodule exports are both supported we
        // check for both
        if (exp === fn || exp && exp.default === fn) {
            wkey = key;
            break;
        }
    }

    if (!wkey) {
        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
        var wcache = {};
        for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            wcache[key] = key;
        }
        sources[wkey] = [
            Function(['require','module','exports'], '(' + fn + ')(self)'),
            wcache
        ];
    }
    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);

    var scache = {}; scache[wkey] = wkey;
    sources[skey] = [
        Function(['require'], (
            // try to call default if defined to also support babel esmodule
            // exports
            'var f = require(' + stringify(wkey) + ');' +
            '(f.default ? f.default : f)(self);'
        )),
        scache
    ];

    var src = '(' + bundleFn + ')({'
        + Object.keys(sources).map(function (key) {
            return stringify(key) + ':['
                + sources[key][0]
                + ',' + stringify(sources[key][1]) + ']'
            ;
        }).join(',')
        + '},{},[' + stringify(skey) + '])'
    ;

    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;

    var blob = new Blob([src], { type: 'text/javascript' });
    if (options && options.bare) { return blob; }
    var workerUrl = URL.createObjectURL(blob);
    var worker = new Worker(workerUrl);
    if (typeof URL.revokeObjectURL == "function") {
      URL.revokeObjectURL(workerUrl);
    }
    return worker;
};

},{}],206:[function(require,module,exports){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.WhooTS = global.WhooTS || {})));
}(this, function (exports) {

/**
 * getURL
 *
 * @param    {String}  baseUrl  Base url of the WMS server
 * @param    {String}  layer    Layer name
 * @param    {Number}  x        Tile coordinate x
 * @param    {Number}  y        Tile coordinate y
 * @param    {Number}  z        Tile zoom
 * @param    {Object}  [options]
 * @param    {String}  [options.format='image/png']
 * @param    {String}  [options.service='WMS']
 * @param    {String}  [options.version='1.1.1']
 * @param    {String}  [options.request='GetMap']
 * @param    {String}  [options.srs='EPSG:3857']
 * @param    {Number}  [options.width='256']
 * @param    {Number}  [options.height='256']
 * @returns  {String}  url
 * @example
 * var baseUrl = 'http://geodata.state.nj.us/imagerywms/Natural2015';
 * var layer = 'Natural2015';
 * var url = whoots.getURL(baseUrl, layer, 154308, 197167, 19);
 */
function getURL(baseUrl, layer, x, y, z, options) {
    options = options || {};

    var url = baseUrl + '?' + [
        'bbox='    + getTileBBox(x, y, z),
        'format='  + (options.format || 'image/png'),
        'service=' + (options.service || 'WMS'),
        'version=' + (options.version || '1.1.1'),
        'request=' + (options.request || 'GetMap'),
        'srs='     + (options.srs || 'EPSG:3857'),
        'width='   + (options.width || 256),
        'height='  + (options.height || 256),
        'layers='  + layer
    ].join('&');

    return url;
}


/**
 * getTileBBox
 *
 * @param    {Number}  x  Tile coordinate x
 * @param    {Number}  y  Tile coordinate y
 * @param    {Number}  z  Tile zoom
 * @returns  {String}  String of the bounding box
 */
function getTileBBox(x, y, z) {
    // for Google/OSM tile scheme we need to alter the y
    y = (Math.pow(2, z) - y - 1);

    var min = getMercCoords(x * 256, y * 256, z),
        max = getMercCoords((x + 1) * 256, (y + 1) * 256, z);

    return min[0] + ',' + min[1] + ',' + max[0] + ',' + max[1];
}


/**
 * getMercCoords
 *
 * @param    {Number}  x  Pixel coordinate x
 * @param    {Number}  y  Pixel coordinate y
 * @param    {Number}  z  Tile zoom
 * @returns  {Array}   [x, y]
 */
function getMercCoords(x, y, z) {
    var resolution = (2 * Math.PI * 6378137 / 256) / Math.pow(2, z),
        merc_x = (x * resolution - 2 * Math.PI  * 6378137 / 2.0),
        merc_y = (y * resolution - 2 * Math.PI  * 6378137 / 2.0);

    return [merc_x, merc_y];
}

exports.getURL = getURL;
exports.getTileBBox = getTileBBox;
exports.getMercCoords = getMercCoords;

Object.defineProperty(exports, '__esModule', { value: true });

}));
},{}],207:[function(require,module,exports){
module.exports={
  "name": "mapbox-gl",
  "description": "A WebGL interactive maps library",
  "version": "0.22.1",
  "main": "js/mapbox-gl.js",
  "license": "BSD-3-Clause",
  "repository": {
    "type": "git",
    "url": "git://github.com/mapbox/mapbox-gl-js.git"
  },
  "engines": {
    "node": ">=4.0.0"
  },
  "dependencies": {
    "csscolorparser": "^1.0.2",
    "earcut": "^2.0.3",
    "feature-filter": "^2.2.0",
    "geojson-rewind": "^0.1.0",
    "geojson-vt": "^2.4.0",
    "gl-matrix": "^2.3.1",
    "grid-index": "^1.0.0",
    "mapbox-gl-function": "^1.2.1",
    "mapbox-gl-shaders": "mapbox/mapbox-gl-shaders#df162476980d9ee2ab6f8d0cf5a06e27aac60472",
    "mapbox-gl-style-spec": "mapbox/mapbox-gl-style-spec#83b1a3e5837d785af582efd5ed1a212f2df6a4ae",
    "mapbox-gl-supported": "^1.2.0",
    "pbf": "^1.3.2",
    "pngjs": "^2.2.0",
    "point-geometry": "^0.0.0",
    "quickselect": "^1.0.0",
    "request": "^2.39.0",
    "resolve-url": "^0.2.1",
    "shelf-pack": "^1.0.0",
    "supercluster": "^2.0.1",
    "tinyqueue": "^1.1.0",
    "unassertify": "^2.0.0",
    "unitbezier": "^0.0.0",
    "vector-tile": "^1.3.0",
    "vt-pbf": "^2.0.2",
    "webworkify": "^1.3.0",
    "whoots-js": "^2.0.0"
  },
  "devDependencies": {
    "babel-preset-react": "^6.11.1",
    "babelify": "^7.3.0",
    "benchmark": "~2.1.0",
    "browserify": "^13.0.0",
    "clipboard": "^1.5.12",
    "concat-stream": "1.5.1",
    "coveralls": "^2.11.8",
    "doctrine": "^1.2.1",
    "documentation": "https://github.com/documentationjs/documentation/archive/bb41619c734e59ef3fbc3648610032efcfdaaace.tar.gz",
    "documentation-theme-utils": "3.0.0",
    "envify": "^3.4.0",
    "eslint": "^3.3.1",
    "eslint-config-mourner": "^2.0.0",
    "eslint-plugin-html": "^1.5.1",
    "gl": "^4.0.1",
    "handlebars": "4.0.5",
    "highlight.js": "9.3.0",
    "istanbul": "^0.4.2",
    "json-loader": "^0.5.4",
    "lodash": "^4.13.1",
    "mapbox-gl-test-suite": "mapbox/mapbox-gl-test-suite#3e36b193a0c442a3fd863119f101afa6db97b32d",
    "memory-fs": "^0.3.0",
    "minifyify": "^7.0.1",
    "npm-run-all": "^3.0.0",
    "nyc": "6.4.0",
    "proxyquire": "^1.7.9",
    "remark": "4.2.2",
    "remark-html": "3.0.0",
    "sinon": "^1.15.4",
    "st": "^1.2.0",
    "tap": "^5.7.0",
    "transform-loader": "^0.2.3",
    "unist-util-visit": "1.1.0",
    "vinyl": "1.1.1",
    "vinyl-fs": "2.4.3",
    "watchify": "^3.7.0",
    "webpack": "^1.13.1",
    "webworkify-webpack": "^1.1.3"
  },
  "browser": {
    "./js/util/ajax.js": "./js/util/browser/ajax.js",
    "./js/util/browser.js": "./js/util/browser/browser.js",
    "./js/util/canvas.js": "./js/util/browser/canvas.js",
    "./js/util/dom.js": "./js/util/browser/dom.js",
    "./js/util/web_worker.js": "./js/util/browser/web_worker.js"
  },
  "scripts": {
    "build-dev": "browserify js/mapbox-gl.js --debug --standalone mapboxgl > dist/mapbox-gl-dev.js && tap --no-coverage test/build/dev.test.js",
    "watch-dev": "watchify js/mapbox-gl.js --debug --standalone mapboxgl --outfile dist/mapbox-gl-dev.js --verbose",
    "build-min": "browserify js/mapbox-gl.js --debug --transform unassertify --plugin [minifyify --map mapbox-gl.js.map --output dist/mapbox-gl.js.map] --standalone mapboxgl > dist/mapbox-gl.js && tap --no-coverage test/build/min.test.js",
    "build-token": "browserify debug/access-token.js --debug --transform envify > debug/access-token-generated.js",
    "watch-bench": "node bench/download-data.js && watchify bench/index.js --plugin [minifyify --no-map] --transform [babelify --presets react] --transform unassertify --transform envify --outfile bench/index-generated.js --verbose",
    "start-server": "st --no-cache --localhost --port 9966 --index index.html .",

    "start": "run-p build-token watch-dev watch-bench start-server",
    "start-debug": "run-p build-token watch-dev start-server",
    "start-bench": "run-p build-token watch-bench start-server",

    "build-docs": "documentation build --github --format html --config documentation.yml --theme ./docs/_theme --output docs/api/",
    "build": "npm run build-docs # invoked by publisher when publishing docs on the mb-pages branch",
    "start-docs": "npm run build-min && npm run build-docs && jekyll serve --watch",

    "lint": "eslint  --ignore-path .gitignore js test bench docs/_posts/examples/*.html",
    "open-changed-examples": "git diff --name-only mb-pages HEAD -- docs/_posts/examples/*.html | awk '{print \"http://127.0.0.1:4000/mapbox-gl-js/example/\" substr($0,33,length($0)-37)}' | xargs open",
    "test-suite": "node test/render.test.js && node test/query.test.js",
    "test": "npm run lint && tap --reporter dot test/js/*/*.js test/build/webpack.test.js"
  }
}

},{}]},{},[17])(17)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9kYXRhL2FycmF5X2dyb3VwLmpzIiwianMvZGF0YS9idWNrZXQuanMiLCJqcy9kYXRhL2J1Y2tldC9jaXJjbGVfYnVja2V0LmpzIiwianMvZGF0YS9idWNrZXQvZXh0cnVzaW9uX2J1Y2tldC5qcyIsImpzL2RhdGEvYnVja2V0L2ZpbGxfYnVja2V0LmpzIiwianMvZGF0YS9idWNrZXQvbGluZV9idWNrZXQuanMiLCJqcy9kYXRhL2J1Y2tldC9zeW1ib2xfYnVja2V0LmpzIiwianMvZGF0YS9idWZmZXIuanMiLCJqcy9kYXRhL2J1ZmZlcl9ncm91cC5qcyIsImpzL2RhdGEvZmVhdHVyZV9pbmRleC5qcyIsImpzL2RhdGEvbG9hZF9nZW9tZXRyeS5qcyIsImpzL2dlby9jb29yZGluYXRlLmpzIiwianMvZ2VvL2xuZ19sYXQuanMiLCJqcy9nZW8vbG5nX2xhdF9ib3VuZHMuanMiLCJqcy9nZW8vdHJhbnNmb3JtLmpzIiwianMvbGliL2RlYnVndGV4dC5qcyIsImpzL21hcGJveC1nbC5qcyIsImpzL3JlbmRlci9jcmVhdGVfdW5pZm9ybV9wcmFnbWFzLmpzIiwianMvcmVuZGVyL2RyYXdfYmFja2dyb3VuZC5qcyIsImpzL3JlbmRlci9kcmF3X2NpcmNsZS5qcyIsImpzL3JlbmRlci9kcmF3X2NvbGxpc2lvbl9kZWJ1Zy5qcyIsImpzL3JlbmRlci9kcmF3X2RlYnVnLmpzIiwianMvcmVuZGVyL2RyYXdfZXh0cnVzaW9uLmpzIiwianMvcmVuZGVyL2RyYXdfZmlsbC5qcyIsImpzL3JlbmRlci9kcmF3X2xpbmUuanMiLCJqcy9yZW5kZXIvZHJhd19yYXN0ZXIuanMiLCJqcy9yZW5kZXIvZHJhd19zeW1ib2wuanMiLCJqcy9yZW5kZXIvZnJhbWVfaGlzdG9yeS5qcyIsImpzL3JlbmRlci9saW5lX2F0bGFzLmpzIiwianMvcmVuZGVyL3BhaW50ZXIuanMiLCJqcy9yZW5kZXIvcGFpbnRlci91c2VfcHJvZ3JhbS5qcyIsImpzL3JlbmRlci92ZXJ0ZXhfYXJyYXlfb2JqZWN0LmpzIiwianMvc291cmNlL2dlb2pzb25fc291cmNlLmpzIiwianMvc291cmNlL2dlb2pzb25fd29ya2VyX3NvdXJjZS5qcyIsImpzL3NvdXJjZS9nZW9qc29uX3dyYXBwZXIuanMiLCJqcy9zb3VyY2UvaW1hZ2Vfc291cmNlLmpzIiwianMvc291cmNlL2xvYWRfdGlsZWpzb24uanMiLCJqcy9zb3VyY2UvcGl4ZWxzX3RvX3RpbGVfdW5pdHMuanMiLCJqcy9zb3VyY2UvcXVlcnlfZmVhdHVyZXMuanMiLCJqcy9zb3VyY2UvcmFzdGVyX3RpbGVfc291cmNlLmpzIiwianMvc291cmNlL3NvdXJjZS5qcyIsImpzL3NvdXJjZS9zb3VyY2VfY2FjaGUuanMiLCJqcy9zb3VyY2UvdGlsZS5qcyIsImpzL3NvdXJjZS90aWxlX2Nvb3JkLmpzIiwianMvc291cmNlL3ZlY3Rvcl90aWxlX3NvdXJjZS5qcyIsImpzL3NvdXJjZS92ZWN0b3JfdGlsZV93b3JrZXJfc291cmNlLmpzIiwianMvc291cmNlL3ZpZGVvX3NvdXJjZS5qcyIsImpzL3NvdXJjZS93b3JrZXIuanMiLCJqcy9zb3VyY2Uvd29ya2VyX3RpbGUuanMiLCJqcy9zdHlsZS9hbmltYXRpb25fbG9vcC5qcyIsImpzL3N0eWxlL2ltYWdlX3Nwcml0ZS5qcyIsImpzL3N0eWxlL3BhcnNlX2NvbG9yLmpzIiwianMvc3R5bGUvc3R5bGUuanMiLCJqcy9zdHlsZS9zdHlsZV9kZWNsYXJhdGlvbi5qcyIsImpzL3N0eWxlL3N0eWxlX2Z1bmN0aW9uLmpzIiwianMvc3R5bGUvc3R5bGVfbGF5ZXIuanMiLCJqcy9zdHlsZS9zdHlsZV9sYXllci9iYWNrZ3JvdW5kX3N0eWxlX2xheWVyLmpzIiwianMvc3R5bGUvc3R5bGVfbGF5ZXIvY2lyY2xlX3N0eWxlX2xheWVyLmpzIiwianMvc3R5bGUvc3R5bGVfbGF5ZXIvZXh0cnVzaW9uX3N0eWxlX2xheWVyLmpzIiwianMvc3R5bGUvc3R5bGVfbGF5ZXIvZmlsbF9zdHlsZV9sYXllci5qcyIsImpzL3N0eWxlL3N0eWxlX2xheWVyL2xpbmVfc3R5bGVfbGF5ZXIuanMiLCJqcy9zdHlsZS9zdHlsZV9sYXllci9yYXN0ZXJfc3R5bGVfbGF5ZXIuanMiLCJqcy9zdHlsZS9zdHlsZV9sYXllci9zeW1ib2xfc3R5bGVfbGF5ZXIuanMiLCJqcy9zdHlsZS9zdHlsZV9zcGVjLmpzIiwianMvc3R5bGUvc3R5bGVfdHJhbnNpdGlvbi5qcyIsImpzL3N0eWxlL3ZhbGlkYXRlX3N0eWxlLmpzIiwianMvc3ltYm9sL2FuY2hvci5qcyIsImpzL3N5bWJvbC9jaGVja19tYXhfYW5nbGUuanMiLCJqcy9zeW1ib2wvY2xpcF9saW5lLmpzIiwianMvc3ltYm9sL2NvbGxpc2lvbl9ib3guanMiLCJqcy9zeW1ib2wvY29sbGlzaW9uX2ZlYXR1cmUuanMiLCJqcy9zeW1ib2wvY29sbGlzaW9uX3RpbGUuanMiLCJqcy9zeW1ib2wvZ2V0X2FuY2hvcnMuanMiLCJqcy9zeW1ib2wvZ2x5cGhfYXRsYXMuanMiLCJqcy9zeW1ib2wvZ2x5cGhfc291cmNlLmpzIiwianMvc3ltYm9sL21lcmdlbGluZXMuanMiLCJqcy9zeW1ib2wvcXVhZHMuanMiLCJqcy9zeW1ib2wvcmVzb2x2ZV90ZXh0LmpzIiwianMvc3ltYm9sL3NoYXBpbmcuanMiLCJqcy9zeW1ib2wvc3ByaXRlX2F0bGFzLmpzIiwianMvc3ltYm9sL3N5bWJvbF9pbnN0YW5jZXMuanMiLCJqcy9zeW1ib2wvc3ltYm9sX3F1YWRzLmpzIiwianMvdWkvYmluZF9oYW5kbGVycy5qcyIsImpzL3VpL2NhbWVyYS5qcyIsImpzL3VpL2NvbnRyb2wvYXR0cmlidXRpb24uanMiLCJqcy91aS9jb250cm9sL2NvbnRyb2wuanMiLCJqcy91aS9jb250cm9sL2dlb2xvY2F0ZS5qcyIsImpzL3VpL2NvbnRyb2wvbmF2aWdhdGlvbi5qcyIsImpzL3VpL2NvbnRyb2wvc2NhbGUuanMiLCJqcy91aS9oYW5kbGVyL2JveF96b29tLmpzIiwianMvdWkvaGFuZGxlci9kYmxjbGlja196b29tLmpzIiwianMvdWkvaGFuZGxlci9kcmFnX3Bhbi5qcyIsImpzL3VpL2hhbmRsZXIvZHJhZ19yb3RhdGUuanMiLCJqcy91aS9oYW5kbGVyL2tleWJvYXJkLmpzIiwianMvdWkvaGFuZGxlci9zY3JvbGxfem9vbS5qcyIsImpzL3VpL2hhbmRsZXIvdG91Y2hfem9vbV9yb3RhdGUuanMiLCJqcy91aS9oYXNoLmpzIiwianMvdWkvbWFwLmpzIiwianMvdWkvbWFya2VyLmpzIiwianMvdWkvcG9wdXAuanMiLCJqcy91dGlsL2FjdG9yLmpzIiwianMvdXRpbC9icm93c2VyL2FqYXguanMiLCJqcy91dGlsL2Jyb3dzZXIvYnJvd3Nlci5qcyIsImpzL3V0aWwvYnJvd3Nlci9jYW52YXMuanMiLCJqcy91dGlsL2Jyb3dzZXIvZG9tLmpzIiwianMvdXRpbC9icm93c2VyL3dlYl93b3JrZXIuanMiLCJqcy91dGlsL2NsYXNzaWZ5X3JpbmdzLmpzIiwianMvdXRpbC9jb25maWcuanMiLCJqcy91dGlsL2RpY3Rpb25hcnlfY29kZXIuanMiLCJqcy91dGlsL2Rpc3BhdGNoZXIuanMiLCJqcy91dGlsL2V2ZW50ZWQuanMiLCJqcy91dGlsL2ZpbmRfcG9sZV9vZl9pbmFjY2Vzc2liaWxpdHkuanMiLCJqcy91dGlsL2dseXBocy5qcyIsImpzL3V0aWwvaW50ZXJwb2xhdGUuanMiLCJqcy91dGlsL2ludGVyc2VjdGlvbl90ZXN0cy5qcyIsImpzL3V0aWwvbHJ1X2NhY2hlLmpzIiwianMvdXRpbC9tYXBib3guanMiLCJqcy91dGlsL3N0cnVjdF9hcnJheS5qcyIsImpzL3V0aWwvdG9rZW4uanMiLCJqcy91dGlsL3V0aWwuanMiLCJqcy91dGlsL3ZlY3RvcnRpbGVfdG9fZ2VvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9hc3NlcnQvYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvY3NzY29sb3JwYXJzZXIvY3NzY29sb3JwYXJzZXIuanMiLCJub2RlX21vZHVsZXMvZWFyY3V0L3NyYy9lYXJjdXQuanMiLCJub2RlX21vZHVsZXMvZmVhdHVyZS1maWx0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2VvanNvbi1yZXdpbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2VvanNvbi1yZXdpbmQvbm9kZV9tb2R1bGVzL2dlb2pzb24tYXJlYS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXJld2luZC9ub2RlX21vZHVsZXMvZ2VvanNvbi1hcmVhL25vZGVfbW9kdWxlcy93Z3M4NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy9jbGlwLmpzIiwibm9kZV9tb2R1bGVzL2dlb2pzb24tdnQvc3JjL2NvbnZlcnQuanMiLCJub2RlX21vZHVsZXMvZ2VvanNvbi12dC9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2VvanNvbi12dC9zcmMvc2ltcGxpZnkuanMiLCJub2RlX21vZHVsZXMvZ2VvanNvbi12dC9zcmMvdGlsZS5qcyIsIm5vZGVfbW9kdWxlcy9nZW9qc29uLXZ0L3NyYy90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvZ2VvanNvbi12dC9zcmMvd3JhcC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9jb21tb24uanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0Mi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQyZC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQzLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvcXVhdC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWMyLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzMuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvdmVjNC5qcyIsIm5vZGVfbW9kdWxlcy9ncmlkLWluZGV4L2dyaWQtaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsLWZ1bmN0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zaGFkZXJzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi9lcnJvci92YWxpZGF0aW9uX2Vycm9yLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi91dGlsL2V4dGVuZC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdXRpbC9nZXRfdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdXRpbC91bmJ1bmRsZV9qc29ubGludC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGUvdmFsaWRhdGUuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlL3ZhbGlkYXRlX2FycmF5LmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZS92YWxpZGF0ZV9ib29sZWFuLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZS92YWxpZGF0ZV9jb2xvci5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGUvdmFsaWRhdGVfY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZS92YWxpZGF0ZV9lbnVtLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZS92YWxpZGF0ZV9maWx0ZXIuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlL3ZhbGlkYXRlX2Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZS92YWxpZGF0ZV9nbHlwaHNfdXJsLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZS92YWxpZGF0ZV9sYXllci5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGUvdmFsaWRhdGVfbGF5b3V0X3Byb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZS92YWxpZGF0ZV9udW1iZXIuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlL3ZhbGlkYXRlX29iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGUvdmFsaWRhdGVfcGFpbnRfcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlL3ZhbGlkYXRlX3NvdXJjZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGUvdmFsaWRhdGVfc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZV9zdHlsZS5taW4uanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvcmVmZXJlbmNlL2xhdGVzdC5taW4uanMiLCJub2RlX21vZHVsZXMvbWFwYm94LWdsLXN0eWxlLXNwZWMvcmVmZXJlbmNlL3Y4Lm1pbi5qc29uIiwibm9kZV9tb2R1bGVzL21hcGJveC1nbC1zdXBwb3J0ZWQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGJmL2J1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9wYmYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGJmL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BvaW50LWdlb21ldHJ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3F1aWNrc2VsZWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Jlc29sdmUtdXJsL3Jlc29sdmUtdXJsLmpzIiwibm9kZV9tb2R1bGVzL3NoZWxmLXBhY2svaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3VwZXJjbHVzdGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyY2x1c3Rlci9ub2RlX21vZHVsZXMva2RidXNoL3NyYy9rZGJ1c2guanMiLCJub2RlX21vZHVsZXMvc3VwZXJjbHVzdGVyL25vZGVfbW9kdWxlcy9rZGJ1c2gvc3JjL3JhbmdlLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyY2x1c3Rlci9ub2RlX21vZHVsZXMva2RidXNoL3NyYy9zb3J0LmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyY2x1c3Rlci9ub2RlX21vZHVsZXMva2RidXNoL3NyYy93aXRoaW4uanMiLCJub2RlX21vZHVsZXMvdGlueXF1ZXVlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3VuaXRiZXppZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmVjdG9yLXRpbGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmVjdG9yLXRpbGUvbGliL3ZlY3RvcnRpbGUuanMiLCJub2RlX21vZHVsZXMvdmVjdG9yLXRpbGUvbGliL3ZlY3RvcnRpbGVmZWF0dXJlLmpzIiwibm9kZV9tb2R1bGVzL3ZlY3Rvci10aWxlL2xpYi92ZWN0b3J0aWxlbGF5ZXIuanMiLCJub2RlX21vZHVsZXMvdnQtcGJmL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Z0LXBiZi9saWIvZ2VvanNvbl93cmFwcGVyLmpzIiwibm9kZV9tb2R1bGVzL3Z0LXBiZi92ZWN0b3ItdGlsZS1wYi5qcyIsIm5vZGVfbW9kdWxlcy93ZWJ3b3JraWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dob290cy1qcy9pbmRleC51bWQuanMiLCJwYWNrYWdlLmpzb24iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4aEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3p4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzErQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4bEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDendCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXlHcm91cDtcblxuLyoqXG4gKiBBIGNsYXNzIHRoYXQgbWFuYWdlcyB2ZXJ0ZXggYW5kIGVsZW1lbnQgYXJyYXlzIGZvciBhIHJhbmdlIG9mIGZlYXR1cmVzLiBJdCBoYW5kbGVzIGluaXRpYWxpemF0aW9uLFxuICogc2VyaWFsaXphdGlvbiBmb3IgdHJhbnNmZXIgdG8gdGhlIG1haW4gdGhyZWFkLCBhbmQgY2VydGFpbiBpbnRlcnZlbmluZyBtdXRhdGlvbnMuXG4gKlxuICogQXJyYXkgZWxlbWVudHMgYXJlIGJyb2tlbiBpbnRvIGFycmF5IGdyb3VwcyBiYXNlZCBvbiBpbmhlcmVudCBsaW1pdHMgb2YgV2ViR0wuIFdpdGhpbiBhIGdyb3VwIGlzOlxuICpcbiAqICogQSBcImxheW91dFwiIHZlcnRleCBhcnJheSwgd2l0aCBmaXhlZCBsYXlvdXQsIGNvbnRhaW5pbmcgdmFsdWVzIGNhbGN1bGF0ZWQgZnJvbSBsYXlvdXQgcHJvcGVydGllcy5cbiAqICogWmVybywgb25lLCBvciB0d28gZWxlbWVudCBhcnJheXMsIHdpdGggZml4ZWQgbGF5b3V0LCB0eXBpY2FsbHkgZm9yIGV2ZW50dWFsIHVzZSBpblxuICogICBgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgLi4uKWAuXG4gKiAqIFplcm8gb3IgbW9yZSBcInBhaW50XCIgdmVydGV4IGFycmF5cyBrZXllZCBieSBsYXllciBJRCwgZWFjaCB3aXRoIGEgZHluYW1pYyBsYXlvdXQgd2hpY2ggZGVwZW5kc1xuICogICBvbiB3aGljaCBwYWludCBwcm9wZXJ0aWVzIG9mIHRoYXQgbGF5ZXIgdXNlIGRhdGEtZHJpdmVuLWZ1bmN0aW9ucyAocHJvcGVydHkgZnVuY3Rpb25zIG9yXG4gKiAgIHByb3BlcnR5LWFuZC16b29tIGZ1bmN0aW9ucykuIFZhbHVlcyBhcmUgY2FsY3VsYXRlZCBieSBldmFsdWF0aW5nIHRob3NlIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBBcnJheUdyb3VwKGFycmF5VHlwZXMpIHtcbiAgICB2YXIgTGF5b3V0VmVydGV4QXJyYXlUeXBlID0gYXJyYXlUeXBlcy5sYXlvdXRWZXJ0ZXhBcnJheVR5cGU7XG4gICAgdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheSA9IG5ldyBMYXlvdXRWZXJ0ZXhBcnJheVR5cGUoKTtcblxuICAgIHZhciBFbGVtZW50QXJyYXlUeXBlID0gYXJyYXlUeXBlcy5lbGVtZW50QXJyYXlUeXBlO1xuICAgIGlmIChFbGVtZW50QXJyYXlUeXBlKSB0aGlzLmVsZW1lbnRBcnJheSA9IG5ldyBFbGVtZW50QXJyYXlUeXBlKCk7XG5cbiAgICB2YXIgRWxlbWVudEFycmF5VHlwZTIgPSBhcnJheVR5cGVzLmVsZW1lbnRBcnJheVR5cGUyO1xuICAgIGlmIChFbGVtZW50QXJyYXlUeXBlMikgdGhpcy5lbGVtZW50QXJyYXkyID0gbmV3IEVsZW1lbnRBcnJheVR5cGUyKCk7XG5cbiAgICB0aGlzLnBhaW50VmVydGV4QXJyYXlzID0gdXRpbC5tYXBPYmplY3QoYXJyYXlUeXBlcy5wYWludFZlcnRleEFycmF5VHlwZXMsIGZ1bmN0aW9uIChQYWludFZlcnRleEFycmF5VHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IFBhaW50VmVydGV4QXJyYXlUeXBlKCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogVGhlIG1heGltdW0gc2l6ZSBvZiBhIHZlcnRleCBhcnJheS4gVGhpcyBsaW1pdCBpcyBpbXBvc2VkIGJ5IFdlYkdMJ3MgMTYgYml0XG4gKiBhZGRyZXNzaW5nIG9mIHZlcnRleCBidWZmZXJzLlxuICogQHByaXZhdGVcbiAqIEByZWFkb25seVxuICovXG5BcnJheUdyb3VwLk1BWF9WRVJURVhfQVJSQVlfTEVOR1RIID0gTWF0aC5wb3coMiwgMTYpIC0gMTtcblxuQXJyYXlHcm91cC5wcm90b3R5cGUuaGFzQ2FwYWNpdHlGb3IgPSBmdW5jdGlvbihudW1WZXJ0aWNlcykge1xuICAgIHJldHVybiB0aGlzLmxheW91dFZlcnRleEFycmF5Lmxlbmd0aCArIG51bVZlcnRpY2VzIDw9IEFycmF5R3JvdXAuTUFYX1ZFUlRFWF9BUlJBWV9MRU5HVEg7XG59O1xuXG5BcnJheUdyb3VwLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5b3V0VmVydGV4QXJyYXkubGVuZ3RoID09PSAwO1xufTtcblxuQXJyYXlHcm91cC5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubGF5b3V0VmVydGV4QXJyYXkudHJpbSgpO1xuXG4gICAgaWYgKHRoaXMuZWxlbWVudEFycmF5KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudEFycmF5LnRyaW0oKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lbGVtZW50QXJyYXkyKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudEFycmF5Mi50cmltKCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgbGF5ZXJOYW1lIGluIHRoaXMucGFpbnRWZXJ0ZXhBcnJheXMpIHtcbiAgICAgICAgdGhpcy5wYWludFZlcnRleEFycmF5c1tsYXllck5hbWVdLnRyaW0oKTtcbiAgICB9XG59O1xuXG5BcnJheUdyb3VwLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsYXlvdXRWZXJ0ZXhBcnJheTogdGhpcy5sYXlvdXRWZXJ0ZXhBcnJheS5zZXJpYWxpemUoKSxcbiAgICAgICAgZWxlbWVudEFycmF5OiB0aGlzLmVsZW1lbnRBcnJheSAmJiB0aGlzLmVsZW1lbnRBcnJheS5zZXJpYWxpemUoKSxcbiAgICAgICAgZWxlbWVudEFycmF5MjogdGhpcy5lbGVtZW50QXJyYXkyICYmIHRoaXMuZWxlbWVudEFycmF5Mi5zZXJpYWxpemUoKSxcbiAgICAgICAgcGFpbnRWZXJ0ZXhBcnJheXM6IHV0aWwubWFwT2JqZWN0KHRoaXMucGFpbnRWZXJ0ZXhBcnJheXMsIGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXkuc2VyaWFsaXplKCk7XG4gICAgICAgIH0pXG4gICAgfTtcbn07XG5cbkFycmF5R3JvdXAucHJvdG90eXBlLmdldFRyYW5zZmVyYWJsZXMgPSBmdW5jdGlvbih0cmFuc2ZlcmFibGVzKSB7XG4gICAgdHJhbnNmZXJhYmxlcy5wdXNoKHRoaXMubGF5b3V0VmVydGV4QXJyYXkuYXJyYXlCdWZmZXIpO1xuXG4gICAgaWYgKHRoaXMuZWxlbWVudEFycmF5KSB7XG4gICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaCh0aGlzLmVsZW1lbnRBcnJheS5hcnJheUJ1ZmZlcik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZWxlbWVudEFycmF5Mikge1xuICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2godGhpcy5lbGVtZW50QXJyYXkyLmFycmF5QnVmZmVyKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBsYXllck5hbWUgaW4gdGhpcy5wYWludFZlcnRleEFycmF5cykge1xuICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2godGhpcy5wYWludFZlcnRleEFycmF5c1tsYXllck5hbWVdLmFycmF5QnVmZmVyKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZmVhdHVyZUZpbHRlciA9IHJlcXVpcmUoJ2ZlYXR1cmUtZmlsdGVyJyk7XG52YXIgQXJyYXlHcm91cCA9IHJlcXVpcmUoJy4vYXJyYXlfZ3JvdXAnKTtcbnZhciBCdWZmZXJHcm91cCA9IHJlcXVpcmUoJy4vYnVmZmVyX2dyb3VwJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIFN0cnVjdEFycmF5VHlwZSA9IHJlcXVpcmUoJy4uL3V0aWwvc3RydWN0X2FycmF5Jyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQnVja2V0O1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIHRoZSBhcHByb3ByaWF0ZSBzdWJjbGFzcyBvZiBgQnVja2V0YCBmb3IgYG9wdGlvbnNgLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBvcHRpb25zIFNlZSBgQnVja2V0YCBjb25zdHJ1Y3RvciBvcHRpb25zXG4gKiBAcmV0dXJucyB7QnVja2V0fVxuICovXG5CdWNrZXQuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBDbGFzc2VzID0ge1xuICAgICAgICBmaWxsOiByZXF1aXJlKCcuL2J1Y2tldC9maWxsX2J1Y2tldCcpLFxuICAgICAgICBsaW5lOiByZXF1aXJlKCcuL2J1Y2tldC9saW5lX2J1Y2tldCcpLFxuICAgICAgICBjaXJjbGU6IHJlcXVpcmUoJy4vYnVja2V0L2NpcmNsZV9idWNrZXQnKSxcbiAgICAgICAgc3ltYm9sOiByZXF1aXJlKCcuL2J1Y2tldC9zeW1ib2xfYnVja2V0JyksXG4gICAgICAgIGV4dHJ1c2lvbjogcmVxdWlyZSgnLi9idWNrZXQvZXh0cnVzaW9uX2J1Y2tldCcpXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IENsYXNzZXNbb3B0aW9ucy5sYXllci50eXBlXShvcHRpb25zKTtcbn07XG5cblxuLyoqXG4gKiBUaGUgbWF4aW11bSBleHRlbnQgb2YgYSBmZWF0dXJlIHRoYXQgY2FuIGJlIHNhZmVseSBzdG9yZWQgaW4gdGhlIGJ1ZmZlci5cbiAqIEluIHByYWN0aWNlLCBhbGwgZmVhdHVyZXMgYXJlIGNvbnZlcnRlZCB0byB0aGlzIGV4dGVudCBiZWZvcmUgYmVpbmcgYWRkZWQuXG4gKlxuICogUG9zaXRpb25zIGFyZSBzdG9yZWQgYXMgc2lnbmVkIDE2Yml0IGludGVnZXJzLlxuICogT25lIGJpdCBpcyBsb3N0IGZvciBzaWduZWRuZXNzIHRvIHN1cHBvcnQgZmVhdHVlcnMgZXh0ZW5kaW5nIHBhc3QgdGhlIGxlZnQgZWRnZSBvZiB0aGUgdGlsZS5cbiAqIE9uZSBiaXQgaXMgbG9zdCBiZWNhdXNlIHRoZSBsaW5lIHZlcnRleCBidWZmZXIgcGFja3MgMSBiaXQgb2Ygb3RoZXIgZGF0YSBpbnRvIHRoZSBpbnQuXG4gKiBPbmUgYml0IGlzIGxvc3QgdG8gc3VwcG9ydCBmZWF0dXJlcyBleHRlbmRpbmcgcGFzdCB0aGUgZXh0ZW50IG9uIHRoZSByaWdodCBlZGdlIG9mIHRoZSB0aWxlLlxuICogVGhpcyBsZWF2ZXMgdXMgd2l0aCAyXjEzID0gODE5MlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcmVhZG9ubHlcbiAqL1xuQnVja2V0LkVYVEVOVCA9IDgxOTI7XG5cbi8qKlxuICogVGhlIGBCdWNrZXRgIGNsYXNzIGlzIHRoZSBzaW5nbGUgcG9pbnQgb2Yga25vd2xlZGdlIGFib3V0IHR1cm5pbmcgdmVjdG9yXG4gKiB0aWxlcyBpbnRvIFdlYkdMIGJ1ZmZlcnMuXG4gKlxuICogYEJ1Y2tldGAgaXMgYW4gYWJzdHJhY3QgY2xhc3MuIEEgc3ViY2xhc3MgZXhpc3RzIGZvciBlYWNoIE1hcGJveCBHTFxuICogc3R5bGUgc3BlYyBsYXllciB0eXBlLiBCZWNhdXNlIGBCdWNrZXRgIGlzIGFuIGFic3RyYWN0IGNsYXNzLFxuICogaW5zdGFuY2VzIHNob3VsZCBiZSBjcmVhdGVkIHZpYSB0aGUgYEJ1Y2tldC5jcmVhdGVgIG1ldGhvZC5cbiAqXG4gKiBAY2xhc3MgQnVja2V0XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnpvb20gWm9vbSBsZXZlbCBvZiB0aGUgYnVmZmVycyBiZWluZyBidWlsdC4gTWF5IGJlXG4gKiAgICAgYSBmcmFjdGlvbmFsIHpvb20gbGV2ZWwuXG4gKiBAcGFyYW0gb3B0aW9ucy5sYXllciBBIE1hcGJveCBzdHlsZSBsYXllciBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIEJ1ZmZlcj59IG9wdGlvbnMuYnVmZmVycyBUaGUgc2V0IG9mIGBCdWZmZXJgcyBiZWluZ1xuICogICAgIGJ1aWx0IGZvciB0aGlzIHRpbGUuIFRoaXMgb2JqZWN0IGZhY2lsaXRhdGVzIHNoYXJpbmcgb2YgYEJ1ZmZlcmBzIGJlXG4gICAgICAgYmV0d2VlbiBgQnVja2V0YHMuXG4gKi9cbmZ1bmN0aW9uIEJ1Y2tldChvcHRpb25zKSB7XG4gICAgdGhpcy56b29tID0gb3B0aW9ucy56b29tO1xuICAgIHRoaXMub3ZlcnNjYWxpbmcgPSBvcHRpb25zLm92ZXJzY2FsaW5nO1xuICAgIHRoaXMubGF5ZXIgPSBvcHRpb25zLmxheWVyO1xuICAgIHRoaXMuY2hpbGRMYXllcnMgPSBvcHRpb25zLmNoaWxkTGF5ZXJzO1xuXG4gICAgdGhpcy50eXBlID0gdGhpcy5sYXllci50eXBlO1xuICAgIHRoaXMuZmVhdHVyZXMgPSBbXTtcbiAgICB0aGlzLmlkID0gdGhpcy5sYXllci5pZDtcbiAgICB0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcbiAgICB0aGlzLnNvdXJjZUxheWVyID0gdGhpcy5sYXllci5zb3VyY2VMYXllcjtcbiAgICB0aGlzLnNvdXJjZUxheWVySW5kZXggPSBvcHRpb25zLnNvdXJjZUxheWVySW5kZXg7XG4gICAgdGhpcy5taW5ab29tID0gdGhpcy5sYXllci5taW56b29tO1xuICAgIHRoaXMubWF4Wm9vbSA9IHRoaXMubGF5ZXIubWF4em9vbTtcblxuICAgIHRoaXMucGFpbnRBdHRyaWJ1dGVzID0gY3JlYXRlUGFpbnRBdHRyaWJ1dGVzKHRoaXMpO1xuXG4gICAgaWYgKG9wdGlvbnMuYXJyYXlzKSB7XG4gICAgICAgIHZhciBwcm9ncmFtSW50ZXJmYWNlcyA9IHRoaXMucHJvZ3JhbUludGVyZmFjZXM7XG4gICAgICAgIHRoaXMuYnVmZmVyR3JvdXBzID0gdXRpbC5tYXBPYmplY3Qob3B0aW9ucy5hcnJheXMsIGZ1bmN0aW9uKHByb2dyYW1BcnJheUdyb3VwcywgcHJvZ3JhbU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBwcm9ncmFtSW50ZXJmYWNlID0gcHJvZ3JhbUludGVyZmFjZXNbcHJvZ3JhbU5hbWVdO1xuICAgICAgICAgICAgdmFyIHBhaW50VmVydGV4QXJyYXlUeXBlcyA9IG9wdGlvbnMucGFpbnRWZXJ0ZXhBcnJheVR5cGVzW3Byb2dyYW1OYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBwcm9ncmFtQXJyYXlHcm91cHMubWFwKGZ1bmN0aW9uKGFycmF5R3JvdXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlckdyb3VwKGFycmF5R3JvdXAsIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0VmVydGV4QXJyYXlUeXBlOiBwcm9ncmFtSW50ZXJmYWNlLmxheW91dFZlcnRleEFycmF5VHlwZS5zZXJpYWxpemUoKSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudEFycmF5VHlwZTogcHJvZ3JhbUludGVyZmFjZS5lbGVtZW50QXJyYXlUeXBlICYmIHByb2dyYW1JbnRlcmZhY2UuZWxlbWVudEFycmF5VHlwZS5zZXJpYWxpemUoKSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudEFycmF5VHlwZTI6IHByb2dyYW1JbnRlcmZhY2UuZWxlbWVudEFycmF5VHlwZTIgJiYgcHJvZ3JhbUludGVyZmFjZS5lbGVtZW50QXJyYXlUeXBlMi5zZXJpYWxpemUoKSxcbiAgICAgICAgICAgICAgICAgICAgcGFpbnRWZXJ0ZXhBcnJheVR5cGVzOiBwYWludFZlcnRleEFycmF5VHlwZXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQnVpbGQgdGhlIGFycmF5cyEgRmVhdHVyZXMgYXJlIHNldCBkaXJlY3RseSB0byB0aGUgYGZlYXR1cmVzYCBwcm9wZXJ0eS5cbiAqIEBwcml2YXRlXG4gKi9cbkJ1Y2tldC5wcm90b3R5cGUucG9wdWxhdGVBcnJheXMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNyZWF0ZUFycmF5cygpO1xuICAgIHRoaXMucmVjYWxjdWxhdGVTdHlsZUxheWVycygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRkRmVhdHVyZSh0aGlzLmZlYXR1cmVzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLnRyaW1BcnJheXMoKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBhcnJheSBncm91cCBmb3JcbiAqIGB2ZXJ0ZXhMZW5ndGhgIHZlcnRpY2VzLiBJZiBub3QsIGFwcGVuZCBhIG5ldyBhcnJheSBncm91cC4gU2hvdWxkIGJlIGNhbGxlZFxuICogYnkgYHBvcHVsYXRlQXJyYXlzYCBhbmQgaXRzIGNhbGxlZXMuXG4gKlxuICogQXJyYXkgZ3JvdXBzIGFyZSBhZGRlZCB0byB0aGlzLmFycmF5R3JvdXBzW3Byb2dyYW1OYW1lXS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb2dyYW1OYW1lIHRoZSBuYW1lIG9mIHRoZSBwcm9ncmFtIGFzc29jaWF0ZWQgd2l0aCB0aGUgYnVmZmVyIHRoYXQgd2lsbCByZWNlaXZlIHRoZSB2ZXJ0aWNlc1xuICogQHBhcmFtIHtudW1iZXJ9IHZlcnRleExlbmd0aCBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIHRoYXQgd2lsbCBiZSBpbnNlcnRlZCB0byB0aGUgYnVmZmVyLlxuICogQHJldHVybnMgVGhlIGN1cnJlbnQgYXJyYXkgZ3JvdXBcbiAqL1xuQnVja2V0LnByb3RvdHlwZS5wcmVwYXJlQXJyYXlHcm91cCA9IGZ1bmN0aW9uKHByb2dyYW1OYW1lLCBudW1WZXJ0aWNlcykge1xuICAgIHZhciBncm91cHMgPSB0aGlzLmFycmF5R3JvdXBzW3Byb2dyYW1OYW1lXTtcbiAgICB2YXIgY3VycmVudEdyb3VwID0gZ3JvdXBzLmxlbmd0aCAmJiBncm91cHNbZ3JvdXBzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKCFjdXJyZW50R3JvdXAgfHwgIWN1cnJlbnRHcm91cC5oYXNDYXBhY2l0eUZvcihudW1WZXJ0aWNlcykpIHtcbiAgICAgICAgY3VycmVudEdyb3VwID0gbmV3IEFycmF5R3JvdXAoe1xuICAgICAgICAgICAgbGF5b3V0VmVydGV4QXJyYXlUeXBlOiB0aGlzLnByb2dyYW1JbnRlcmZhY2VzW3Byb2dyYW1OYW1lXS5sYXlvdXRWZXJ0ZXhBcnJheVR5cGUsXG4gICAgICAgICAgICBlbGVtZW50QXJyYXlUeXBlOiB0aGlzLnByb2dyYW1JbnRlcmZhY2VzW3Byb2dyYW1OYW1lXS5lbGVtZW50QXJyYXlUeXBlLFxuICAgICAgICAgICAgZWxlbWVudEFycmF5VHlwZTI6IHRoaXMucHJvZ3JhbUludGVyZmFjZXNbcHJvZ3JhbU5hbWVdLmVsZW1lbnRBcnJheVR5cGUyLFxuICAgICAgICAgICAgcGFpbnRWZXJ0ZXhBcnJheVR5cGVzOiB0aGlzLnBhaW50VmVydGV4QXJyYXlUeXBlc1twcm9ncmFtTmFtZV1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY3VycmVudEdyb3VwLmluZGV4ID0gZ3JvdXBzLmxlbmd0aDtcblxuICAgICAgICBncm91cHMucHVzaChjdXJyZW50R3JvdXApO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50R3JvdXA7XG59O1xuXG4vKipcbiAqIFNldHMgdXAgYHRoaXMucGFpbnRWZXJ0ZXhBcnJheVR5cGVzYCBhcyB7IFtwcm9ncmFtTmFtZV06IHsgW2xheWVyTmFtZV06IFBhaW50QXJyYXlUeXBlLCAuLi4gfSwgLi4uIH1cbiAqXG4gKiBBbmQgYHRoaXMuYXJyYXlHcm91cHNgIGFzIHsgW3Byb2dyYW1OYW1lXTogW10sIC4uLiB9OyB0aGVzZSBnZXQgcG9wdWxhdGVkXG4gKiB3aXRoIGFycmF5IGdyb3VwIHN0cnVjdHVyZSBvdmVyIGluIGBwcmVwYXJlQXJyYXlHcm91cGAuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuQnVja2V0LnByb3RvdHlwZS5jcmVhdGVBcnJheXMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFycmF5R3JvdXBzID0ge307XG4gICAgdGhpcy5wYWludFZlcnRleEFycmF5VHlwZXMgPSB7fTtcblxuICAgIGZvciAodmFyIHByb2dyYW1OYW1lIGluIHRoaXMucHJvZ3JhbUludGVyZmFjZXMpIHtcbiAgICAgICAgdGhpcy5hcnJheUdyb3Vwc1twcm9ncmFtTmFtZV0gPSBbXTtcblxuICAgICAgICB2YXIgcGFpbnRWZXJ0ZXhBcnJheVR5cGVzID0gdGhpcy5wYWludFZlcnRleEFycmF5VHlwZXNbcHJvZ3JhbU5hbWVdID0ge307XG4gICAgICAgIHZhciBsYXllclBhaW50QXR0cmlidXRlcyA9IHRoaXMucGFpbnRBdHRyaWJ1dGVzW3Byb2dyYW1OYW1lXTtcblxuICAgICAgICBmb3IgKHZhciBsYXllck5hbWUgaW4gbGF5ZXJQYWludEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHBhaW50VmVydGV4QXJyYXlUeXBlc1tsYXllck5hbWVdID0gbmV3IEJ1Y2tldC5WZXJ0ZXhBcnJheVR5cGUobGF5ZXJQYWludEF0dHJpYnV0ZXNbbGF5ZXJOYW1lXS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkJ1Y2tldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKGdsKSB7XG4gICAgZm9yICh2YXIgcHJvZ3JhbU5hbWUgaW4gdGhpcy5idWZmZXJHcm91cHMpIHtcbiAgICAgICAgdmFyIHByb2dyYW1CdWZmZXJHcm91cHMgPSB0aGlzLmJ1ZmZlckdyb3Vwc1twcm9ncmFtTmFtZV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvZ3JhbUJ1ZmZlckdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcHJvZ3JhbUJ1ZmZlckdyb3Vwc1tpXS5kZXN0cm95KGdsKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkJ1Y2tldC5wcm90b3R5cGUudHJpbUFycmF5cyA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHByb2dyYW1OYW1lIGluIHRoaXMuYXJyYXlHcm91cHMpIHtcbiAgICAgICAgdmFyIGFycmF5R3JvdXBzID0gdGhpcy5hcnJheUdyb3Vwc1twcm9ncmFtTmFtZV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlHcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5R3JvdXBzW2ldLnRyaW0oKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkJ1Y2tldC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHByb2dyYW1OYW1lIGluIHRoaXMuYXJyYXlHcm91cHMpIHtcbiAgICAgICAgdmFyIGFycmF5R3JvdXBzID0gdGhpcy5hcnJheUdyb3Vwc1twcm9ncmFtTmFtZV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlHcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghYXJyYXlHcm91cHNbaV0uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuQnVja2V0LnByb3RvdHlwZS5nZXRUcmFuc2ZlcmFibGVzID0gZnVuY3Rpb24odHJhbnNmZXJhYmxlcykge1xuICAgIGZvciAodmFyIHByb2dyYW1OYW1lIGluIHRoaXMuYXJyYXlHcm91cHMpIHtcbiAgICAgICAgdmFyIGFycmF5R3JvdXBzID0gdGhpcy5hcnJheUdyb3Vwc1twcm9ncmFtTmFtZV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlHcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5R3JvdXBzW2ldLmdldFRyYW5zZmVyYWJsZXModHJhbnNmZXJhYmxlcyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5CdWNrZXQucHJvdG90eXBlLnNldFVuaWZvcm1zID0gZnVuY3Rpb24oZ2wsIHByb2dyYW1OYW1lLCBwcm9ncmFtLCBsYXllciwgZ2xvYmFsUHJvcGVydGllcykge1xuICAgIHZhciB1bmlmb3JtcyA9IHRoaXMucGFpbnRBdHRyaWJ1dGVzW3Byb2dyYW1OYW1lXVtsYXllci5pZF0udW5pZm9ybXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmlmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdW5pZm9ybSA9IHVuaWZvcm1zW2ldO1xuICAgICAgICB2YXIgdW5pZm9ybUxvY2F0aW9uID0gcHJvZ3JhbVt1bmlmb3JtLm5hbWVdO1xuICAgICAgICBnbFsndW5pZm9ybScgKyB1bmlmb3JtLmNvbXBvbmVudHMgKyAnZnYnXSh1bmlmb3JtTG9jYXRpb24sIHVuaWZvcm0uZ2V0VmFsdWUobGF5ZXIsIGdsb2JhbFByb3BlcnRpZXMpKTtcbiAgICB9XG59O1xuXG5CdWNrZXQucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxheWVySWQ6IHRoaXMubGF5ZXIuaWQsXG4gICAgICAgIHpvb206IHRoaXMuem9vbSxcbiAgICAgICAgYXJyYXlzOiB1dGlsLm1hcE9iamVjdCh0aGlzLmFycmF5R3JvdXBzLCBmdW5jdGlvbihwcm9ncmFtQXJyYXlHcm91cHMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9ncmFtQXJyYXlHcm91cHMubWFwKGZ1bmN0aW9uKGFycmF5R3JvdXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlHcm91cC5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSxcbiAgICAgICAgcGFpbnRWZXJ0ZXhBcnJheVR5cGVzOiB1dGlsLm1hcE9iamVjdCh0aGlzLnBhaW50VmVydGV4QXJyYXlUeXBlcywgZnVuY3Rpb24oYXJyYXlUeXBlcykge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWwubWFwT2JqZWN0KGFycmF5VHlwZXMsIGZ1bmN0aW9uKGFycmF5VHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVR5cGUuc2VyaWFsaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSksXG5cbiAgICAgICAgY2hpbGRMYXllcklkczogdGhpcy5jaGlsZExheWVycy5tYXAoZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXllci5pZDtcbiAgICAgICAgfSlcbiAgICB9O1xufTtcblxuQnVja2V0LnByb3RvdHlwZS5jcmVhdGVGaWx0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gZmVhdHVyZUZpbHRlcih0aGlzLmxheWVyLmZpbHRlcik7XG4gICAgfVxufTtcblxudmFyIEZBS0VfWk9PTV9ISVNUT1JZID0geyBsYXN0SW50ZWdlclpvb206IEluZmluaXR5LCBsYXN0SW50ZWdlclpvb21UaW1lOiAwLCBsYXN0Wm9vbTogMCB9O1xuQnVja2V0LnByb3RvdHlwZS5yZWNhbGN1bGF0ZVN0eWxlTGF5ZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuY2hpbGRMYXllcnNbaV0ucmVjYWxjdWxhdGUodGhpcy56b29tLCBGQUtFX1pPT01fSElTVE9SWSk7XG4gICAgfVxufTtcblxuQnVja2V0LnByb3RvdHlwZS5wb3B1bGF0ZVBhaW50QXJyYXlzID0gZnVuY3Rpb24oaW50ZXJmYWNlTmFtZSwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMsIHN0YXJ0R3JvdXAsIHN0YXJ0SW5kZXgpIHtcbiAgICBmb3IgKHZhciBsID0gMDsgbCA8IHRoaXMuY2hpbGRMYXllcnMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5jaGlsZExheWVyc1tsXTtcbiAgICAgICAgdmFyIGdyb3VwcyA9IHRoaXMuYXJyYXlHcm91cHNbaW50ZXJmYWNlTmFtZV07XG4gICAgICAgIGZvciAodmFyIGcgPSBzdGFydEdyb3VwLmluZGV4OyBnIDwgZ3JvdXBzLmxlbmd0aDsgZysrKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbZ107XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gZ3JvdXAubGF5b3V0VmVydGV4QXJyYXkubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHBhaW50QXJyYXkgPSBncm91cC5wYWludFZlcnRleEFycmF5c1tsYXllci5pZF07XG4gICAgICAgICAgICBwYWludEFycmF5LnJlc2l6ZShsZW5ndGgpO1xuXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMucGFpbnRBdHRyaWJ1dGVzW2ludGVyZmFjZU5hbWVdW2xheWVyLmlkXS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBhdHRyaWJ1dGVzLmxlbmd0aDsgbSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbbV07XG5cbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGUuZ2V0VmFsdWUobGF5ZXIsIGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKTtcblxuICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gYXR0cmlidXRlLm11bHRpcGxpZXIgfHwgMTtcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50cyA9IGF0dHJpYnV0ZS5jb21wb25lbnRzIHx8IDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBnID09PSBzdGFydEdyb3VwLmluZGV4ICA/IHN0YXJ0SW5kZXggOiAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSBwYWludEFycmF5LmdldChpKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjb21wb25lbnRzOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZW1iZXJOYW1lID0gY29tcG9uZW50cyA+IDEgPyAoYXR0cmlidXRlLm5hbWUgKyBjKSA6IGF0dHJpYnV0ZS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4W21lbWJlck5hbWVdID0gdmFsdWVbY10gKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBBIHZlcnRleCBhcnJheSBzdG9yZXMgZGF0YSBmb3IgZWFjaCB2ZXJ0ZXggaW4gYSBnZW9tZXRyeS4gRWxlbWVudHMgYXJlIGFsaWduZWQgdG8gNCBieXRlXG4gKiBib3VuZGFyaWVzIGZvciBiZXN0IHBlcmZvcm1hbmNlIGluIFdlYkdMLlxuICogQHByaXZhdGVcbiAqL1xuQnVja2V0LlZlcnRleEFycmF5VHlwZSA9IGZ1bmN0aW9uIChtZW1iZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3RBcnJheVR5cGUoe1xuICAgICAgICBtZW1iZXJzOiBtZW1iZXJzLFxuICAgICAgICBhbGlnbm1lbnQ6IDRcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQW4gZWxlbWVudCBhcnJheSBzdG9yZXMgVWludDE2IGluZGljaWVzIG9mIHZlcnRleGVzIGluIGEgY29ycmVzcG9uZGluZyB2ZXJ0ZXggYXJyYXkuIFdpdGggbm9cbiAqIGFyZ3VtZW50cywgaXQgZGVmYXVsdHMgdG8gdGhyZWUgY29tcG9uZW50cyBwZXIgZWxlbWVudCwgZm9ybWluZyB0cmlhbmdsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5CdWNrZXQuRWxlbWVudEFycmF5VHlwZSA9IGZ1bmN0aW9uIChjb21wb25lbnRzKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3RBcnJheVR5cGUoe1xuICAgICAgICBtZW1iZXJzOiBbe1xuICAgICAgICAgICAgdHlwZTogJ1VpbnQxNicsXG4gICAgICAgICAgICBuYW1lOiAndmVydGljZXMnLFxuICAgICAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50cyB8fCAzXG4gICAgICAgIH1dXG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVQYWludEF0dHJpYnV0ZXMoYnVja2V0KSB7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBmb3IgKHZhciBpbnRlcmZhY2VOYW1lIGluIGJ1Y2tldC5wcm9ncmFtSW50ZXJmYWNlcykge1xuICAgICAgICB2YXIgbGF5ZXJQYWludEF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzW2ludGVyZmFjZU5hbWVdID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBidWNrZXQuY2hpbGRMYXllcnMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZExheWVyID0gYnVja2V0LmNoaWxkTGF5ZXJzW2NdO1xuXG4gICAgICAgICAgICBsYXllclBhaW50QXR0cmlidXRlc1tjaGlsZExheWVyLmlkXSA9IHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXSxcbiAgICAgICAgICAgICAgICB1bmlmb3JtczogW10sXG4gICAgICAgICAgICAgICAgZGVmaW5lczogW10sXG4gICAgICAgICAgICAgICAgdmVydGV4UHJhZ21hczogeyBkZWZpbmU6IHt9LCBpbml0aWFsaXplOiB7fSB9LFxuICAgICAgICAgICAgICAgIGZyYWdtZW50UHJhZ21hczogeyBkZWZpbmU6IHt9LCBpbml0aWFsaXplOiB7fSB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGludGVyZmFjZV8gPSBidWNrZXQucHJvZ3JhbUludGVyZmFjZXNbaW50ZXJmYWNlTmFtZV07XG4gICAgICAgIGlmICghaW50ZXJmYWNlXy5wYWludEF0dHJpYnV0ZXMpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIFRoZXNlIHRva2VucyBhcmUgcmVwbGFjZWQgYnkgYXJndW1lbnRzIHRvIHRoZSBwcmFnbWFcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtc2hhZGVycyNwcmFnbWFzXG4gICAgICAgIHZhciBhdHRyaWJ1dGVQcmVjaXNpb24gPSAne3ByZWNpc2lvbn0nO1xuICAgICAgICB2YXIgYXR0cmlidXRlVHlwZSA9ICd7dHlwZX0nO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50ZXJmYWNlXy5wYWludEF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBpbnRlcmZhY2VfLnBhaW50QXR0cmlidXRlc1tpXTtcbiAgICAgICAgICAgIGF0dHJpYnV0ZS5tdWx0aXBsaWVyID0gYXR0cmlidXRlLm11bHRpcGxpZXIgfHwgMTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBidWNrZXQuY2hpbGRMYXllcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBidWNrZXQuY2hpbGRMYXllcnNbal07XG4gICAgICAgICAgICAgICAgdmFyIHBhaW50QXR0cmlidXRlcyA9IGxheWVyUGFpbnRBdHRyaWJ1dGVzW2xheWVyLmlkXTtcblxuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVJbnB1dE5hbWUgPSBhdHRyaWJ1dGUubmFtZTtcbiAgICAgICAgICAgICAgICBhc3NlcnQoYXR0cmlidXRlLm5hbWUuc2xpY2UoMCwgMikgPT09ICdhXycpO1xuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVJbm5lck5hbWUgPSBhdHRyaWJ1dGUubmFtZS5zbGljZSgyKTtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlVmFyeWluZ0RlZmluaXRpb247XG5cbiAgICAgICAgICAgICAgICBwYWludEF0dHJpYnV0ZXMuZnJhZ21lbnRQcmFnbWFzLmluaXRpYWxpemVbYXR0cmlidXRlSW5uZXJOYW1lXSA9ICcnO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLmlzUGFpbnRWYWx1ZUZlYXR1cmVDb25zdGFudChhdHRyaWJ1dGUucGFpbnRQcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLnVuaWZvcm1zLnB1c2goYXR0cmlidXRlKTtcblxuICAgICAgICAgICAgICAgICAgICBwYWludEF0dHJpYnV0ZXMuZnJhZ21lbnRQcmFnbWFzLmRlZmluZVthdHRyaWJ1dGVJbm5lck5hbWVdID0gcGFpbnRBdHRyaWJ1dGVzLnZlcnRleFByYWdtYXMuZGVmaW5lW2F0dHJpYnV0ZUlubmVyTmFtZV0gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAndW5pZm9ybScsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVQcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlSW5wdXROYW1lXG4gICAgICAgICAgICAgICAgICAgIF0uam9pbignICcpICsgJzsnO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhaW50QXR0cmlidXRlcy5mcmFnbWVudFByYWdtYXMuaW5pdGlhbGl6ZVthdHRyaWJ1dGVJbm5lck5hbWVdID0gcGFpbnRBdHRyaWJ1dGVzLnZlcnRleFByYWdtYXMuaW5pdGlhbGl6ZVthdHRyaWJ1dGVJbm5lck5hbWVdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlUHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUlubmVyTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICc9JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUlucHV0TmFtZVxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSArICc7XFxuJztcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5ZXIuaXNQYWludFZhbHVlWm9vbUNvbnN0YW50KGF0dHJpYnV0ZS5wYWludFByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICBwYWludEF0dHJpYnV0ZXMuYXR0cmlidXRlcy5wdXNoKHV0aWwuZXh0ZW5kKHt9LCBhdHRyaWJ1dGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGF0dHJpYnV0ZUlucHV0TmFtZVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlVmFyeWluZ0RlZmluaXRpb24gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAndmFyeWluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVQcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlSW5uZXJOYW1lXG4gICAgICAgICAgICAgICAgICAgIF0uam9pbignICcpICsgJztcXG4nO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVBdHRyaWJ1dGVEZWZpbml0aW9uID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLmZyYWdtZW50UHJhZ21hcy5kZWZpbmVbYXR0cmlidXRlSW5uZXJOYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdhdHRyaWJ1dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlUHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUlucHV0TmFtZVxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSArICc7XFxuJztcblxuICAgICAgICAgICAgICAgICAgICBwYWludEF0dHJpYnV0ZXMuZnJhZ21lbnRQcmFnbWFzLmRlZmluZVthdHRyaWJ1dGVJbm5lck5hbWVdID0gYXR0cmlidXRlVmFyeWluZ0RlZmluaXRpb247XG5cbiAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLnZlcnRleFByYWdtYXMuZGVmaW5lW2F0dHJpYnV0ZUlubmVyTmFtZV0gPSBhdHRyaWJ1dGVWYXJ5aW5nRGVmaW5pdGlvbiArIGF0dHJpYnV0ZUF0dHJpYnV0ZURlZmluaXRpb247XG5cbiAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLnZlcnRleFByYWdtYXMuaW5pdGlhbGl6ZVthdHRyaWJ1dGVJbm5lck5hbWVdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlSW5uZXJOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgJz0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlSW5wdXROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgJy8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlLm11bHRpcGxpZXIudG9GaXhlZCgxKVxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSArICc7XFxuJztcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHROYW1lID0gJ3VfJyArIGF0dHJpYnV0ZUlucHV0TmFtZS5zbGljZSgyKSArICdfdCc7XG4gICAgICAgICAgICAgICAgICAgIHZhciB6b29tTGV2ZWxzID0gbGF5ZXIuZ2V0UGFpbnRWYWx1ZVN0b3Bab29tTGV2ZWxzKGF0dHJpYnV0ZS5wYWludFByb3BlcnR5KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQaWNrIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgb2Zmc2V0IHRvIGFkZCB0byB0aGUgYnVmZmVycy5cbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgZm91ciBjbG9zZXN0IHN0b3BzLCBpZGVhbGx5IHdpdGggdHdvIG9uIGVhY2ggc2lkZSBvZiB0aGUgem9vbSBsZXZlbC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bVN0b3BzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG51bVN0b3BzIDwgem9vbUxldmVscy5sZW5ndGggJiYgem9vbUxldmVsc1tudW1TdG9wc10gPCBidWNrZXQuem9vbSkgbnVtU3RvcHMrKztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3BPZmZzZXQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih6b29tTGV2ZWxzLmxlbmd0aCAtIDQsIG51bVN0b3BzIC0gMikpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3VyWm9vbUxldmVscyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IDQ7IHMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91clpvb21MZXZlbHMucHVzaCh6b29tTGV2ZWxzW01hdGgubWluKHN0b3BPZmZzZXQgKyBzLCB6b29tTGV2ZWxzLmxlbmd0aCAtIDEpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVWYXJ5aW5nRGVmaW5pdGlvbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd2YXJ5aW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVJbm5lck5hbWVcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcgJykgKyAnO1xcbic7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLnZlcnRleFByYWdtYXMuZGVmaW5lW2F0dHJpYnV0ZUlubmVyTmFtZV0gPSBhdHRyaWJ1dGVWYXJ5aW5nRGVmaW5pdGlvbiArIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICd1bmlmb3JtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsb3dwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmbG9hdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0TmFtZVxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSArICc7XFxuJztcbiAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLmZyYWdtZW50UHJhZ21hcy5kZWZpbmVbYXR0cmlidXRlSW5uZXJOYW1lXSA9IGF0dHJpYnV0ZVZhcnlpbmdEZWZpbml0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhaW50QXR0cmlidXRlcy51bmlmb3Jtcy5wdXNoKHV0aWwuZXh0ZW5kKHt9LCBhdHRyaWJ1dGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWU6IGNyZWF0ZUdldFVuaWZvcm0oYXR0cmlidXRlLCBzdG9wT2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IDFcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRzID0gYXR0cmlidXRlLmNvbXBvbmVudHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRzID09PSAxKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaW50QXR0cmlidXRlcy5hdHRyaWJ1dGVzLnB1c2godXRpbC5leHRlbmQoe30sIGF0dHJpYnV0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFZhbHVlOiBjcmVhdGVGdW5jdGlvbkdldFZhbHVlKGF0dHJpYnV0ZSwgZm91clpvb21MZXZlbHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50cyAqIDRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLnZlcnRleFByYWdtYXMuZGVmaW5lW2F0dHJpYnV0ZUlubmVyTmFtZV0gKz0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhdHRyaWJ1dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZVByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndmVjNCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlSW5wdXROYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSArICc7XFxuJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLnZlcnRleFByYWdtYXMuaW5pdGlhbGl6ZVthdHRyaWJ1dGVJbm5lck5hbWVdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUlubmVyTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2V2YWx1YXRlX3pvb21fZnVuY3Rpb25fMSgnICsgYXR0cmlidXRlSW5wdXROYW1lICsgJywgJyArIHROYW1lICsgJyknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUubXVsdGlwbGllci50b0ZpeGVkKDEpXG4gICAgICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSArICc7XFxuJztcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlSW5wdXROYW1lcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCA0OyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVJbnB1dE5hbWVzLnB1c2goYXR0cmlidXRlSW5wdXROYW1lICsgayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLmF0dHJpYnV0ZXMucHVzaCh1dGlsLmV4dGVuZCh7fSwgYXR0cmlidXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFZhbHVlOiBjcmVhdGVGdW5jdGlvbkdldFZhbHVlKGF0dHJpYnV0ZSwgW2ZvdXJab29tTGV2ZWxzW2tdXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGF0dHJpYnV0ZUlucHV0TmFtZSArIGtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFpbnRBdHRyaWJ1dGVzLnZlcnRleFByYWdtYXMuZGVmaW5lW2F0dHJpYnV0ZUlubmVyTmFtZV0gKz0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYXR0cmlidXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlUHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVJbnB1dE5hbWUgKyBrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcgJykgKyAnO1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWludEF0dHJpYnV0ZXMudmVydGV4UHJhZ21hcy5pbml0aWFsaXplW2F0dHJpYnV0ZUlubmVyTmFtZV0gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlSW5uZXJOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgPSAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdldmFsdWF0ZV96b29tX2Z1bmN0aW9uXzQoJyArIGF0dHJpYnV0ZUlucHV0TmFtZXMuam9pbignLCAnKSArICcsICcgKyB0TmFtZSArICcpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlLm11bHRpcGxpZXIudG9GaXhlZCgxKVxuICAgICAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcgJykgKyAnO1xcbic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uR2V0VmFsdWUoYXR0cmlidXRlLCBzdG9wWm9vbUxldmVscykge1xuICAgIHJldHVybiBmdW5jdGlvbihsYXllciwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHN0b3Bab29tTGV2ZWxzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIG9uZSBtdWx0aS1jb21wb25lbnQgdmFsdWUgbGlrZSBjb2xvcjBcbiAgICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGUuZ2V0VmFsdWUobGF5ZXIsIHV0aWwuZXh0ZW5kKHt9LCBnbG9iYWxQcm9wZXJ0aWVzLCB7IHpvb206IHN0b3Bab29tTGV2ZWxzWzBdIH0pLCBmZWF0dXJlUHJvcGVydGllcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwYWNrIG11bHRpcGxlIHNpbmdsZS1jb21wb25lbnQgdmFsdWVzIGludG8gYSBmb3VyIGNvbXBvbmVudCBhdHRyaWJ1dGVcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIHogPSAwOyB6IDwgc3RvcFpvb21MZXZlbHMubGVuZ3RoOyB6KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcFpvb21MZXZlbCA9IHN0b3Bab29tTGV2ZWxzW3pdO1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGF0dHJpYnV0ZS5nZXRWYWx1ZShsYXllciwgdXRpbC5leHRlbmQoe30sIGdsb2JhbFByb3BlcnRpZXMsIHsgem9vbTogc3RvcFpvb21MZXZlbCB9KSwgZmVhdHVyZVByb3BlcnRpZXMpWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVHZXRVbmlmb3JtKGF0dHJpYnV0ZSwgc3RvcE9mZnNldCkge1xuICAgIHJldHVybiBmdW5jdGlvbihsYXllciwgZ2xvYmFsUHJvcGVydGllcykge1xuICAgICAgICAvLyBzdG9wSW50ZXJwIGluZGljYXRlcyB3aGljaCBzdG9wcyBuZWVkIHRvIGJlIGludGVycG9sYXRlZC5cbiAgICAgICAgLy8gSWYgc3RvcEludGVycCBpcyAzLjUgdGhlbiBpbnRlcnBvbGF0ZSBoYWxmIHdheSBiZXR3ZWVuIHN0b3BzIDMgYW5kIDQuXG4gICAgICAgIHZhciBzdG9wSW50ZXJwID0gbGF5ZXIuZ2V0UGFpbnRJbnRlcnBvbGF0aW9uVChhdHRyaWJ1dGUucGFpbnRQcm9wZXJ0eSwgZ2xvYmFsUHJvcGVydGllcy56b29tKTtcbiAgICAgICAgLy8gV2UgY2FuIG9ubHkgc3RvcmUgZm91ciBzdG9wIHZhbHVlcyBpbiB0aGUgYnVmZmVycy4gc3RvcE9mZnNldCBpcyB0aGUgbnVtYmVyIG9mIHN0b3BzIHRoYXQgY29tZVxuICAgICAgICAvLyBiZWZvcmUgdGhlIHN0b3BzIHRoYXQgd2VyZSBhZGRlZCB0byB0aGUgYnVmZmVycy5cbiAgICAgICAgcmV0dXJuIFtNYXRoLm1heCgwLCBNYXRoLm1pbig0LCBzdG9wSW50ZXJwIC0gc3RvcE9mZnNldCkpXTtcbiAgICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVja2V0ID0gcmVxdWlyZSgnLi4vYnVja2V0Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xudmFyIGxvYWRHZW9tZXRyeSA9IHJlcXVpcmUoJy4uL2xvYWRfZ2VvbWV0cnknKTtcbnZhciBFWFRFTlQgPSBCdWNrZXQuRVhURU5UO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENpcmNsZUJ1Y2tldDtcblxuLyoqXG4gKiBDaXJjbGVzIGFyZSByZXByZXNlbnRlZCBieSB0d28gdHJpYW5nbGVzLlxuICpcbiAqIEVhY2ggY29ybmVyIGhhcyBhIHBvcyB0aGF0IGlzIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZSBhbmQgYW4gZXh0cnVzaW9uXG4gKiB2ZWN0b3IgdGhhdCBpcyB3aGVyZSBpdCBwb2ludHMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBDaXJjbGVCdWNrZXQoKSB7XG4gICAgQnVja2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbkNpcmNsZUJ1Y2tldC5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoQnVja2V0LCB7fSk7XG5cbkNpcmNsZUJ1Y2tldC5wcm90b3R5cGUuYWRkQ2lyY2xlVmVydGV4ID0gZnVuY3Rpb24obGF5b3V0VmVydGV4QXJyYXksIHgsIHksIGV4dHJ1ZGVYLCBleHRydWRlWSkge1xuICAgIHJldHVybiBsYXlvdXRWZXJ0ZXhBcnJheS5lbXBsYWNlQmFjayhcbiAgICAgICAgICAgICh4ICogMikgKyAoKGV4dHJ1ZGVYICsgMSkgLyAyKSxcbiAgICAgICAgICAgICh5ICogMikgKyAoKGV4dHJ1ZGVZICsgMSkgLyAyKSk7XG59O1xuXG5DaXJjbGVCdWNrZXQucHJvdG90eXBlLnByb2dyYW1JbnRlcmZhY2VzID0ge1xuICAgIGNpcmNsZToge1xuICAgICAgICBsYXlvdXRWZXJ0ZXhBcnJheVR5cGU6IG5ldyBCdWNrZXQuVmVydGV4QXJyYXlUeXBlKFt7XG4gICAgICAgICAgICBuYW1lOiAnYV9wb3MnLFxuICAgICAgICAgICAgY29tcG9uZW50czogMixcbiAgICAgICAgICAgIHR5cGU6ICdJbnQxNidcbiAgICAgICAgfV0pLFxuICAgICAgICBlbGVtZW50QXJyYXlUeXBlOiBuZXcgQnVja2V0LkVsZW1lbnRBcnJheVR5cGUoKSxcblxuICAgICAgICBwYWludEF0dHJpYnV0ZXM6IFt7XG4gICAgICAgICAgICBuYW1lOiAnYV9jb2xvcicsXG4gICAgICAgICAgICBjb21wb25lbnRzOiA0LFxuICAgICAgICAgICAgdHlwZTogJ1VpbnQ4JyxcbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbihsYXllciwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGF5ZXIuZ2V0UGFpbnRWYWx1ZShcImNpcmNsZS1jb2xvclwiLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXVsdGlwbGllcjogMjU1LFxuICAgICAgICAgICAgcGFpbnRQcm9wZXJ0eTogJ2NpcmNsZS1jb2xvcidcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2FfcmFkaXVzJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IDEsXG4gICAgICAgICAgICB0eXBlOiAnVWludDE2JyxcbiAgICAgICAgICAgIGlzTGF5ZXJDb25zdGFudDogZmFsc2UsXG4gICAgICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24obGF5ZXIsIGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsYXllci5nZXRQYWludFZhbHVlKFwiY2lyY2xlLXJhZGl1c1wiLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcyldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11bHRpcGxpZXI6IDEwLFxuICAgICAgICAgICAgcGFpbnRQcm9wZXJ0eTogJ2NpcmNsZS1yYWRpdXMnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdhX2JsdXInLFxuICAgICAgICAgICAgY29tcG9uZW50czogMSxcbiAgICAgICAgICAgIHR5cGU6ICdVaW50MTYnLFxuICAgICAgICAgICAgaXNMYXllckNvbnN0YW50OiBmYWxzZSxcbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbihsYXllciwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2xheWVyLmdldFBhaW50VmFsdWUoXCJjaXJjbGUtYmx1clwiLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcyldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11bHRpcGxpZXI6IDEwLFxuICAgICAgICAgICAgcGFpbnRQcm9wZXJ0eTogJ2NpcmNsZS1ibHVyJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnYV9vcGFjaXR5JyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IDEsXG4gICAgICAgICAgICB0eXBlOiAnVWludDE2JyxcbiAgICAgICAgICAgIGlzTGF5ZXJDb25zdGFudDogZmFsc2UsXG4gICAgICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24obGF5ZXIsIGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsYXllci5nZXRQYWludFZhbHVlKFwiY2lyY2xlLW9wYWNpdHlcIiwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdWx0aXBsaWVyOiAyNTUsXG4gICAgICAgICAgICBwYWludFByb3BlcnR5OiAnY2lyY2xlLW9wYWNpdHknXG4gICAgICAgIH1dXG4gICAgfVxufTtcblxuQ2lyY2xlQnVja2V0LnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgIHZhciBnbG9iYWxQcm9wZXJ0aWVzID0ge3pvb206IHRoaXMuem9vbX07XG4gICAgdmFyIGdlb21ldHJpZXMgPSBsb2FkR2VvbWV0cnkoZmVhdHVyZSk7XG5cbiAgICB2YXIgc3RhcnRHcm91cCA9IHRoaXMucHJlcGFyZUFycmF5R3JvdXAoJ2NpcmNsZScsIDApO1xuICAgIHZhciBzdGFydEluZGV4ID0gc3RhcnRHcm91cC5sYXlvdXRWZXJ0ZXhBcnJheS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdlb21ldHJpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBnZW9tZXRyaWVzW2pdLmxlbmd0aDsgaysrKSB7XG5cbiAgICAgICAgICAgIHZhciB4ID0gZ2VvbWV0cmllc1tqXVtrXS54O1xuICAgICAgICAgICAgdmFyIHkgPSBnZW9tZXRyaWVzW2pdW2tdLnk7XG5cbiAgICAgICAgICAgIC8vIERvIG5vdCBpbmNsdWRlIHBvaW50cyB0aGF0IGFyZSBvdXRzaWRlIHRoZSB0aWxlIGJvdW5kYXJpZXMuXG4gICAgICAgICAgICBpZiAoeCA8IDAgfHwgeCA+PSBFWFRFTlQgfHwgeSA8IDAgfHwgeSA+PSBFWFRFTlQpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyB0aGlzIGdlb21ldHJ5IHdpbGwgYmUgb2YgdGhlIFBvaW50IHR5cGUsIGFuZCB3ZSdsbCBkZXJpdmVcbiAgICAgICAgICAgIC8vIHR3byB0cmlhbmdsZXMgZnJvbSBpdC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgICAgICAgICAgIC8vIOKUgiAzICAgICAyIOKUglxuICAgICAgICAgICAgLy8g4pSCICAgICAgICAg4pSCXG4gICAgICAgICAgICAvLyDilIIgMCAgICAgMSDilIJcbiAgICAgICAgICAgIC8vIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLnByZXBhcmVBcnJheUdyb3VwKCdjaXJjbGUnLCA0KTtcbiAgICAgICAgICAgIHZhciBsYXlvdXRWZXJ0ZXhBcnJheSA9IGdyb3VwLmxheW91dFZlcnRleEFycmF5O1xuXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmFkZENpcmNsZVZlcnRleChsYXlvdXRWZXJ0ZXhBcnJheSwgeCwgeSwgLTEsIC0xKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQ2lyY2xlVmVydGV4KGxheW91dFZlcnRleEFycmF5LCB4LCB5LCAxLCAtMSk7XG4gICAgICAgICAgICB0aGlzLmFkZENpcmNsZVZlcnRleChsYXlvdXRWZXJ0ZXhBcnJheSwgeCwgeSwgMSwgMSk7XG4gICAgICAgICAgICB0aGlzLmFkZENpcmNsZVZlcnRleChsYXlvdXRWZXJ0ZXhBcnJheSwgeCwgeSwgLTEsIDEpO1xuXG4gICAgICAgICAgICBncm91cC5lbGVtZW50QXJyYXkuZW1wbGFjZUJhY2soaW5kZXgsIGluZGV4ICsgMSwgaW5kZXggKyAyKTtcbiAgICAgICAgICAgIGdyb3VwLmVsZW1lbnRBcnJheS5lbXBsYWNlQmFjayhpbmRleCwgaW5kZXggKyAzLCBpbmRleCArIDIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wb3B1bGF0ZVBhaW50QXJyYXlzKCdjaXJjbGUnLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlLnByb3BlcnRpZXMsIHN0YXJ0R3JvdXAsIHN0YXJ0SW5kZXgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1Y2tldCA9IHJlcXVpcmUoJy4uL2J1Y2tldCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcbnZhciBsb2FkR2VvbWV0cnkgPSByZXF1aXJlKCcuLi9sb2FkX2dlb21ldHJ5Jyk7XG52YXIgZWFyY3V0ID0gcmVxdWlyZSgnZWFyY3V0Jyk7XG52YXIgY2xhc3NpZnlSaW5ncyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvY2xhc3NpZnlfcmluZ3MnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG52YXIgRUFSQ1VUX01BWF9SSU5HUyA9IDUwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBFeHRydXNpb25CdWNrZXQ7XG5cbmZ1bmN0aW9uIEV4dHJ1c2lvbkJ1Y2tldCgpIHtcbiAgICBCdWNrZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuRXh0cnVzaW9uQnVja2V0LnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChCdWNrZXQsIHt9KTtcblxuXG5FeHRydXNpb25CdWNrZXQucHJvdG90eXBlLmFkZEV4dHJ1c2lvblZlcnRleCA9IGZ1bmN0aW9uKHZlcnRleEJ1ZmZlciwgeCwgeSxoLCBueCwgbnksIG56LCB0LCBlKSB7XG4gICAgdmFyIGZhY3RvciA9IE1hdGgucG93KDIsIDEzKTtcblxuICAgIHJldHVybiB2ZXJ0ZXhCdWZmZXIuZW1wbGFjZUJhY2soXG4gICAgICAgICAgICAvLyBhX3Bvc1xuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICBoLFxuICAgICAgICAgICAgLy8gYV9ub3JtYWxcbiAgICAgICAgICAgIE1hdGguZmxvb3IobnggKiBmYWN0b3IpICogMiArIHQsXG4gICAgICAgICAgICBueSAqIGZhY3RvciAqIDIsXG4gICAgICAgICAgICBueiAqIGZhY3RvciAqIDIsXG5cbiAgICAgICAgICAgIC8vIGFfZWRnZWRpc3RhbmNlXG4gICAgICAgICAgICBlXG4gICAgICAgICAgICApO1xufTtcblxuRXh0cnVzaW9uQnVja2V0LnByb3RvdHlwZS5wcm9ncmFtSW50ZXJmYWNlcyA9IHtcbiAgICBleHRydXNpb246IHtcbiAgICAgICAgbGF5b3V0VmVydGV4QXJyYXlUeXBlOiBuZXcgQnVja2V0LlZlcnRleEFycmF5VHlwZShbe1xuICAgICAgICAgICAgbmFtZTogJ2FfcG9zJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IDMsXG4gICAgICAgICAgICB0eXBlOiAnSW50MTYnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdhX25vcm1hbCcsXG4gICAgICAgICAgICBjb21wb25lbnRzOiAzLFxuICAgICAgICAgICAgdHlwZTogJ0ludDE2J1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnYV9lZGdlZGlzdGFuY2UnLFxuICAgICAgICAgICAgY29tcG9uZW50czogMSxcbiAgICAgICAgICAgIHR5cGU6ICdJbnQxNidcbiAgICAgICAgfV0pLFxuICAgICAgICBlbGVtZW50QXJyYXlUeXBlOiBuZXcgQnVja2V0LkVsZW1lbnRBcnJheVR5cGUoMyksXG4gICAgICAgIGVsZW1lbnRBcnJheVR5cGUyOiBuZXcgQnVja2V0LkVsZW1lbnRBcnJheVR5cGUoMiksXG5cbiAgICAgICAgcGFpbnRBdHRyaWJ1dGVzOiBbe1xuICAgICAgICAgICAgbmFtZTogJ2FfbWluSCcsXG4gICAgICAgICAgICBjb21wb25lbnRzOiAxLFxuICAgICAgICAgICAgdHlwZTogJ1VpbnQxNicsXG4gICAgICAgICAgICBpc0xheWVyQ29uc3RhbnQ6IGZhbHNlLCAvLyB3aGF0IGlzIHRoaXNcbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbihsYXllciwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2xheWVyLmdldFBhaW50VmFsdWUoXCJleHRydXNpb24tbWluLWhlaWdodFwiLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcyldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11bHRpcGxpZXI6IDEsXG4gICAgICAgICAgICBwYWludFByb3BlcnR5OiAnZXh0cnVzaW9uLW1pbi1oZWlnaHQnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdhX21heEgnLFxuICAgICAgICAgICAgY29tcG9uZW50czogMSxcbiAgICAgICAgICAgIHR5cGU6ICdVaW50MTYnLFxuICAgICAgICAgICAgaXNMYXllckNvbnN0YW50OiBmYWxzZSwgLy8gd2hhdCBpcyB0aGlzXG4gICAgICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24obGF5ZXIsIGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsYXllci5nZXRQYWludFZhbHVlKFwiZXh0cnVzaW9uLWhlaWdodFwiLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcyldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11bHRpcGxpZXI6IDEsXG4gICAgICAgICAgICBwYWludFByb3BlcnR5OiAnZXh0cnVzaW9uLWhlaWdodCdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2FfY29sb3InLFxuICAgICAgICAgICAgY29tcG9uZW50czogNCxcbiAgICAgICAgICAgIHR5cGU6ICdVaW50OCcsXG4gICAgICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24obGF5ZXIsIGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxheWVyLmdldFBhaW50VmFsdWUoXCJleHRydXNpb24tY29sb3JcIiwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11bHRpcGxpZXI6IDI1NSxcbiAgICAgICAgICAgIHBhaW50UHJvcGVydHk6ICdleHRydXNpb24tY29sb3InXG4gICAgICAgIH1dXG4gICAgfVxufTtcblxuRXh0cnVzaW9uQnVja2V0LnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgIHZhciBsaW5lcyA9IGxvYWRHZW9tZXRyeShmZWF0dXJlKTtcbiAgICB2YXIgcG9seWdvbnMgPSBjb252ZXJ0Q29vcmRzKGNsYXNzaWZ5UmluZ3MobGluZXMsIEVBUkNVVF9NQVhfUklOR1MpKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRkUG9seWdvbihwb2x5Z29uc1tpXSwgZmVhdHVyZSk7XG4gICAgfVxufTtcblxuRXh0cnVzaW9uQnVja2V0LnByb3RvdHlwZS5hZGRQb2x5Z29uID0gZnVuY3Rpb24ocG9seWdvbiwgZmVhdHVyZSkge1xuICAgIHZhciBudW1WZXJ0aWNlcyA9IDA7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBwb2x5Z29uLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIG51bVZlcnRpY2VzICs9IHBvbHlnb25ba10ubGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBncm91cCA9IHRoaXMucHJlcGFyZUFycmF5R3JvdXAoJ2V4dHJ1c2lvbicsIG51bVZlcnRpY2VzKTtcbiAgICB2YXIgZmxhdHRlbmVkID0gW107XG4gICAgdmFyIGhvbGVJbmRpY2VzID0gW107XG4gICAgdmFyIHN0YXJ0SW5kZXggPSBncm91cC5sYXlvdXRWZXJ0ZXhBcnJheS5sZW5ndGg7XG5cbiAgICB2YXIgaCA9IGZlYXR1cmUucHJvcGVydGllcy5sZXZlbHM/ZmVhdHVyZS5wcm9wZXJ0aWVzLmxldmVscyozOi0xLjA7XG5cbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgciA9IDA7IHIgPCBwb2x5Z29uLmxlbmd0aDsgcisrKSB7XG4gICAgICAgIHZhciByaW5nID0gcG9seWdvbltyXTtcblxuICAgICAgICBpZiAociA+IDApIGhvbGVJbmRpY2VzLnB1c2goZmxhdHRlbmVkLmxlbmd0aCAvIDIpO1xuXG4gICAgICAgIC8vIGFkZCB2ZXJ0aWNlcyBmcm9tIHRoZSByb29mXG4gICAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwgcmluZy5sZW5ndGg7IHYrKykge1xuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHJpbmdbdl07XG5cbiAgICAgICAgICAgIHZhciB0b3BJbmRleCA9IHRoaXMuYWRkRXh0cnVzaW9uVmVydGV4KGdyb3VwLmxheW91dFZlcnRleEFycmF5LCB2ZXJ0ZXhbMF0sIHZlcnRleFsxXSwgaCwgMCwgMCwgMSwgMSwgMCk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godG9wSW5kZXgpO1xuXG4gICAgICAgICAgICBpZiAodiA+PSAxKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAuZWxlbWVudEFycmF5Mi5lbXBsYWNlQmFjayh0b3BJbmRleC0xLCB0b3BJbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdG8gZm9ybWF0IHVzZWQgYnkgZWFyY3V0XG4gICAgICAgICAgICBmbGF0dGVuZWQucHVzaCh2ZXJ0ZXhbMF0pO1xuICAgICAgICAgICAgZmxhdHRlbmVkLnB1c2godmVydGV4WzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlZGdlRGlzdGFuY2UgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgcmluZy5sZW5ndGggLSAxOyBzKyspIHtcbiAgICAgICAgICAgIHZhciB2MSA9IHJpbmdbc107XG4gICAgICAgICAgICB2YXIgdjIgPSByaW5nW3MgKyAxXTtcbiAgICAgICAgICAgIHZhciBwZXJwID0gUG9pbnQuY29udmVydCh2MikuX3N1YihQb2ludC5jb252ZXJ0KHYxKSkuX3BlcnAoKS5fdW5pdCgpO1xuXG4gICAgICAgICAgICB2YXIgdmVydGV4QXJyYXkgPSBncm91cC5sYXlvdXRWZXJ0ZXhBcnJheTtcbiAgICAgICAgICAgIHZhciB3SW5kZXggPSB0aGlzLmFkZEV4dHJ1c2lvblZlcnRleCh2ZXJ0ZXhBcnJheSwgdjFbMF0sIHYxWzFdLCAwLCBwZXJwLngsIHBlcnAueSwgMCwgMCwgZWRnZURpc3RhbmNlKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRXh0cnVzaW9uVmVydGV4KHZlcnRleEFycmF5LCB2MVswXSwgdjFbMV0sIGgsIHBlcnAueCwgcGVycC55LCAwLCAxLCBlZGdlRGlzdGFuY2UpO1xuXG4gICAgICAgICAgICBlZGdlRGlzdGFuY2UgKz0gUG9pbnQuY29udmVydCh2MikuZGlzdChQb2ludC5jb252ZXJ0KHYxKSk7XG5cbiAgICAgICAgICAgIHRoaXMuYWRkRXh0cnVzaW9uVmVydGV4KHZlcnRleEFycmF5LCB2MlswXSwgdjJbMV0sIDAsIHBlcnAueCwgcGVycC55LCAwLCAwLCBlZGdlRGlzdGFuY2UpO1xuICAgICAgICAgICAgdGhpcy5hZGRFeHRydXNpb25WZXJ0ZXgodmVydGV4QXJyYXksIHYyWzBdLCB2MlsxXSwgaCwgcGVycC54LCBwZXJwLnksIDAsIDEsIGVkZ2VEaXN0YW5jZSk7XG5cbiAgICAgICAgICAgIGdyb3VwLmVsZW1lbnRBcnJheS5lbXBsYWNlQmFjayh3SW5kZXgsIHdJbmRleCArIDEsIHdJbmRleCArIDIpO1xuICAgICAgICAgICAgZ3JvdXAuZWxlbWVudEFycmF5LmVtcGxhY2VCYWNrKHdJbmRleCArIDEsIHdJbmRleCArIDIsIHdJbmRleCArIDMpO1xuXG4gICAgICAgICAgICBncm91cC5lbGVtZW50QXJyYXkyLmVtcGxhY2VCYWNrKHdJbmRleCwgd0luZGV4ICsgMSk7XG4gICAgICAgICAgICBncm91cC5lbGVtZW50QXJyYXkyLmVtcGxhY2VCYWNrKHdJbmRleCArIDIsIHdJbmRleCArIDMpO1xuICAgICAgICAgICAgZ3JvdXAuZWxlbWVudEFycmF5Mi5lbXBsYWNlQmFjayh3SW5kZXgsIHdJbmRleCArIDIpO1xuICAgICAgICAgICAgZ3JvdXAuZWxlbWVudEFycmF5Mi5lbXBsYWNlQmFjayh3SW5kZXggKyAxLCB3SW5kZXggKyAzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cmlhbmdsZUluZGljZXMgPSBlYXJjdXQoZmxhdHRlbmVkLCBob2xlSW5kaWNlcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyaWFuZ2xlSW5kaWNlcy5sZW5ndGggLSAyOyBpICs9IDMpIHtcbiAgICAgICAgZ3JvdXAuZWxlbWVudEFycmF5LmVtcGxhY2VCYWNrKGluZGljZXNbdHJpYW5nbGVJbmRpY2VzW2ldXSxcbiAgICAgICAgICAgIGluZGljZXNbdHJpYW5nbGVJbmRpY2VzW2krMV1dLFxuICAgICAgICAgICAgaW5kaWNlc1t0cmlhbmdsZUluZGljZXNbaSsyXV0pO1xuICAgIH1cblxuICAgIHRoaXMucG9wdWxhdGVQYWludEFycmF5cygnZXh0cnVzaW9uJywge3pvb206IHRoaXMuem9vbX0sIGZlYXR1cmUucHJvcGVydGllcywgZ3JvdXAsIHN0YXJ0SW5kZXgpO1xufTtcblxuZnVuY3Rpb24gY29udmVydENvb3JkcyhyaW5ncykge1xuICAgIGlmIChyaW5ncyBpbnN0YW5jZW9mIFBvaW50KSByZXR1cm4gW3JpbmdzLngsIHJpbmdzLnldO1xuICAgIHJldHVybiByaW5ncy5tYXAoY29udmVydENvb3Jkcyk7XG59XG5cbmZ1bmN0aW9uIGlzQm91bmRhcnlFZGdlKHYxLCB2Mikge1xuICAgIHJldHVybiB2MS5zb21lKGZ1bmN0aW9uKGEsIGkpIHsgcmV0dXJuIChhID09PSAwIC0gNjQgfHwgYSA9PT0gQnVja2V0LkVYVEVOVCArIDY0KSAmJiB2MltpXSA9PT0gYTsgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCdWNrZXQgPSByZXF1aXJlKCcuLi9idWNrZXQnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgbG9hZEdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vbG9hZF9nZW9tZXRyeScpO1xudmFyIGVhcmN1dCA9IHJlcXVpcmUoJ2VhcmN1dCcpO1xudmFyIGNsYXNzaWZ5UmluZ3MgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NsYXNzaWZ5X3JpbmdzJyk7XG52YXIgRUFSQ1VUX01BWF9SSU5HUyA9IDUwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWxsQnVja2V0O1xuXG5mdW5jdGlvbiBGaWxsQnVja2V0KCkge1xuICAgIEJ1Y2tldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5GaWxsQnVja2V0LnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChCdWNrZXQsIHt9KTtcblxuRmlsbEJ1Y2tldC5wcm90b3R5cGUucHJvZ3JhbUludGVyZmFjZXMgPSB7XG4gICAgZmlsbDoge1xuICAgICAgICBsYXlvdXRWZXJ0ZXhBcnJheVR5cGU6IG5ldyBCdWNrZXQuVmVydGV4QXJyYXlUeXBlKFt7XG4gICAgICAgICAgICBuYW1lOiAnYV9wb3MnLFxuICAgICAgICAgICAgY29tcG9uZW50czogMixcbiAgICAgICAgICAgIHR5cGU6ICdJbnQxNidcbiAgICAgICAgfV0pLFxuICAgICAgICBlbGVtZW50QXJyYXlUeXBlOiBuZXcgQnVja2V0LkVsZW1lbnRBcnJheVR5cGUoMSksXG4gICAgICAgIGVsZW1lbnRBcnJheVR5cGUyOiBuZXcgQnVja2V0LkVsZW1lbnRBcnJheVR5cGUoMiksXG5cbiAgICAgICAgcGFpbnRBdHRyaWJ1dGVzOiBbe1xuICAgICAgICAgICAgbmFtZTogJ2FfY29sb3InLFxuICAgICAgICAgICAgY29tcG9uZW50czogNCxcbiAgICAgICAgICAgIHR5cGU6ICdVaW50OCcsXG4gICAgICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24obGF5ZXIsIGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxheWVyLmdldFBhaW50VmFsdWUoXCJmaWxsLWNvbG9yXCIsIGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdWx0aXBsaWVyOiAyNTUsXG4gICAgICAgICAgICBwYWludFByb3BlcnR5OiAnZmlsbC1jb2xvcidcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2Ffb3V0bGluZV9jb2xvcicsXG4gICAgICAgICAgICBjb21wb25lbnRzOiA0LFxuICAgICAgICAgICAgdHlwZTogJ1VpbnQ4JyxcbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbihsYXllciwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGF5ZXIuZ2V0UGFpbnRWYWx1ZShcImZpbGwtb3V0bGluZS1jb2xvclwiLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXVsdGlwbGllcjogMjU1LFxuICAgICAgICAgICAgcGFpbnRQcm9wZXJ0eTogJ2ZpbGwtb3V0bGluZS1jb2xvcidcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2Ffb3BhY2l0eScsXG4gICAgICAgICAgICBjb21wb25lbnRzOiAxLFxuICAgICAgICAgICAgdHlwZTogJ1VpbnQ4JyxcbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbihsYXllciwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2xheWVyLmdldFBhaW50VmFsdWUoXCJmaWxsLW9wYWNpdHlcIiwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdWx0aXBsaWVyOiAyNTUsXG4gICAgICAgICAgICBwYWludFByb3BlcnR5OiAnZmlsbC1vcGFjaXR5J1xuICAgICAgICB9XVxuICAgIH1cbn07XG5cbkZpbGxCdWNrZXQucHJvdG90eXBlLmFkZEZlYXR1cmUgPSBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgdmFyIGxpbmVzID0gbG9hZEdlb21ldHJ5KGZlYXR1cmUpO1xuICAgIHZhciBwb2x5Z29ucyA9IGNsYXNzaWZ5UmluZ3MobGluZXMsIEVBUkNVVF9NQVhfUklOR1MpO1xuXG4gICAgdmFyIHN0YXJ0R3JvdXAgPSB0aGlzLnByZXBhcmVBcnJheUdyb3VwKCdmaWxsJywgMCk7XG4gICAgdmFyIHN0YXJ0SW5kZXggPSBzdGFydEdyb3VwLmxheW91dFZlcnRleEFycmF5Lmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hZGRQb2x5Z29uKHBvbHlnb25zW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLnBvcHVsYXRlUGFpbnRBcnJheXMoJ2ZpbGwnLCB7em9vbTogdGhpcy56b29tfSwgZmVhdHVyZS5wcm9wZXJ0aWVzLCBzdGFydEdyb3VwLCBzdGFydEluZGV4KTtcbn07XG5cbkZpbGxCdWNrZXQucHJvdG90eXBlLmFkZFBvbHlnb24gPSBmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgdmFyIG51bVZlcnRpY2VzID0gMDtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHBvbHlnb24ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgbnVtVmVydGljZXMgKz0gcG9seWdvbltrXS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwID0gdGhpcy5wcmVwYXJlQXJyYXlHcm91cCgnZmlsbCcsIG51bVZlcnRpY2VzKTtcbiAgICB2YXIgZmxhdHRlbmVkID0gW107XG4gICAgdmFyIGhvbGVJbmRpY2VzID0gW107XG4gICAgdmFyIHN0YXJ0SW5kZXggPSBncm91cC5sYXlvdXRWZXJ0ZXhBcnJheS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciByID0gMDsgciA8IHBvbHlnb24ubGVuZ3RoOyByKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSBwb2x5Z29uW3JdO1xuXG4gICAgICAgIGlmIChyID4gMCkgaG9sZUluZGljZXMucHVzaChmbGF0dGVuZWQubGVuZ3RoIC8gMik7XG5cbiAgICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCByaW5nLmxlbmd0aDsgdisrKSB7XG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gcmluZ1t2XTtcblxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ3JvdXAubGF5b3V0VmVydGV4QXJyYXkuZW1wbGFjZUJhY2sodmVydGV4LngsIHZlcnRleC55KTtcblxuICAgICAgICAgICAgaWYgKHYgPj0gMSkge1xuICAgICAgICAgICAgICAgIGdyb3VwLmVsZW1lbnRBcnJheTIuZW1wbGFjZUJhY2soaW5kZXggLSAxLCBpbmRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdG8gZm9ybWF0IHVzZWQgYnkgZWFyY3V0XG4gICAgICAgICAgICBmbGF0dGVuZWQucHVzaCh2ZXJ0ZXgueCk7XG4gICAgICAgICAgICBmbGF0dGVuZWQucHVzaCh2ZXJ0ZXgueSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdHJpYW5nbGVJbmRpY2VzID0gZWFyY3V0KGZsYXR0ZW5lZCwgaG9sZUluZGljZXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmlhbmdsZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ3JvdXAuZWxlbWVudEFycmF5LmVtcGxhY2VCYWNrKHRyaWFuZ2xlSW5kaWNlc1tpXSArIHN0YXJ0SW5kZXgpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCdWNrZXQgPSByZXF1aXJlKCcuLi9idWNrZXQnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgbG9hZEdlb21ldHJ5ID0gcmVxdWlyZSgnLi4vbG9hZF9nZW9tZXRyeScpO1xudmFyIEVYVEVOVCA9IEJ1Y2tldC5FWFRFTlQ7XG5cbi8vIE5PVEUgT04gRVhUUlVERSBTQ0FMRTpcbi8vIHNjYWxlIHRoZSBleHRydXNpb24gdmVjdG9yIHNvIHRoYXQgdGhlIG5vcm1hbCBsZW5ndGggaXMgdGhpcyB2YWx1ZS5cbi8vIGNvbnRhaW5zIHRoZSBcInRleHR1cmVcIiBub3JtYWxzICgtMS4uMSkuIHRoaXMgaXMgZGlzdGluY3QgZnJvbSB0aGUgZXh0cnVkZVxuLy8gbm9ybWFscyBmb3IgbGluZSBqb2lucywgYmVjYXVzZSB0aGUgeC12YWx1ZSByZW1haW5zIDAgZm9yIHRoZSB0ZXh0dXJlXG4vLyBub3JtYWwgYXJyYXksIHdoaWxlIHRoZSBleHRydWRlIG5vcm1hbCBhY3R1YWxseSBtb3ZlcyB0aGUgdmVydGV4IHRvIGNyZWF0ZVxuLy8gdGhlIGFjdXRlL2JldmVsbGVkIGxpbmUgam9pbi5cbnZhciBFWFRSVURFX1NDQUxFID0gNjM7XG5cbi8qXG4gKiBTaGFycCBjb3JuZXJzIGNhdXNlIGRhc2hlZCBsaW5lcyB0byB0aWx0IGJlY2F1c2UgdGhlIGRpc3RhbmNlIGFsb25nIHRoZSBsaW5lXG4gKiBpcyB0aGUgc2FtZSBhdCBib3RoIHRoZSBpbm5lciBhbmQgb3V0ZXIgY29ybmVycy4gVG8gaW1wcm92ZSB0aGUgYXBwZWFyYW5jZSBvZlxuICogZGFzaGVkIGxpbmVzIHdlIGFkZCBleHRyYSBwb2ludHMgbmVhciBzaGFycCBjb3JuZXJzIHNvIHRoYXQgYSBzbWFsbGVyIHBhcnRcbiAqIG9mIHRoZSBsaW5lIGlzIHRpbHRlZC5cbiAqXG4gKiBDT1NfSEFMRl9TSEFSUF9DT1JORVIgY29udHJvbHMgaG93IHNoYXJwIGEgY29ybmVyIGhhcyB0byBiZSBmb3IgdXMgdG8gYWRkIGFuXG4gKiBleHRyYSB2ZXJ0ZXguIFRoZSBkZWZhdWx0IGlzIDc1IGRlZ3JlZXMuXG4gKlxuICogVGhlIG5ld2x5IGNyZWF0ZWQgdmVydGljZXMgYXJlIHBsYWNlZCBTSEFSUF9DT1JORVJfT0ZGU0VUIHBpeGVscyBmcm9tIHRoZSBjb3JuZXIuXG4gKi9cbnZhciBDT1NfSEFMRl9TSEFSUF9DT1JORVIgPSBNYXRoLmNvcyg3NSAvIDIgKiAoTWF0aC5QSSAvIDE4MCkpO1xudmFyIFNIQVJQX0NPUk5FUl9PRkZTRVQgPSAxNTtcblxuLy8gVGhlIG51bWJlciBvZiBiaXRzIHRoYXQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbGluZSBkaXN0YW5jZSBpbiB0aGUgYnVmZmVyLlxudmFyIExJTkVfRElTVEFOQ0VfQlVGRkVSX0JJVFMgPSAxNTtcblxuLy8gV2UgZG9uJ3QgaGF2ZSBlbm91Z2ggYml0cyBmb3IgdGhlIGxpbmUgZGlzdGFuY2UgYXMgd2UnZCBsaWtlIHRvIGhhdmUsIHNvXG4vLyB1c2UgdGhpcyB2YWx1ZSB0byBzY2FsZSB0aGUgbGluZSBkaXN0YW5jZSAoaW4gdGlsZSB1bml0cykgZG93biB0byBhIHNtYWxsZXJcbi8vIHZhbHVlLiBUaGlzIGxldHMgdXMgc3RvcmUgbG9uZ2VyIGRpc3RhbmNlcyB3aGlsZSBzYWNyaWZpY2luZyBwcmVjaXNpb24uXG52YXIgTElORV9ESVNUQU5DRV9TQ0FMRSA9IDEgLyAyO1xuXG4vLyBUaGUgbWF4aW11bSBsaW5lIGRpc3RhbmNlLCBpbiB0aWxlIHVuaXRzLCB0aGF0IGZpdHMgaW4gdGhlIGJ1ZmZlci5cbnZhciBNQVhfTElORV9ESVNUQU5DRSA9IE1hdGgucG93KDIsIExJTkVfRElTVEFOQ0VfQlVGRkVSX0JJVFMgLSAxKSAvIExJTkVfRElTVEFOQ0VfU0NBTEU7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lQnVja2V0O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIExpbmVCdWNrZXQoKSB7XG4gICAgQnVja2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbkxpbmVCdWNrZXQucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KEJ1Y2tldCwge30pO1xuXG5MaW5lQnVja2V0LnByb3RvdHlwZS5hZGRMaW5lVmVydGV4ID0gZnVuY3Rpb24obGF5b3V0VmVydGV4QnVmZmVyLCBwb2ludCwgZXh0cnVkZSwgdHgsIHR5LCBkaXIsIGxpbmVzb2Zhcikge1xuICAgIHJldHVybiBsYXlvdXRWZXJ0ZXhCdWZmZXIuZW1wbGFjZUJhY2soXG4gICAgICAgICAgICAvLyBhX3Bvc1xuICAgICAgICAgICAgKHBvaW50LnggPDwgMSkgfCB0eCxcbiAgICAgICAgICAgIChwb2ludC55IDw8IDEpIHwgdHksXG4gICAgICAgICAgICAvLyBhX2RhdGFcbiAgICAgICAgICAgIC8vIGFkZCAxMjggdG8gc3RvcmUgYW4gYnl0ZSBpbiBhbiB1bnNpZ25lZCBieXRlXG4gICAgICAgICAgICBNYXRoLnJvdW5kKEVYVFJVREVfU0NBTEUgKiBleHRydWRlLngpICsgMTI4LFxuICAgICAgICAgICAgTWF0aC5yb3VuZChFWFRSVURFX1NDQUxFICogZXh0cnVkZS55KSArIDEyOCxcbiAgICAgICAgICAgIC8vIEVuY29kZSB0aGUgLTEvMC8xIGRpcmVjdGlvbiB2YWx1ZSBpbnRvIHRoZSBmaXJzdCB0d28gYml0cyBvZiAueiBvZiBhX2RhdGEuXG4gICAgICAgICAgICAvLyBDb21iaW5lIGl0IHdpdGggdGhlIGxvd2VyIDYgYml0cyBvZiBgbGluZXNvZmFyYCAoc2hpZnRlZCBieSAyIGJpdGVzIHRvIG1ha2VcbiAgICAgICAgICAgIC8vIHJvb20gZm9yIHRoZSBkaXJlY3Rpb24gdmFsdWUpLiBUaGUgdXBwZXIgOCBiaXRzIG9mIGBsaW5lc29mYXJgIGFyZSBwbGFjZWQgaW5cbiAgICAgICAgICAgIC8vIHRoZSBgd2AgY29tcG9uZW50LiBgbGluZXNvZmFyYCBpcyBzY2FsZWQgZG93biBieSBgTElORV9ESVNUQU5DRV9TQ0FMRWAgc28gdGhhdFxuICAgICAgICAgICAgLy8gd2UgY2FuIHN0b3JlIGxvbmdlciBkaXN0YW5jZXMgd2hpbGUgc2FjcmlmaWNpbmcgcHJlY2lzaW9uLlxuICAgICAgICAgICAgKChkaXIgPT09IDAgPyAwIDogKGRpciA8IDAgPyAtMSA6IDEpKSArIDEpIHwgKCgobGluZXNvZmFyICogTElORV9ESVNUQU5DRV9TQ0FMRSkgJiAweDNGKSA8PCAyKSxcbiAgICAgICAgICAgIChsaW5lc29mYXIgKiBMSU5FX0RJU1RBTkNFX1NDQUxFKSA+PiA2KTtcbn07XG5cbkxpbmVCdWNrZXQucHJvdG90eXBlLnByb2dyYW1JbnRlcmZhY2VzID0ge1xuICAgIGxpbmU6IHtcbiAgICAgICAgbGF5b3V0VmVydGV4QXJyYXlUeXBlOiBuZXcgQnVja2V0LlZlcnRleEFycmF5VHlwZShbe1xuICAgICAgICAgICAgbmFtZTogJ2FfcG9zJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICAgICAgICB0eXBlOiAnSW50MTYnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdhX2RhdGEnLFxuICAgICAgICAgICAgY29tcG9uZW50czogNCxcbiAgICAgICAgICAgIHR5cGU6ICdVaW50OCdcbiAgICAgICAgfV0pLFxuICAgICAgICBwYWludEF0dHJpYnV0ZXM6IFt7XG4gICAgICAgICAgICBuYW1lOiAnYV9jb2xvcicsXG4gICAgICAgICAgICBjb21wb25lbnRzOiA0LFxuICAgICAgICAgICAgdHlwZTogJ1VpbnQ4JyxcbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbihsYXllciwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGF5ZXIuZ2V0UGFpbnRWYWx1ZShcImxpbmUtY29sb3JcIiwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11bHRpcGxpZXI6IDI1NSxcbiAgICAgICAgICAgIHBhaW50UHJvcGVydHk6ICdsaW5lLWNvbG9yJ1xuICAgICAgICB9XSxcbiAgICAgICAgZWxlbWVudEFycmF5VHlwZTogbmV3IEJ1Y2tldC5FbGVtZW50QXJyYXlUeXBlKClcbiAgICB9XG59O1xuXG5MaW5lQnVja2V0LnByb3RvdHlwZS5hZGRGZWF0dXJlID0gZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgIHZhciBsaW5lcyA9IGxvYWRHZW9tZXRyeShmZWF0dXJlLCBMSU5FX0RJU1RBTkNFX0JVRkZFUl9CSVRTKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRkTGluZShcbiAgICAgICAgICAgIGxpbmVzW2ldLFxuICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgdGhpcy5sYXllci5sYXlvdXRbJ2xpbmUtam9pbiddLFxuICAgICAgICAgICAgdGhpcy5sYXllci5sYXlvdXRbJ2xpbmUtY2FwJ10sXG4gICAgICAgICAgICB0aGlzLmxheWVyLmxheW91dFsnbGluZS1taXRlci1saW1pdCddLFxuICAgICAgICAgICAgdGhpcy5sYXllci5sYXlvdXRbJ2xpbmUtcm91bmQtbGltaXQnXVxuICAgICAgICApO1xuICAgIH1cbn07XG5cbkxpbmVCdWNrZXQucHJvdG90eXBlLmFkZExpbmUgPSBmdW5jdGlvbih2ZXJ0aWNlcywgZmVhdHVyZVByb3BlcnRpZXMsIGpvaW4sIGNhcCwgbWl0ZXJMaW1pdCwgcm91bmRMaW1pdCkge1xuXG4gICAgdmFyIGxlbiA9IHZlcnRpY2VzLmxlbmd0aDtcbiAgICAvLyBJZiB0aGUgbGluZSBoYXMgZHVwbGljYXRlIHZlcnRpY2VzIGF0IHRoZSBlbmQsIGFkanVzdCBsZW5ndGggdG8gcmVtb3ZlIHRoZW0uXG4gICAgd2hpbGUgKGxlbiA+IDIgJiYgdmVydGljZXNbbGVuIC0gMV0uZXF1YWxzKHZlcnRpY2VzW2xlbiAtIDJdKSkge1xuICAgICAgICBsZW4tLTtcbiAgICB9XG5cbiAgICAvLyBhIGxpbmUgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byB2ZXJ0aWNlc1xuICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPCAyKSByZXR1cm47XG5cbiAgICBpZiAoam9pbiA9PT0gJ2JldmVsJykgbWl0ZXJMaW1pdCA9IDEuMDU7XG5cbiAgICB2YXIgc2hhcnBDb3JuZXJPZmZzZXQgPSBTSEFSUF9DT1JORVJfT0ZGU0VUICogKEVYVEVOVCAvICg1MTIgKiB0aGlzLm92ZXJzY2FsaW5nKSk7XG5cbiAgICB2YXIgZmlyc3RWZXJ0ZXggPSB2ZXJ0aWNlc1swXSxcbiAgICAgICAgbGFzdFZlcnRleCA9IHZlcnRpY2VzW2xlbiAtIDFdLFxuICAgICAgICBjbG9zZWQgPSBmaXJzdFZlcnRleC5lcXVhbHMobGFzdFZlcnRleCk7XG5cbiAgICAvLyB3ZSBjb3VsZCBiZSBtb3JlIHByZWNpc2UsIGJ1dCBpdCB3b3VsZCBvbmx5IHNhdmUgYSBuZWdsaWdpYmxlIGFtb3VudCBvZiBzcGFjZVxuICAgIHZhciBncm91cCA9IHRoaXMucHJlcGFyZUFycmF5R3JvdXAoJ2xpbmUnLCBsZW4gKiAxMCk7XG4gICAgdmFyIHN0YXJ0SW5kZXggPSBncm91cC5sYXlvdXRWZXJ0ZXhBcnJheS5sZW5ndGg7XG5cbiAgICAvLyBhIGxpbmUgbWF5IG5vdCBoYXZlIGNvaW5jaWRlbnQgcG9pbnRzXG4gICAgaWYgKGxlbiA9PT0gMiAmJiBjbG9zZWQpIHJldHVybjtcblxuICAgIHRoaXMuZGlzdGFuY2UgPSAwO1xuXG4gICAgdmFyIGJlZ2luQ2FwID0gY2FwLFxuICAgICAgICBlbmRDYXAgPSBjbG9zZWQgPyAnYnV0dCcgOiBjYXAsXG4gICAgICAgIHN0YXJ0T2ZMaW5lID0gdHJ1ZSxcbiAgICAgICAgY3VycmVudFZlcnRleCwgcHJldlZlcnRleCwgbmV4dFZlcnRleCwgcHJldk5vcm1hbCwgbmV4dE5vcm1hbCwgb2Zmc2V0QSwgb2Zmc2V0QjtcblxuICAgIC8vIHRoZSBsYXN0IHRocmVlIHZlcnRpY2VzIGFkZGVkXG4gICAgdGhpcy5lMSA9IHRoaXMuZTIgPSB0aGlzLmUzID0gLTE7XG5cbiAgICBpZiAoY2xvc2VkKSB7XG4gICAgICAgIGN1cnJlbnRWZXJ0ZXggPSB2ZXJ0aWNlc1tsZW4gLSAyXTtcbiAgICAgICAgbmV4dE5vcm1hbCA9IGZpcnN0VmVydGV4LnN1YihjdXJyZW50VmVydGV4KS5fdW5pdCgpLl9wZXJwKCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgIG5leHRWZXJ0ZXggPSBjbG9zZWQgJiYgaSA9PT0gbGVuIC0gMSA/XG4gICAgICAgICAgICB2ZXJ0aWNlc1sxXSA6IC8vIGlmIHRoZSBsaW5lIGlzIGNsb3NlZCwgd2UgdHJlYXQgdGhlIGxhc3QgdmVydGV4IGxpa2UgdGhlIGZpcnN0XG4gICAgICAgICAgICB2ZXJ0aWNlc1tpICsgMV07IC8vIGp1c3QgdGhlIG5leHQgdmVydGV4XG5cbiAgICAgICAgLy8gaWYgdHdvIGNvbnNlY3V0aXZlIHZlcnRpY2VzIGV4aXN0LCBza2lwIHRoZSBjdXJyZW50IG9uZVxuICAgICAgICBpZiAobmV4dFZlcnRleCAmJiB2ZXJ0aWNlc1tpXS5lcXVhbHMobmV4dFZlcnRleCkpIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmIChuZXh0Tm9ybWFsKSBwcmV2Tm9ybWFsID0gbmV4dE5vcm1hbDtcbiAgICAgICAgaWYgKGN1cnJlbnRWZXJ0ZXgpIHByZXZWZXJ0ZXggPSBjdXJyZW50VmVydGV4O1xuXG4gICAgICAgIGN1cnJlbnRWZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG5vcm1hbCB0b3dhcmRzIHRoZSBuZXh0IHZlcnRleCBpbiB0aGlzIGxpbmUuIEluIGNhc2VcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gbmV4dCB2ZXJ0ZXgsIHByZXRlbmQgdGhhdCB0aGUgbGluZSBpcyBjb250aW51aW5nIHN0cmFpZ2h0LFxuICAgICAgICAvLyBtZWFuaW5nIHRoYXQgd2UgYXJlIGp1c3QgdXNpbmcgdGhlIHByZXZpb3VzIG5vcm1hbC5cbiAgICAgICAgbmV4dE5vcm1hbCA9IG5leHRWZXJ0ZXggPyBuZXh0VmVydGV4LnN1YihjdXJyZW50VmVydGV4KS5fdW5pdCgpLl9wZXJwKCkgOiBwcmV2Tm9ybWFsO1xuXG4gICAgICAgIC8vIElmIHdlIHN0aWxsIGRvbid0IGhhdmUgYSBwcmV2aW91cyBub3JtYWwsIHRoaXMgaXMgdGhlIGJlZ2lubmluZyBvZiBhXG4gICAgICAgIC8vIG5vbi1jbG9zZWQgbGluZSwgc28gd2UncmUgZG9pbmcgYSBzdHJhaWdodCBcImpvaW5cIi5cbiAgICAgICAgcHJldk5vcm1hbCA9IHByZXZOb3JtYWwgfHwgbmV4dE5vcm1hbDtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIG5vcm1hbCBvZiB0aGUgam9pbiBleHRydXNpb24uIEl0IGlzIHRoZSBhbmdsZSBiaXNlY3RvclxuICAgICAgICAvLyBvZiB0aGUgc2VnbWVudHMgYmV0d2VlbiB0aGUgcHJldmlvdXMgbGluZSBhbmQgdGhlIG5leHQgbGluZS5cbiAgICAgICAgdmFyIGpvaW5Ob3JtYWwgPSBwcmV2Tm9ybWFsLmFkZChuZXh0Tm9ybWFsKS5fdW5pdCgpO1xuXG4gICAgICAgIC8qICBqb2luTm9ybWFsICAgICBwcmV2Tm9ybWFsXG4gICAgICAgICAqICAgICAgICAgICAgIOKGliAgICAgIOKGkVxuICAgICAgICAgKiAgICAgICAgICAgICAgICAuX19fX19fX18uIHByZXZWZXJ0ZXhcbiAgICAgICAgICogICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiBuZXh0Tm9ybWFsICDihpAgIHwgIGN1cnJlbnRWZXJ0ZXhcbiAgICAgICAgICogICAgICAgICAgICAgICAgfFxuICAgICAgICAgKiAgICAgbmV4dFZlcnRleCAhXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBtaXRlciAodGhlIHJhdGlvIG9mIHRoZSBtaXRlciB0byB0aGUgd2lkdGgpLlxuICAgICAgICAvLyBGaW5kIHRoZSBjb3NpbmUgb2YgdGhlIGFuZ2xlIGJldHdlZW4gdGhlIG5leHQgYW5kIGpvaW4gbm9ybWFsc1xuICAgICAgICAvLyB1c2luZyBkb3QgcHJvZHVjdC4gVGhlIGludmVyc2Ugb2YgdGhhdCBpcyB0aGUgbWl0ZXIgbGVuZ3RoLlxuICAgICAgICB2YXIgY29zSGFsZkFuZ2xlID0gam9pbk5vcm1hbC54ICogbmV4dE5vcm1hbC54ICsgam9pbk5vcm1hbC55ICogbmV4dE5vcm1hbC55O1xuICAgICAgICB2YXIgbWl0ZXJMZW5ndGggPSAxIC8gY29zSGFsZkFuZ2xlO1xuXG4gICAgICAgIHZhciBpc1NoYXJwQ29ybmVyID0gY29zSGFsZkFuZ2xlIDwgQ09TX0hBTEZfU0hBUlBfQ09STkVSICYmIHByZXZWZXJ0ZXggJiYgbmV4dFZlcnRleDtcblxuICAgICAgICBpZiAoaXNTaGFycENvcm5lciAmJiBpID4gMCkge1xuICAgICAgICAgICAgdmFyIHByZXZTZWdtZW50TGVuZ3RoID0gY3VycmVudFZlcnRleC5kaXN0KHByZXZWZXJ0ZXgpO1xuICAgICAgICAgICAgaWYgKHByZXZTZWdtZW50TGVuZ3RoID4gMiAqIHNoYXJwQ29ybmVyT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ByZXZWZXJ0ZXggPSBjdXJyZW50VmVydGV4LnN1YihjdXJyZW50VmVydGV4LnN1YihwcmV2VmVydGV4KS5fbXVsdChzaGFycENvcm5lck9mZnNldCAvIHByZXZTZWdtZW50TGVuZ3RoKS5fcm91bmQoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSArPSBuZXdQcmV2VmVydGV4LmRpc3QocHJldlZlcnRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KG5ld1ByZXZWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIHByZXZOb3JtYWwubXVsdCgxKSwgMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHByZXZWZXJ0ZXggPSBuZXdQcmV2VmVydGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGpvaW4gaWYgYSBtaWRkbGUgdmVydGV4LCBvdGhlcndpc2UgdGhlIGNhcC5cbiAgICAgICAgdmFyIG1pZGRsZVZlcnRleCA9IHByZXZWZXJ0ZXggJiYgbmV4dFZlcnRleDtcbiAgICAgICAgdmFyIGN1cnJlbnRKb2luID0gbWlkZGxlVmVydGV4ID8gam9pbiA6IG5leHRWZXJ0ZXggPyBiZWdpbkNhcCA6IGVuZENhcDtcblxuICAgICAgICBpZiAobWlkZGxlVmVydGV4ICYmIGN1cnJlbnRKb2luID09PSAncm91bmQnKSB7XG4gICAgICAgICAgICBpZiAobWl0ZXJMZW5ndGggPCByb3VuZExpbWl0KSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEpvaW4gPSAnbWl0ZXInO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtaXRlckxlbmd0aCA8PSAyKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEpvaW4gPSAnZmFrZXJvdW5kJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50Sm9pbiA9PT0gJ21pdGVyJyAmJiBtaXRlckxlbmd0aCA+IG1pdGVyTGltaXQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRKb2luID0gJ2JldmVsJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50Sm9pbiA9PT0gJ2JldmVsJykge1xuICAgICAgICAgICAgLy8gVGhlIG1heGltdW0gZXh0cnVkZSBsZW5ndGggaXMgMTI4IC8gNjMgPSAyIHRpbWVzIHRoZSB3aWR0aCBvZiB0aGUgbGluZVxuICAgICAgICAgICAgLy8gc28gaWYgbWl0ZXJMZW5ndGggPj0gMiB3ZSBuZWVkIHRvIGRyYXcgYSBkaWZmZXJlbnQgdHlwZSBvZiBiZXZlbCB3aGVyZS5cbiAgICAgICAgICAgIGlmIChtaXRlckxlbmd0aCA+IDIpIGN1cnJlbnRKb2luID0gJ2ZsaXBiZXZlbCc7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBtaXRlckxlbmd0aCBpcyByZWFsbHkgc21hbGwgYW5kIHRoZSBsaW5lIGJldmVsIHdvdWxkbid0IGJlIHZpc2libGUsXG4gICAgICAgICAgICAvLyBqdXN0IGRyYXcgYSBtaXRlciBqb2luIHRvIHNhdmUgYSB0cmlhbmdsZS5cbiAgICAgICAgICAgIGlmIChtaXRlckxlbmd0aCA8IG1pdGVyTGltaXQpIGN1cnJlbnRKb2luID0gJ21pdGVyJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBob3cgZmFyIGFsb25nIHRoZSBsaW5lIHRoZSBjdXJyZW50VmVydGV4IGlzXG4gICAgICAgIGlmIChwcmV2VmVydGV4KSB0aGlzLmRpc3RhbmNlICs9IGN1cnJlbnRWZXJ0ZXguZGlzdChwcmV2VmVydGV4KTtcblxuICAgICAgICBpZiAoY3VycmVudEpvaW4gPT09ICdtaXRlcicpIHtcblxuICAgICAgICAgICAgam9pbk5vcm1hbC5fbXVsdChtaXRlckxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgam9pbk5vcm1hbCwgMCwgMCwgZmFsc2UpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEpvaW4gPT09ICdmbGlwYmV2ZWwnKSB7XG4gICAgICAgICAgICAvLyBtaXRlciBpcyB0b28gYmlnLCBmbGlwIHRoZSBkaXJlY3Rpb24gdG8gbWFrZSBhIGJldmVsZWQgam9pblxuXG4gICAgICAgICAgICBpZiAobWl0ZXJMZW5ndGggPiAxMDApIHtcbiAgICAgICAgICAgICAgICAvLyBBbG1vc3QgcGFyYWxsZWwgbGluZXNcbiAgICAgICAgICAgICAgICBqb2luTm9ybWFsID0gbmV4dE5vcm1hbC5jbG9uZSgpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBwcmV2Tm9ybWFsLnggKiBuZXh0Tm9ybWFsLnkgLSBwcmV2Tm9ybWFsLnkgKiBuZXh0Tm9ybWFsLnggPiAwID8gLTEgOiAxO1xuICAgICAgICAgICAgICAgIHZhciBiZXZlbExlbmd0aCA9IG1pdGVyTGVuZ3RoICogcHJldk5vcm1hbC5hZGQobmV4dE5vcm1hbCkubWFnKCkgLyBwcmV2Tm9ybWFsLnN1YihuZXh0Tm9ybWFsKS5tYWcoKTtcbiAgICAgICAgICAgICAgICBqb2luTm9ybWFsLl9wZXJwKCkuX211bHQoYmV2ZWxMZW5ndGggKiBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIGpvaW5Ob3JtYWwsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBqb2luTm9ybWFsLm11bHQoLTEpLCAwLCAwLCBmYWxzZSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Sm9pbiA9PT0gJ2JldmVsJyB8fCBjdXJyZW50Sm9pbiA9PT0gJ2Zha2Vyb3VuZCcpIHtcbiAgICAgICAgICAgIHZhciBsaW5lVHVybnNMZWZ0ID0gKHByZXZOb3JtYWwueCAqIG5leHROb3JtYWwueSAtIHByZXZOb3JtYWwueSAqIG5leHROb3JtYWwueCkgPiAwO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IC1NYXRoLnNxcnQobWl0ZXJMZW5ndGggKiBtaXRlckxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgaWYgKGxpbmVUdXJuc0xlZnQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRCID0gMDtcbiAgICAgICAgICAgICAgICBvZmZzZXRBID0gb2Zmc2V0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRBID0gMDtcbiAgICAgICAgICAgICAgICBvZmZzZXRCID0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDbG9zZSBwcmV2aW91cyBzZWdtZW50IHdpdGggYSBiZXZlbFxuICAgICAgICAgICAgaWYgKCFzdGFydE9mTGluZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBwcmV2Tm9ybWFsLCBvZmZzZXRBLCBvZmZzZXRCLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50Sm9pbiA9PT0gJ2Zha2Vyb3VuZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgam9pbiBhbmdsZSBpcyBzaGFycCBlbm91Z2ggdGhhdCBhIHJvdW5kIGpvaW4gd291bGQgYmUgdmlzaWJsZS5cbiAgICAgICAgICAgICAgICAvLyBCZXZlbCBqb2lucyBmaWxsIHRoZSBnYXAgYmV0d2VlbiBzZWdtZW50cyB3aXRoIGEgc2luZ2xlIHBpZSBzbGljZSB0cmlhbmdsZS5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSByb3VuZCBqb2luIGJ5IGFkZGluZyBtdWx0aXBsZSBwaWUgc2xpY2VzLiBUaGUgam9pbiBpc24ndCBhY3R1YWxseSByb3VuZCwgYnV0XG4gICAgICAgICAgICAgICAgLy8gaXQgbG9va3MgbGlrZSBpdCBpcyBhdCB0aGUgc2l6ZXMgd2UgcmVuZGVyIGxpbmVzIGF0LlxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIG1vcmUgdHJpYW5nbGVzIGZvciBzaGFycGVyIGFuZ2xlcy5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIG1hdGggaXMganVzdCBhIGdvb2QgZW5vdWdoIGFwcHJveGltYXRpb24uIEl0IGlzbid0IFwiY29ycmVjdFwiLlxuICAgICAgICAgICAgICAgIHZhciBuID0gTWF0aC5mbG9vcigoMC41IC0gKGNvc0hhbGZBbmdsZSAtIDAuNSkpICogOCk7XG4gICAgICAgICAgICAgICAgdmFyIGFwcHJveEZyYWN0aW9uYWxKb2luTm9ybWFsO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBuOyBtKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwcm94RnJhY3Rpb25hbEpvaW5Ob3JtYWwgPSBuZXh0Tm9ybWFsLm11bHQoKG0gKyAxKSAvIChuICsgMSkpLl9hZGQocHJldk5vcm1hbCkuX3VuaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRQaWVTbGljZVZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBhcHByb3hGcmFjdGlvbmFsSm9pbk5vcm1hbCwgbGluZVR1cm5zTGVmdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRQaWVTbGljZVZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBqb2luTm9ybWFsLCBsaW5lVHVybnNMZWZ0KTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSBuIC0gMTsgayA+PSAwOyBrLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwcm94RnJhY3Rpb25hbEpvaW5Ob3JtYWwgPSBwcmV2Tm9ybWFsLm11bHQoKGsgKyAxKSAvIChuICsgMSkpLl9hZGQobmV4dE5vcm1hbCkuX3VuaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRQaWVTbGljZVZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBhcHByb3hGcmFjdGlvbmFsSm9pbk5vcm1hbCwgbGluZVR1cm5zTGVmdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdGFydCBuZXh0IHNlZ21lbnRcbiAgICAgICAgICAgIGlmIChuZXh0VmVydGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIG5leHROb3JtYWwsIC1vZmZzZXRBLCAtb2Zmc2V0QiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEpvaW4gPT09ICdidXR0Jykge1xuICAgICAgICAgICAgaWYgKCFzdGFydE9mTGluZSkge1xuICAgICAgICAgICAgICAgIC8vIENsb3NlIHByZXZpb3VzIHNlZ21lbnQgd2l0aCBhIGJ1dHRcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgcHJldk5vcm1hbCwgMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdGFydCBuZXh0IHNlZ21lbnQgd2l0aCBhIGJ1dHRcbiAgICAgICAgICAgIGlmIChuZXh0VmVydGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIG5leHROb3JtYWwsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRKb2luID09PSAnc3F1YXJlJykge1xuXG4gICAgICAgICAgICBpZiAoIXN0YXJ0T2ZMaW5lKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xvc2UgcHJldmlvdXMgc2VnbWVudCB3aXRoIGEgc3F1YXJlIGNhcFxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBwcmV2Tm9ybWFsLCAxLCAxLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgc2VnbWVudCBpcyBkb25lLiBVbnNldCB2ZXJ0aWNlcyB0byBkaXNjb25uZWN0IHNlZ21lbnRzLlxuICAgICAgICAgICAgICAgIHRoaXMuZTEgPSB0aGlzLmUyID0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IG5leHQgc2VnbWVudFxuICAgICAgICAgICAgaWYgKG5leHRWZXJ0ZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgbmV4dE5vcm1hbCwgLTEsIC0xLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Sm9pbiA9PT0gJ3JvdW5kJykge1xuXG4gICAgICAgICAgICBpZiAoIXN0YXJ0T2ZMaW5lKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xvc2UgcHJldmlvdXMgc2VnbWVudCB3aXRoIGJ1dHRcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgcHJldk5vcm1hbCwgMCwgMCwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJvdW5kIGNhcCBvciBsaW5lam9pbiBhdCBlbmQgb2Ygc2VnbWVudFxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBwcmV2Tm9ybWFsLCAxLCAxLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIC8vIFRoZSBzZWdtZW50IGlzIGRvbmUuIFVuc2V0IHZlcnRpY2VzIHRvIGRpc2Nvbm5lY3Qgc2VnbWVudHMuXG4gICAgICAgICAgICAgICAgdGhpcy5lMSA9IHRoaXMuZTIgPSAtMTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAvLyBTdGFydCBuZXh0IHNlZ21lbnQgd2l0aCBhIGJ1dHRcbiAgICAgICAgICAgIGlmIChuZXh0VmVydGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHJvdW5kIGNhcCBiZWZvcmUgZmlyc3Qgc2VnbWVudFxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3VycmVudFZlcnRleChjdXJyZW50VmVydGV4LCB0aGlzLmRpc3RhbmNlLCBuZXh0Tm9ybWFsLCAtMSwgLTEsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDdXJyZW50VmVydGV4KGN1cnJlbnRWZXJ0ZXgsIHRoaXMuZGlzdGFuY2UsIG5leHROb3JtYWwsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1NoYXJwQ29ybmVyICYmIGkgPCBsZW4gLSAxKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFNlZ21lbnRMZW5ndGggPSBjdXJyZW50VmVydGV4LmRpc3QobmV4dFZlcnRleCk7XG4gICAgICAgICAgICBpZiAobmV4dFNlZ21lbnRMZW5ndGggPiAyICogc2hhcnBDb3JuZXJPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q3VycmVudFZlcnRleCA9IGN1cnJlbnRWZXJ0ZXguYWRkKG5leHRWZXJ0ZXguc3ViKGN1cnJlbnRWZXJ0ZXgpLl9tdWx0KHNoYXJwQ29ybmVyT2Zmc2V0IC8gbmV4dFNlZ21lbnRMZW5ndGgpLl9yb3VuZCgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlICs9IG5ld0N1cnJlbnRWZXJ0ZXguZGlzdChjdXJyZW50VmVydGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgobmV3Q3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgbmV4dE5vcm1hbC5tdWx0KDEpLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgY3VycmVudFZlcnRleCA9IG5ld0N1cnJlbnRWZXJ0ZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE9mTGluZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMucG9wdWxhdGVQYWludEFycmF5cyhcbiAgICAgICAgJ2xpbmUnLCB7em9vbTogdGhpcy56b29tfSxcbiAgICAgICAgZmVhdHVyZVByb3BlcnRpZXMsXG4gICAgICAgIGdyb3VwLFxuICAgICAgICBzdGFydEluZGV4XG4gICAgKTtcbn07XG5cbi8qKlxuICogQWRkIHR3byB2ZXJ0aWNlcyB0byB0aGUgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3VycmVudFZlcnRleCB0aGUgbGluZSB2ZXJ0ZXggdG8gYWRkIGJ1ZmZlciB2ZXJ0aWNlcyBmb3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lIHRvIHRoZSB2ZXJ0ZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRMZWZ0IGV4dHJ1ZGUgdG8gc2hpZnQgdGhlIGxlZnQgdmVydGV4IGFsb25nIHRoZSBsaW5lXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kUmlnaHQgZXh0cnVkZSB0byBzaGlmdCB0aGUgbGVmdCB2ZXJ0ZXggYWxvbmcgdGhlIGxpbmVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcm91bmQgd2hldGhlciB0aGlzIGlzIGEgcm91bmQgY2FwXG4gKiBAcHJpdmF0ZVxuICovXG5MaW5lQnVja2V0LnByb3RvdHlwZS5hZGRDdXJyZW50VmVydGV4ID0gZnVuY3Rpb24oY3VycmVudFZlcnRleCwgZGlzdGFuY2UsIG5vcm1hbCwgZW5kTGVmdCwgZW5kUmlnaHQsIHJvdW5kKSB7XG4gICAgdmFyIHR4ID0gcm91bmQgPyAxIDogMDtcbiAgICB2YXIgZXh0cnVkZTtcbiAgICB2YXIgYXJyYXlHcm91cCA9IHRoaXMuYXJyYXlHcm91cHMubGluZVt0aGlzLmFycmF5R3JvdXBzLmxpbmUubGVuZ3RoIC0gMV07XG4gICAgdmFyIGxheW91dFZlcnRleEFycmF5ID0gYXJyYXlHcm91cC5sYXlvdXRWZXJ0ZXhBcnJheTtcbiAgICB2YXIgZWxlbWVudEFycmF5ID0gYXJyYXlHcm91cC5lbGVtZW50QXJyYXk7XG5cbiAgICBleHRydWRlID0gbm9ybWFsLmNsb25lKCk7XG4gICAgaWYgKGVuZExlZnQpIGV4dHJ1ZGUuX3N1Yihub3JtYWwucGVycCgpLl9tdWx0KGVuZExlZnQpKTtcbiAgICB0aGlzLmUzID0gdGhpcy5hZGRMaW5lVmVydGV4KGxheW91dFZlcnRleEFycmF5LCBjdXJyZW50VmVydGV4LCBleHRydWRlLCB0eCwgMCwgZW5kTGVmdCwgZGlzdGFuY2UpO1xuICAgIGlmICh0aGlzLmUxID49IDAgJiYgdGhpcy5lMiA+PSAwKSB7XG4gICAgICAgIGVsZW1lbnRBcnJheS5lbXBsYWNlQmFjayh0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzKTtcbiAgICB9XG4gICAgdGhpcy5lMSA9IHRoaXMuZTI7XG4gICAgdGhpcy5lMiA9IHRoaXMuZTM7XG5cbiAgICBleHRydWRlID0gbm9ybWFsLm11bHQoLTEpO1xuICAgIGlmIChlbmRSaWdodCkgZXh0cnVkZS5fc3ViKG5vcm1hbC5wZXJwKCkuX211bHQoZW5kUmlnaHQpKTtcbiAgICB0aGlzLmUzID0gdGhpcy5hZGRMaW5lVmVydGV4KGxheW91dFZlcnRleEFycmF5LCBjdXJyZW50VmVydGV4LCBleHRydWRlLCB0eCwgMSwgLWVuZFJpZ2h0LCBkaXN0YW5jZSk7XG4gICAgaWYgKHRoaXMuZTEgPj0gMCAmJiB0aGlzLmUyID49IDApIHtcbiAgICAgICAgZWxlbWVudEFycmF5LmVtcGxhY2VCYWNrKHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMpO1xuICAgIH1cbiAgICB0aGlzLmUxID0gdGhpcy5lMjtcbiAgICB0aGlzLmUyID0gdGhpcy5lMztcblxuICAgIC8vIFRoZXJlIGlzIGEgbWF4aW11bSBcImRpc3RhbmNlIGFsb25nIHRoZSBsaW5lXCIgdGhhdCB3ZSBjYW4gc3RvcmUgaW4gdGhlIGJ1ZmZlcnMuXG4gICAgLy8gV2hlbiB3ZSBnZXQgY2xvc2UgdG8gdGhlIGRpc3RhbmNlLCByZXNldCBpdCB0byB6ZXJvIGFuZCBhZGQgdGhlIHZlcnRleCBhZ2FpbiB3aXRoXG4gICAgLy8gYSBkaXN0YW5jZSBvZiB6ZXJvLiBUaGUgbWF4IGRpc3RhbmNlIGlzIGRldGVybWluZWQgYnkgdGhlIG51bWJlciBvZiBiaXRzIHdlIGFsbG9jYXRlXG4gICAgLy8gdG8gYGxpbmVzb2ZhcmAuXG4gICAgaWYgKGRpc3RhbmNlID4gTUFYX0xJTkVfRElTVEFOQ0UgLyAyKSB7XG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLmFkZEN1cnJlbnRWZXJ0ZXgoY3VycmVudFZlcnRleCwgdGhpcy5kaXN0YW5jZSwgbm9ybWFsLCBlbmRMZWZ0LCBlbmRSaWdodCwgcm91bmQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQWRkIGEgc2luZ2xlIG5ldyB2ZXJ0ZXggYW5kIGEgdHJpYW5nbGUgdXNpbmcgdHdvIHByZXZpb3VzIHZlcnRpY2VzLlxuICogVGhpcyBhZGRzIGEgcGllIHNsaWNlIHRyaWFuZ2xlIG5lYXIgYSBqb2luIHRvIHNpbXVsYXRlIHJvdW5kIGpvaW5zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN1cnJlbnRWZXJ0ZXggdGhlIGxpbmUgdmVydGV4IHRvIGFkZCBidWZmZXIgdmVydGljZXMgZm9yXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGJlZ2dpbmluZyBvZiB0aGUgbGluZSB0byB0aGUgdmVydGV4XG4gKiBAcGFyYW0ge09iamVjdH0gZXh0cnVkZSB0aGUgb2Zmc2V0IG9mIHRoZSBuZXcgdmVydGV4IGZyb20gdGhlIGN1cnJlbnRWZXJ0ZXhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gd2hldGhlciB0aGUgbGluZSBpcyB0dXJuaW5nIGxlZnQgb3IgcmlnaHQgYXQgdGhpcyBhbmdsZVxuICogQHByaXZhdGVcbiAqL1xuTGluZUJ1Y2tldC5wcm90b3R5cGUuYWRkUGllU2xpY2VWZXJ0ZXggPSBmdW5jdGlvbihjdXJyZW50VmVydGV4LCBkaXN0YW5jZSwgZXh0cnVkZSwgbGluZVR1cm5zTGVmdCkge1xuICAgIHZhciB0eSA9IGxpbmVUdXJuc0xlZnQgPyAxIDogMDtcbiAgICBleHRydWRlID0gZXh0cnVkZS5tdWx0KGxpbmVUdXJuc0xlZnQgPyAtMSA6IDEpO1xuICAgIHZhciBhcnJheUdyb3VwID0gdGhpcy5hcnJheUdyb3Vwcy5saW5lW3RoaXMuYXJyYXlHcm91cHMubGluZS5sZW5ndGggLSAxXTtcbiAgICB2YXIgbGF5b3V0VmVydGV4QXJyYXkgPSBhcnJheUdyb3VwLmxheW91dFZlcnRleEFycmF5O1xuICAgIHZhciBlbGVtZW50QXJyYXkgPSBhcnJheUdyb3VwLmVsZW1lbnRBcnJheTtcblxuICAgIHRoaXMuZTMgPSB0aGlzLmFkZExpbmVWZXJ0ZXgobGF5b3V0VmVydGV4QXJyYXksIGN1cnJlbnRWZXJ0ZXgsIGV4dHJ1ZGUsIDAsIHR5LCAwLCBkaXN0YW5jZSk7XG5cbiAgICBpZiAodGhpcy5lMSA+PSAwICYmIHRoaXMuZTIgPj0gMCkge1xuICAgICAgICBlbGVtZW50QXJyYXkuZW1wbGFjZUJhY2sodGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMyk7XG4gICAgfVxuXG4gICAgaWYgKGxpbmVUdXJuc0xlZnQpIHtcbiAgICAgICAgdGhpcy5lMiA9IHRoaXMuZTM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lMSA9IHRoaXMuZTM7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxudmFyIEJ1Y2tldCA9IHJlcXVpcmUoJy4uL2J1Y2tldCcpO1xudmFyIEFuY2hvciA9IHJlcXVpcmUoJy4uLy4uL3N5bWJvbC9hbmNob3InKTtcbnZhciBnZXRBbmNob3JzID0gcmVxdWlyZSgnLi4vLi4vc3ltYm9sL2dldF9hbmNob3JzJyk7XG52YXIgcmVzb2x2ZVRva2VucyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdG9rZW4nKTtcbnZhciBRdWFkcyA9IHJlcXVpcmUoJy4uLy4uL3N5bWJvbC9xdWFkcycpO1xudmFyIFNoYXBpbmcgPSByZXF1aXJlKCcuLi8uLi9zeW1ib2wvc2hhcGluZycpO1xudmFyIHJlc29sdmVUZXh0ID0gcmVxdWlyZSgnLi4vLi4vc3ltYm9sL3Jlc29sdmVfdGV4dCcpO1xudmFyIG1lcmdlTGluZXMgPSByZXF1aXJlKCcuLi8uLi9zeW1ib2wvbWVyZ2VsaW5lcycpO1xudmFyIGNsaXBMaW5lID0gcmVxdWlyZSgnLi4vLi4vc3ltYm9sL2NsaXBfbGluZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcbnZhciBsb2FkR2VvbWV0cnkgPSByZXF1aXJlKCcuLi9sb2FkX2dlb21ldHJ5Jyk7XG52YXIgQ29sbGlzaW9uRmVhdHVyZSA9IHJlcXVpcmUoJy4uLy4uL3N5bWJvbC9jb2xsaXNpb25fZmVhdHVyZScpO1xudmFyIGZpbmRQb2xlT2ZJbmFjY2Vzc2liaWxpdHkgPSByZXF1aXJlKCcuLi8uLi91dGlsL2ZpbmRfcG9sZV9vZl9pbmFjY2Vzc2liaWxpdHknKTtcbnZhciBjbGFzc2lmeVJpbmdzID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jbGFzc2lmeV9yaW5ncycpO1xuXG52YXIgc2hhcGVUZXh0ID0gU2hhcGluZy5zaGFwZVRleHQ7XG52YXIgc2hhcGVJY29uID0gU2hhcGluZy5zaGFwZUljb247XG52YXIgZ2V0R2x5cGhRdWFkcyA9IFF1YWRzLmdldEdseXBoUXVhZHM7XG52YXIgZ2V0SWNvblF1YWRzID0gUXVhZHMuZ2V0SWNvblF1YWRzO1xuXG52YXIgRVhURU5UID0gQnVja2V0LkVYVEVOVDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2xCdWNrZXQ7XG5cbmZ1bmN0aW9uIFN5bWJvbEJ1Y2tldChvcHRpb25zKSB7XG4gICAgQnVja2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5zaG93Q29sbGlzaW9uQm94ZXMgPSBvcHRpb25zLnNob3dDb2xsaXNpb25Cb3hlcztcbiAgICB0aGlzLm92ZXJzY2FsaW5nID0gb3B0aW9ucy5vdmVyc2NhbGluZztcbiAgICB0aGlzLmNvbGxpc2lvbkJveEFycmF5ID0gb3B0aW9ucy5jb2xsaXNpb25Cb3hBcnJheTtcbiAgICB0aGlzLnN5bWJvbFF1YWRzQXJyYXkgPSBvcHRpb25zLnN5bWJvbFF1YWRzQXJyYXk7XG4gICAgdGhpcy5zeW1ib2xJbnN0YW5jZXNBcnJheSA9IG9wdGlvbnMuc3ltYm9sSW5zdGFuY2VzQXJyYXk7XG5cbiAgICB0aGlzLnNkZkljb25zID0gb3B0aW9ucy5zZGZJY29ucztcbiAgICB0aGlzLmljb25zTmVlZExpbmVhciA9IG9wdGlvbnMuaWNvbnNOZWVkTGluZWFyO1xuICAgIHRoaXMuYWRqdXN0ZWRUZXh0U2l6ZSA9IG9wdGlvbnMuYWRqdXN0ZWRUZXh0U2l6ZTtcbiAgICB0aGlzLmFkanVzdGVkSWNvblNpemUgPSBvcHRpb25zLmFkanVzdGVkSWNvblNpemU7XG4gICAgdGhpcy5mb250c3RhY2sgPSBvcHRpb25zLmZvbnRzdGFjaztcbn1cblxuLy8gdGhpcyBjb25zdGFudCBpcyBiYXNlZCBvbiB0aGUgc2l6ZSBvZiB0aGUgZ2x5cGhRdWFkRW5kSW5kZXggYW5kIGljb25RdWFkRW5kSW5kZXhcbi8vIGluIHRoZSBzeW1ib2xfaW5zdGFuY2VzIFN0cnVjdEFycmF5VHlwZVxuLy8gZWcgdGhlIG1heCB2YWxpZCBVSW50MTYgaXMgNjUsNTM1XG5TeW1ib2xCdWNrZXQuTUFYX1FVQURTID0gNjU1MzU7XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoQnVja2V0LCB7fSk7XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBCdWNrZXQucHJvdG90eXBlLnNlcmlhbGl6ZS5hcHBseSh0aGlzKTtcbiAgICBzZXJpYWxpemVkLnNkZkljb25zID0gdGhpcy5zZGZJY29ucztcbiAgICBzZXJpYWxpemVkLmljb25zTmVlZExpbmVhciA9IHRoaXMuaWNvbnNOZWVkTGluZWFyO1xuICAgIHNlcmlhbGl6ZWQuYWRqdXN0ZWRUZXh0U2l6ZSA9IHRoaXMuYWRqdXN0ZWRUZXh0U2l6ZTtcbiAgICBzZXJpYWxpemVkLmFkanVzdGVkSWNvblNpemUgPSB0aGlzLmFkanVzdGVkSWNvblNpemU7XG4gICAgc2VyaWFsaXplZC5mb250c3RhY2sgPSB0aGlzLmZvbnRzdGFjaztcbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbn07XG5cbnZhciBsYXlvdXRWZXJ0ZXhBcnJheVR5cGUgPSBuZXcgQnVja2V0LlZlcnRleEFycmF5VHlwZShbe1xuICAgIG5hbWU6ICdhX3BvcycsXG4gICAgY29tcG9uZW50czogMixcbiAgICB0eXBlOiAnSW50MTYnXG59LCB7XG4gICAgbmFtZTogJ2Ffb2Zmc2V0JyxcbiAgICBjb21wb25lbnRzOiAyLFxuICAgIHR5cGU6ICdJbnQxNidcbn0sIHtcbiAgICBuYW1lOiAnYV90ZXh0dXJlX3BvcycsXG4gICAgY29tcG9uZW50czogMixcbiAgICB0eXBlOiAnVWludDE2J1xufSwge1xuICAgIG5hbWU6ICdhX2RhdGEnLFxuICAgIGNvbXBvbmVudHM6IDQsXG4gICAgdHlwZTogJ1VpbnQ4J1xufV0pO1xuXG52YXIgZWxlbWVudEFycmF5VHlwZSA9IG5ldyBCdWNrZXQuRWxlbWVudEFycmF5VHlwZSgpO1xuXG5mdW5jdGlvbiBhZGRWZXJ0ZXgoYXJyYXksIHgsIHksIG94LCBveSwgdHgsIHR5LCBtaW56b29tLCBtYXh6b29tLCBsYWJlbG1pbnpvb20sIGxhYmVsYW5nbGUpIHtcbiAgICByZXR1cm4gYXJyYXkuZW1wbGFjZUJhY2soXG4gICAgICAgICAgICAvLyBhX3Bvc1xuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG5cbiAgICAgICAgICAgIC8vIGFfb2Zmc2V0XG4gICAgICAgICAgICBNYXRoLnJvdW5kKG94ICogNjQpLFxuICAgICAgICAgICAgTWF0aC5yb3VuZChveSAqIDY0KSxcblxuICAgICAgICAgICAgLy8gYV90ZXh0dXJlX3Bvc1xuICAgICAgICAgICAgdHggLyA0LCAvLyB4IGNvb3JkaW5hdGUgb2Ygc3ltYm9sIG9uIGdseXBoIGF0bGFzIHRleHR1cmVcbiAgICAgICAgICAgIHR5IC8gNCwgLy8geSBjb29yZGluYXRlIG9mIHN5bWJvbCBvbiBnbHlwaCBhdGxhcyB0ZXh0dXJlXG5cbiAgICAgICAgICAgIC8vIGFfZGF0YVxuICAgICAgICAgICAgKGxhYmVsbWluem9vbSB8fCAwKSAqIDEwLCAvLyBsYWJlbG1pbnpvb21cbiAgICAgICAgICAgIGxhYmVsYW5nbGUsIC8vIGxhYmVsYW5nbGVcbiAgICAgICAgICAgIChtaW56b29tIHx8IDApICogMTAsIC8vIG1pbnpvb21cbiAgICAgICAgICAgIE1hdGgubWluKG1heHpvb20gfHwgMjUsIDI1KSAqIDEwKTsgLy8gbWF4em9vbVxufVxuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLmFkZENvbGxpc2lvbkJveFZlcnRleCA9IGZ1bmN0aW9uKGxheW91dFZlcnRleEFycmF5LCBwb2ludCwgZXh0cnVkZSwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSkge1xuICAgIHJldHVybiBsYXlvdXRWZXJ0ZXhBcnJheS5lbXBsYWNlQmFjayhcbiAgICAgICAgICAgIC8vIHBvc1xuICAgICAgICAgICAgcG9pbnQueCxcbiAgICAgICAgICAgIHBvaW50LnksXG4gICAgICAgICAgICAvLyBleHRydWRlXG4gICAgICAgICAgICBNYXRoLnJvdW5kKGV4dHJ1ZGUueCksXG4gICAgICAgICAgICBNYXRoLnJvdW5kKGV4dHJ1ZGUueSksXG4gICAgICAgICAgICAvLyBkYXRhXG4gICAgICAgICAgICBtYXhab29tICogMTAsXG4gICAgICAgICAgICBwbGFjZW1lbnRab29tICogMTApO1xufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5wcm9ncmFtSW50ZXJmYWNlcyA9IHtcblxuICAgIGdseXBoOiB7XG4gICAgICAgIGxheW91dFZlcnRleEFycmF5VHlwZTogbGF5b3V0VmVydGV4QXJyYXlUeXBlLFxuICAgICAgICBlbGVtZW50QXJyYXlUeXBlOiBlbGVtZW50QXJyYXlUeXBlXG4gICAgfSxcblxuICAgIGljb246IHtcbiAgICAgICAgbGF5b3V0VmVydGV4QXJyYXlUeXBlOiBsYXlvdXRWZXJ0ZXhBcnJheVR5cGUsXG4gICAgICAgIGVsZW1lbnRBcnJheVR5cGU6IGVsZW1lbnRBcnJheVR5cGVcbiAgICB9LFxuXG4gICAgY29sbGlzaW9uQm94OiB7XG4gICAgICAgIGxheW91dFZlcnRleEFycmF5VHlwZTogbmV3IEJ1Y2tldC5WZXJ0ZXhBcnJheVR5cGUoW3tcbiAgICAgICAgICAgIG5hbWU6ICdhX3BvcycsXG4gICAgICAgICAgICBjb21wb25lbnRzOiAyLFxuICAgICAgICAgICAgdHlwZTogJ0ludDE2J1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiAnYV9leHRydWRlJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IDIsXG4gICAgICAgICAgICB0eXBlOiAnSW50MTYnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdhX2RhdGEnLFxuICAgICAgICAgICAgY29tcG9uZW50czogMixcbiAgICAgICAgICAgIHR5cGU6ICdVaW50OCdcbiAgICAgICAgfV0pXG4gICAgfVxufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5wb3B1bGF0ZUFycmF5cyA9IGZ1bmN0aW9uKGNvbGxpc2lvblRpbGUsIHN0YWNrcywgaWNvbnMpIHtcblxuICAgIC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIGxhYmVscyB0aGF0IGp1bXAgYXJvdW5kIHdoZW4gem9vbWluZyB3ZSBuZWVkXG4gICAgLy8gdG8gdXNlIGEgdGV4dC1zaXplIHZhbHVlIHRoYXQgaXMgdGhlIHNhbWUgZm9yIGFsbCB6b29tIGxldmVscy5cbiAgICAvLyBUaGlzIGNhbGN1bGF0ZXMgdGV4dC1zaXplIGF0IGEgaGlnaCB6b29tIGxldmVsIHNvIHRoYXQgYWxsIHRpbGVzIGNhblxuICAgIC8vIHVzZSB0aGUgc2FtZSB2YWx1ZSB3aGVuIGNhbGN1bGF0aW5nIGFuY2hvciBwb3NpdGlvbnMuXG4gICAgdmFyIHpvb21IaXN0b3J5ID0geyBsYXN0SW50ZWdlclpvb206IEluZmluaXR5LCBsYXN0SW50ZWdlclpvb21UaW1lOiAwLCBsYXN0Wm9vbTogMCB9O1xuICAgIHRoaXMuYWRqdXN0ZWRUZXh0TWF4U2l6ZSA9IHRoaXMubGF5ZXIuZ2V0TGF5b3V0VmFsdWUoJ3RleHQtc2l6ZScsIHt6b29tOiAxOCwgem9vbUhpc3Rvcnk6IHpvb21IaXN0b3J5fSk7XG4gICAgdGhpcy5hZGp1c3RlZFRleHRTaXplID0gdGhpcy5sYXllci5nZXRMYXlvdXRWYWx1ZSgndGV4dC1zaXplJywge3pvb206IHRoaXMuem9vbSArIDEsIHpvb21IaXN0b3J5OiB6b29tSGlzdG9yeX0pO1xuICAgIHRoaXMuYWRqdXN0ZWRJY29uTWF4U2l6ZSA9IHRoaXMubGF5ZXIuZ2V0TGF5b3V0VmFsdWUoJ2ljb24tc2l6ZScsIHt6b29tOiAxOCwgem9vbUhpc3Rvcnk6IHpvb21IaXN0b3J5fSk7XG4gICAgdGhpcy5hZGp1c3RlZEljb25TaXplID0gdGhpcy5sYXllci5nZXRMYXlvdXRWYWx1ZSgnaWNvbi1zaXplJywge3pvb206IHRoaXMuem9vbSArIDEsIHpvb21IaXN0b3J5OiB6b29tSGlzdG9yeX0pO1xuXG4gICAgdmFyIHRpbGVTaXplID0gNTEyICogdGhpcy5vdmVyc2NhbGluZztcbiAgICB0aGlzLnRpbGVQaXhlbFJhdGlvID0gRVhURU5UIC8gdGlsZVNpemU7XG4gICAgdGhpcy5jb21wYXJlVGV4dCA9IHt9O1xuICAgIHRoaXMuaWNvbnNOZWVkTGluZWFyID0gZmFsc2U7XG4gICAgdGhpcy5zeW1ib2xJbnN0YW5jZXNTdGFydEluZGV4ID0gdGhpcy5zeW1ib2xJbnN0YW5jZXNBcnJheS5sZW5ndGg7XG5cbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5sYXllci5sYXlvdXQ7XG4gICAgdmFyIGZlYXR1cmVzID0gdGhpcy5mZWF0dXJlcztcbiAgICB2YXIgdGV4dEZlYXR1cmVzID0gdGhpcy50ZXh0RmVhdHVyZXM7XG5cbiAgICB2YXIgaG9yaXpvbnRhbEFsaWduID0gMC41LFxuICAgICAgICB2ZXJ0aWNhbEFsaWduID0gMC41O1xuXG4gICAgc3dpdGNoIChsYXlvdXRbJ3RleHQtYW5jaG9yJ10pIHtcbiAgICBjYXNlICdyaWdodCc6XG4gICAgY2FzZSAndG9wLXJpZ2h0JzpcbiAgICBjYXNlICdib3R0b20tcmlnaHQnOlxuICAgICAgICBob3Jpem9udGFsQWxpZ24gPSAxO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdsZWZ0JzpcbiAgICBjYXNlICd0b3AtbGVmdCc6XG4gICAgY2FzZSAnYm90dG9tLWxlZnQnOlxuICAgICAgICBob3Jpem9udGFsQWxpZ24gPSAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGxheW91dFsndGV4dC1hbmNob3InXSkge1xuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgY2FzZSAnYm90dG9tLXJpZ2h0JzpcbiAgICBjYXNlICdib3R0b20tbGVmdCc6XG4gICAgICAgIHZlcnRpY2FsQWxpZ24gPSAxO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICd0b3AnOlxuICAgIGNhc2UgJ3RvcC1yaWdodCc6XG4gICAgY2FzZSAndG9wLWxlZnQnOlxuICAgICAgICB2ZXJ0aWNhbEFsaWduID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGp1c3RpZnkgPSBsYXlvdXRbJ3RleHQtanVzdGlmeSddID09PSAncmlnaHQnID8gMSA6XG4gICAgICAgIGxheW91dFsndGV4dC1qdXN0aWZ5J10gPT09ICdsZWZ0JyA/IDAgOlxuICAgICAgICAwLjU7XG5cbiAgICB2YXIgb25lRW0gPSAyNDtcbiAgICB2YXIgbGluZUhlaWdodCA9IGxheW91dFsndGV4dC1saW5lLWhlaWdodCddICogb25lRW07XG4gICAgdmFyIG1heFdpZHRoID0gbGF5b3V0WydzeW1ib2wtcGxhY2VtZW50J10gIT09ICdsaW5lJyA/IGxheW91dFsndGV4dC1tYXgtd2lkdGgnXSAqIG9uZUVtIDogMDtcbiAgICB2YXIgc3BhY2luZyA9IGxheW91dFsndGV4dC1sZXR0ZXItc3BhY2luZyddICogb25lRW07XG4gICAgdmFyIHRleHRPZmZzZXQgPSBbbGF5b3V0Wyd0ZXh0LW9mZnNldCddWzBdICogb25lRW0sIGxheW91dFsndGV4dC1vZmZzZXQnXVsxXSAqIG9uZUVtXTtcbiAgICB2YXIgZm9udHN0YWNrID0gdGhpcy5mb250c3RhY2sgPSBsYXlvdXRbJ3RleHQtZm9udCddLmpvaW4oJywnKTtcblxuICAgIHZhciBnZW9tZXRyaWVzID0gW107XG4gICAgZm9yICh2YXIgZyA9IDA7IGcgPCBmZWF0dXJlcy5sZW5ndGg7IGcrKykge1xuICAgICAgICBnZW9tZXRyaWVzLnB1c2gobG9hZEdlb21ldHJ5KGZlYXR1cmVzW2ddKSk7XG4gICAgfVxuXG4gICAgaWYgKGxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddID09PSAnbGluZScpIHtcbiAgICAgICAgLy8gTWVyZ2UgYWRqYWNlbnQgbGluZXMgd2l0aCB0aGUgc2FtZSB0ZXh0IHRvIGltcHJvdmUgbGFiZWxsaW5nLlxuICAgICAgICAvLyBJdCdzIGJldHRlciB0byBwbGFjZSBsYWJlbHMgb24gb25lIGxvbmcgbGluZSB0aGFuIG9uIG1hbnkgc2hvcnQgc2VnbWVudHMuXG4gICAgICAgIHZhciBtZXJnZWQgPSBtZXJnZUxpbmVzKGZlYXR1cmVzLCB0ZXh0RmVhdHVyZXMsIGdlb21ldHJpZXMpO1xuXG4gICAgICAgIGdlb21ldHJpZXMgPSBtZXJnZWQuZ2VvbWV0cmllcztcbiAgICAgICAgZmVhdHVyZXMgPSBtZXJnZWQuZmVhdHVyZXM7XG4gICAgICAgIHRleHRGZWF0dXJlcyA9IG1lcmdlZC50ZXh0RmVhdHVyZXM7XG4gICAgfVxuXG4gICAgdmFyIHNoYXBlZFRleHQsIHNoYXBlZEljb247XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGZlYXR1cmVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGlmICghZ2VvbWV0cmllc1trXSkgY29udGludWU7XG5cbiAgICAgICAgaWYgKHRleHRGZWF0dXJlc1trXSkge1xuICAgICAgICAgICAgc2hhcGVkVGV4dCA9IHNoYXBlVGV4dCh0ZXh0RmVhdHVyZXNba10sIHN0YWNrc1tmb250c3RhY2tdLCBtYXhXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodCwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBqdXN0aWZ5LCBzcGFjaW5nLCB0ZXh0T2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNoYXBlZFRleHQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxheW91dFsnaWNvbi1pbWFnZSddKSB7XG4gICAgICAgICAgICB2YXIgaWNvbk5hbWUgPSByZXNvbHZlVG9rZW5zKGZlYXR1cmVzW2tdLnByb3BlcnRpZXMsIGxheW91dFsnaWNvbi1pbWFnZSddKTtcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IGljb25zW2ljb25OYW1lXTtcbiAgICAgICAgICAgIHNoYXBlZEljb24gPSBzaGFwZUljb24oaW1hZ2UsIGxheW91dCk7XG5cbiAgICAgICAgICAgIGlmIChpbWFnZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNkZkljb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZGZJY29ucyA9IGltYWdlLnNkZjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2RmSWNvbnMgIT09IGltYWdlLnNkZikge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLndhcm5PbmNlKCdTdHlsZSBzaGVldCB3YXJuaW5nOiBDYW5ub3QgbWl4IFNERiBhbmQgbm9uLVNERiBpY29ucyBpbiBvbmUgYnVmZmVyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbWFnZS5waXhlbFJhdGlvICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWNvbnNOZWVkTGluZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxheW91dFsnaWNvbi1yb3RhdGUnXSAhPT0gMCB8fCAhdGhpcy5sYXllci5pc0xheW91dFZhbHVlRmVhdHVyZUNvbnN0YW50KCdpY29uLXJvdGF0ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWNvbnNOZWVkTGluZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaGFwZWRJY29uID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZWRUZXh0IHx8IHNoYXBlZEljb24pIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRmVhdHVyZShnZW9tZXRyaWVzW2tdLCBzaGFwZWRUZXh0LCBzaGFwZWRJY29uLCBmZWF0dXJlc1trXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zeW1ib2xJbnN0YW5jZXNFbmRJbmRleCA9IHRoaXMuc3ltYm9sSW5zdGFuY2VzQXJyYXkubGVuZ3RoO1xuICAgIHRoaXMucGxhY2VGZWF0dXJlcyhjb2xsaXNpb25UaWxlLCB0aGlzLnNob3dDb2xsaXNpb25Cb3hlcyk7XG5cbiAgICB0aGlzLnRyaW1BcnJheXMoKTtcbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuYWRkRmVhdHVyZSA9IGZ1bmN0aW9uKGxpbmVzLCBzaGFwZWRUZXh0LCBzaGFwZWRJY29uLCBmZWF0dXJlKSB7XG4gICAgdmFyIGxheW91dCA9IHRoaXMubGF5ZXIubGF5b3V0O1xuXG4gICAgdmFyIGdseXBoU2l6ZSA9IDI0O1xuXG4gICAgdmFyIGZvbnRTY2FsZSA9IHRoaXMuYWRqdXN0ZWRUZXh0U2l6ZSAvIGdseXBoU2l6ZSxcbiAgICAgICAgdGV4dE1heFNpemUgPSB0aGlzLmFkanVzdGVkVGV4dE1heFNpemUgIT09IHVuZGVmaW5lZCA/IHRoaXMuYWRqdXN0ZWRUZXh0TWF4U2l6ZSA6IHRoaXMuYWRqdXN0ZWRUZXh0U2l6ZSxcbiAgICAgICAgdGV4dEJveFNjYWxlID0gdGhpcy50aWxlUGl4ZWxSYXRpbyAqIGZvbnRTY2FsZSxcbiAgICAgICAgdGV4dE1heEJveFNjYWxlID0gdGhpcy50aWxlUGl4ZWxSYXRpbyAqIHRleHRNYXhTaXplIC8gZ2x5cGhTaXplLFxuICAgICAgICBpY29uQm94U2NhbGUgPSB0aGlzLnRpbGVQaXhlbFJhdGlvICogdGhpcy5hZGp1c3RlZEljb25TaXplLFxuICAgICAgICBzeW1ib2xNaW5EaXN0YW5jZSA9IHRoaXMudGlsZVBpeGVsUmF0aW8gKiBsYXlvdXRbJ3N5bWJvbC1zcGFjaW5nJ10sXG4gICAgICAgIGF2b2lkRWRnZXMgPSBsYXlvdXRbJ3N5bWJvbC1hdm9pZC1lZGdlcyddLFxuICAgICAgICB0ZXh0UGFkZGluZyA9IGxheW91dFsndGV4dC1wYWRkaW5nJ10gKiB0aGlzLnRpbGVQaXhlbFJhdGlvLFxuICAgICAgICBpY29uUGFkZGluZyA9IGxheW91dFsnaWNvbi1wYWRkaW5nJ10gKiB0aGlzLnRpbGVQaXhlbFJhdGlvLFxuICAgICAgICB0ZXh0TWF4QW5nbGUgPSBsYXlvdXRbJ3RleHQtbWF4LWFuZ2xlJ10gLyAxODAgKiBNYXRoLlBJLFxuICAgICAgICB0ZXh0QWxvbmdMaW5lID0gbGF5b3V0Wyd0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCddID09PSAnbWFwJyAmJiBsYXlvdXRbJ3N5bWJvbC1wbGFjZW1lbnQnXSA9PT0gJ2xpbmUnLFxuICAgICAgICBpY29uQWxvbmdMaW5lID0gbGF5b3V0WydpY29uLXJvdGF0aW9uLWFsaWdubWVudCddID09PSAnbWFwJyAmJiBsYXlvdXRbJ3N5bWJvbC1wbGFjZW1lbnQnXSA9PT0gJ2xpbmUnLFxuICAgICAgICBtYXlPdmVybGFwID0gbGF5b3V0Wyd0ZXh0LWFsbG93LW92ZXJsYXAnXSB8fCBsYXlvdXRbJ2ljb24tYWxsb3ctb3ZlcmxhcCddIHx8XG4gICAgICAgICAgICBsYXlvdXRbJ3RleHQtaWdub3JlLXBsYWNlbWVudCddIHx8IGxheW91dFsnaWNvbi1pZ25vcmUtcGxhY2VtZW50J10sXG4gICAgICAgIHN5bWJvbFBsYWNlbWVudCA9IGxheW91dFsnc3ltYm9sLXBsYWNlbWVudCddLFxuICAgICAgICBpc0xpbmUgPSBzeW1ib2xQbGFjZW1lbnQgPT09ICdsaW5lJyxcbiAgICAgICAgdGV4dFJlcGVhdERpc3RhbmNlID0gc3ltYm9sTWluRGlzdGFuY2UgLyAyO1xuXG4gICAgdmFyIGxpc3QgPSBudWxsO1xuICAgIGlmIChpc0xpbmUpIHtcbiAgICAgICAgbGlzdCA9IGNsaXBMaW5lKGxpbmVzLCAwLCAwLCBFWFRFTlQsIEVYVEVOVCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT25seSBjYXJlIGFib3V0IGxvb3BpbmcgdGhyb3VnaCB0aGUgb3V0ZXIgcmluZ3NcbiAgICAgICAgbGlzdCA9IGNsYXNzaWZ5UmluZ3MobGluZXMsIDApO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYW5jaG9ycyA9IG51bGw7XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgaXQgaXMgYSBsaXN0IG9mIHBvaW50cyBmb3IgYSBsaW5lIG9yIGEgbGlzdCBvZiBwb2x5Z29uIHJpbmdzXG4gICAgICAgIHZhciBwb2ludHNPclJpbmdzID0gbGlzdFtpXTtcbiAgICAgICAgdmFyIGxpbmUgPSBudWxsO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYW5jaG9yIHBvaW50cyBhcm91bmQgd2hpY2ggeW91IHdhbnQgdG8gcGxhY2UgbGFiZWxzXG4gICAgICAgIGlmIChpc0xpbmUpIHtcbiAgICAgICAgICAgIGxpbmUgPSBwb2ludHNPclJpbmdzO1xuICAgICAgICAgICAgYW5jaG9ycyA9IGdldEFuY2hvcnMoXG4gICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICBzeW1ib2xNaW5EaXN0YW5jZSxcbiAgICAgICAgICAgICAgICB0ZXh0TWF4QW5nbGUsXG4gICAgICAgICAgICAgICAgc2hhcGVkVGV4dCxcbiAgICAgICAgICAgICAgICBzaGFwZWRJY29uLFxuICAgICAgICAgICAgICAgIGdseXBoU2l6ZSxcbiAgICAgICAgICAgICAgICB0ZXh0TWF4Qm94U2NhbGUsXG4gICAgICAgICAgICAgICAgdGhpcy5vdmVyc2NhbGluZyxcbiAgICAgICAgICAgICAgICBFWFRFTlRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaW5lID0gcG9pbnRzT3JSaW5nc1swXTtcbiAgICAgICAgICAgIGFuY2hvcnMgPSB0aGlzLmZpbmRQb2x5Z29uQW5jaG9ycyhwb2ludHNPclJpbmdzKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gSGVyZSBsaW5lIGlzIGEgbGlzdCBvZiBwb2ludHMgdGhhdCBpcyBlaXRoZXIgdGhlIG91dGVyIHJpbmcgb2YgYSBwb2x5Z29uIG9yIGp1c3QgYSBsaW5lXG5cbiAgICAgICAgLy8gRm9yIGVhY2ggcG90ZW50aWFsIGxhYmVsLCBjcmVhdGUgdGhlIHBsYWNlbWVudCBmZWF0dXJlcyB1c2VkIHRvIGNoZWNrIGZvciBjb2xsaXNpb25zLCBhbmQgdGhlIHF1YWRzIHVzZSBmb3IgcmVuZGVyaW5nLlxuICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gYW5jaG9ycy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgdmFyIGFuY2hvciA9IGFuY2hvcnNbal07XG5cbiAgICAgICAgICAgIGlmIChzaGFwZWRUZXh0ICYmIGlzTGluZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFuY2hvcklzVG9vQ2xvc2Uoc2hhcGVkVGV4dC50ZXh0LCB0ZXh0UmVwZWF0RGlzdGFuY2UsIGFuY2hvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5zaWRlID0gIShhbmNob3IueCA8IDAgfHwgYW5jaG9yLnggPiBFWFRFTlQgfHwgYW5jaG9yLnkgPCAwIHx8IGFuY2hvci55ID4gRVhURU5UKTtcblxuICAgICAgICAgICAgaWYgKGF2b2lkRWRnZXMgJiYgIWluc2lkZSkgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIE5vcm1hbGx5IHN5bWJvbCBsYXllcnMgYXJlIGRyYXduIGFjcm9zcyB0aWxlIGJvdW5kYXJpZXMuIE9ubHkgc3ltYm9sc1xuICAgICAgICAgICAgLy8gd2l0aCB0aGVpciBhbmNob3JzIHdpdGhpbiB0aGUgdGlsZSBib3VuZGFyaWVzIGFyZSBhZGRlZCB0byB0aGUgYnVmZmVyc1xuICAgICAgICAgICAgLy8gdG8gcHJldmVudCBzeW1ib2xzIGZyb20gYmVpbmcgZHJhd24gdHdpY2UuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gU3ltYm9scyBpbiBsYXllcnMgd2l0aCBvdmVybGFwIGFyZSBzb3J0ZWQgaW4gdGhlIHkgZGlyZWN0aW9uIHNvIHRoYXRcbiAgICAgICAgICAgIC8vIHN5bWJvbHMgbG93ZXIgb24gdGhlIGNhbnZhcyBhcmUgZHJhd24gb24gdG9wIG9mIHN5bWJvbHMgbmVhciB0aGUgdG9wLlxuICAgICAgICAgICAgLy8gVG8gcHJlc2VydmUgdGhpcyBvcmRlciBhY3Jvc3MgdGlsZSBib3VuZGFyaWVzIHRoZXNlIHN5bWJvbHMgY2FuJ3RcbiAgICAgICAgICAgIC8vIGJlIGRyYXduIGFjcm9zcyB0aWxlIGJvdW5kYXJpZXMuIEluc3RlYWQgdGhleSBuZWVkIHRvIGJlIGluY2x1ZGVkIGluXG4gICAgICAgICAgICAvLyB0aGUgYnVmZmVycyBmb3IgYm90aCB0aWxlcyBhbmQgY2xpcHBlZCB0byB0aWxlIGJvdW5kYXJpZXMgYXQgZHJhdyB0aW1lLlxuICAgICAgICAgICAgdmFyIGFkZFRvQnVmZmVycyA9IGluc2lkZSB8fCBtYXlPdmVybGFwO1xuICAgICAgICAgICAgdGhpcy5hZGRTeW1ib2xJbnN0YW5jZShhbmNob3IsIGxpbmUsIHNoYXBlZFRleHQsIHNoYXBlZEljb24sIHRoaXMubGF5ZXIsXG4gICAgICAgICAgICAgICAgYWRkVG9CdWZmZXJzLCB0aGlzLnN5bWJvbEluc3RhbmNlc0FycmF5Lmxlbmd0aCwgdGhpcy5jb2xsaXNpb25Cb3hBcnJheSwgZmVhdHVyZS5pbmRleCwgdGhpcy5zb3VyY2VMYXllckluZGV4LCB0aGlzLmluZGV4LFxuICAgICAgICAgICAgICAgIHRleHRCb3hTY2FsZSwgdGV4dFBhZGRpbmcsIHRleHRBbG9uZ0xpbmUsXG4gICAgICAgICAgICAgICAgaWNvbkJveFNjYWxlLCBpY29uUGFkZGluZywgaWNvbkFsb25nTGluZSwge3pvb206IHRoaXMuem9vbX0sIGZlYXR1cmUucHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLmZpbmRQb2x5Z29uQW5jaG9ycyA9IGZ1bmN0aW9uKHBvbHlnb25SaW5ncykge1xuXG4gICAgdmFyIG91dGVyUmluZyA9IHBvbHlnb25SaW5nc1swXTtcbiAgICBpZiAob3V0ZXJSaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIGlmIChvdXRlclJpbmcubGVuZ3RoIDwgMyB8fCAhdXRpbC5pc0Nsb3NlZFBvbHlnb24ob3V0ZXJSaW5nKSkge1xuICAgICAgICByZXR1cm4gWyBuZXcgQW5jaG9yKG91dGVyUmluZ1swXS54LCBvdXRlclJpbmdbMF0ueSwgMCkgXTtcbiAgICB9XG5cbiAgICB2YXIgYW5jaG9ycyA9IG51bGw7XG4gICAgLy8gMTYgaGVyZSByZXByZXNlbnRzIDIgcGl4ZWxzXG4gICAgdmFyIHBvaSA9IGZpbmRQb2xlT2ZJbmFjY2Vzc2liaWxpdHkocG9seWdvblJpbmdzLCAxNik7XG4gICAgYW5jaG9ycyA9IFsgbmV3IEFuY2hvcihwb2kueCwgcG9pLnksIDApIF07XG5cbiAgICByZXR1cm4gYW5jaG9ycztcbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuYW5jaG9ySXNUb29DbG9zZSA9IGZ1bmN0aW9uKHRleHQsIHJlcGVhdERpc3RhbmNlLCBhbmNob3IpIHtcbiAgICB2YXIgY29tcGFyZVRleHQgPSB0aGlzLmNvbXBhcmVUZXh0O1xuICAgIGlmICghKHRleHQgaW4gY29tcGFyZVRleHQpKSB7XG4gICAgICAgIGNvbXBhcmVUZXh0W3RleHRdID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG90aGVyQW5jaG9ycyA9IGNvbXBhcmVUZXh0W3RleHRdO1xuICAgICAgICBmb3IgKHZhciBrID0gb3RoZXJBbmNob3JzLmxlbmd0aCAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgICAgICBpZiAoYW5jaG9yLmRpc3Qob3RoZXJBbmNob3JzW2tdKSA8IHJlcGVhdERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyB3aXRoaW4gcmVwZWF0RGlzdGFuY2Ugb2Ygb25lIGFuY2hvciwgc3RvcCBsb29raW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgYW5jaG9yIGlzIG5vdCB3aXRoaW4gcmVwZWF0RGlzdGFuY2Ugb2YgYW55IG90aGVyIGFuY2hvciwgYWRkIHRvIGFycmF5XG4gICAgY29tcGFyZVRleHRbdGV4dF0ucHVzaChhbmNob3IpO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUucGxhY2VGZWF0dXJlcyA9IGZ1bmN0aW9uKGNvbGxpc2lvblRpbGUsIHNob3dDb2xsaXNpb25Cb3hlcykge1xuICAgIHRoaXMucmVjYWxjdWxhdGVTdHlsZUxheWVycygpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHdoaWNoIGxhYmVscyBjYW4gYmUgc2hvd24gYW5kIHdoZW4gdGhleSBjYW4gYmUgc2hvd24gYW5kXG4gICAgLy8gY3JlYXRlIHRoZSBidWZlcnMgdXNlZCBmb3IgcmVuZGVyaW5nLlxuXG4gICAgdGhpcy5jcmVhdGVBcnJheXMoKTtcblxuICAgIHZhciBsYXlvdXQgPSB0aGlzLmxheWVyLmxheW91dDtcblxuICAgIHZhciBtYXhTY2FsZSA9IGNvbGxpc2lvblRpbGUubWF4U2NhbGU7XG5cbiAgICB2YXIgdGV4dEFsb25nTGluZSA9IGxheW91dFsndGV4dC1yb3RhdGlvbi1hbGlnbm1lbnQnXSA9PT0gJ21hcCcgJiYgbGF5b3V0WydzeW1ib2wtcGxhY2VtZW50J10gPT09ICdsaW5lJztcbiAgICB2YXIgaWNvbkFsb25nTGluZSA9IGxheW91dFsnaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnQnXSA9PT0gJ21hcCcgJiYgbGF5b3V0WydzeW1ib2wtcGxhY2VtZW50J10gPT09ICdsaW5lJztcblxuICAgIHZhciBtYXlPdmVybGFwID0gbGF5b3V0Wyd0ZXh0LWFsbG93LW92ZXJsYXAnXSB8fCBsYXlvdXRbJ2ljb24tYWxsb3ctb3ZlcmxhcCddIHx8XG4gICAgICAgIGxheW91dFsndGV4dC1pZ25vcmUtcGxhY2VtZW50J10gfHwgbGF5b3V0WydpY29uLWlnbm9yZS1wbGFjZW1lbnQnXTtcblxuICAgIC8vIFNvcnQgc3ltYm9scyBieSB0aGVpciB5IHBvc2l0aW9uIG9uIHRoZSBjYW52YXMgc28gdGhhdCB0aGUgbG93ZXIgc3ltYm9sc1xuICAgIC8vIGFyZSBkcmF3biBvbiB0b3Agb2YgaGlnaGVyIHN5bWJvbHMuXG4gICAgLy8gRG9uJ3Qgc29ydCBzeW1ib2xzIHRoYXQgd29uJ3Qgb3ZlcmxhcCBiZWNhdXNlIGl0IGlzbid0IG5lY2Vzc2FyeSBhbmRcbiAgICAvLyBiZWNhdXNlIGl0IGNhdXNlcyBtb3JlIGxhYmVscyB0byBwb3AgaW4gYW5kIG91dCB3aGVuIHJvdGF0aW5nLlxuICAgIGlmIChtYXlPdmVybGFwKSB7XG4gICAgICAgIC8vIE9ubHkgbmVlZCB0aGUgc3ltYm9sIGluc3RhbmNlcyBmcm9tIHRoZSBjdXJyZW50IHRpbGUgdG8gc29ydCwgc28gY29udmVydCB0aG9zZSBpbnN0YW5jZXMgaW50byBhbiBhcnJheVxuICAgICAgICAvLyBvZiBgU3RydWN0VHlwZWBzIHRvIGVuYWJsZSBzb3J0aW5nXG4gICAgICAgIHZhciBzeW1ib2xJbnN0YW5jZXNTdHJ1Y3RUeXBlQXJyYXkgPSB0aGlzLnN5bWJvbEluc3RhbmNlc0FycmF5LnRvQXJyYXkodGhpcy5zeW1ib2xJbnN0YW5jZXNTdGFydEluZGV4LCB0aGlzLnN5bWJvbEluc3RhbmNlc0VuZEluZGV4KTtcblxuICAgICAgICB2YXIgYW5nbGUgPSBjb2xsaXNpb25UaWxlLmFuZ2xlO1xuXG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG5cbiAgICAgICAgdGhpcy5zb3J0ZWRTeW1ib2xJbnN0YW5jZXMgPSBzeW1ib2xJbnN0YW5jZXNTdHJ1Y3RUeXBlQXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICB2YXIgYVJvdGF0ZWQgPSAoc2luICogYS5hbmNob3JQb2ludFggKyBjb3MgKiBhLmFuY2hvclBvaW50WSkgfCAwO1xuICAgICAgICAgICAgdmFyIGJSb3RhdGVkID0gKHNpbiAqIGIuYW5jaG9yUG9pbnRYICsgY29zICogYi5hbmNob3JQb2ludFkpIHwgMDtcbiAgICAgICAgICAgIHJldHVybiAoYVJvdGF0ZWQgLSBiUm90YXRlZCkgfHwgKGIuaW5kZXggLSBhLmluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcCA9IHRoaXMuc3ltYm9sSW5zdGFuY2VzU3RhcnRJbmRleDsgcCA8IHRoaXMuc3ltYm9sSW5zdGFuY2VzRW5kSW5kZXg7IHArKykge1xuICAgICAgICB2YXIgc3ltYm9sSW5zdGFuY2UgPSB0aGlzLnNvcnRlZFN5bWJvbEluc3RhbmNlcyA/IHRoaXMuc29ydGVkU3ltYm9sSW5zdGFuY2VzW3AgLSB0aGlzLnN5bWJvbEluc3RhbmNlc1N0YXJ0SW5kZXhdIDogdGhpcy5zeW1ib2xJbnN0YW5jZXNBcnJheS5nZXQocCk7XG4gICAgICAgIHZhciB0ZXh0Q29sbGlzaW9uRmVhdHVyZSA9IHtcbiAgICAgICAgICAgIGJveFN0YXJ0SW5kZXg6IHN5bWJvbEluc3RhbmNlLnRleHRCb3hTdGFydEluZGV4LFxuICAgICAgICAgICAgYm94RW5kSW5kZXg6IHN5bWJvbEluc3RhbmNlLnRleHRCb3hFbmRJbmRleFxuICAgICAgICB9O1xuICAgICAgICB2YXIgaWNvbkNvbGxpc2lvbkZlYXR1cmUgPSB7XG4gICAgICAgICAgICBib3hTdGFydEluZGV4OiBzeW1ib2xJbnN0YW5jZS5pY29uQm94U3RhcnRJbmRleCxcbiAgICAgICAgICAgIGJveEVuZEluZGV4OiBzeW1ib2xJbnN0YW5jZS5pY29uQm94RW5kSW5kZXhcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaGFzVGV4dCA9ICEoc3ltYm9sSW5zdGFuY2UudGV4dEJveFN0YXJ0SW5kZXggPT09IHN5bWJvbEluc3RhbmNlLnRleHRCb3hFbmRJbmRleCk7XG4gICAgICAgIHZhciBoYXNJY29uID0gIShzeW1ib2xJbnN0YW5jZS5pY29uQm94U3RhcnRJbmRleCA9PT0gc3ltYm9sSW5zdGFuY2UuaWNvbkJveEVuZEluZGV4KTtcblxuICAgICAgICB2YXIgaWNvbldpdGhvdXRUZXh0ID0gbGF5b3V0Wyd0ZXh0LW9wdGlvbmFsJ10gfHwgIWhhc1RleHQsXG4gICAgICAgICAgICB0ZXh0V2l0aG91dEljb24gPSBsYXlvdXRbJ2ljb24tb3B0aW9uYWwnXSB8fCAhaGFzSWNvbjtcblxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgc2NhbGVzIGF0IHdoaWNoIHRoZSB0ZXh0IGFuZCBpY29uIGNhbiBiZSBwbGFjZWQgd2l0aG91dCBjb2xsaXNpb24uXG5cbiAgICAgICAgdmFyIGdseXBoU2NhbGUgPSBoYXNUZXh0ID9cbiAgICAgICAgICAgIGNvbGxpc2lvblRpbGUucGxhY2VDb2xsaXNpb25GZWF0dXJlKHRleHRDb2xsaXNpb25GZWF0dXJlLFxuXHRcdFx0XHRcdGxheW91dFsndGV4dC1hbGxvdy1vdmVybGFwJ10sIGxheW91dFsnc3ltYm9sLWF2b2lkLWVkZ2VzJ10pIDpcbiAgICAgICAgICAgIGNvbGxpc2lvblRpbGUubWluU2NhbGU7XG5cbiAgICAgICAgdmFyIGljb25TY2FsZSA9IGhhc0ljb24gP1xuICAgICAgICAgICAgY29sbGlzaW9uVGlsZS5wbGFjZUNvbGxpc2lvbkZlYXR1cmUoaWNvbkNvbGxpc2lvbkZlYXR1cmUsXG4gICAgICAgICAgICAgICAgICAgIGxheW91dFsnaWNvbi1hbGxvdy1vdmVybGFwJ10sIGxheW91dFsnc3ltYm9sLWF2b2lkLWVkZ2VzJ10pIDpcbiAgICAgICAgICAgIGNvbGxpc2lvblRpbGUubWluU2NhbGU7XG5cblxuICAgICAgICAvLyBDb21iaW5lIHRoZSBzY2FsZXMgZm9yIGljb25zIGFuZCB0ZXh0LlxuXG4gICAgICAgIGlmICghaWNvbldpdGhvdXRUZXh0ICYmICF0ZXh0V2l0aG91dEljb24pIHtcbiAgICAgICAgICAgIGljb25TY2FsZSA9IGdseXBoU2NhbGUgPSBNYXRoLm1heChpY29uU2NhbGUsIGdseXBoU2NhbGUpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0ZXh0V2l0aG91dEljb24gJiYgZ2x5cGhTY2FsZSkge1xuICAgICAgICAgICAgZ2x5cGhTY2FsZSA9IE1hdGgubWF4KGljb25TY2FsZSwgZ2x5cGhTY2FsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWljb25XaXRob3V0VGV4dCAmJiBpY29uU2NhbGUpIHtcbiAgICAgICAgICAgIGljb25TY2FsZSA9IE1hdGgubWF4KGljb25TY2FsZSwgZ2x5cGhTY2FsZSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIEluc2VydCBmaW5hbCBwbGFjZW1lbnQgaW50byBjb2xsaXNpb24gdHJlZSBhbmQgYWRkIGdseXBocy9pY29ucyB0byBidWZmZXJzXG5cbiAgICAgICAgaWYgKGhhc1RleHQpIHtcbiAgICAgICAgICAgIGNvbGxpc2lvblRpbGUuaW5zZXJ0Q29sbGlzaW9uRmVhdHVyZSh0ZXh0Q29sbGlzaW9uRmVhdHVyZSwgZ2x5cGhTY2FsZSwgbGF5b3V0Wyd0ZXh0LWlnbm9yZS1wbGFjZW1lbnQnXSk7XG4gICAgICAgICAgICBpZiAoZ2x5cGhTY2FsZSA8PSBtYXhTY2FsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkU3ltYm9scygnZ2x5cGgnLCBzeW1ib2xJbnN0YW5jZS5nbHlwaFF1YWRTdGFydEluZGV4LCBzeW1ib2xJbnN0YW5jZS5nbHlwaFF1YWRFbmRJbmRleCwgZ2x5cGhTY2FsZSwgbGF5b3V0Wyd0ZXh0LWtlZXAtdXByaWdodCddLCB0ZXh0QWxvbmdMaW5lLCBjb2xsaXNpb25UaWxlLmFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNJY29uKSB7XG4gICAgICAgICAgICBjb2xsaXNpb25UaWxlLmluc2VydENvbGxpc2lvbkZlYXR1cmUoaWNvbkNvbGxpc2lvbkZlYXR1cmUsIGljb25TY2FsZSwgbGF5b3V0WydpY29uLWlnbm9yZS1wbGFjZW1lbnQnXSk7XG4gICAgICAgICAgICBpZiAoaWNvblNjYWxlIDw9IG1heFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTeW1ib2xzKCdpY29uJywgc3ltYm9sSW5zdGFuY2UuaWNvblF1YWRTdGFydEluZGV4LCBzeW1ib2xJbnN0YW5jZS5pY29uUXVhZEVuZEluZGV4LCBpY29uU2NhbGUsIGxheW91dFsnaWNvbi1rZWVwLXVwcmlnaHQnXSwgaWNvbkFsb25nTGluZSwgY29sbGlzaW9uVGlsZS5hbmdsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGlmIChzaG93Q29sbGlzaW9uQm94ZXMpIHRoaXMuYWRkVG9EZWJ1Z0J1ZmZlcnMoY29sbGlzaW9uVGlsZSk7XG59O1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLmFkZFN5bWJvbHMgPSBmdW5jdGlvbihwcm9ncmFtTmFtZSwgcXVhZHNTdGFydCwgcXVhZHNFbmQsIHNjYWxlLCBrZWVwVXByaWdodCwgYWxvbmdMaW5lLCBwbGFjZW1lbnRBbmdsZSkge1xuXG4gICAgdmFyIGdyb3VwID0gdGhpcy5wcmVwYXJlQXJyYXlHcm91cChwcm9ncmFtTmFtZSwgNCAqIChxdWFkc0VuZCAtIHF1YWRzU3RhcnQpKTtcblxuICAgIHZhciBlbGVtZW50QXJyYXkgPSBncm91cC5lbGVtZW50QXJyYXk7XG4gICAgdmFyIGxheW91dFZlcnRleEFycmF5ID0gZ3JvdXAubGF5b3V0VmVydGV4QXJyYXk7XG5cbiAgICB2YXIgem9vbSA9IHRoaXMuem9vbTtcbiAgICB2YXIgcGxhY2VtZW50Wm9vbSA9IE1hdGgubWF4KE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yICsgem9vbSwgMCk7XG5cbiAgICBmb3IgKHZhciBrID0gcXVhZHNTdGFydDsgayA8IHF1YWRzRW5kOyBrKyspIHtcblxuICAgICAgICB2YXIgc3ltYm9sID0gdGhpcy5zeW1ib2xRdWFkc0FycmF5LmdldChrKS5TeW1ib2xRdWFkO1xuXG4gICAgICAgIC8vIGRyb3AgdXBzaWRlIGRvd24gdmVyc2lvbnMgb2YgZ2x5cGhzXG4gICAgICAgIHZhciBhID0gKHN5bWJvbC5hbmNob3JBbmdsZSArIHBsYWNlbWVudEFuZ2xlICsgTWF0aC5QSSkgJSAoTWF0aC5QSSAqIDIpO1xuICAgICAgICBpZiAoa2VlcFVwcmlnaHQgJiYgYWxvbmdMaW5lICYmIChhIDw9IE1hdGguUEkgLyAyIHx8IGEgPiBNYXRoLlBJICogMyAvIDIpKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgdGwgPSBzeW1ib2wudGwsXG4gICAgICAgICAgICB0ciA9IHN5bWJvbC50cixcbiAgICAgICAgICAgIGJsID0gc3ltYm9sLmJsLFxuICAgICAgICAgICAgYnIgPSBzeW1ib2wuYnIsXG4gICAgICAgICAgICB0ZXggPSBzeW1ib2wudGV4LFxuICAgICAgICAgICAgYW5jaG9yUG9pbnQgPSBzeW1ib2wuYW5jaG9yUG9pbnQsXG5cbiAgICAgICAgICAgIG1pblpvb20gPSBNYXRoLm1heCh6b29tICsgTWF0aC5sb2coc3ltYm9sLm1pblNjYWxlKSAvIE1hdGguTE4yLCBwbGFjZW1lbnRab29tKSxcbiAgICAgICAgICAgIG1heFpvb20gPSBNYXRoLm1pbih6b29tICsgTWF0aC5sb2coc3ltYm9sLm1heFNjYWxlKSAvIE1hdGguTE4yLCAyNSk7XG5cbiAgICAgICAgaWYgKG1heFpvb20gPD0gbWluWm9vbSkgY29udGludWU7XG5cbiAgICAgICAgLy8gTG93ZXIgbWluIHpvb20gc28gdGhhdCB3aGlsZSBmYWRpbmcgb3V0IHRoZSBsYWJlbCBpdCBjYW4gYmUgc2hvd24gb3V0c2lkZSBvZiBjb2xsaXNpb24tZnJlZSB6b29tIGxldmVsc1xuICAgICAgICBpZiAobWluWm9vbSA9PT0gcGxhY2VtZW50Wm9vbSkgbWluWm9vbSA9IDA7XG5cbiAgICAgICAgLy8gRW5jb2RlIGFuZ2xlIG9mIGdseXBoXG4gICAgICAgIHZhciBnbHlwaEFuZ2xlID0gTWF0aC5yb3VuZCgoc3ltYm9sLmdseXBoQW5nbGUgLyAoTWF0aC5QSSAqIDIpKSAqIDI1Nik7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gYWRkVmVydGV4KGxheW91dFZlcnRleEFycmF5LCBhbmNob3JQb2ludC54LCBhbmNob3JQb2ludC55LCB0bC54LCB0bC55LCB0ZXgueCwgdGV4LnksIG1pblpvb20sIG1heFpvb20sIHBsYWNlbWVudFpvb20sIGdseXBoQW5nbGUpO1xuICAgICAgICBhZGRWZXJ0ZXgobGF5b3V0VmVydGV4QXJyYXksIGFuY2hvclBvaW50LngsIGFuY2hvclBvaW50LnksIHRyLngsIHRyLnksIHRleC54ICsgdGV4LncsIHRleC55LCBtaW5ab29tLCBtYXhab29tLCBwbGFjZW1lbnRab29tLCBnbHlwaEFuZ2xlKTtcbiAgICAgICAgYWRkVmVydGV4KGxheW91dFZlcnRleEFycmF5LCBhbmNob3JQb2ludC54LCBhbmNob3JQb2ludC55LCBibC54LCBibC55LCB0ZXgueCwgdGV4LnkgKyB0ZXguaCwgbWluWm9vbSwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSwgZ2x5cGhBbmdsZSk7XG4gICAgICAgIGFkZFZlcnRleChsYXlvdXRWZXJ0ZXhBcnJheSwgYW5jaG9yUG9pbnQueCwgYW5jaG9yUG9pbnQueSwgYnIueCwgYnIueSwgdGV4LnggKyB0ZXgudywgdGV4LnkgKyB0ZXguaCwgbWluWm9vbSwgbWF4Wm9vbSwgcGxhY2VtZW50Wm9vbSwgZ2x5cGhBbmdsZSk7XG5cbiAgICAgICAgZWxlbWVudEFycmF5LmVtcGxhY2VCYWNrKGluZGV4LCBpbmRleCArIDEsIGluZGV4ICsgMik7XG4gICAgICAgIGVsZW1lbnRBcnJheS5lbXBsYWNlQmFjayhpbmRleCArIDEsIGluZGV4ICsgMiwgaW5kZXggKyAzKTtcbiAgICB9XG5cbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUudXBkYXRlSWNvbnMgPSBmdW5jdGlvbihpY29ucykge1xuICAgIHRoaXMucmVjYWxjdWxhdGVTdHlsZUxheWVycygpO1xuICAgIHZhciBpY29uVmFsdWUgPSB0aGlzLmxheWVyLmxheW91dFsnaWNvbi1pbWFnZSddO1xuICAgIGlmICghaWNvblZhbHVlKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGljb25OYW1lID0gcmVzb2x2ZVRva2Vucyh0aGlzLmZlYXR1cmVzW2ldLnByb3BlcnRpZXMsIGljb25WYWx1ZSk7XG4gICAgICAgIGlmIChpY29uTmFtZSlcbiAgICAgICAgICAgIGljb25zW2ljb25OYW1lXSA9IHRydWU7XG4gICAgfVxufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS51cGRhdGVGb250ID0gZnVuY3Rpb24oc3RhY2tzKSB7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZVN0eWxlTGF5ZXJzKCk7XG4gICAgdmFyIGZvbnROYW1lID0gdGhpcy5sYXllci5sYXlvdXRbJ3RleHQtZm9udCddLFxuICAgICAgICBzdGFjayA9IHN0YWNrc1tmb250TmFtZV0gPSBzdGFja3NbZm9udE5hbWVdIHx8IHt9O1xuXG4gICAgdGhpcy50ZXh0RmVhdHVyZXMgPSByZXNvbHZlVGV4dCh0aGlzLmZlYXR1cmVzLCB0aGlzLmxheWVyLmxheW91dCwgc3RhY2spO1xufTtcblxuU3ltYm9sQnVja2V0LnByb3RvdHlwZS5hZGRUb0RlYnVnQnVmZmVycyA9IGZ1bmN0aW9uKGNvbGxpc2lvblRpbGUpIHtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLnByZXBhcmVBcnJheUdyb3VwKCdjb2xsaXNpb25Cb3gnLCAwKTtcbiAgICB2YXIgbGF5b3V0VmVydGV4QXJyYXkgPSBncm91cC5sYXlvdXRWZXJ0ZXhBcnJheTtcbiAgICB2YXIgYW5nbGUgPSAtY29sbGlzaW9uVGlsZS5hbmdsZTtcbiAgICB2YXIgeVN0cmV0Y2ggPSBjb2xsaXNpb25UaWxlLnlTdHJldGNoO1xuXG4gICAgZm9yICh2YXIgaiA9IHRoaXMuc3ltYm9sSW5zdGFuY2VzU3RhcnRJbmRleDsgaiA8IHRoaXMuc3ltYm9sSW5zdGFuY2VzRW5kSW5kZXg7IGorKykge1xuICAgICAgICB2YXIgc3ltYm9sSW5zdGFuY2UgPSB0aGlzLnN5bWJvbEluc3RhbmNlc0FycmF5LmdldChqKTtcbiAgICAgICAgc3ltYm9sSW5zdGFuY2UudGV4dENvbGxpc2lvbkZlYXR1cmUgPSB7Ym94U3RhcnRJbmRleDogc3ltYm9sSW5zdGFuY2UudGV4dEJveFN0YXJ0SW5kZXgsIGJveEVuZEluZGV4OiBzeW1ib2xJbnN0YW5jZS50ZXh0Qm94RW5kSW5kZXh9O1xuICAgICAgICBzeW1ib2xJbnN0YW5jZS5pY29uQ29sbGlzaW9uRmVhdHVyZSA9IHtib3hTdGFydEluZGV4OiBzeW1ib2xJbnN0YW5jZS5pY29uQm94U3RhcnRJbmRleCwgYm94RW5kSW5kZXg6IHN5bWJvbEluc3RhbmNlLmljb25Cb3hFbmRJbmRleH07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlID0gc3ltYm9sSW5zdGFuY2VbaSA9PT0gMCA/ICd0ZXh0Q29sbGlzaW9uRmVhdHVyZScgOiAnaWNvbkNvbGxpc2lvbkZlYXR1cmUnXTtcbiAgICAgICAgICAgIGlmICghZmVhdHVyZSkgY29udGludWU7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGIgPSBmZWF0dXJlLmJveFN0YXJ0SW5kZXg7IGIgPCBmZWF0dXJlLmJveEVuZEluZGV4OyBiKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYm94ID0gdGhpcy5jb2xsaXNpb25Cb3hBcnJheS5nZXQoYik7XG4gICAgICAgICAgICAgICAgdmFyIGFuY2hvclBvaW50ID0gYm94LmFuY2hvclBvaW50O1xuXG4gICAgICAgICAgICAgICAgdmFyIHRsID0gbmV3IFBvaW50KGJveC54MSwgYm94LnkxICogeVN0cmV0Y2gpLl9yb3RhdGUoYW5nbGUpO1xuICAgICAgICAgICAgICAgIHZhciB0ciA9IG5ldyBQb2ludChib3gueDIsIGJveC55MSAqIHlTdHJldGNoKS5fcm90YXRlKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICB2YXIgYmwgPSBuZXcgUG9pbnQoYm94LngxLCBib3gueTIgKiB5U3RyZXRjaCkuX3JvdGF0ZShhbmdsZSk7XG4gICAgICAgICAgICAgICAgdmFyIGJyID0gbmV3IFBvaW50KGJveC54MiwgYm94LnkyICogeVN0cmV0Y2gpLl9yb3RhdGUoYW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIG1heFpvb20gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNSwgdGhpcy56b29tICsgTWF0aC5sb2coYm94Lm1heFNjYWxlKSAvIE1hdGguTE4yKSk7XG4gICAgICAgICAgICAgICAgdmFyIHBsYWNlbWVudFpvb20gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNSwgdGhpcy56b29tICsgTWF0aC5sb2coYm94LnBsYWNlbWVudFNjYWxlKSAvIE1hdGguTE4yKSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbGxpc2lvbkJveFZlcnRleChsYXlvdXRWZXJ0ZXhBcnJheSwgYW5jaG9yUG9pbnQsIHRsLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbGxpc2lvbkJveFZlcnRleChsYXlvdXRWZXJ0ZXhBcnJheSwgYW5jaG9yUG9pbnQsIHRyLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbGxpc2lvbkJveFZlcnRleChsYXlvdXRWZXJ0ZXhBcnJheSwgYW5jaG9yUG9pbnQsIHRyLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbGxpc2lvbkJveFZlcnRleChsYXlvdXRWZXJ0ZXhBcnJheSwgYW5jaG9yUG9pbnQsIGJyLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbGxpc2lvbkJveFZlcnRleChsYXlvdXRWZXJ0ZXhBcnJheSwgYW5jaG9yUG9pbnQsIGJyLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbGxpc2lvbkJveFZlcnRleChsYXlvdXRWZXJ0ZXhBcnJheSwgYW5jaG9yUG9pbnQsIGJsLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbGxpc2lvbkJveFZlcnRleChsYXlvdXRWZXJ0ZXhBcnJheSwgYW5jaG9yUG9pbnQsIGJsLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbGxpc2lvbkJveFZlcnRleChsYXlvdXRWZXJ0ZXhBcnJheSwgYW5jaG9yUG9pbnQsIHRsLCBtYXhab29tLCBwbGFjZW1lbnRab29tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblN5bWJvbEJ1Y2tldC5wcm90b3R5cGUuYWRkU3ltYm9sSW5zdGFuY2UgPSBmdW5jdGlvbihhbmNob3IsIGxpbmUsIHNoYXBlZFRleHQsIHNoYXBlZEljb24sIGxheWVyLCBhZGRUb0J1ZmZlcnMsIGluZGV4LCBjb2xsaXNpb25Cb3hBcnJheSwgZmVhdHVyZUluZGV4LCBzb3VyY2VMYXllckluZGV4LCBidWNrZXRJbmRleCxcbiAgICB0ZXh0Qm94U2NhbGUsIHRleHRQYWRkaW5nLCB0ZXh0QWxvbmdMaW5lLFxuICAgIGljb25Cb3hTY2FsZSwgaWNvblBhZGRpbmcsIGljb25BbG9uZ0xpbmUsIGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKSB7XG5cbiAgICB2YXIgZ2x5cGhRdWFkU3RhcnRJbmRleCwgZ2x5cGhRdWFkRW5kSW5kZXgsIGljb25RdWFkU3RhcnRJbmRleCwgaWNvblF1YWRFbmRJbmRleCwgdGV4dENvbGxpc2lvbkZlYXR1cmUsIGljb25Db2xsaXNpb25GZWF0dXJlLCBnbHlwaFF1YWRzLCBpY29uUXVhZHM7XG4gICAgaWYgKHNoYXBlZFRleHQpIHtcbiAgICAgICAgZ2x5cGhRdWFkcyA9IGFkZFRvQnVmZmVycyA/IGdldEdseXBoUXVhZHMoYW5jaG9yLCBzaGFwZWRUZXh0LCB0ZXh0Qm94U2NhbGUsIGxpbmUsIGxheWVyLCB0ZXh0QWxvbmdMaW5lKSA6IFtdO1xuICAgICAgICB0ZXh0Q29sbGlzaW9uRmVhdHVyZSA9IG5ldyBDb2xsaXNpb25GZWF0dXJlKGNvbGxpc2lvbkJveEFycmF5LCBsaW5lLCBhbmNob3IsIGZlYXR1cmVJbmRleCwgc291cmNlTGF5ZXJJbmRleCwgYnVja2V0SW5kZXgsIHNoYXBlZFRleHQsIHRleHRCb3hTY2FsZSwgdGV4dFBhZGRpbmcsIHRleHRBbG9uZ0xpbmUsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBnbHlwaFF1YWRTdGFydEluZGV4ID0gdGhpcy5zeW1ib2xRdWFkc0FycmF5Lmxlbmd0aDtcbiAgICBpZiAoZ2x5cGhRdWFkcyAmJiBnbHlwaFF1YWRzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBoUXVhZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU3ltYm9sUXVhZChnbHlwaFF1YWRzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnbHlwaFF1YWRFbmRJbmRleCA9IHRoaXMuc3ltYm9sUXVhZHNBcnJheS5sZW5ndGg7XG5cbiAgICB2YXIgdGV4dEJveFN0YXJ0SW5kZXggPSB0ZXh0Q29sbGlzaW9uRmVhdHVyZSA/IHRleHRDb2xsaXNpb25GZWF0dXJlLmJveFN0YXJ0SW5kZXggOiB0aGlzLmNvbGxpc2lvbkJveEFycmF5Lmxlbmd0aDtcbiAgICB2YXIgdGV4dEJveEVuZEluZGV4ID0gdGV4dENvbGxpc2lvbkZlYXR1cmUgPyB0ZXh0Q29sbGlzaW9uRmVhdHVyZS5ib3hFbmRJbmRleCA6IHRoaXMuY29sbGlzaW9uQm94QXJyYXkubGVuZ3RoO1xuXG4gICAgaWYgKHNoYXBlZEljb24pIHtcbiAgICAgICAgaWNvblF1YWRzID0gYWRkVG9CdWZmZXJzID8gZ2V0SWNvblF1YWRzKGFuY2hvciwgc2hhcGVkSWNvbiwgaWNvbkJveFNjYWxlLCBsaW5lLCBsYXllciwgaWNvbkFsb25nTGluZSwgc2hhcGVkVGV4dCwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIDogW107XG4gICAgICAgIGljb25Db2xsaXNpb25GZWF0dXJlID0gbmV3IENvbGxpc2lvbkZlYXR1cmUoY29sbGlzaW9uQm94QXJyYXksIGxpbmUsIGFuY2hvciwgZmVhdHVyZUluZGV4LCBzb3VyY2VMYXllckluZGV4LCBidWNrZXRJbmRleCwgc2hhcGVkSWNvbiwgaWNvbkJveFNjYWxlLCBpY29uUGFkZGluZywgaWNvbkFsb25nTGluZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWNvblF1YWRTdGFydEluZGV4ID0gdGhpcy5zeW1ib2xRdWFkc0FycmF5Lmxlbmd0aDtcbiAgICBpZiAoaWNvblF1YWRzICYmIGljb25RdWFkcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5hZGRTeW1ib2xRdWFkKGljb25RdWFkc1swXSk7XG4gICAgfVxuICAgIGljb25RdWFkRW5kSW5kZXggPSB0aGlzLnN5bWJvbFF1YWRzQXJyYXkubGVuZ3RoO1xuXG4gICAgdmFyIGljb25Cb3hTdGFydEluZGV4ID0gaWNvbkNvbGxpc2lvbkZlYXR1cmUgPyBpY29uQ29sbGlzaW9uRmVhdHVyZS5ib3hTdGFydEluZGV4IDogdGhpcy5jb2xsaXNpb25Cb3hBcnJheS5sZW5ndGg7XG4gICAgdmFyIGljb25Cb3hFbmRJbmRleCA9IGljb25Db2xsaXNpb25GZWF0dXJlID8gaWNvbkNvbGxpc2lvbkZlYXR1cmUuYm94RW5kSW5kZXggOiB0aGlzLmNvbGxpc2lvbkJveEFycmF5Lmxlbmd0aDtcbiAgICBpZiAoaWNvblF1YWRFbmRJbmRleCA+IFN5bWJvbEJ1Y2tldC5NQVhfUVVBRFMpIHV0aWwud2Fybk9uY2UoXCJUb28gbWFueSBzeW1ib2xzIGJlaW5nIHJlbmRlcmVkIGluIGEgdGlsZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzL2lzc3Vlcy8yOTA3XCIpO1xuICAgIGlmIChnbHlwaFF1YWRFbmRJbmRleCA+IFN5bWJvbEJ1Y2tldC5NQVhfUVVBRFMpIHV0aWwud2Fybk9uY2UoXCJUb28gbWFueSBnbHlwaHMgYmVpbmcgcmVuZGVyZWQgaW4gYSB0aWxlLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanMvaXNzdWVzLzI5MDdcIik7XG5cbiAgICByZXR1cm4gdGhpcy5zeW1ib2xJbnN0YW5jZXNBcnJheS5lbXBsYWNlQmFjayhcbiAgICAgICAgdGV4dEJveFN0YXJ0SW5kZXgsXG4gICAgICAgIHRleHRCb3hFbmRJbmRleCxcbiAgICAgICAgaWNvbkJveFN0YXJ0SW5kZXgsXG4gICAgICAgIGljb25Cb3hFbmRJbmRleCxcbiAgICAgICAgZ2x5cGhRdWFkU3RhcnRJbmRleCxcbiAgICAgICAgZ2x5cGhRdWFkRW5kSW5kZXgsXG4gICAgICAgIGljb25RdWFkU3RhcnRJbmRleCxcbiAgICAgICAgaWNvblF1YWRFbmRJbmRleCxcbiAgICAgICAgYW5jaG9yLngsXG4gICAgICAgIGFuY2hvci55LFxuICAgICAgICBpbmRleCk7XG59O1xuXG5TeW1ib2xCdWNrZXQucHJvdG90eXBlLmFkZFN5bWJvbFF1YWQgPSBmdW5jdGlvbihzeW1ib2xRdWFkKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ltYm9sUXVhZHNBcnJheS5lbXBsYWNlQmFjayhcbiAgICAgICAgLy8gYW5jaG9yUG9pbnRzXG4gICAgICAgIHN5bWJvbFF1YWQuYW5jaG9yUG9pbnQueCxcbiAgICAgICAgc3ltYm9sUXVhZC5hbmNob3JQb2ludC55LFxuICAgICAgICAvLyBjb3JuZXJzXG4gICAgICAgIHN5bWJvbFF1YWQudGwueCxcbiAgICAgICAgc3ltYm9sUXVhZC50bC55LFxuICAgICAgICBzeW1ib2xRdWFkLnRyLngsXG4gICAgICAgIHN5bWJvbFF1YWQudHIueSxcbiAgICAgICAgc3ltYm9sUXVhZC5ibC54LFxuICAgICAgICBzeW1ib2xRdWFkLmJsLnksXG4gICAgICAgIHN5bWJvbFF1YWQuYnIueCxcbiAgICAgICAgc3ltYm9sUXVhZC5ici55LFxuICAgICAgICAvLyB0ZXh0dXJlXG4gICAgICAgIHN5bWJvbFF1YWQudGV4LmgsXG4gICAgICAgIHN5bWJvbFF1YWQudGV4LncsXG4gICAgICAgIHN5bWJvbFF1YWQudGV4LngsXG4gICAgICAgIHN5bWJvbFF1YWQudGV4LnksXG4gICAgICAgIC8vYW5nbGVcbiAgICAgICAgc3ltYm9sUXVhZC5hbmNob3JBbmdsZSxcbiAgICAgICAgc3ltYm9sUXVhZC5nbHlwaEFuZ2xlLFxuICAgICAgICAvLyBzY2FsZXNcbiAgICAgICAgc3ltYm9sUXVhZC5tYXhTY2FsZSxcbiAgICAgICAgc3ltYm9sUXVhZC5taW5TY2FsZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcjtcblxuLyoqXG4gKiBUaGUgYEJ1ZmZlcmAgY2xhc3MgdHVybnMgYSBgU3RydWN0QXJyYXlgIGludG8gYSBXZWJHTCBidWZmZXIuIEVhY2ggbWVtYmVyIG9mIHRoZSBTdHJ1Y3RBcnJheSdzXG4gKiBTdHJ1Y3QgdHlwZSBpcyBjb252ZXJ0ZWQgdG8gYSBXZWJHTCBhdHJpYnV0ZS5cbiAqXG4gKiBAY2xhc3MgQnVmZmVyXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtvYmplY3R9IGFycmF5IEEgc2VyaWFsaXplZCBTdHJ1Y3RBcnJheS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBhcnJheVR5cGUgQSBzZXJpYWxpemVkIFN0cnVjdEFycmF5VHlwZS5cbiAqIEBwYXJhbSB7QnVmZmVyVHlwZX0gdHlwZVxuICovXG5mdW5jdGlvbiBCdWZmZXIoYXJyYXksIGFycmF5VHlwZSwgdHlwZSkge1xuICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBhcnJheS5hcnJheUJ1ZmZlcjtcbiAgICB0aGlzLmxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhcnJheVR5cGUubWVtYmVycztcbiAgICB0aGlzLml0ZW1TaXplID0gYXJyYXlUeXBlLmJ5dGVzUGVyRWxlbWVudDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuYXJyYXlUeXBlID0gYXJyYXlUeXBlO1xufVxuXG4vKipcbiAqIEJpbmQgdGhpcyBidWZmZXIgdG8gYSBXZWJHTCBjb250ZXh0LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBnbCBUaGUgV2ViR0wgY29udGV4dFxuICovXG5CdWZmZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihnbCkge1xuICAgIHZhciB0eXBlID0gZ2xbdGhpcy50eXBlXTtcblxuICAgIGlmICghdGhpcy5idWZmZXIpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcih0eXBlLCB0aGlzLmJ1ZmZlcik7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEodHlwZSwgdGhpcy5hcnJheUJ1ZmZlciwgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgICAgIC8vIGR1bXAgYXJyYXkgYnVmZmVyIG9uY2UgaXQncyBib3VuZCB0byBnbFxuICAgICAgICB0aGlzLmFycmF5QnVmZmVyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC5iaW5kQnVmZmVyKHR5cGUsIHRoaXMuYnVmZmVyKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9IEF0dHJpYnV0ZVR5cGVcbiAqIEBwcml2YXRlXG4gKiBAcmVhZG9ubHlcbiAqL1xudmFyIEF0dHJpYnV0ZVR5cGUgPSB7XG4gICAgSW50ODogICAnQllURScsXG4gICAgVWludDg6ICAnVU5TSUdORURfQllURScsXG4gICAgSW50MTY6ICAnU0hPUlQnLFxuICAgIFVpbnQxNjogJ1VOU0lHTkVEX1NIT1JUJ1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGF0dHJpYnV0ZSBwb2ludGVycyBpbiBhIFdlYkdMIGNvbnRleHRcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZ2wgVGhlIFdlYkdMIGNvbnRleHRcbiAqIEBwYXJhbSBwcm9ncmFtIFRoZSBhY3RpdmUgV2ViR0wgcHJvZ3JhbVxuICovXG5CdWZmZXIucHJvdG90eXBlLnNldFZlcnRleEF0dHJpYlBvaW50ZXJzID0gZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuYXR0cmlidXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbWVtYmVyID0gdGhpcy5hdHRyaWJ1dGVzW2pdO1xuICAgICAgICB2YXIgYXR0cmliSW5kZXggPSBwcm9ncmFtW21lbWJlci5uYW1lXTtcblxuICAgICAgICBpZiAoYXR0cmliSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgICAgICAgICBhdHRyaWJJbmRleCxcbiAgICAgICAgICAgICAgICBtZW1iZXIuY29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICBnbFtBdHRyaWJ1dGVUeXBlW21lbWJlci50eXBlXV0sXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgdGhpcy5hcnJheVR5cGUuYnl0ZXNQZXJFbGVtZW50LFxuICAgICAgICAgICAgICAgIG1lbWJlci5vZmZzZXRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIERlc3Ryb3kgdGhlIEdMIGJ1ZmZlciBib3VuZCB0byB0aGUgZ2l2ZW4gV2ViR0wgY29udGV4dFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBnbCBUaGUgV2ViR0wgY29udGV4dFxuICovXG5CdWZmZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihnbCkge1xuICAgIGlmICh0aGlzLmJ1ZmZlcikge1xuICAgICAgICBnbC5kZWxldGVCdWZmZXIodGhpcy5idWZmZXIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQGVudW0ge3N0cmluZ30gQnVmZmVyVHlwZVxuICogQHByaXZhdGVcbiAqIEByZWFkb25seVxuICovXG5CdWZmZXIuQnVmZmVyVHlwZSA9IHtcbiAgICBWRVJURVg6ICdBUlJBWV9CVUZGRVInLFxuICAgIEVMRU1FTlQ6ICdFTEVNRU5UX0FSUkFZX0JVRkZFUidcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXInKTtcbnZhciBWZXJ0ZXhBcnJheU9iamVjdCA9IHJlcXVpcmUoJy4uL3JlbmRlci92ZXJ0ZXhfYXJyYXlfb2JqZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyR3JvdXA7XG5cbmZ1bmN0aW9uIEJ1ZmZlckdyb3VwKGFycmF5R3JvdXAsIGFycmF5VHlwZXMpIHtcbiAgICB0aGlzLmxheW91dFZlcnRleEJ1ZmZlciA9IG5ldyBCdWZmZXIoYXJyYXlHcm91cC5sYXlvdXRWZXJ0ZXhBcnJheSxcbiAgICAgICAgYXJyYXlUeXBlcy5sYXlvdXRWZXJ0ZXhBcnJheVR5cGUsIEJ1ZmZlci5CdWZmZXJUeXBlLlZFUlRFWCk7XG5cbiAgICBpZiAoYXJyYXlHcm91cC5lbGVtZW50QXJyYXkpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50QnVmZmVyID0gbmV3IEJ1ZmZlcihhcnJheUdyb3VwLmVsZW1lbnRBcnJheSxcbiAgICAgICAgICAgIGFycmF5VHlwZXMuZWxlbWVudEFycmF5VHlwZSwgQnVmZmVyLkJ1ZmZlclR5cGUuRUxFTUVOVCk7XG4gICAgfVxuXG4gICAgdmFyIHZhb3MgPSB0aGlzLnZhb3MgPSB7fTtcbiAgICB2YXIgc2Vjb25kVmFvcztcblxuICAgIGlmIChhcnJheUdyb3VwLmVsZW1lbnRBcnJheTIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50QnVmZmVyMiA9IG5ldyBCdWZmZXIoYXJyYXlHcm91cC5lbGVtZW50QXJyYXkyLFxuICAgICAgICAgICAgYXJyYXlUeXBlcy5lbGVtZW50QXJyYXlUeXBlMiwgQnVmZmVyLkJ1ZmZlclR5cGUuRUxFTUVOVCk7XG4gICAgICAgIHNlY29uZFZhb3MgPSB0aGlzLnNlY29uZFZhb3MgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLnBhaW50VmVydGV4QnVmZmVycyA9IHV0aWwubWFwT2JqZWN0KGFycmF5R3JvdXAucGFpbnRWZXJ0ZXhBcnJheXMsIGZ1bmN0aW9uKGFycmF5LCBuYW1lKSB7XG4gICAgICAgIHZhb3NbbmFtZV0gPSBuZXcgVmVydGV4QXJyYXlPYmplY3QoKTtcbiAgICAgICAgaWYgKGFycmF5R3JvdXAuZWxlbWVudEFycmF5Mikge1xuICAgICAgICAgICAgc2Vjb25kVmFvc1tuYW1lXSA9IG5ldyBWZXJ0ZXhBcnJheU9iamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKGFycmF5LCBhcnJheVR5cGVzLnBhaW50VmVydGV4QXJyYXlUeXBlc1tuYW1lXSwgQnVmZmVyLkJ1ZmZlclR5cGUuVkVSVEVYKTtcbiAgICB9KTtcbn1cblxuQnVmZmVyR3JvdXAucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihnbCkge1xuICAgIHRoaXMubGF5b3V0VmVydGV4QnVmZmVyLmRlc3Ryb3koZ2wpO1xuICAgIGlmICh0aGlzLmVsZW1lbnRCdWZmZXIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50QnVmZmVyLmRlc3Ryb3koZ2wpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lbGVtZW50QnVmZmVyMikge1xuICAgICAgICB0aGlzLmVsZW1lbnRCdWZmZXIyLmRlc3Ryb3koZ2wpO1xuICAgIH1cbiAgICBmb3IgKHZhciBuIGluIHRoaXMucGFpbnRWZXJ0ZXhCdWZmZXJzKSB7XG4gICAgICAgIHRoaXMucGFpbnRWZXJ0ZXhCdWZmZXJzW25dLmRlc3Ryb3koZ2wpO1xuICAgIH1cbiAgICBmb3IgKHZhciBqIGluIHRoaXMudmFvcykge1xuICAgICAgICB0aGlzLnZhb3Nbal0uZGVzdHJveShnbCk7XG4gICAgfVxuICAgIGZvciAodmFyIGsgaW4gdGhpcy5zZWNvbmRWYW9zKSB7XG4gICAgICAgIHRoaXMuc2Vjb25kVmFvc1trXS5kZXN0cm95KGdsKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xudmFyIGxvYWRHZW9tZXRyeSA9IHJlcXVpcmUoJy4vbG9hZF9nZW9tZXRyeScpO1xudmFyIEVYVEVOVCA9IHJlcXVpcmUoJy4vYnVja2V0JykuRVhURU5UO1xudmFyIGZlYXR1cmVGaWx0ZXIgPSByZXF1aXJlKCdmZWF0dXJlLWZpbHRlcicpO1xudmFyIFN0cnVjdEFycmF5VHlwZSA9IHJlcXVpcmUoJy4uL3V0aWwvc3RydWN0X2FycmF5Jyk7XG52YXIgR3JpZCA9IHJlcXVpcmUoJ2dyaWQtaW5kZXgnKTtcbnZhciBEaWN0aW9uYXJ5Q29kZXIgPSByZXF1aXJlKCcuLi91dGlsL2RpY3Rpb25hcnlfY29kZXInKTtcbnZhciB2dCA9IHJlcXVpcmUoJ3ZlY3Rvci10aWxlJyk7XG52YXIgUHJvdG9idWYgPSByZXF1aXJlKCdwYmYnKTtcbnZhciBHZW9KU09ORmVhdHVyZSA9IHJlcXVpcmUoJy4uL3V0aWwvdmVjdG9ydGlsZV90b19nZW9qc29uJyk7XG52YXIgYXJyYXlzSW50ZXJzZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJykuYXJyYXlzSW50ZXJzZWN0O1xuXG52YXIgaW50ZXJzZWN0aW9uID0gcmVxdWlyZSgnLi4vdXRpbC9pbnRlcnNlY3Rpb25fdGVzdHMnKTtcbnZhciBtdWx0aVBvbHlnb25JbnRlcnNlY3RzQnVmZmVyZWRNdWx0aVBvaW50ID0gaW50ZXJzZWN0aW9uLm11bHRpUG9seWdvbkludGVyc2VjdHNCdWZmZXJlZE11bHRpUG9pbnQ7XG52YXIgbXVsdGlQb2x5Z29uSW50ZXJzZWN0c011bHRpUG9seWdvbiA9IGludGVyc2VjdGlvbi5tdWx0aVBvbHlnb25JbnRlcnNlY3RzTXVsdGlQb2x5Z29uO1xudmFyIG11bHRpUG9seWdvbkludGVyc2VjdHNCdWZmZXJlZE11bHRpTGluZSA9IGludGVyc2VjdGlvbi5tdWx0aVBvbHlnb25JbnRlcnNlY3RzQnVmZmVyZWRNdWx0aUxpbmU7XG5cblxudmFyIEZlYXR1cmVJbmRleEFycmF5ID0gbmV3IFN0cnVjdEFycmF5VHlwZSh7XG4gICAgbWVtYmVyczogW1xuICAgICAgICAvLyB0aGUgaW5kZXggb2YgdGhlIGZlYXR1cmUgaW4gdGhlIG9yaWdpbmFsIHZlY3RvcnRpbGVcbiAgICAgICAgeyB0eXBlOiAnVWludDMyJywgbmFtZTogJ2ZlYXR1cmVJbmRleCcgfSxcbiAgICAgICAgLy8gdGhlIHNvdXJjZSBsYXllciB0aGUgZmVhdHVyZSBhcHBlYXJzIGluXG4gICAgICAgIHsgdHlwZTogJ1VpbnQxNicsIG5hbWU6ICdzb3VyY2VMYXllckluZGV4JyB9LFxuICAgICAgICAvLyB0aGUgYnVja2V0IHRoZSBmZWF0dXJlIGFwcGVhcnMgaW5cbiAgICAgICAgeyB0eXBlOiAnVWludDE2JywgbmFtZTogJ2J1Y2tldEluZGV4JyB9XG4gICAgXX0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZlYXR1cmVJbmRleDtcblxuZnVuY3Rpb24gRmVhdHVyZUluZGV4KGNvb3JkLCBvdmVyc2NhbGluZywgY29sbGlzaW9uVGlsZSkge1xuICAgIGlmIChjb29yZC5ncmlkKSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVkID0gY29vcmQ7XG4gICAgICAgIHZhciByYXdUaWxlRGF0YSA9IG92ZXJzY2FsaW5nO1xuICAgICAgICBjb29yZCA9IHNlcmlhbGl6ZWQuY29vcmQ7XG4gICAgICAgIG92ZXJzY2FsaW5nID0gc2VyaWFsaXplZC5vdmVyc2NhbGluZztcbiAgICAgICAgdGhpcy5ncmlkID0gbmV3IEdyaWQoc2VyaWFsaXplZC5ncmlkKTtcbiAgICAgICAgdGhpcy5mZWF0dXJlSW5kZXhBcnJheSA9IG5ldyBGZWF0dXJlSW5kZXhBcnJheShzZXJpYWxpemVkLmZlYXR1cmVJbmRleEFycmF5KTtcbiAgICAgICAgdGhpcy5yYXdUaWxlRGF0YSA9IHJhd1RpbGVEYXRhO1xuICAgICAgICB0aGlzLmJ1Y2tldExheWVySURzID0gc2VyaWFsaXplZC5idWNrZXRMYXllcklEcztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmdyaWQgPSBuZXcgR3JpZChFWFRFTlQsIDE2LCAwKTtcbiAgICAgICAgdGhpcy5mZWF0dXJlSW5kZXhBcnJheSA9IG5ldyBGZWF0dXJlSW5kZXhBcnJheSgpO1xuICAgIH1cbiAgICB0aGlzLmNvb3JkID0gY29vcmQ7XG4gICAgdGhpcy5vdmVyc2NhbGluZyA9IG92ZXJzY2FsaW5nO1xuICAgIHRoaXMueCA9IGNvb3JkLng7XG4gICAgdGhpcy55ID0gY29vcmQueTtcbiAgICB0aGlzLnogPSBjb29yZC56IC0gTWF0aC5sb2cob3ZlcnNjYWxpbmcpIC8gTWF0aC5MTjI7XG4gICAgdGhpcy5zZXRDb2xsaXNpb25UaWxlKGNvbGxpc2lvblRpbGUpO1xufVxuXG5GZWF0dXJlSW5kZXgucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKGZlYXR1cmUsIGZlYXR1cmVJbmRleCwgc291cmNlTGF5ZXJJbmRleCwgYnVja2V0SW5kZXgpIHtcbiAgICB2YXIga2V5ID0gdGhpcy5mZWF0dXJlSW5kZXhBcnJheS5sZW5ndGg7XG4gICAgdGhpcy5mZWF0dXJlSW5kZXhBcnJheS5lbXBsYWNlQmFjayhmZWF0dXJlSW5kZXgsIHNvdXJjZUxheWVySW5kZXgsIGJ1Y2tldEluZGV4KTtcbiAgICB2YXIgZ2VvbWV0cnkgPSBsb2FkR2VvbWV0cnkoZmVhdHVyZSk7XG5cbiAgICBmb3IgKHZhciByID0gMDsgciA8IGdlb21ldHJ5Lmxlbmd0aDsgcisrKSB7XG4gICAgICAgIHZhciByaW5nID0gZ2VvbWV0cnlbcl07XG5cbiAgICAgICAgdmFyIGJib3ggPSBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHAgPSByaW5nW2ldO1xuICAgICAgICAgICAgYmJveFswXSA9IE1hdGgubWluKGJib3hbMF0sIHAueCk7XG4gICAgICAgICAgICBiYm94WzFdID0gTWF0aC5taW4oYmJveFsxXSwgcC55KTtcbiAgICAgICAgICAgIGJib3hbMl0gPSBNYXRoLm1heChiYm94WzJdLCBwLngpO1xuICAgICAgICAgICAgYmJveFszXSA9IE1hdGgubWF4KGJib3hbM10sIHAueSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdyaWQuaW5zZXJ0KGtleSwgYmJveFswXSwgYmJveFsxXSwgYmJveFsyXSwgYmJveFszXSk7XG4gICAgfVxufTtcblxuRmVhdHVyZUluZGV4LnByb3RvdHlwZS5zZXRDb2xsaXNpb25UaWxlID0gZnVuY3Rpb24oY29sbGlzaW9uVGlsZSkge1xuICAgIHRoaXMuY29sbGlzaW9uVGlsZSA9IGNvbGxpc2lvblRpbGU7XG59O1xuXG5GZWF0dXJlSW5kZXgucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgICBjb29yZDogdGhpcy5jb29yZCxcbiAgICAgICAgb3ZlcnNjYWxpbmc6IHRoaXMub3ZlcnNjYWxpbmcsXG4gICAgICAgIGdyaWQ6IHRoaXMuZ3JpZC50b0FycmF5QnVmZmVyKCksXG4gICAgICAgIGZlYXR1cmVJbmRleEFycmF5OiB0aGlzLmZlYXR1cmVJbmRleEFycmF5LnNlcmlhbGl6ZSgpLFxuICAgICAgICBidWNrZXRMYXllcklEczogdGhpcy5idWNrZXRMYXllcklEc1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgdHJhbnNmZXJhYmxlczogW2RhdGEuZ3JpZCwgZGF0YS5mZWF0dXJlSW5kZXhBcnJheS5hcnJheUJ1ZmZlcl1cbiAgICB9O1xufTtcblxuZnVuY3Rpb24gdHJhbnNsYXRlRGlzdGFuY2UodHJhbnNsYXRlKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0cmFuc2xhdGVbMF0gKiB0cmFuc2xhdGVbMF0gKyB0cmFuc2xhdGVbMV0gKiB0cmFuc2xhdGVbMV0pO1xufVxuXG4vLyBGaW5kcyBmZWF0dXJlcyBpbiB0aGlzIHRpbGUgYXQgYSBwYXJ0aWN1bGFyIHBvc2l0aW9uLlxuRmVhdHVyZUluZGV4LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKGFyZ3MsIHN0eWxlTGF5ZXJzKSB7XG4gICAgaWYgKCF0aGlzLnZ0TGF5ZXJzKSB7XG4gICAgICAgIHRoaXMudnRMYXllcnMgPSBuZXcgdnQuVmVjdG9yVGlsZShuZXcgUHJvdG9idWYobmV3IFVpbnQ4QXJyYXkodGhpcy5yYXdUaWxlRGF0YSkpKS5sYXllcnM7XG4gICAgICAgIHRoaXMuc291cmNlTGF5ZXJDb2RlciA9IG5ldyBEaWN0aW9uYXJ5Q29kZXIodGhpcy52dExheWVycyA/IE9iamVjdC5rZXlzKHRoaXMudnRMYXllcnMpLnNvcnQoKSA6IFsnX2dlb2pzb25UaWxlTGF5ZXInXSk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgdmFyIHBhcmFtcyA9IGFyZ3MucGFyYW1zIHx8IHt9LFxuICAgICAgICBwaXhlbHNUb1RpbGVVbml0cyA9IEVYVEVOVCAvIGFyZ3MudGlsZVNpemUgLyBhcmdzLnNjYWxlLFxuICAgICAgICBmaWx0ZXIgPSBmZWF0dXJlRmlsdGVyKHBhcmFtcy5maWx0ZXIpO1xuXG4gICAgLy8gRmVhdHVyZXMgYXJlIGluZGV4ZWQgdGhlaXIgb3JpZ2luYWwgZ2VvbWV0cmllcy4gVGhlIHJlbmRlcmVkIGdlb21ldHJpZXMgbWF5XG4gICAgLy8gYmUgYnVmZmVyZWQsIHRyYW5zbGF0ZWQgb3Igb2Zmc2V0LiBGaWd1cmUgb3V0IGhvdyBtdWNoIHRoZSBzZWFyY2ggcmFkaXVzIG5lZWRzIHRvIGJlXG4gICAgLy8gZXhwYW5kZWQgYnkgdG8gaW5jbHVkZSB0aGVzZSBmZWF0dXJlcy5cbiAgICB2YXIgYWRkaXRpb25hbFJhZGl1cyA9IDA7XG4gICAgZm9yICh2YXIgaWQgaW4gc3R5bGVMYXllcnMpIHtcbiAgICAgICAgdmFyIHN0eWxlTGF5ZXIgPSBzdHlsZUxheWVyc1tpZF07XG4gICAgICAgIHZhciBwYWludCA9IHN0eWxlTGF5ZXIucGFpbnQ7XG5cbiAgICAgICAgdmFyIHN0eWxlTGF5ZXJEaXN0YW5jZSA9IDA7XG4gICAgICAgIGlmIChzdHlsZUxheWVyLnR5cGUgPT09ICdsaW5lJykge1xuICAgICAgICAgICAgc3R5bGVMYXllckRpc3RhbmNlID0gZ2V0TGluZVdpZHRoKHBhaW50KSAvIDIgKyBNYXRoLmFicyhwYWludFsnbGluZS1vZmZzZXQnXSkgKyB0cmFuc2xhdGVEaXN0YW5jZShwYWludFsnbGluZS10cmFuc2xhdGUnXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3R5bGVMYXllci50eXBlID09PSAnZmlsbCcpIHtcbiAgICAgICAgICAgIHN0eWxlTGF5ZXJEaXN0YW5jZSA9IHRyYW5zbGF0ZURpc3RhbmNlKHBhaW50WydmaWxsLXRyYW5zbGF0ZSddKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZUxheWVyLnR5cGUgPT09ICdjaXJjbGUnKSB7XG4gICAgICAgICAgICBzdHlsZUxheWVyRGlzdGFuY2UgPSBwYWludFsnY2lyY2xlLXJhZGl1cyddICsgdHJhbnNsYXRlRGlzdGFuY2UocGFpbnRbJ2NpcmNsZS10cmFuc2xhdGUnXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3R5bGVMYXllci50eXBlID09PSAnZXh0cnVzaW9uJykge1xuICAgICAgICAgICAgc3R5bGVMYXllckRpc3RhbmNlID0gdHJhbnNsYXRlRGlzdGFuY2UocGFpbnRbJ2V4dHJ1c2lvbi10cmFuc2xhdGUnXSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkaXRpb25hbFJhZGl1cyA9IE1hdGgubWF4KGFkZGl0aW9uYWxSYWRpdXMsIHN0eWxlTGF5ZXJEaXN0YW5jZSAqIHBpeGVsc1RvVGlsZVVuaXRzKTtcbiAgICB9XG5cbiAgICB2YXIgcXVlcnlHZW9tZXRyeSA9IGFyZ3MucXVlcnlHZW9tZXRyeS5tYXAoZnVuY3Rpb24ocSkge1xuICAgICAgICByZXR1cm4gcS5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwLngsIHAueSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVlcnlHZW9tZXRyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmluZyA9IHF1ZXJ5R2VvbWV0cnlbaV07XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcmluZy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdmFyIHAgPSByaW5nW2tdO1xuICAgICAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHAueCk7XG4gICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgcC55KTtcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBwLngpO1xuICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHAueSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hpbmcgPSB0aGlzLmdyaWQucXVlcnkobWluWCAtIGFkZGl0aW9uYWxSYWRpdXMsIG1pblkgLSBhZGRpdGlvbmFsUmFkaXVzLCBtYXhYICsgYWRkaXRpb25hbFJhZGl1cywgbWF4WSArIGFkZGl0aW9uYWxSYWRpdXMpO1xuICAgIG1hdGNoaW5nLnNvcnQodG9wRG93bkZlYXR1cmVDb21wYXJhdG9yKTtcbiAgICB0aGlzLmZpbHRlck1hdGNoaW5nKHJlc3VsdCwgbWF0Y2hpbmcsIHRoaXMuZmVhdHVyZUluZGV4QXJyYXksIHF1ZXJ5R2VvbWV0cnksIGZpbHRlciwgcGFyYW1zLmxheWVycywgc3R5bGVMYXllcnMsIGFyZ3MuYmVhcmluZywgcGl4ZWxzVG9UaWxlVW5pdHMpO1xuXG4gICAgdmFyIG1hdGNoaW5nU3ltYm9scyA9IHRoaXMuY29sbGlzaW9uVGlsZS5xdWVyeVJlbmRlcmVkU3ltYm9scyhtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCBhcmdzLnNjYWxlKTtcbiAgICBtYXRjaGluZ1N5bWJvbHMuc29ydCgpO1xuICAgIHRoaXMuZmlsdGVyTWF0Y2hpbmcocmVzdWx0LCBtYXRjaGluZ1N5bWJvbHMsIHRoaXMuY29sbGlzaW9uVGlsZS5jb2xsaXNpb25Cb3hBcnJheSwgcXVlcnlHZW9tZXRyeSwgZmlsdGVyLCBwYXJhbXMubGF5ZXJzLCBzdHlsZUxheWVycywgYXJncy5iZWFyaW5nLCBwaXhlbHNUb1RpbGVVbml0cyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gdG9wRG93bkZlYXR1cmVDb21wYXJhdG9yKGEsIGIpIHtcbiAgICByZXR1cm4gYiAtIGE7XG59XG5cbmZ1bmN0aW9uIGdldExpbmVXaWR0aChwYWludCkge1xuICAgIGlmIChwYWludFsnbGluZS1nYXAtd2lkdGgnXSA+IDApIHtcbiAgICAgICAgcmV0dXJuIHBhaW50WydsaW5lLWdhcC13aWR0aCddICsgMiAqIHBhaW50WydsaW5lLXdpZHRoJ107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhaW50WydsaW5lLXdpZHRoJ107XG4gICAgfVxufVxuXG5GZWF0dXJlSW5kZXgucHJvdG90eXBlLmZpbHRlck1hdGNoaW5nID0gZnVuY3Rpb24ocmVzdWx0LCBtYXRjaGluZywgYXJyYXksIHF1ZXJ5R2VvbWV0cnksIGZpbHRlciwgZmlsdGVyTGF5ZXJJRHMsIHN0eWxlTGF5ZXJzLCBiZWFyaW5nLCBwaXhlbHNUb1RpbGVVbml0cykge1xuICAgIHZhciBwcmV2aW91c0luZGV4O1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbWF0Y2hpbmcubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbWF0Y2hpbmdba107XG5cbiAgICAgICAgLy8gZG9uJ3QgY2hlY2sgdGhlIHNhbWUgZmVhdHVyZSBtb3JlIHRoYW4gb25jZVxuICAgICAgICBpZiAoaW5kZXggPT09IHByZXZpb3VzSW5kZXgpIGNvbnRpbnVlO1xuICAgICAgICBwcmV2aW91c0luZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgdmFyIG1hdGNoID0gYXJyYXkuZ2V0KGluZGV4KTtcblxuICAgICAgICB2YXIgbGF5ZXJJRHMgPSB0aGlzLmJ1Y2tldExheWVySURzW21hdGNoLmJ1Y2tldEluZGV4XTtcbiAgICAgICAgaWYgKGZpbHRlckxheWVySURzICYmICFhcnJheXNJbnRlcnNlY3QoZmlsdGVyTGF5ZXJJRHMsIGxheWVySURzKSkgY29udGludWU7XG5cbiAgICAgICAgdmFyIHNvdXJjZUxheWVyTmFtZSA9IHRoaXMuc291cmNlTGF5ZXJDb2Rlci5kZWNvZGUobWF0Y2guc291cmNlTGF5ZXJJbmRleCk7XG4gICAgICAgIHZhciBzb3VyY2VMYXllciA9IHRoaXMudnRMYXllcnNbc291cmNlTGF5ZXJOYW1lXTtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBzb3VyY2VMYXllci5mZWF0dXJlKG1hdGNoLmZlYXR1cmVJbmRleCk7XG5cbiAgICAgICAgaWYgKCFmaWx0ZXIoZmVhdHVyZSkpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG51bGw7XG5cbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsYXllcklEcy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgdmFyIGxheWVySUQgPSBsYXllcklEc1tsXTtcblxuICAgICAgICAgICAgaWYgKGZpbHRlckxheWVySURzICYmIGZpbHRlckxheWVySURzLmluZGV4T2YobGF5ZXJJRCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdHlsZUxheWVyID0gc3R5bGVMYXllcnNbbGF5ZXJJRF07XG4gICAgICAgICAgICBpZiAoIXN0eWxlTGF5ZXIpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB2YXIgdHJhbnNsYXRlZFBvbHlnb247XG4gICAgICAgICAgICBpZiAoc3R5bGVMYXllci50eXBlICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIC8vIGFsbCBzeW1ib2xzIGFscmVhZHkgbWF0Y2ggdGhlIHN0eWxlXG5cbiAgICAgICAgICAgICAgICBpZiAoIWdlb21ldHJ5KSBnZW9tZXRyeSA9IGxvYWRHZW9tZXRyeShmZWF0dXJlKTtcblxuICAgICAgICAgICAgICAgIHZhciBwYWludCA9IHN0eWxlTGF5ZXIucGFpbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVMYXllci50eXBlID09PSAnbGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlZFBvbHlnb24gPSB0cmFuc2xhdGUocXVlcnlHZW9tZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWludFsnbGluZS10cmFuc2xhdGUnXSwgcGFpbnRbJ2xpbmUtdHJhbnNsYXRlLWFuY2hvciddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlYXJpbmcsIHBpeGVsc1RvVGlsZVVuaXRzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbGZXaWR0aCA9IGdldExpbmVXaWR0aChwYWludCkgLyAyICogcGl4ZWxzVG9UaWxlVW5pdHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWludFsnbGluZS1vZmZzZXQnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkgPSBvZmZzZXRMaW5lKGdlb21ldHJ5LCBwYWludFsnbGluZS1vZmZzZXQnXSAqIHBpeGVsc1RvVGlsZVVuaXRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW11bHRpUG9seWdvbkludGVyc2VjdHNCdWZmZXJlZE11bHRpTGluZSh0cmFuc2xhdGVkUG9seWdvbiwgZ2VvbWV0cnksIGhhbGZXaWR0aCkpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZUxheWVyLnR5cGUgPT09ICdmaWxsJykge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVkUG9seWdvbiA9IHRyYW5zbGF0ZShxdWVyeUdlb21ldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhaW50WydmaWxsLXRyYW5zbGF0ZSddLCBwYWludFsnZmlsbC10cmFuc2xhdGUtYW5jaG9yJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVhcmluZywgcGl4ZWxzVG9UaWxlVW5pdHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW11bHRpUG9seWdvbkludGVyc2VjdHNNdWx0aVBvbHlnb24odHJhbnNsYXRlZFBvbHlnb24sIGdlb21ldHJ5KSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlTGF5ZXIudHlwZSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlZFBvbHlnb24gPSB0cmFuc2xhdGUocXVlcnlHZW9tZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWludFsnY2lyY2xlLXRyYW5zbGF0ZSddLCBwYWludFsnY2lyY2xlLXRyYW5zbGF0ZS1hbmNob3InXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWFyaW5nLCBwaXhlbHNUb1RpbGVVbml0cyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaXJjbGVSYWRpdXMgPSBwYWludFsnY2lyY2xlLXJhZGl1cyddICogcGl4ZWxzVG9UaWxlVW5pdHM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbXVsdGlQb2x5Z29uSW50ZXJzZWN0c0J1ZmZlcmVkTXVsdGlQb2ludCh0cmFuc2xhdGVkUG9seWdvbiwgZ2VvbWV0cnksIGNpcmNsZVJhZGl1cykpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGVMYXllci50eXBlID09PSAnZXh0cnVzaW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ2VvanNvbkZlYXR1cmUgPSBuZXcgR2VvSlNPTkZlYXR1cmUoZmVhdHVyZSwgdGhpcy56LCB0aGlzLngsIHRoaXMueSk7XG4gICAgICAgICAgICBnZW9qc29uRmVhdHVyZS5sYXllciA9IHN0eWxlTGF5ZXIuc2VyaWFsaXplKHtcbiAgICAgICAgICAgICAgICBpbmNsdWRlUmVmUHJvcGVydGllczogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbGF5ZXJSZXN1bHQgPSByZXN1bHRbbGF5ZXJJRF07XG4gICAgICAgICAgICBpZiAobGF5ZXJSZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxheWVyUmVzdWx0ID0gcmVzdWx0W2xheWVySURdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXllclJlc3VsdC5wdXNoKGdlb2pzb25GZWF0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZShxdWVyeUdlb21ldHJ5LCB0cmFuc2xhdGUsIHRyYW5zbGF0ZUFuY2hvciwgYmVhcmluZywgcGl4ZWxzVG9UaWxlVW5pdHMpIHtcbiAgICBpZiAoIXRyYW5zbGF0ZVswXSAmJiAhdHJhbnNsYXRlWzFdKSB7XG4gICAgICAgIHJldHVybiBxdWVyeUdlb21ldHJ5O1xuICAgIH1cblxuICAgIHRyYW5zbGF0ZSA9IFBvaW50LmNvbnZlcnQodHJhbnNsYXRlKTtcblxuICAgIGlmICh0cmFuc2xhdGVBbmNob3IgPT09IFwidmlld3BvcnRcIikge1xuICAgICAgICB0cmFuc2xhdGUuX3JvdGF0ZSgtYmVhcmluZyk7XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zbGF0ZWQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXJ5R2VvbWV0cnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSBxdWVyeUdlb21ldHJ5W2ldO1xuICAgICAgICB2YXIgdHJhbnNsYXRlZFJpbmcgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCByaW5nLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB0cmFuc2xhdGVkUmluZy5wdXNoKHJpbmdba10uc3ViKHRyYW5zbGF0ZS5fbXVsdChwaXhlbHNUb1RpbGVVbml0cykpKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2xhdGVkLnB1c2godHJhbnNsYXRlZFJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNsYXRlZDtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0TGluZShyaW5ncywgb2Zmc2V0KSB7XG4gICAgdmFyIG5ld1JpbmdzID0gW107XG4gICAgdmFyIHplcm8gPSBuZXcgUG9pbnQoMCwgMCk7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCByaW5ncy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgcmluZyA9IHJpbmdzW2tdO1xuICAgICAgICB2YXIgbmV3UmluZyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhID0gcmluZ1tpIC0gMV07XG4gICAgICAgICAgICB2YXIgYiA9IHJpbmdbaV07XG4gICAgICAgICAgICB2YXIgYyA9IHJpbmdbaSArIDFdO1xuICAgICAgICAgICAgdmFyIGFUb0IgPSBpID09PSAwID8gemVybyA6IGIuc3ViKGEpLl91bml0KCkuX3BlcnAoKTtcbiAgICAgICAgICAgIHZhciBiVG9DID0gaSA9PT0gcmluZy5sZW5ndGggLSAxID8gemVybyA6IGMuc3ViKGIpLl91bml0KCkuX3BlcnAoKTtcbiAgICAgICAgICAgIHZhciBleHRydWRlID0gYVRvQi5fYWRkKGJUb0MpLl91bml0KCk7XG5cbiAgICAgICAgICAgIHZhciBjb3NIYWxmQW5nbGUgPSBleHRydWRlLnggKiBiVG9DLnggKyBleHRydWRlLnkgKiBiVG9DLnk7XG4gICAgICAgICAgICBleHRydWRlLl9tdWx0KDEgLyBjb3NIYWxmQW5nbGUpO1xuXG4gICAgICAgICAgICBuZXdSaW5nLnB1c2goZXh0cnVkZS5fbXVsdChvZmZzZXQpLl9hZGQoYikpO1xuICAgICAgICB9XG4gICAgICAgIG5ld1JpbmdzLnB1c2gobmV3UmluZyk7XG4gICAgfVxuICAgIHJldHVybiBuZXdSaW5ncztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBFWFRFTlQgPSByZXF1aXJlKCcuL2J1Y2tldCcpLkVYVEVOVDtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxuXG4vLyBUaGVzZSBib3VuZHMgZGVmaW5lIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHN1cHBvcnRlZCBjb29yZGluYXRlIHZhbHVlcy5cbi8vIFdoaWxlIHZpc2libGUgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiBbMCwgRVhURU5UXSwgdGlsZXMgbWF5IHRoZW9yZXRpY2FsbHlcbi8vIGNvbnRhaW4gY29yZGluYXRlcyB3aXRoaW4gWy1JbmZpbml0eSwgSW5maW5pdHldLiBPdXIgcmFuZ2UgaXMgbGltaXRlZCBieSB0aGVcbi8vIG51bWJlciBvZiBiaXRzIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBjb29yZGluYXRlLlxuZnVuY3Rpb24gY3JlYXRlQm91bmRzKGJpdHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtaW46IC0xICogTWF0aC5wb3coMiwgYml0cyAtIDEpLFxuICAgICAgICBtYXg6IE1hdGgucG93KDIsIGJpdHMgLSAxKSAtIDFcbiAgICB9O1xufVxuXG52YXIgYm91bmRzTG9va3VwID0ge1xuICAgIDE1OiBjcmVhdGVCb3VuZHMoMTUpLFxuICAgIDE2OiBjcmVhdGVCb3VuZHMoMTYpXG59O1xuXG4vKipcbiAqIExvYWRzIGEgZ2VvbWV0cnkgZnJvbSBhIFZlY3RvclRpbGVGZWF0dXJlIGFuZCBzY2FsZXMgaXQgdG8gdGhlIGNvbW1vbiBleHRlbnRcbiAqIHVzZWQgaW50ZXJuYWxseS5cbiAqIEBwYXJhbSB7VmVjdG9yVGlsZUZlYXR1cmV9IGZlYXR1cmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYml0cz0xNl0gVGhlIG51bWJlciBvZiBzaWduZWQgaW50ZWdlciBiaXRzIGF2YWlsYWJsZSB0byBzdG9yZVxuICogICBlYWNoIGNvb3JkaW5hdGUuIEEgd2FybmluZyB3aWxsIGJlIGlzc3VlZCBpZiBhbnkgY29vcmRpbmF0ZSB3aWxsIG5vdCBmaXRzXG4gKiAgIGluIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJpdHMuXG4gKiBAcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxvYWRHZW9tZXRyeShmZWF0dXJlLCBiaXRzKSB7XG4gICAgdmFyIGJvdW5kcyA9IGJvdW5kc0xvb2t1cFtiaXRzIHx8IDE2XTtcbiAgICBhc3NlcnQoYm91bmRzKTtcblxuICAgIHZhciBzY2FsZSA9IEVYVEVOVCAvIGZlYXR1cmUuZXh0ZW50O1xuICAgIHZhciBnZW9tZXRyeSA9IGZlYXR1cmUubG9hZEdlb21ldHJ5KCk7XG4gICAgZm9yICh2YXIgciA9IDA7IHIgPCBnZW9tZXRyeS5sZW5ndGg7IHIrKykge1xuICAgICAgICB2YXIgcmluZyA9IGdlb21ldHJ5W3JdO1xuICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHJpbmcubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IHJpbmdbcF07XG4gICAgICAgICAgICAvLyByb3VuZCBoZXJlIGJlY2F1c2UgbWFwYm94LWdsLW5hdGl2ZSB1c2VzIGludGVnZXJzIHRvIHJlcHJlc2VudFxuICAgICAgICAgICAgLy8gcG9pbnRzIGFuZCB3ZSBuZWVkIHRvIGRvIHRoZSBzYW1lIHRvIGF2b2lkIHJlbmVyaW5nIGRpZmZlcmVuY2VzLlxuICAgICAgICAgICAgcG9pbnQueCA9IE1hdGgucm91bmQocG9pbnQueCAqIHNjYWxlKTtcbiAgICAgICAgICAgIHBvaW50LnkgPSBNYXRoLnJvdW5kKHBvaW50LnkgKiBzY2FsZSk7XG5cbiAgICAgICAgICAgIGlmIChwb2ludC54IDwgYm91bmRzLm1pbiB8fCBwb2ludC54ID4gYm91bmRzLm1heCB8fCBwb2ludC55IDwgYm91bmRzLm1pbiB8fCBwb2ludC55ID4gYm91bmRzLm1heCkge1xuICAgICAgICAgICAgICAgIHV0aWwud2Fybk9uY2UoJ0dlb21ldHJ5IGV4Y2VlZHMgYWxsb3dlZCBleHRlbnQsIHJlZHVjZSB5b3VyIHZlY3RvciB0aWxlIGJ1ZmZlciBzaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBDb29yZGluYXRlO1xuXG4vKipcbiAqIEEgY29vcmRpbmF0ZSBpcyBhIGNvbHVtbiwgcm93LCB6b29tIGNvbWJpbmF0aW9uLCBvZnRlbiB1c2VkXG4gKiBhcyB0aGUgZGF0YSBjb21wb25lbnQgb2YgYSB0aWxlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSB6b29tXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBDb29yZGluYXRlKGNvbHVtbiwgcm93LCB6b29tKSB7XG4gICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgdGhpcy5yb3cgPSByb3c7XG4gICAgdGhpcy56b29tID0gem9vbTtcbn1cblxuQ29vcmRpbmF0ZS5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjbG9uZSBvZiB0aGlzIGNvb3JkaW5hdGUgdGhhdCBjYW4gYmUgbXV0YXRlZCB3aXRob3V0XG4gICAgICogY2hhbmdpbmcgdGhlIG9yaWdpbmFsIGNvb3JkaW5hdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb29yZGluYXRlfSBjbG9uZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogdmFyIGNvb3JkID0gbmV3IENvb3JkaW5hdGUoMCwgMCwgMCk7XG4gICAgICogdmFyIGMyID0gY29vcmQuY2xvbmUoKTtcbiAgICAgKiAvLyBzaW5jZSBjb29yZCBpcyBjbG9uZWQsIG1vZGlmeWluZyBhIHByb3BlcnR5IG9mIGMyIGRvZXNcbiAgICAgKiAvLyBub3QgbW9kaWZ5IGl0LlxuICAgICAqIGMyLnpvb20gPSAyO1xuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb29yZGluYXRlKHRoaXMuY29sdW1uLCB0aGlzLnJvdywgdGhpcy56b29tKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWm9vbSB0aGlzIGNvb3JkaW5hdGUgdG8gYSBnaXZlbiB6b29tIGxldmVsLiBUaGlzIHJldHVybnMgYSBuZXdcbiAgICAgKiBjb29yZGluYXRlIG9iamVjdCwgbm90IG11dGF0aW5nIHRoZSBvbGQgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpvb21cbiAgICAgKiBAcmV0dXJucyB7Q29vcmRpbmF0ZX0gem9vbWVkIGNvb3JkaW5hdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGNvb3JkID0gbmV3IENvb3JkaW5hdGUoMCwgMCwgMCk7XG4gICAgICogdmFyIGMyID0gY29vcmQuem9vbVRvKDEpO1xuICAgICAqIGMyIC8vIGVxdWFscyBuZXcgQ29vcmRpbmF0ZSgwLCAwLCAxKTtcbiAgICAgKi9cbiAgICB6b29tVG86IGZ1bmN0aW9uKHpvb20pIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fem9vbVRvKHpvb20pOyB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3QgdGhlIGNvbHVtbiBhbmQgcm93IHZhbHVlcyBvZiB0aGlzIGNvb3JkaW5hdGUgZnJvbSB0aG9zZVxuICAgICAqIG9mIGFub3RoZXIgY29vcmRpbmF0ZS4gVGhlIG90aGVyIGNvb3JkaW5hdCB3aWxsIGJlIHpvb21lZCB0byB0aGVcbiAgICAgKiBzYW1lIGxldmVsIGFzIGB0aGlzYCBiZWZvcmUgdGhlIHN1YnRyYWN0aW9uIG9jY3Vyc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjIG90aGVyIGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7Q29vcmRpbmF0ZX0gcmVzdWx0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdWI6IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fc3ViKGMpOyB9LFxuXG4gICAgX3pvb21UbzogZnVuY3Rpb24oem9vbSkge1xuICAgICAgICB2YXIgc2NhbGUgPSBNYXRoLnBvdygyLCB6b29tIC0gdGhpcy56b29tKTtcbiAgICAgICAgdGhpcy5jb2x1bW4gKj0gc2NhbGU7XG4gICAgICAgIHRoaXMucm93ICo9IHNjYWxlO1xuICAgICAgICB0aGlzLnpvb20gPSB6b29tO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3N1YjogZnVuY3Rpb24oYykge1xuICAgICAgICBjID0gYy56b29tVG8odGhpcy56b29tKTtcbiAgICAgICAgdGhpcy5jb2x1bW4gLT0gYy5jb2x1bW47XG4gICAgICAgIHRoaXMucm93IC09IGMucm93O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExuZ0xhdDtcblxudmFyIHdyYXAgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKS53cmFwO1xuXG4vKipcbiAqIEEgYExuZ0xhdGAgb2JqZWN0IHJlcHJlc2VudHMgYSBnaXZlbiBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIGNvb3JkaW5hdGUsIG1lYXN1cmVkIGluIGRlZ3JlZXMuXG4gKlxuICogTWFwYm94IEdMIHVzZXMgbG9uZ2l0dWRlLCBsYXRpdHVkZSBjb29yZGluYXRlIG9yZGVyIChhcyBvcHBvc2VkIHRvIGxhdGl0dWRlLCBsb25naXR1ZGUpIHRvIG1hdGNoIEdlb0pTT04uXG4gKlxuICogTm90ZSB0aGF0IGFueSBNYXBib3ggR0wgbWV0aG9kIHRoYXQgYWNjZXB0cyBhIGBMbmdMYXRgIG9iamVjdCBhcyBhbiBhcmd1bWVudCBvciBvcHRpb25cbiAqIGNhbiBhbHNvIGFjY2VwdCBhbiBgQXJyYXlgIG9mIHR3byBudW1iZXJzIGFuZCB3aWxsIHBlcmZvcm0gYW4gaW1wbGljaXQgY29udmVyc2lvbi5cbiAqIFRoaXMgZmxleGlibGUgdHlwZSBpcyBkb2N1bWVudGVkIGFzIFtgTG5nTGF0TGlrZWBdKCNMbmdMYXRMaWtlKS5cbiAqXG4gKiBAY2xhc3MgTG5nTGF0XG4gKiBAcGFyYW0ge251bWJlcn0gbG5nIExvbmdpdHVkZSwgbWVhc3VyZWQgaW4gZGVncmVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsYXQgTGF0aXR1ZGUsIG1lYXN1cmVkIGluIGRlZ3JlZXMuXG4gKiBAZXhhbXBsZVxuICogdmFyIGxsID0gbmV3IG1hcGJveGdsLkxuZ0xhdCgtNzMuOTc0OSwgNDAuNzczNik7XG4gKi9cbmZ1bmN0aW9uIExuZ0xhdChsbmcsIGxhdCkge1xuICAgIGlmIChpc05hTihsbmcpIHx8IGlzTmFOKGxhdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExuZ0xhdCBvYmplY3Q6ICgnICsgbG5nICsgJywgJyArIGxhdCArICcpJyk7XG4gICAgfVxuICAgIHRoaXMubG5nID0gK2xuZztcbiAgICB0aGlzLmxhdCA9ICtsYXQ7XG4gICAgaWYgKHRoaXMubGF0ID4gOTAgfHwgdGhpcy5sYXQgPCAtOTApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExuZ0xhdCBsYXRpdHVkZSB2YWx1ZTogbXVzdCBiZSBiZXR3ZWVuIC05MCBhbmQgOTAnKTtcbiAgICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBgTG5nTGF0YCBvYmplY3Qgd2hvc2UgbG9uZ2l0dWRlIGlzIHdyYXBwZWQgdG8gdGhlIHJhbmdlICgtMTgwLCAxODApLlxuICpcbiAqIEByZXR1cm5zIHtMbmdMYXR9IFRoZSB3cmFwcGVkIGBMbmdMYXRgIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgbGwgPSBuZXcgbWFwYm94Z2wuTG5nTGF0KDI4Ni4wMjUxLCA0MC43NzM2KTtcbiAqIHZhciB3cmFwcGVkID0gbGwud3JhcCgpO1xuICogd3JhcHBlZC5sbmc7IC8vID0gLTczLjk3NDlcbiAqL1xuTG5nTGF0LnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgTG5nTGF0KHdyYXAodGhpcy5sbmcsIC0xODAsIDE4MCksIHRoaXMubGF0KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2YgdHdvIG51bWJlcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IFRoZSBjb29yZGluYXRlcyByZXByZXNldGVkIGFzIGFuIGFycmF5IG9mIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUuXG4gKiBAZXhhbXBsZVxuICogdmFyIGxsID0gbmV3IG1hcGJveGdsLkxuZ0xhdCgtNzMuOTc0OSwgNDAuNzczNik7XG4gKiBsbC50b0FycmF5KCk7IC8vID0gWy03My45NzQ5LCA0MC43NzM2XVxuICovXG5MbmdMYXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmxuZywgdGhpcy5sYXRdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyByZXByZXNlbnQgYXMgYSBzdHJpbmcuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvb3JkaW5hdGVzIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nIG9mIHRoZSBmb3JtYXQgYCdMbmdMYXQobG5nLCBsYXQpJ2AuXG4gKiBAZXhhbXBsZVxuICogdmFyIGxsID0gbmV3IG1hcGJveGdsLkxuZ0xhdCgtNzMuOTc0OSwgNDAuNzczNik7XG4gKiBsbC50b1N0cmluZygpOyAvLyA9IFwiTG5nTGF0KC03My45NzQ5LCA0MC43NzM2KVwiXG4gKi9cbkxuZ0xhdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdMbmdMYXQoJyArIHRoaXMubG5nICsgJywgJyArIHRoaXMubGF0ICsgJyknO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvZiB0d28gbnVtYmVycyB0byBhIGBMbmdMYXRgIG9iamVjdC5cbiAqXG4gKiBJZiBhIGBMbmdMYXRgIG9iamVjdCBpcyBwYXNzZWQgaW4sIHRoZSBmdW5jdGlvbiByZXR1cm5zIGl0IHVuY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge0xuZ0xhdExpa2V9IGlucHV0IEFuIGFycmF5IG9mIHR3byBudW1iZXJzIHRvIGNvbnZlcnQsIG9yIGEgYExuZ0xhdGAgb2JqZWN0IHRvIHJldHVybi5cbiAqIEByZXR1cm5zIHtMbmdMYXR9IEEgbmV3IGBMbmdMYXRgIG9iamVjdCwgaWYgYSBjb252ZXJzaW9uIG9jY3VycmVkLCBvciB0aGUgb3JpZ2luYWwgYExuZ0xhdGAgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqIHZhciBhcnIgPSBbLTczLjk3NDksIDQwLjc3MzZdO1xuICogdmFyIGxsID0gbWFwYm94Z2wuTG5nTGF0LmNvbnZlcnQoYXJyKTtcbiAqIGxsOyAgIC8vID0gTG5nTGF0IHtsbmc6IC03My45NzQ5LCBsYXQ6IDQwLjc3MzZ9XG4gKi9cbkxuZ0xhdC5jb252ZXJ0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgTG5nTGF0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG5nTGF0KGlucHV0WzBdLCBpbnB1dFsxXSk7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gTG5nTGF0Qm91bmRzO1xuXG52YXIgTG5nTGF0ID0gcmVxdWlyZSgnLi9sbmdfbGF0Jyk7XG5cbi8qKlxuICogQSBgTG5nTGF0Qm91bmRzYCBvYmplY3QgcmVwcmVzZW50cyBhIGdlb2dyYXBoaWNhbCBib3VuZGluZyBib3gsXG4gKiBkZWZpbmVkIGJ5IGl0cyBzb3V0aHdlc3QgYW5kIG5vcnRoZWFzdCBwb2ludHMgaW4gbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZS5cbiAqXG4gKiBJZiBubyBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3RvciwgYSBgbnVsbGAgYm91bmRpbmcgYm94IGlzIGNyZWF0ZWQuXG4gKlxuICogTm90ZSB0aGF0IGFueSBNYXBib3ggR0wgbWV0aG9kIHRoYXQgYWNjZXB0cyBhIGBMbmdMYXRCb3VuZHNgIG9iamVjdCBhcyBhbiBhcmd1bWVudCBvciBvcHRpb25cbiAqIGNhbiBhbHNvIGFjY2VwdCBhbiBgQXJyYXlgIG9mIHR3byBbYExuZ0xhdExpa2VgXSgjTG5nTGF0TGlrZSkgY29uc3RydWN0cyBhbmQgd2lsbCBwZXJmb3JtIGFuIGltcGxpY2l0IGNvbnZlcnNpb24uXG4gKiBUaGlzIGZsZXhpYmxlIHR5cGUgaXMgZG9jdW1lbnRlZCBhcyBbYExuZ0xhdEJvdW5kc0xpa2VgXSgjTG5nTGF0Qm91bmRzTGlrZSkuXG4gKlxuICogQGNsYXNzIExuZ0xhdEJvdW5kc1xuICogQHBhcmFtIHtMbmdMYXRMaWtlfSBzdyBUaGUgc291dGh3ZXN0IGNvcm5lciBvZiB0aGUgYm91bmRpbmcgYm94LlxuICogQHBhcmFtIHtMbmdMYXRMaWtlfSBuZSBUaGUgbm9ydGhlYXN0IGNvcm5lciBvZiB0aGUgYm91bmRpbmcgYm94LlxuICogQGV4YW1wbGVcbiAqIHZhciBzdyA9IG5ldyBtYXBib3hnbC5MbmdMYXQoLTczLjk4NzYsIDQwLjc2NjEpO1xuICogdmFyIG5lID0gbmV3IG1hcGJveGdsLkxuZ0xhdCgtNzMuOTM5NywgNDAuODAwMik7XG4gKiB2YXIgbGxiID0gbmV3IG1hcGJveGdsLkxuZ0xhdEJvdW5kcyhzdywgbmUpO1xuICovXG5mdW5jdGlvbiBMbmdMYXRCb3VuZHMoc3csIG5lKSB7XG4gICAgaWYgKCFzdykge1xuICAgICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChuZSkge1xuICAgICAgICB0aGlzLmV4dGVuZChzdykuZXh0ZW5kKG5lKTtcbiAgICB9IGVsc2UgaWYgKHN3Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICB0aGlzLmV4dGVuZChbc3dbMF0sIHN3WzFdXSkuZXh0ZW5kKFtzd1syXSwgc3dbM11dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4dGVuZChzd1swXSkuZXh0ZW5kKHN3WzFdKTtcbiAgICB9XG59XG5cbkxuZ0xhdEJvdW5kcy5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmRzIHRoZSBib3VuZGluZyBib3ggdG8gaW5jbHVkZSBhbiBhcmVhIHJlcHJlc2VudGVkIGJ5IGEgYExuZ0xhdGAgb3IgYExuZ0xhdEJvdW5kc2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xuZ0xhdExpa2V8TG5nTGF0Qm91bmRzTGlrZX0gb2JqIFRoZSBhcmVhIHRoYXQgdGhlIGJvdW5kaW5nIGJveCB3aWxsIGV4dGVuZCB0byBpbmNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtMbmdMYXRCb3VuZHN9IGB0aGlzYFxuICAgICAqL1xuICAgIGV4dGVuZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHZhciBzdyA9IHRoaXMuX3N3LFxuICAgICAgICAgICAgbmUgPSB0aGlzLl9uZSxcbiAgICAgICAgICAgIHN3MiwgbmUyO1xuXG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBMbmdMYXQpIHtcbiAgICAgICAgICAgIHN3MiA9IG9iajtcbiAgICAgICAgICAgIG5lMiA9IG9iajtcblxuICAgICAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExuZ0xhdEJvdW5kcykge1xuICAgICAgICAgICAgc3cyID0gb2JqLl9zdztcbiAgICAgICAgICAgIG5lMiA9IG9iai5fbmU7XG5cbiAgICAgICAgICAgIGlmICghc3cyIHx8ICFuZTIpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqID8gdGhpcy5leHRlbmQoTG5nTGF0LmNvbnZlcnQob2JqKSB8fCBMbmdMYXRCb3VuZHMuY29udmVydChvYmopKSA6IHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN3ICYmICFuZSkge1xuICAgICAgICAgICAgdGhpcy5fc3cgPSBuZXcgTG5nTGF0KHN3Mi5sbmcsIHN3Mi5sYXQpO1xuICAgICAgICAgICAgdGhpcy5fbmUgPSBuZXcgTG5nTGF0KG5lMi5sbmcsIG5lMi5sYXQpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdy5sbmcgPSBNYXRoLm1pbihzdzIubG5nLCBzdy5sbmcpO1xuICAgICAgICAgICAgc3cubGF0ID0gTWF0aC5taW4oc3cyLmxhdCwgc3cubGF0KTtcbiAgICAgICAgICAgIG5lLmxuZyA9IE1hdGgubWF4KG5lMi5sbmcsIG5lLmxuZyk7XG4gICAgICAgICAgICBuZS5sYXQgPSBNYXRoLm1heChuZTIubGF0LCBuZS5sYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGdlb2dyYXBoaWNhbCBjb29yZGluYXRlIGVxdWlkaXN0YW50IGZyb20gdGhlIGJvdW5kaW5nIGJveCdzIGNvcm5lcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TG5nTGF0fSBUaGUgYm91bmRpbmcgYm94J3MgY2VudGVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGxsYiA9IG5ldyBtYXBib3hnbC5MbmdMYXRCb3VuZHMoWy03My45ODc2LCA0MC43NjYxXSwgWy03My45Mzk3LCA0MC44MDAyXSk7XG4gICAgICogbGxiLmdldENlbnRlcigpOyAvLyA9IExuZ0xhdCB7bG5nOiAtNzMuOTYzNjUsIGxhdDogNDAuNzgzMTV9XG4gICAgICovXG4gICAgZ2V0Q2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMbmdMYXQoKHRoaXMuX3N3LmxuZyArIHRoaXMuX25lLmxuZykgLyAyLCAodGhpcy5fc3cubGF0ICsgdGhpcy5fbmUubGF0KSAvIDIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzb3V0aHdlc3QgY29ybmVyIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TG5nTGF0fSBUaGUgc291dGh3ZXN0IGNvcm5lciBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgICAqL1xuICAgIGdldFNvdXRoV2VzdDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9zdzsgfSxcblxuICAgIC8qKlxuICAgICogUmV0dXJucyB0aGUgbm9ydGhlYXN0IGNvcm5lciBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgICpcbiAgICAqIEByZXR1cm5zIHtMbmdMYXR9IFRoZSBub3J0aGVhc3QgY29ybmVyIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICovXG4gICAgZ2V0Tm9ydGhFYXN0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX25lOyB9LFxuXG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIHRoZSBub3J0aHdlc3QgY29ybmVyIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgKlxuICAgICogQHJldHVybnMge0xuZ0xhdH0gVGhlIG5vcnRod2VzdCBjb3JuZXIgb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgKi9cbiAgICBnZXROb3J0aFdlc3Q6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IExuZ0xhdCh0aGlzLmdldFdlc3QoKSwgdGhpcy5nZXROb3J0aCgpKTsgfSxcblxuICAgIC8qKlxuICAgICogUmV0dXJucyB0aGUgc291dGhlYXN0IGNvcm5lciBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgICpcbiAgICAqIEByZXR1cm5zIHtMbmdMYXR9IFRoZSBzb3V0aGVhc3QgY29ybmVyIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICovXG4gICAgZ2V0U291dGhFYXN0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBMbmdMYXQodGhpcy5nZXRFYXN0KCksIHRoaXMuZ2V0U291dGgoKSk7IH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgdGhlIHdlc3QgZWRnZSBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgICpcbiAgICAqIEByZXR1cm5zIHtMbmdMYXR9IFRoZSB3ZXN0IGVkZ2Ugb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgKi9cbiAgICBnZXRXZXN0OiAgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9zdy5sbmc7IH0sXG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgdGhlIHNvdXRoIGVkZ2Ugb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAqXG4gICAgKiBAcmV0dXJucyB7TG5nTGF0fSBUaGUgc291dGggZWRnZSBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgICAqL1xuICAgIGdldFNvdXRoOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3N3LmxhdDsgfSxcblxuICAgIC8qKlxuICAgICogUmV0dXJucyB0aGUgZWFzdCBlZGdlIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgKlxuICAgICogQHJldHVybnMge0xuZ0xhdH0gVGhlIGVhc3QgZWRnZSBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgICAqL1xuICAgIGdldEVhc3Q6ICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX25lLmxuZzsgfSxcblxuICAgIC8qKlxuICAgICogUmV0dXJucyB0aGUgbm9ydGggZWRnZSBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgICpcbiAgICAqIEByZXR1cm5zIHtMbmdMYXR9IFRoZSBub3J0aCBlZGdlIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICovXG4gICAgZ2V0Tm9ydGg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fbmUubGF0OyB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYm91bmRpbmcgYm94IHJlcHJlc2VudGVkIGFzIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5PEFycmF5PG51bWJlcj4+fSBUaGUgYm91bmRpbmcgYm94IHJlcHJlc2VudGVkIGFzIGFuIGFycmF5LCBjb25zaXN0aW5nIG9mIHRoZVxuICAgICAqICAgc291dGh3ZXN0IGFuZCBub3J0aGVhc3QgY29vcmRpbmF0ZXMgb2YgdGhlIGJvdW5kaW5nIHJlcHJlc2VudGVkIGFzIGFycmF5cyBvZiBudW1iZXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGxsYiA9IG5ldyBtYXBib3hnbC5MbmdMYXRCb3VuZHMoWy03My45ODc2LCA0MC43NjYxXSwgWy03My45Mzk3LCA0MC44MDAyXSk7XG4gICAgICogbGxiLnRvQXJyYXkoKTsgLy8gPSBbWy03My45ODc2LCA0MC43NjYxXSwgWy03My45Mzk3LCA0MC44MDAyXV1cbiAgICAgKi9cbiAgICB0b0FycmF5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5fc3cudG9BcnJheSgpLCB0aGlzLl9uZS50b0FycmF5KCldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGJvdW5kaW5nIGJveCByZXByZXNlbnRlZCBhcyBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBib3VuZGluZyBib3ggcmVwcmVzZW50cyBhcyBhIHN0cmluZyBvZiB0aGUgZm9ybWF0XG4gICAgICogICBgJ0xuZ0xhdEJvdW5kcyhMbmdMYXQobG5nLCBsYXQpLCBMbmdMYXQobG5nLCBsYXQpKSdgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGxsYiA9IG5ldyBtYXBib3hnbC5MbmdMYXRCb3VuZHMoWy03My45ODc2LCA0MC43NjYxXSwgWy03My45Mzk3LCA0MC44MDAyXSk7XG4gICAgICogbGxiLnRvU3RyaW5nKCk7IC8vID0gXCJMbmdMYXRCb3VuZHMoTG5nTGF0KC03My45ODc2LCA0MC43NjYxKSwgTG5nTGF0KC03My45Mzk3LCA0MC44MDAyKSlcIlxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnTG5nTGF0Qm91bmRzKCcgKyB0aGlzLl9zdy50b1N0cmluZygpICsgJywgJyArIHRoaXMuX25lLnRvU3RyaW5nKCkgKyAnKSc7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSB0byBhIGBMbmdMYXRCb3VuZHNgIG9iamVjdC5cbiAqXG4gKiBJZiBhIGBMbmdMYXRCb3VuZHNgIG9iamVjdCBpcyBwYXNzZWQgaW4sIHRoZSBmdW5jdGlvbiByZXR1cm5zIGl0IHVuY2hhbmdlZC5cbiAqXG4gKiBJbnRlcm5hbGx5LCB0aGUgZnVuY3Rpb24gY2FsbHMgYExuZ0xhdCNjb252ZXJ0YCB0byBjb252ZXJ0IGFycmF5cyB0byBgTG5nTGF0YCB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtMbmdMYXRCb3VuZHNMaWtlfSBpbnB1dCBBbiBhcnJheSBvZiB0d28gY29vcmRpbmF0ZXMgdG8gY29udmVydCwgb3IgYSBgTG5nTGF0Qm91bmRzYCBvYmplY3QgdG8gcmV0dXJuLlxuICogQHJldHVybnMge0xuZ0xhdEJvdW5kc30gQSBuZXcgYExuZ0xhdEJvdW5kc2Agb2JqZWN0LCBpZiBhIGNvbnZlcnNpb24gb2NjdXJyZWQsIG9yIHRoZSBvcmlnaW5hbCBgTG5nTGF0Qm91bmRzYCBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICogdmFyIGFyciA9IFtbLTczLjk4NzYsIDQwLjc2NjFdLCBbLTczLjkzOTcsIDQwLjgwMDJdXTtcbiAqIHZhciBsbGIgPSBtYXBib3hnbC5MbmdMYXRCb3VuZHMuY29udmVydChhcnIpO1xuICogbGxiOyAgIC8vID0gTG5nTGF0Qm91bmRzIHtfc3c6IExuZ0xhdCB7bG5nOiAtNzMuOTg3NiwgbGF0OiA0MC43NjYxfSwgX25lOiBMbmdMYXQge2xuZzogLTczLjkzOTcsIGxhdDogNDAuODAwMn19XG4gKi9cbkxuZ0xhdEJvdW5kcy5jb252ZXJ0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCB8fCBpbnB1dCBpbnN0YW5jZW9mIExuZ0xhdEJvdW5kcykgcmV0dXJuIGlucHV0O1xuICAgIHJldHVybiBuZXcgTG5nTGF0Qm91bmRzKGlucHV0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBMbmdMYXQgPSByZXF1aXJlKCcuL2xuZ19sYXQnKSxcbiAgICBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5JyksXG4gICAgQ29vcmRpbmF0ZSA9IHJlcXVpcmUoJy4vY29vcmRpbmF0ZScpLFxuICAgIHdyYXAgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKS53cmFwLFxuICAgIGludGVycCA9IHJlcXVpcmUoJy4uL3V0aWwvaW50ZXJwb2xhdGUnKSxcbiAgICBUaWxlQ29vcmQgPSByZXF1aXJlKCcuLi9zb3VyY2UvdGlsZV9jb29yZCcpLFxuICAgIEVYVEVOVCA9IHJlcXVpcmUoJy4uL2RhdGEvYnVja2V0JykuRVhURU5ULFxuICAgIGdsbWF0cml4ID0gcmVxdWlyZSgnZ2wtbWF0cml4Jyk7XG5cbnZhciB2ZWM0ID0gZ2xtYXRyaXgudmVjNCxcbiAgICBtYXQ0ID0gZ2xtYXRyaXgubWF0NCxcbiAgICBtYXQyID0gZ2xtYXRyaXgubWF0MjtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbi8qKlxuICogQSBzaW5nbGUgdHJhbnNmb3JtLCBnZW5lcmFsbHkgdXNlZCBmb3IgYSBzaW5nbGUgdGlsZSB0byBiZVxuICogc2NhbGVkLCByb3RhdGVkLCBhbmQgem9vbWVkLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5ab29tXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4Wm9vbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVHJhbnNmb3JtKG1pblpvb20sIG1heFpvb20pIHtcbiAgICB0aGlzLnRpbGVTaXplID0gNTEyOyAvLyBjb25zdGFudFxuXG4gICAgdGhpcy5fbWluWm9vbSA9IG1pblpvb20gfHwgMDtcbiAgICB0aGlzLl9tYXhab29tID0gbWF4Wm9vbSB8fCAyMjtcblxuICAgIHRoaXMubGF0UmFuZ2UgPSBbLTg1LjA1MTEzLCA4NS4wNTExM107XG5cbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5fY2VudGVyID0gbmV3IExuZ0xhdCgwLCAwKTtcbiAgICB0aGlzLnpvb20gPSAwO1xuICAgIHRoaXMuYW5nbGUgPSAwO1xuICAgIHRoaXMuX2FsdGl0dWRlID0gMS41O1xuICAgIHRoaXMuX3BpdGNoID0gMDtcbiAgICB0aGlzLl91bm1vZGlmaWVkID0gdHJ1ZTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZSA9IHtcbiAgICBnZXQgbWluWm9vbSgpIHsgcmV0dXJuIHRoaXMuX21pblpvb207IH0sXG4gICAgc2V0IG1pblpvb20oem9vbSkge1xuICAgICAgICBpZiAodGhpcy5fbWluWm9vbSA9PT0gem9vbSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9taW5ab29tID0gem9vbTtcbiAgICAgICAgdGhpcy56b29tID0gTWF0aC5tYXgodGhpcy56b29tLCB6b29tKTtcbiAgICB9LFxuXG4gICAgZ2V0IG1heFpvb20oKSB7IHJldHVybiB0aGlzLl9tYXhab29tOyB9LFxuICAgIHNldCBtYXhab29tKHpvb20pIHtcbiAgICAgICAgaWYgKHRoaXMuX21heFpvb20gPT09IHpvb20pIHJldHVybjtcbiAgICAgICAgdGhpcy5fbWF4Wm9vbSA9IHpvb207XG4gICAgICAgIHRoaXMuem9vbSA9IE1hdGgubWluKHRoaXMuem9vbSwgem9vbSk7XG4gICAgfSxcblxuICAgIGdldCB3b3JsZFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVTaXplICogdGhpcy5zY2FsZTtcbiAgICB9LFxuXG4gICAgZ2V0IGNlbnRlclBvaW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplLl9kaXYoMik7XG4gICAgfSxcblxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgZ2V0IGJlYXJpbmcoKSB7XG4gICAgICAgIHJldHVybiAtdGhpcy5hbmdsZSAvIE1hdGguUEkgKiAxODA7XG4gICAgfSxcbiAgICBzZXQgYmVhcmluZyhiZWFyaW5nKSB7XG4gICAgICAgIHZhciBiID0gLXdyYXAoYmVhcmluZywgLTE4MCwgMTgwKSAqIE1hdGguUEkgLyAxODA7XG4gICAgICAgIGlmICh0aGlzLmFuZ2xlID09PSBiKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3VubW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbmdsZSA9IGI7XG4gICAgICAgIHRoaXMuX2NhbGNNYXRyaWNlcygpO1xuXG4gICAgICAgIC8vIDJ4MiBtYXRyaXggZm9yIHJvdGF0aW5nIHBvaW50c1xuICAgICAgICB0aGlzLnJvdGF0aW9uTWF0cml4ID0gbWF0Mi5jcmVhdGUoKTtcbiAgICAgICAgbWF0Mi5yb3RhdGUodGhpcy5yb3RhdGlvbk1hdHJpeCwgdGhpcy5yb3RhdGlvbk1hdHJpeCwgdGhpcy5hbmdsZSk7XG4gICAgfSxcblxuICAgIGdldCBwaXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BpdGNoIC8gTWF0aC5QSSAqIDE4MDtcbiAgICB9LFxuICAgIHNldCBwaXRjaChwaXRjaCkge1xuICAgICAgICB2YXIgcCA9IE1hdGgubWluKDYwLCBwaXRjaCkgLyAxODAgKiBNYXRoLlBJO1xuICAgICAgICBpZiAodGhpcy5fcGl0Y2ggPT09IHApIHJldHVybjtcbiAgICAgICAgdGhpcy5fdW5tb2RpZmllZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9waXRjaCA9IHA7XG4gICAgICAgIHRoaXMuX2NhbGNNYXRyaWNlcygpO1xuICAgIH0sXG5cbiAgICBnZXQgYWx0aXR1ZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbHRpdHVkZTtcbiAgICB9LFxuICAgIHNldCBhbHRpdHVkZShhbHRpdHVkZSkge1xuICAgICAgICB2YXIgYSA9IE1hdGgubWF4KDAuNzUsIGFsdGl0dWRlKTtcbiAgICAgICAgaWYgKHRoaXMuX2FsdGl0dWRlID09PSBhKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3VubW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYWx0aXR1ZGUgPSBhO1xuICAgICAgICB0aGlzLl9jYWxjTWF0cmljZXMoKTtcbiAgICB9LFxuXG4gICAgZ2V0IHpvb20oKSB7IHJldHVybiB0aGlzLl96b29tOyB9LFxuICAgIHNldCB6b29tKHpvb20pIHtcbiAgICAgICAgdmFyIHogPSBNYXRoLm1pbihNYXRoLm1heCh6b29tLCB0aGlzLm1pblpvb20pLCB0aGlzLm1heFpvb20pO1xuICAgICAgICBpZiAodGhpcy5fem9vbSA9PT0geikgcmV0dXJuO1xuICAgICAgICB0aGlzLl91bm1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3pvb20gPSB6O1xuICAgICAgICB0aGlzLnNjYWxlID0gdGhpcy56b29tU2NhbGUoeik7XG4gICAgICAgIHRoaXMudGlsZVpvb20gPSBNYXRoLmZsb29yKHopO1xuICAgICAgICB0aGlzLnpvb21GcmFjdGlvbiA9IHogLSB0aGlzLnRpbGVab29tO1xuICAgICAgICB0aGlzLl9jYWxjTWF0cmljZXMoKTtcbiAgICAgICAgdGhpcy5fY29uc3RyYWluKCk7XG4gICAgfSxcblxuICAgIGdldCBjZW50ZXIoKSB7IHJldHVybiB0aGlzLl9jZW50ZXI7IH0sXG4gICAgc2V0IGNlbnRlcihjZW50ZXIpIHtcbiAgICAgICAgaWYgKGNlbnRlci5sYXQgPT09IHRoaXMuX2NlbnRlci5sYXQgJiYgY2VudGVyLmxuZyA9PT0gdGhpcy5fY2VudGVyLmxuZykgcmV0dXJuO1xuICAgICAgICB0aGlzLl91bm1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NlbnRlciA9IGNlbnRlcjtcbiAgICAgICAgdGhpcy5fY2FsY01hdHJpY2VzKCk7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB6b29tIGxldmVsIHRoYXQgd2lsbCBjb3ZlciBhbGwgdGlsZXMgdGhlIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudGlsZVNpemVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMucm91bmRab29tXG4gICAgICogQHJldHVybnMge251bWJlcn0gem9vbSBsZXZlbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY292ZXJpbmdab29tTGV2ZWw6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLnJvdW5kWm9vbSA/IE1hdGgucm91bmQgOiBNYXRoLmZsb29yKShcbiAgICAgICAgICAgIHRoaXMuem9vbSArIHRoaXMuc2NhbGVab29tKHRoaXMudGlsZVNpemUgLyBvcHRpb25zLnRpbGVTaXplKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYWxsIGNvb3JkaW5hdGVzIHRoYXQgY291bGQgY292ZXIgdGhpcyB0cmFuc2Zvcm0gZm9yIGEgY292ZXJpbmdcbiAgICAgKiB6b29tIGxldmVsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMudGlsZVNpemVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5taW56b29tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubWF4em9vbVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5yb3VuZFpvb21cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMucmVwYXJzZU92ZXJzY2FsZWRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8VGlsZT59IHRpbGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb3ZlcmluZ1RpbGVzOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciB6ID0gdGhpcy5jb3ZlcmluZ1pvb21MZXZlbChvcHRpb25zKTtcbiAgICAgICAgdmFyIGFjdHVhbFogPSB6O1xuXG4gICAgICAgIGlmICh6IDwgb3B0aW9ucy5taW56b29tKSByZXR1cm4gW107XG4gICAgICAgIGlmICh6ID4gb3B0aW9ucy5tYXh6b29tKSB6ID0gb3B0aW9ucy5tYXh6b29tO1xuXG4gICAgICAgIHZhciB0ciA9IHRoaXMsXG4gICAgICAgICAgICB0aWxlQ2VudGVyID0gdHIubG9jYXRpb25Db29yZGluYXRlKHRyLmNlbnRlcikuX3pvb21Ubyh6KSxcbiAgICAgICAgICAgIGNlbnRlclBvaW50ID0gbmV3IFBvaW50KHRpbGVDZW50ZXIuY29sdW1uIC0gMC41LCB0aWxlQ2VudGVyLnJvdyAtIDAuNSk7XG5cbiAgICAgICAgcmV0dXJuIFRpbGVDb29yZC5jb3Zlcih6LCBbXG4gICAgICAgICAgICB0ci5wb2ludENvb3JkaW5hdGUobmV3IFBvaW50KDAsIDApKS5fem9vbVRvKHopLFxuICAgICAgICAgICAgdHIucG9pbnRDb29yZGluYXRlKG5ldyBQb2ludCh0ci53aWR0aCwgMCkpLl96b29tVG8oeiksXG4gICAgICAgICAgICB0ci5wb2ludENvb3JkaW5hdGUobmV3IFBvaW50KHRyLndpZHRoLCB0ci5oZWlnaHQpKS5fem9vbVRvKHopLFxuICAgICAgICAgICAgdHIucG9pbnRDb29yZGluYXRlKG5ldyBQb2ludCgwLCB0ci5oZWlnaHQpKS5fem9vbVRvKHopXG4gICAgICAgIF0sIG9wdGlvbnMucmVwYXJzZU92ZXJzY2FsZWQgPyBhY3R1YWxaIDogeikuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gY2VudGVyUG9pbnQuZGlzdChhKSAtIGNlbnRlclBvaW50LmRpc3QoYik7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZXNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICB0aGlzLnBpeGVsc1RvR0xVbml0cyA9IFsyIC8gd2lkdGgsIC0yIC8gaGVpZ2h0XTtcbiAgICAgICAgdGhpcy5fY2FsY01hdHJpY2VzKCk7XG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbigpO1xuICAgIH0sXG5cbiAgICBnZXQgdW5tb2RpZmllZCgpIHsgcmV0dXJuIHRoaXMuX3VubW9kaWZpZWQ7IH0sXG5cbiAgICB6b29tU2NhbGU6IGZ1bmN0aW9uKHpvb20pIHsgcmV0dXJuIE1hdGgucG93KDIsIHpvb20pOyB9LFxuICAgIHNjYWxlWm9vbTogZnVuY3Rpb24oc2NhbGUpIHsgcmV0dXJuIE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yOyB9LFxuXG4gICAgcHJvamVjdDogZnVuY3Rpb24obG5nbGF0LCB3b3JsZFNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgIHRoaXMubG5nWChsbmdsYXQubG5nLCB3b3JsZFNpemUpLFxuICAgICAgICAgICAgdGhpcy5sYXRZKGxuZ2xhdC5sYXQsIHdvcmxkU2l6ZSkpO1xuICAgIH0sXG5cbiAgICB1bnByb2plY3Q6IGZ1bmN0aW9uKHBvaW50LCB3b3JsZFNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMbmdMYXQoXG4gICAgICAgICAgICB0aGlzLnhMbmcocG9pbnQueCwgd29ybGRTaXplKSxcbiAgICAgICAgICAgIHRoaXMueUxhdChwb2ludC55LCB3b3JsZFNpemUpKTtcbiAgICB9LFxuXG4gICAgZ2V0IHgoKSB7IHJldHVybiB0aGlzLmxuZ1godGhpcy5jZW50ZXIubG5nKTsgfSxcbiAgICBnZXQgeSgpIHsgcmV0dXJuIHRoaXMubGF0WSh0aGlzLmNlbnRlci5sYXQpOyB9LFxuXG4gICAgZ2V0IHBvaW50KCkgeyByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTsgfSxcblxuICAgIC8qKlxuICAgICAqIGxhdGl0dWRlIHRvIGFic29sdXRlIHggY29vcmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3b3JsZFNpemU9dGhpcy53b3JsZFNpemVdXG4gICAgICogQHJldHVybnMge251bWJlcn0gcGl4ZWwgY29vcmRpbmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbG5nWDogZnVuY3Rpb24obG5nLCB3b3JsZFNpemUpIHtcbiAgICAgICAgcmV0dXJuICgxODAgKyBsbmcpICogKHdvcmxkU2l6ZSB8fCB0aGlzLndvcmxkU2l6ZSkgLyAzNjA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBsYXRpdHVkZSB0byBhYnNvbHV0ZSB5IGNvb3JkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd29ybGRTaXplPXRoaXMud29ybGRTaXplXVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBpeGVsIGNvb3JkaW5hdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGxhdFk6IGZ1bmN0aW9uKGxhdCwgd29ybGRTaXplKSB7XG4gICAgICAgIHZhciB5ID0gMTgwIC8gTWF0aC5QSSAqIE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgbGF0ICogTWF0aC5QSSAvIDM2MCkpO1xuICAgICAgICByZXR1cm4gKDE4MCAtIHkpICogKHdvcmxkU2l6ZSB8fCB0aGlzLndvcmxkU2l6ZSkgLyAzNjA7XG4gICAgfSxcblxuICAgIHhMbmc6IGZ1bmN0aW9uKHgsIHdvcmxkU2l6ZSkge1xuICAgICAgICByZXR1cm4geCAqIDM2MCAvICh3b3JsZFNpemUgfHwgdGhpcy53b3JsZFNpemUpIC0gMTgwO1xuICAgIH0sXG4gICAgeUxhdDogZnVuY3Rpb24oeSwgd29ybGRTaXplKSB7XG4gICAgICAgIHZhciB5MiA9IDE4MCAtIHkgKiAzNjAgLyAod29ybGRTaXplIHx8IHRoaXMud29ybGRTaXplKTtcbiAgICAgICAgcmV0dXJuIDM2MCAvIE1hdGguUEkgKiBNYXRoLmF0YW4oTWF0aC5leHAoeTIgKiBNYXRoLlBJIC8gMTgwKSkgLSA5MDtcbiAgICB9LFxuXG4gICAgcGFuQnk6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLmNlbnRlclBvaW50Ll9hZGQob2Zmc2V0KTtcbiAgICAgICAgdGhpcy5jZW50ZXIgPSB0aGlzLnBvaW50TG9jYXRpb24ocG9pbnQpO1xuICAgIH0sXG5cbiAgICBzZXRMb2NhdGlvbkF0UG9pbnQ6IGZ1bmN0aW9uKGxuZ2xhdCwgcG9pbnQpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmxvY2F0aW9uQ29vcmRpbmF0ZShsbmdsYXQpO1xuICAgICAgICB2YXIgY29vcmRBdFBvaW50ID0gdGhpcy5wb2ludENvb3JkaW5hdGUocG9pbnQpO1xuICAgICAgICB2YXIgY29vcmRDZW50ZXIgPSB0aGlzLnBvaW50Q29vcmRpbmF0ZSh0aGlzLmNlbnRlclBvaW50KTtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZSA9IGNvb3JkQXRQb2ludC5fc3ViKGMpO1xuICAgICAgICB0aGlzLl91bm1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2VudGVyID0gdGhpcy5jb29yZGluYXRlTG9jYXRpb24oY29vcmRDZW50ZXIuX3N1Yih0cmFuc2xhdGUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBsb2NhdGlvbiwgcmV0dXJuIHRoZSBzY3JlZW4gcG9pbnQgdGhhdCBjb3JyZXNwb25kcyB0byBpdFxuICAgICAqIEBwYXJhbSB7TG5nTGF0fSBsbmdsYXQgbG9jYXRpb25cbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IHNjcmVlbiBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbG9jYXRpb25Qb2ludDogZnVuY3Rpb24obG5nbGF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvb3JkaW5hdGVQb2ludCh0aGlzLmxvY2F0aW9uQ29vcmRpbmF0ZShsbmdsYXQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBwb2ludCBvbiBzY3JlZW4sIHJldHVybiBpdHMgbG5nbGF0XG4gICAgICogQHBhcmFtIHtQb2ludH0gcCBzY3JlZW4gcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7TG5nTGF0fSBsbmdsYXQgbG9jYXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBvaW50TG9jYXRpb246IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29vcmRpbmF0ZUxvY2F0aW9uKHRoaXMucG9pbnRDb29yZGluYXRlKHApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBnZW9ncmFwaGljYWwgbG5nbGF0LCByZXR1cm4gYW4gdW5yb3VuZGVkXG4gICAgICogY29vcmRpbmF0ZSB0aGF0IHJlcHJlc2VudHMgaXQgYXQgdGhpcyB0cmFuc2Zvcm0ncyB6b29tIGxldmVsIGFuZFxuICAgICAqIHdvcmxkc2l6ZS5cbiAgICAgKiBAcGFyYW0ge0xuZ0xhdH0gbG5nbGF0XG4gICAgICogQHJldHVybnMge0Nvb3JkaW5hdGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBsb2NhdGlvbkNvb3JkaW5hdGU6IGZ1bmN0aW9uKGxuZ2xhdCkge1xuICAgICAgICB2YXIgayA9IHRoaXMuem9vbVNjYWxlKHRoaXMudGlsZVpvb20pIC8gdGhpcy53b3JsZFNpemUsXG4gICAgICAgICAgICBsbCA9IExuZ0xhdC5jb252ZXJ0KGxuZ2xhdCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb29yZGluYXRlKFxuICAgICAgICAgICAgdGhpcy5sbmdYKGxsLmxuZykgKiBrLFxuICAgICAgICAgICAgdGhpcy5sYXRZKGxsLmxhdCkgKiBrLFxuICAgICAgICAgICAgdGhpcy50aWxlWm9vbSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgQ29vcmRpbmF0ZSwgcmV0dXJuIGl0cyBnZW9ncmFwaGljYWwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZFxuICAgICAqIEByZXR1cm5zIHtMbmdMYXR9IGxuZ2xhdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29vcmRpbmF0ZUxvY2F0aW9uOiBmdW5jdGlvbihjb29yZCkge1xuICAgICAgICB2YXIgd29ybGRTaXplID0gdGhpcy56b29tU2NhbGUoY29vcmQuem9vbSk7XG4gICAgICAgIHJldHVybiBuZXcgTG5nTGF0KFxuICAgICAgICAgICAgdGhpcy54TG5nKGNvb3JkLmNvbHVtbiwgd29ybGRTaXplKSxcbiAgICAgICAgICAgIHRoaXMueUxhdChjb29yZC5yb3csIHdvcmxkU2l6ZSkpO1xuICAgIH0sXG5cbiAgICBwb2ludENvb3JkaW5hdGU6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICB2YXIgdGFyZ2V0WiA9IDA7XG4gICAgICAgIC8vIHNpbmNlIHdlIGRvbid0IGtub3cgdGhlIGNvcnJlY3QgcHJvamVjdGVkIHogdmFsdWUgZm9yIHRoZSBwb2ludCxcbiAgICAgICAgLy8gdW5wcm9qZWN0IHR3byBwb2ludHMgdG8gZ2V0IGEgbGluZSBhbmQgdGhlbiBmaW5kIHRoZSBwb2ludCBvbiB0aGF0XG4gICAgICAgIC8vIGxpbmUgd2l0aCB6PTBcblxuICAgICAgICB2YXIgY29vcmQwID0gW3AueCwgcC55LCAwLCAxXTtcbiAgICAgICAgdmFyIGNvb3JkMSA9IFtwLngsIHAueSwgMSwgMV07XG5cbiAgICAgICAgdmVjNC50cmFuc2Zvcm1NYXQ0KGNvb3JkMCwgY29vcmQwLCB0aGlzLnBpeGVsTWF0cml4SW52ZXJzZSk7XG4gICAgICAgIHZlYzQudHJhbnNmb3JtTWF0NChjb29yZDEsIGNvb3JkMSwgdGhpcy5waXhlbE1hdHJpeEludmVyc2UpO1xuXG4gICAgICAgIHZhciB3MCA9IGNvb3JkMFszXTtcbiAgICAgICAgdmFyIHcxID0gY29vcmQxWzNdO1xuICAgICAgICB2YXIgeDAgPSBjb29yZDBbMF0gLyB3MDtcbiAgICAgICAgdmFyIHgxID0gY29vcmQxWzBdIC8gdzE7XG4gICAgICAgIHZhciB5MCA9IGNvb3JkMFsxXSAvIHcwO1xuICAgICAgICB2YXIgeTEgPSBjb29yZDFbMV0gLyB3MTtcbiAgICAgICAgdmFyIHowID0gY29vcmQwWzJdIC8gdzA7XG4gICAgICAgIHZhciB6MSA9IGNvb3JkMVsyXSAvIHcxO1xuXG5cbiAgICAgICAgdmFyIHQgPSB6MCA9PT0gejEgPyAwIDogKHRhcmdldFogLSB6MCkgLyAoejEgLSB6MCk7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMud29ybGRTaXplIC8gdGhpcy56b29tU2NhbGUodGhpcy50aWxlWm9vbSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb29yZGluYXRlKFxuICAgICAgICAgICAgaW50ZXJwKHgwLCB4MSwgdCkgLyBzY2FsZSxcbiAgICAgICAgICAgIGludGVycCh5MCwgeTEsIHQpIC8gc2NhbGUsXG4gICAgICAgICAgICB0aGlzLnRpbGVab29tKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBjb29yZGluYXRlLCByZXR1cm4gdGhlIHNjcmVlbiBwb2ludCB0aGF0IGNvcnJlc3BvbmRzIHRvIGl0XG4gICAgICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZFxuICAgICAqIEByZXR1cm5zIHtQb2ludH0gc2NyZWVuIHBvaW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb29yZGluYXRlUG9pbnQ6IGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMud29ybGRTaXplIC8gdGhpcy56b29tU2NhbGUoY29vcmQuem9vbSk7XG4gICAgICAgIHZhciBwID0gW2Nvb3JkLmNvbHVtbiAqIHNjYWxlLCBjb29yZC5yb3cgKiBzY2FsZSwgMCwgMV07XG4gICAgICAgIHZlYzQudHJhbnNmb3JtTWF0NChwLCBwLCB0aGlzLnBpeGVsTWF0cml4KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwWzBdIC8gcFszXSwgcFsxXSAvIHBbM10pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvc01hdHJpeCB0aGF0LCBnaXZlbiBhIHRpbGUgY29vcmRpbmF0ZSwgd291bGQgYmUgdXNlZCB0byBkaXNwbGF5IHRoZSB0aWxlIG9uIGEgbWFwLlxuICAgICAqIEBwYXJhbSB7VGlsZUNvb3JkfENvb3JkaW5hdGV9IGNvb3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFpvb20gbWF4aW11bSBzb3VyY2Ugem9vbSB0byBhY2NvdW50IGZvciBvdmVyc2NhbGluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2FsY3VsYXRlUG9zTWF0cml4OiBmdW5jdGlvbihjb29yZCwgbWF4Wm9vbSkge1xuICAgICAgICBpZiAobWF4Wm9vbSA9PT0gdW5kZWZpbmVkKSBtYXhab29tID0gSW5maW5pdHk7XG4gICAgICAgIGlmIChjb29yZCBpbnN0YW5jZW9mIFRpbGVDb29yZCkgY29vcmQgPSBjb29yZC50b0Nvb3JkaW5hdGUobWF4Wm9vbSk7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBtb2RlbC12aWV3IG1hdHJpeCB0aGF0IGNvbnZlcnRzIGZyb20gdGhlIHRpbGUgY29vcmRpbmF0ZXMgdG8gc2NyZWVuIGNvb3JkaW5hdGVzLlxuXG4gICAgICAgIC8vIGlmIHogPiBtYXh6b29tIHRoZW4gdGhlIHRpbGUgaXMgYWN0dWFsbHkgYSBvdmVyc2NhbGVkIG1heHpvb20gdGlsZSxcbiAgICAgICAgLy8gc28gY2FsY3VsYXRlIHRoZSBtYXRyaXggdGhlIG1heHpvb20gdGlsZSB3b3VsZCB1c2UuXG4gICAgICAgIHZhciB6ID0gTWF0aC5taW4oY29vcmQuem9vbSwgbWF4Wm9vbSk7XG5cbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy53b3JsZFNpemUgLyBNYXRoLnBvdygyLCB6KTtcbiAgICAgICAgdmFyIHBvc01hdHJpeCA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuXG4gICAgICAgIG1hdDQuaWRlbnRpdHkocG9zTWF0cml4KTtcbiAgICAgICAgbWF0NC50cmFuc2xhdGUocG9zTWF0cml4LCBwb3NNYXRyaXgsIFtjb29yZC5jb2x1bW4gKiBzY2FsZSwgY29vcmQucm93ICogc2NhbGUsIDBdKTtcbiAgICAgICAgbWF0NC5zY2FsZShwb3NNYXRyaXgsIHBvc01hdHJpeCwgWyBzY2FsZSAvIEVYVEVOVCwgc2NhbGUgLyBFWFRFTlQsIDEgXSk7XG4gICAgICAgIG1hdDQubXVsdGlwbHkocG9zTWF0cml4LCB0aGlzLnByb2pNYXRyaXgsIHBvc01hdHJpeCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkocG9zTWF0cml4KTtcbiAgICB9LFxuXG4gICAgX2NvbnN0cmFpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5jZW50ZXIgfHwgIXRoaXMud2lkdGggfHwgIXRoaXMuaGVpZ2h0IHx8IHRoaXMuX2NvbnN0cmFpbmluZykgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuX2NvbnN0cmFpbmluZyA9IHRydWU7XG5cbiAgICAgICAgdmFyIG1pblksIG1heFksIG1pblgsIG1heFgsIHN5LCBzeCwgeDIsIHkyLFxuICAgICAgICAgICAgc2l6ZSA9IHRoaXMuc2l6ZSxcbiAgICAgICAgICAgIHVubW9kaWZpZWQgPSB0aGlzLl91bm1vZGlmaWVkO1xuXG4gICAgICAgIGlmICh0aGlzLmxhdFJhbmdlKSB7XG4gICAgICAgICAgICBtaW5ZID0gdGhpcy5sYXRZKHRoaXMubGF0UmFuZ2VbMV0pO1xuICAgICAgICAgICAgbWF4WSA9IHRoaXMubGF0WSh0aGlzLmxhdFJhbmdlWzBdKTtcbiAgICAgICAgICAgIHN5ID0gbWF4WSAtIG1pblkgPCBzaXplLnkgPyBzaXplLnkgLyAobWF4WSAtIG1pblkpIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmxuZ1JhbmdlKSB7XG4gICAgICAgICAgICBtaW5YID0gdGhpcy5sbmdYKHRoaXMubG5nUmFuZ2VbMF0pO1xuICAgICAgICAgICAgbWF4WCA9IHRoaXMubG5nWCh0aGlzLmxuZ1JhbmdlWzFdKTtcbiAgICAgICAgICAgIHN4ID0gbWF4WCAtIG1pblggPCBzaXplLnggPyBzaXplLnggLyAobWF4WCAtIG1pblgpIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhvdyBtdWNoIHRoZSBtYXAgc2hvdWxkIHNjYWxlIHRvIGZpdCB0aGUgc2NyZWVuIGludG8gZ2l2ZW4gbGF0aXR1ZGUvbG9uZ2l0dWRlIHJhbmdlc1xuICAgICAgICB2YXIgcyA9IE1hdGgubWF4KHN4IHx8IDAsIHN5IHx8IDApO1xuXG4gICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICB0aGlzLmNlbnRlciA9IHRoaXMudW5wcm9qZWN0KG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICBzeCA/IChtYXhYICsgbWluWCkgLyAyIDogdGhpcy54LFxuICAgICAgICAgICAgICAgIHN5ID8gKG1heFkgKyBtaW5ZKSAvIDIgOiB0aGlzLnkpKTtcbiAgICAgICAgICAgIHRoaXMuem9vbSArPSB0aGlzLnNjYWxlWm9vbShzKTtcbiAgICAgICAgICAgIHRoaXMuX3VubW9kaWZpZWQgPSB1bm1vZGlmaWVkO1xuICAgICAgICAgICAgdGhpcy5fY29uc3RyYWluaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5sYXRSYW5nZSkge1xuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLnksXG4gICAgICAgICAgICAgICAgaDIgPSBzaXplLnkgLyAyO1xuXG4gICAgICAgICAgICBpZiAoeSAtIGgyIDwgbWluWSkgeTIgPSBtaW5ZICsgaDI7XG4gICAgICAgICAgICBpZiAoeSArIGgyID4gbWF4WSkgeTIgPSBtYXhZIC0gaDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5sbmdSYW5nZSkge1xuICAgICAgICAgICAgdmFyIHggPSB0aGlzLngsXG4gICAgICAgICAgICAgICAgdzIgPSBzaXplLnggLyAyO1xuXG4gICAgICAgICAgICBpZiAoeCAtIHcyIDwgbWluWCkgeDIgPSBtaW5YICsgdzI7XG4gICAgICAgICAgICBpZiAoeCArIHcyID4gbWF4WCkgeDIgPSBtYXhYIC0gdzI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYW4gdGhlIG1hcCBpZiB0aGUgc2NyZWVuIGdvZXMgb2ZmIHRoZSByYW5nZVxuICAgICAgICBpZiAoeDIgIT09IHVuZGVmaW5lZCB8fCB5MiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNlbnRlciA9IHRoaXMudW5wcm9qZWN0KG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICB4MiAhPT0gdW5kZWZpbmVkID8geDIgOiB0aGlzLngsXG4gICAgICAgICAgICAgICAgeTIgIT09IHVuZGVmaW5lZCA/IHkyIDogdGhpcy55KSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91bm1vZGlmaWVkID0gdW5tb2RpZmllZDtcbiAgICAgICAgdGhpcy5fY29uc3RyYWluaW5nID0gZmFsc2U7XG4gICAgfSxcblxuICAgIF9jYWxjTWF0cmljZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGVpZ2h0KSByZXR1cm47XG5cbiAgICAgICAgLy8gRmluZCB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIHBvaW50IHRvIHRoZSBjZW50ZXIgdG9wIGluIGFsdGl0dWRlIHVuaXRzIHVzaW5nIGxhdyBvZiBzaW5lcy5cbiAgICAgICAgdmFyIGhhbGZGb3YgPSBNYXRoLmF0YW4oMC41IC8gdGhpcy5hbHRpdHVkZSk7XG4gICAgICAgIHZhciB0b3BIYWxmU3VyZmFjZURpc3RhbmNlID0gTWF0aC5zaW4oaGFsZkZvdikgKiB0aGlzLmFsdGl0dWRlIC8gTWF0aC5zaW4oTWF0aC5QSSAvIDIgLSB0aGlzLl9waXRjaCAtIGhhbGZGb3YpO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB6IHZhbHVlIG9mIHRoZSBmYXJ0aGVzdCBmcmFnbWVudCB0aGF0IHNob3VsZCBiZSByZW5kZXJlZC5cbiAgICAgICAgdmFyIGZhclogPSBNYXRoLmNvcyhNYXRoLlBJIC8gMiAtIHRoaXMuX3BpdGNoKSAqIHRvcEhhbGZTdXJmYWNlRGlzdGFuY2UgKyB0aGlzLmFsdGl0dWRlO1xuXG4gICAgICAgIC8vIG1hdHJpeCBmb3IgY29udmVyc2lvbiBmcm9tIGxvY2F0aW9uIHRvIEdMIGNvb3JkaW5hdGVzICgtMSAuLiAxKVxuICAgICAgICB2YXIgbSA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICAgICAgICBtYXQ0LnBlcnNwZWN0aXZlKG0sIDIgKiBNYXRoLmF0YW4oKHRoaXMuaGVpZ2h0IC8gMikgLyB0aGlzLmFsdGl0dWRlKSwgdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0LCAwLjEsIGZhclopO1xuICAgICAgICBtYXQ0LnRyYW5zbGF0ZShtLCBtLCBbMCwgMCwgLXRoaXMuYWx0aXR1ZGVdKTtcblxuICAgICAgICAvLyBBZnRlciB0aGUgcm90YXRlWCwgeiB2YWx1ZXMgYXJlIGluIHBpeGVsIHVuaXRzLiBDb252ZXJ0IHRoZW0gdG9cbiAgICAgICAgLy8gYWx0aXR1ZGUgdW5pdHMuIDEgYWx0aXR1ZGUgdW5pdCA9IHRoZSBzY3JlZW4gaGVpZ2h0LlxuICAgICAgICBtYXQ0LnNjYWxlKG0sIG0sIFsxLCAtMSwgMSAvIHRoaXMuaGVpZ2h0XSk7XG5cbiAgICAgICAgbWF0NC5yb3RhdGVYKG0sIG0sIHRoaXMuX3BpdGNoKTtcbiAgICAgICAgbWF0NC5yb3RhdGVaKG0sIG0sIHRoaXMuYW5nbGUpO1xuICAgICAgICBtYXQ0LnRyYW5zbGF0ZShtLCBtLCBbLXRoaXMueCwgLXRoaXMueSwgMF0pO1xuXG4gICAgICAgIHRoaXMucHJvak1hdHJpeCA9IG07XG5cbiAgICAgICAgLy8gbWF0cml4IGZvciBjb252ZXJzaW9uIGZyb20gbG9jYXRpb24gdG8gc2NyZWVuIGNvb3JkaW5hdGVzXG4gICAgICAgIG0gPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICBtYXQ0LnNjYWxlKG0sIG0sIFt0aGlzLndpZHRoIC8gMiwgLXRoaXMuaGVpZ2h0IC8gMiwgMV0pO1xuICAgICAgICBtYXQ0LnRyYW5zbGF0ZShtLCBtLCBbMSwgLTEsIDBdKTtcbiAgICAgICAgdGhpcy5waXhlbE1hdHJpeCA9IG1hdDQubXVsdGlwbHkobmV3IEZsb2F0NjRBcnJheSgxNiksIG0sIHRoaXMucHJvak1hdHJpeCk7XG5cbiAgICAgICAgLy8gaW52ZXJzZSBtYXRyaXggZm9yIGNvbnZlcnNpb24gZnJvbSBzY3JlZW4gY29vcmRpbmFlcyB0byBsb2NhdGlvblxuICAgICAgICBtID0gbWF0NC5pbnZlcnQobmV3IEZsb2F0NjRBcnJheSgxNiksIHRoaXMucGl4ZWxNYXRyaXgpO1xuICAgICAgICBpZiAoIW0pIHRocm93IG5ldyBFcnJvcihcImZhaWxlZCB0byBpbnZlcnQgbWF0cml4XCIpO1xuICAgICAgICB0aGlzLnBpeGVsTWF0cml4SW52ZXJzZSA9IG07XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gRm9udCBkYXRhIEZyb20gSGVyc2hleSBTaW1wbGV4IEZvbnRcbi8vIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9kYXRhZm9ybWF0cy9oZXJzaGV5L1xudmFyIHNpbXBsZXhGb250ID0ge1xuICAgIFwiIFwiOiBbMTYsIFtdXSxcbiAgICBcIiFcIjogWzEwLCBbNSwgMjEsIDUsIDcsIC0xLCAtMSwgNSwgMiwgNCwgMSwgNSwgMCwgNiwgMSwgNSwgMl1dLFxuICAgIFwiXFxcIlwiOiBbMTYsIFs0LCAyMSwgNCwgMTQsIC0xLCAtMSwgMTIsIDIxLCAxMiwgMTRdXSxcbiAgICBcIiNcIjogWzIxLCBbMTEsIDI1LCA0LCAtNywgLTEsIC0xLCAxNywgMjUsIDEwLCAtNywgLTEsIC0xLCA0LCAxMiwgMTgsIDEyLCAtMSwgLTEsIDMsIDYsIDE3LCA2XV0sXG4gICAgXCIkXCI6IFsyMCwgWzgsIDI1LCA4LCAtNCwgLTEsIC0xLCAxMiwgMjUsIDEyLCAtNCwgLTEsIC0xLCAxNywgMTgsIDE1LCAyMCwgMTIsIDIxLCA4LCAyMSwgNSwgMjAsIDMsIDE4LCAzLCAxNiwgNCwgMTQsIDUsIDEzLCA3LCAxMiwgMTMsIDEwLCAxNSwgOSwgMTYsIDgsIDE3LCA2LCAxNywgMywgMTUsIDEsIDEyLCAwLCA4LCAwLCA1LCAxLCAzLCAzXV0sXG4gICAgXCIlXCI6IFsyNCwgWzIxLCAyMSwgMywgMCwgLTEsIC0xLCA4LCAyMSwgMTAsIDE5LCAxMCwgMTcsIDksIDE1LCA3LCAxNCwgNSwgMTQsIDMsIDE2LCAzLCAxOCwgNCwgMjAsIDYsIDIxLCA4LCAyMSwgMTAsIDIwLCAxMywgMTksIDE2LCAxOSwgMTksIDIwLCAyMSwgMjEsIC0xLCAtMSwgMTcsIDcsIDE1LCA2LCAxNCwgNCwgMTQsIDIsIDE2LCAwLCAxOCwgMCwgMjAsIDEsIDIxLCAzLCAyMSwgNSwgMTksIDcsIDE3LCA3XV0sXG4gICAgXCImXCI6IFsyNiwgWzIzLCAxMiwgMjMsIDEzLCAyMiwgMTQsIDIxLCAxNCwgMjAsIDEzLCAxOSwgMTEsIDE3LCA2LCAxNSwgMywgMTMsIDEsIDExLCAwLCA3LCAwLCA1LCAxLCA0LCAyLCAzLCA0LCAzLCA2LCA0LCA4LCA1LCA5LCAxMiwgMTMsIDEzLCAxNCwgMTQsIDE2LCAxNCwgMTgsIDEzLCAyMCwgMTEsIDIxLCA5LCAyMCwgOCwgMTgsIDgsIDE2LCA5LCAxMywgMTEsIDEwLCAxNiwgMywgMTgsIDEsIDIwLCAwLCAyMiwgMCwgMjMsIDEsIDIzLCAyXV0sXG4gICAgXCInXCI6IFsxMCwgWzUsIDE5LCA0LCAyMCwgNSwgMjEsIDYsIDIwLCA2LCAxOCwgNSwgMTYsIDQsIDE1XV0sXG4gICAgXCIoXCI6IFsxNCwgWzExLCAyNSwgOSwgMjMsIDcsIDIwLCA1LCAxNiwgNCwgMTEsIDQsIDcsIDUsIDIsIDcsIC0yLCA5LCAtNSwgMTEsIC03XV0sXG4gICAgXCIpXCI6IFsxNCwgWzMsIDI1LCA1LCAyMywgNywgMjAsIDksIDE2LCAxMCwgMTEsIDEwLCA3LCA5LCAyLCA3LCAtMiwgNSwgLTUsIDMsIC03XV0sXG4gICAgXCIqXCI6IFsxNiwgWzgsIDIxLCA4LCA5LCAtMSwgLTEsIDMsIDE4LCAxMywgMTIsIC0xLCAtMSwgMTMsIDE4LCAzLCAxMl1dLFxuICAgIFwiK1wiOiBbMjYsIFsxMywgMTgsIDEzLCAwLCAtMSwgLTEsIDQsIDksIDIyLCA5XV0sXG4gICAgXCIsXCI6IFsxMCwgWzYsIDEsIDUsIDAsIDQsIDEsIDUsIDIsIDYsIDEsIDYsIC0xLCA1LCAtMywgNCwgLTRdXSxcbiAgICBcIi1cIjogWzI2LCBbNCwgOSwgMjIsIDldXSxcbiAgICBcIi5cIjogWzEwLCBbNSwgMiwgNCwgMSwgNSwgMCwgNiwgMSwgNSwgMl1dLFxuICAgIFwiL1wiOiBbMjIsIFsyMCwgMjUsIDIsIC03XV0sXG4gICAgXCIwXCI6IFsyMCwgWzksIDIxLCA2LCAyMCwgNCwgMTcsIDMsIDEyLCAzLCA5LCA0LCA0LCA2LCAxLCA5LCAwLCAxMSwgMCwgMTQsIDEsIDE2LCA0LCAxNywgOSwgMTcsIDEyLCAxNiwgMTcsIDE0LCAyMCwgMTEsIDIxLCA5LCAyMV1dLFxuICAgIFwiMVwiOiBbMjAsIFs2LCAxNywgOCwgMTgsIDExLCAyMSwgMTEsIDBdXSxcbiAgICBcIjJcIjogWzIwLCBbNCwgMTYsIDQsIDE3LCA1LCAxOSwgNiwgMjAsIDgsIDIxLCAxMiwgMjEsIDE0LCAyMCwgMTUsIDE5LCAxNiwgMTcsIDE2LCAxNSwgMTUsIDEzLCAxMywgMTAsIDMsIDAsIDE3LCAwXV0sXG4gICAgXCIzXCI6IFsyMCwgWzUsIDIxLCAxNiwgMjEsIDEwLCAxMywgMTMsIDEzLCAxNSwgMTIsIDE2LCAxMSwgMTcsIDgsIDE3LCA2LCAxNiwgMywgMTQsIDEsIDExLCAwLCA4LCAwLCA1LCAxLCA0LCAyLCAzLCA0XV0sXG4gICAgXCI0XCI6IFsyMCwgWzEzLCAyMSwgMywgNywgMTgsIDcsIC0xLCAtMSwgMTMsIDIxLCAxMywgMF1dLFxuICAgIFwiNVwiOiBbMjAsIFsxNSwgMjEsIDUsIDIxLCA0LCAxMiwgNSwgMTMsIDgsIDE0LCAxMSwgMTQsIDE0LCAxMywgMTYsIDExLCAxNywgOCwgMTcsIDYsIDE2LCAzLCAxNCwgMSwgMTEsIDAsIDgsIDAsIDUsIDEsIDQsIDIsIDMsIDRdXSxcbiAgICBcIjZcIjogWzIwLCBbMTYsIDE4LCAxNSwgMjAsIDEyLCAyMSwgMTAsIDIxLCA3LCAyMCwgNSwgMTcsIDQsIDEyLCA0LCA3LCA1LCAzLCA3LCAxLCAxMCwgMCwgMTEsIDAsIDE0LCAxLCAxNiwgMywgMTcsIDYsIDE3LCA3LCAxNiwgMTAsIDE0LCAxMiwgMTEsIDEzLCAxMCwgMTMsIDcsIDEyLCA1LCAxMCwgNCwgN11dLFxuICAgIFwiN1wiOiBbMjAsIFsxNywgMjEsIDcsIDAsIC0xLCAtMSwgMywgMjEsIDE3LCAyMV1dLFxuICAgIFwiOFwiOiBbMjAsIFs4LCAyMSwgNSwgMjAsIDQsIDE4LCA0LCAxNiwgNSwgMTQsIDcsIDEzLCAxMSwgMTIsIDE0LCAxMSwgMTYsIDksIDE3LCA3LCAxNywgNCwgMTYsIDIsIDE1LCAxLCAxMiwgMCwgOCwgMCwgNSwgMSwgNCwgMiwgMywgNCwgMywgNywgNCwgOSwgNiwgMTEsIDksIDEyLCAxMywgMTMsIDE1LCAxNCwgMTYsIDE2LCAxNiwgMTgsIDE1LCAyMCwgMTIsIDIxLCA4LCAyMV1dLFxuICAgIFwiOVwiOiBbMjAsIFsxNiwgMTQsIDE1LCAxMSwgMTMsIDksIDEwLCA4LCA5LCA4LCA2LCA5LCA0LCAxMSwgMywgMTQsIDMsIDE1LCA0LCAxOCwgNiwgMjAsIDksIDIxLCAxMCwgMjEsIDEzLCAyMCwgMTUsIDE4LCAxNiwgMTQsIDE2LCA5LCAxNSwgNCwgMTMsIDEsIDEwLCAwLCA4LCAwLCA1LCAxLCA0LCAzXV0sXG4gICAgXCI6XCI6IFsxMCwgWzUsIDE0LCA0LCAxMywgNSwgMTIsIDYsIDEzLCA1LCAxNCwgLTEsIC0xLCA1LCAyLCA0LCAxLCA1LCAwLCA2LCAxLCA1LCAyXV0sXG4gICAgXCI7XCI6IFsxMCwgWzUsIDE0LCA0LCAxMywgNSwgMTIsIDYsIDEzLCA1LCAxNCwgLTEsIC0xLCA2LCAxLCA1LCAwLCA0LCAxLCA1LCAyLCA2LCAxLCA2LCAtMSwgNSwgLTMsIDQsIC00XV0sXG4gICAgXCI8XCI6IFsyNCwgWzIwLCAxOCwgNCwgOSwgMjAsIDBdXSxcbiAgICBcIj1cIjogWzI2LCBbNCwgMTIsIDIyLCAxMiwgLTEsIC0xLCA0LCA2LCAyMiwgNl1dLFxuICAgIFwiPlwiOiBbMjQsIFs0LCAxOCwgMjAsIDksIDQsIDBdXSxcbiAgICBcIj9cIjogWzE4LCBbMywgMTYsIDMsIDE3LCA0LCAxOSwgNSwgMjAsIDcsIDIxLCAxMSwgMjEsIDEzLCAyMCwgMTQsIDE5LCAxNSwgMTcsIDE1LCAxNSwgMTQsIDEzLCAxMywgMTIsIDksIDEwLCA5LCA3LCAtMSwgLTEsIDksIDIsIDgsIDEsIDksIDAsIDEwLCAxLCA5LCAyXV0sXG4gICAgXCJAXCI6IFsyNywgWzE4LCAxMywgMTcsIDE1LCAxNSwgMTYsIDEyLCAxNiwgMTAsIDE1LCA5LCAxNCwgOCwgMTEsIDgsIDgsIDksIDYsIDExLCA1LCAxNCwgNSwgMTYsIDYsIDE3LCA4LCAtMSwgLTEsIDEyLCAxNiwgMTAsIDE0LCA5LCAxMSwgOSwgOCwgMTAsIDYsIDExLCA1LCAtMSwgLTEsIDE4LCAxNiwgMTcsIDgsIDE3LCA2LCAxOSwgNSwgMjEsIDUsIDIzLCA3LCAyNCwgMTAsIDI0LCAxMiwgMjMsIDE1LCAyMiwgMTcsIDIwLCAxOSwgMTgsIDIwLCAxNSwgMjEsIDEyLCAyMSwgOSwgMjAsIDcsIDE5LCA1LCAxNywgNCwgMTUsIDMsIDEyLCAzLCA5LCA0LCA2LCA1LCA0LCA3LCAyLCA5LCAxLCAxMiwgMCwgMTUsIDAsIDE4LCAxLCAyMCwgMiwgMjEsIDMsIC0xLCAtMSwgMTksIDE2LCAxOCwgOCwgMTgsIDYsIDE5LCA1XV0sXG4gICAgXCJBXCI6IFsxOCwgWzksIDIxLCAxLCAwLCAtMSwgLTEsIDksIDIxLCAxNywgMCwgLTEsIC0xLCA0LCA3LCAxNCwgN11dLFxuICAgIFwiQlwiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTMsIDIxLCAxNiwgMjAsIDE3LCAxOSwgMTgsIDE3LCAxOCwgMTUsIDE3LCAxMywgMTYsIDEyLCAxMywgMTEsIC0xLCAtMSwgNCwgMTEsIDEzLCAxMSwgMTYsIDEwLCAxNywgOSwgMTgsIDcsIDE4LCA0LCAxNywgMiwgMTYsIDEsIDEzLCAwLCA0LCAwXV0sXG4gICAgXCJDXCI6IFsyMSwgWzE4LCAxNiwgMTcsIDE4LCAxNSwgMjAsIDEzLCAyMSwgOSwgMjEsIDcsIDIwLCA1LCAxOCwgNCwgMTYsIDMsIDEzLCAzLCA4LCA0LCA1LCA1LCAzLCA3LCAxLCA5LCAwLCAxMywgMCwgMTUsIDEsIDE3LCAzLCAxOCwgNV1dLFxuICAgIFwiRFwiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTEsIDIxLCAxNCwgMjAsIDE2LCAxOCwgMTcsIDE2LCAxOCwgMTMsIDE4LCA4LCAxNywgNSwgMTYsIDMsIDE0LCAxLCAxMSwgMCwgNCwgMF1dLFxuICAgIFwiRVwiOiBbMTksIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTcsIDIxLCAtMSwgLTEsIDQsIDExLCAxMiwgMTEsIC0xLCAtMSwgNCwgMCwgMTcsIDBdXSxcbiAgICBcIkZcIjogWzE4LCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMjEsIDE3LCAyMSwgLTEsIC0xLCA0LCAxMSwgMTIsIDExXV0sXG4gICAgXCJHXCI6IFsyMSwgWzE4LCAxNiwgMTcsIDE4LCAxNSwgMjAsIDEzLCAyMSwgOSwgMjEsIDcsIDIwLCA1LCAxOCwgNCwgMTYsIDMsIDEzLCAzLCA4LCA0LCA1LCA1LCAzLCA3LCAxLCA5LCAwLCAxMywgMCwgMTUsIDEsIDE3LCAzLCAxOCwgNSwgMTgsIDgsIC0xLCAtMSwgMTMsIDgsIDE4LCA4XV0sXG4gICAgXCJIXCI6IFsyMiwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDE4LCAyMSwgMTgsIDAsIC0xLCAtMSwgNCwgMTEsIDE4LCAxMV1dLFxuICAgIFwiSVwiOiBbOCwgWzQsIDIxLCA0LCAwXV0sXG4gICAgXCJKXCI6IFsxNiwgWzEyLCAyMSwgMTIsIDUsIDExLCAyLCAxMCwgMSwgOCwgMCwgNiwgMCwgNCwgMSwgMywgMiwgMiwgNSwgMiwgN11dLFxuICAgIFwiS1wiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCAxOCwgMjEsIDQsIDcsIC0xLCAtMSwgOSwgMTIsIDE4LCAwXV0sXG4gICAgXCJMXCI6IFsxNywgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDAsIDE2LCAwXV0sXG4gICAgXCJNXCI6IFsyNCwgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDQsIDIxLCAxMiwgMCwgLTEsIC0xLCAyMCwgMjEsIDEyLCAwLCAtMSwgLTEsIDIwLCAyMSwgMjAsIDBdXSxcbiAgICBcIk5cIjogWzIyLCBbNCwgMjEsIDQsIDAsIC0xLCAtMSwgNCwgMjEsIDE4LCAwLCAtMSwgLTEsIDE4LCAyMSwgMTgsIDBdXSxcbiAgICBcIk9cIjogWzIyLCBbOSwgMjEsIDcsIDIwLCA1LCAxOCwgNCwgMTYsIDMsIDEzLCAzLCA4LCA0LCA1LCA1LCAzLCA3LCAxLCA5LCAwLCAxMywgMCwgMTUsIDEsIDE3LCAzLCAxOCwgNSwgMTksIDgsIDE5LCAxMywgMTgsIDE2LCAxNywgMTgsIDE1LCAyMCwgMTMsIDIxLCA5LCAyMV1dLFxuICAgIFwiUFwiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTMsIDIxLCAxNiwgMjAsIDE3LCAxOSwgMTgsIDE3LCAxOCwgMTQsIDE3LCAxMiwgMTYsIDExLCAxMywgMTAsIDQsIDEwXV0sXG4gICAgXCJRXCI6IFsyMiwgWzksIDIxLCA3LCAyMCwgNSwgMTgsIDQsIDE2LCAzLCAxMywgMywgOCwgNCwgNSwgNSwgMywgNywgMSwgOSwgMCwgMTMsIDAsIDE1LCAxLCAxNywgMywgMTgsIDUsIDE5LCA4LCAxOSwgMTMsIDE4LCAxNiwgMTcsIDE4LCAxNSwgMjAsIDEzLCAyMSwgOSwgMjEsIC0xLCAtMSwgMTIsIDQsIDE4LCAtMl1dLFxuICAgIFwiUlwiOiBbMjEsIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAyMSwgMTMsIDIxLCAxNiwgMjAsIDE3LCAxOSwgMTgsIDE3LCAxOCwgMTUsIDE3LCAxMywgMTYsIDEyLCAxMywgMTEsIDQsIDExLCAtMSwgLTEsIDExLCAxMSwgMTgsIDBdXSxcbiAgICBcIlNcIjogWzIwLCBbMTcsIDE4LCAxNSwgMjAsIDEyLCAyMSwgOCwgMjEsIDUsIDIwLCAzLCAxOCwgMywgMTYsIDQsIDE0LCA1LCAxMywgNywgMTIsIDEzLCAxMCwgMTUsIDksIDE2LCA4LCAxNywgNiwgMTcsIDMsIDE1LCAxLCAxMiwgMCwgOCwgMCwgNSwgMSwgMywgM11dLFxuICAgIFwiVFwiOiBbMTYsIFs4LCAyMSwgOCwgMCwgLTEsIC0xLCAxLCAyMSwgMTUsIDIxXV0sXG4gICAgXCJVXCI6IFsyMiwgWzQsIDIxLCA0LCA2LCA1LCAzLCA3LCAxLCAxMCwgMCwgMTIsIDAsIDE1LCAxLCAxNywgMywgMTgsIDYsIDE4LCAyMV1dLFxuICAgIFwiVlwiOiBbMTgsIFsxLCAyMSwgOSwgMCwgLTEsIC0xLCAxNywgMjEsIDksIDBdXSxcbiAgICBcIldcIjogWzI0LCBbMiwgMjEsIDcsIDAsIC0xLCAtMSwgMTIsIDIxLCA3LCAwLCAtMSwgLTEsIDEyLCAyMSwgMTcsIDAsIC0xLCAtMSwgMjIsIDIxLCAxNywgMF1dLFxuICAgIFwiWFwiOiBbMjAsIFszLCAyMSwgMTcsIDAsIC0xLCAtMSwgMTcsIDIxLCAzLCAwXV0sXG4gICAgXCJZXCI6IFsxOCwgWzEsIDIxLCA5LCAxMSwgOSwgMCwgLTEsIC0xLCAxNywgMjEsIDksIDExXV0sXG4gICAgXCJaXCI6IFsyMCwgWzE3LCAyMSwgMywgMCwgLTEsIC0xLCAzLCAyMSwgMTcsIDIxLCAtMSwgLTEsIDMsIDAsIDE3LCAwXV0sXG4gICAgXCJbXCI6IFsxNCwgWzQsIDI1LCA0LCAtNywgLTEsIC0xLCA1LCAyNSwgNSwgLTcsIC0xLCAtMSwgNCwgMjUsIDExLCAyNSwgLTEsIC0xLCA0LCAtNywgMTEsIC03XV0sXG4gICAgXCJcXFxcXCI6IFsxNCwgWzAsIDIxLCAxNCwgLTNdXSxcbiAgICBcIl1cIjogWzE0LCBbOSwgMjUsIDksIC03LCAtMSwgLTEsIDEwLCAyNSwgMTAsIC03LCAtMSwgLTEsIDMsIDI1LCAxMCwgMjUsIC0xLCAtMSwgMywgLTcsIDEwLCAtN11dLFxuICAgIFwiXlwiOiBbMTYsIFs2LCAxNSwgOCwgMTgsIDEwLCAxNSwgLTEsIC0xLCAzLCAxMiwgOCwgMTcsIDEzLCAxMiwgLTEsIC0xLCA4LCAxNywgOCwgMF1dLFxuICAgIFwiX1wiOiBbMTYsIFswLCAtMiwgMTYsIC0yXV0sXG4gICAgXCJgXCI6IFsxMCwgWzYsIDIxLCA1LCAyMCwgNCwgMTgsIDQsIDE2LCA1LCAxNSwgNiwgMTYsIDUsIDE3XV0sXG4gICAgXCJhXCI6IFsxOSwgWzE1LCAxNCwgMTUsIDAsIC0xLCAtMSwgMTUsIDExLCAxMywgMTMsIDExLCAxNCwgOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgM11dLFxuICAgIFwiYlwiOiBbMTksIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAxMSwgNiwgMTMsIDgsIDE0LCAxMSwgMTQsIDEzLCAxMywgMTUsIDExLCAxNiwgOCwgMTYsIDYsIDE1LCAzLCAxMywgMSwgMTEsIDAsIDgsIDAsIDYsIDEsIDQsIDNdXSxcbiAgICBcImNcIjogWzE4LCBbMTUsIDExLCAxMywgMTMsIDExLCAxNCwgOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgM11dLFxuICAgIFwiZFwiOiBbMTksIFsxNSwgMjEsIDE1LCAwLCAtMSwgLTEsIDE1LCAxMSwgMTMsIDEzLCAxMSwgMTQsIDgsIDE0LCA2LCAxMywgNCwgMTEsIDMsIDgsIDMsIDYsIDQsIDMsIDYsIDEsIDgsIDAsIDExLCAwLCAxMywgMSwgMTUsIDNdXSxcbiAgICBcImVcIjogWzE4LCBbMywgOCwgMTUsIDgsIDE1LCAxMCwgMTQsIDEyLCAxMywgMTMsIDExLCAxNCwgOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgM11dLFxuICAgIFwiZlwiOiBbMTIsIFsxMCwgMjEsIDgsIDIxLCA2LCAyMCwgNSwgMTcsIDUsIDAsIC0xLCAtMSwgMiwgMTQsIDksIDE0XV0sXG4gICAgXCJnXCI6IFsxOSwgWzE1LCAxNCwgMTUsIC0yLCAxNCwgLTUsIDEzLCAtNiwgMTEsIC03LCA4LCAtNywgNiwgLTYsIC0xLCAtMSwgMTUsIDExLCAxMywgMTMsIDExLCAxNCwgOCwgMTQsIDYsIDEzLCA0LCAxMSwgMywgOCwgMywgNiwgNCwgMywgNiwgMSwgOCwgMCwgMTEsIDAsIDEzLCAxLCAxNSwgM11dLFxuICAgIFwiaFwiOiBbMTksIFs0LCAyMSwgNCwgMCwgLTEsIC0xLCA0LCAxMCwgNywgMTMsIDksIDE0LCAxMiwgMTQsIDE0LCAxMywgMTUsIDEwLCAxNSwgMF1dLFxuICAgIFwiaVwiOiBbOCwgWzMsIDIxLCA0LCAyMCwgNSwgMjEsIDQsIDIyLCAzLCAyMSwgLTEsIC0xLCA0LCAxNCwgNCwgMF1dLFxuICAgIFwialwiOiBbMTAsIFs1LCAyMSwgNiwgMjAsIDcsIDIxLCA2LCAyMiwgNSwgMjEsIC0xLCAtMSwgNiwgMTQsIDYsIC0zLCA1LCAtNiwgMywgLTcsIDEsIC03XV0sXG4gICAgXCJrXCI6IFsxNywgWzQsIDIxLCA0LCAwLCAtMSwgLTEsIDE0LCAxNCwgNCwgNCwgLTEsIC0xLCA4LCA4LCAxNSwgMF1dLFxuICAgIFwibFwiOiBbOCwgWzQsIDIxLCA0LCAwXV0sXG4gICAgXCJtXCI6IFszMCwgWzQsIDE0LCA0LCAwLCAtMSwgLTEsIDQsIDEwLCA3LCAxMywgOSwgMTQsIDEyLCAxNCwgMTQsIDEzLCAxNSwgMTAsIDE1LCAwLCAtMSwgLTEsIDE1LCAxMCwgMTgsIDEzLCAyMCwgMTQsIDIzLCAxNCwgMjUsIDEzLCAyNiwgMTAsIDI2LCAwXV0sXG4gICAgXCJuXCI6IFsxOSwgWzQsIDE0LCA0LCAwLCAtMSwgLTEsIDQsIDEwLCA3LCAxMywgOSwgMTQsIDEyLCAxNCwgMTQsIDEzLCAxNSwgMTAsIDE1LCAwXV0sXG4gICAgXCJvXCI6IFsxOSwgWzgsIDE0LCA2LCAxMywgNCwgMTEsIDMsIDgsIDMsIDYsIDQsIDMsIDYsIDEsIDgsIDAsIDExLCAwLCAxMywgMSwgMTUsIDMsIDE2LCA2LCAxNiwgOCwgMTUsIDExLCAxMywgMTMsIDExLCAxNCwgOCwgMTRdXSxcbiAgICBcInBcIjogWzE5LCBbNCwgMTQsIDQsIC03LCAtMSwgLTEsIDQsIDExLCA2LCAxMywgOCwgMTQsIDExLCAxNCwgMTMsIDEzLCAxNSwgMTEsIDE2LCA4LCAxNiwgNiwgMTUsIDMsIDEzLCAxLCAxMSwgMCwgOCwgMCwgNiwgMSwgNCwgM11dLFxuICAgIFwicVwiOiBbMTksIFsxNSwgMTQsIDE1LCAtNywgLTEsIC0xLCAxNSwgMTEsIDEzLCAxMywgMTEsIDE0LCA4LCAxNCwgNiwgMTMsIDQsIDExLCAzLCA4LCAzLCA2LCA0LCAzLCA2LCAxLCA4LCAwLCAxMSwgMCwgMTMsIDEsIDE1LCAzXV0sXG4gICAgXCJyXCI6IFsxMywgWzQsIDE0LCA0LCAwLCAtMSwgLTEsIDQsIDgsIDUsIDExLCA3LCAxMywgOSwgMTQsIDEyLCAxNF1dLFxuICAgIFwic1wiOiBbMTcsIFsxNCwgMTEsIDEzLCAxMywgMTAsIDE0LCA3LCAxNCwgNCwgMTMsIDMsIDExLCA0LCA5LCA2LCA4LCAxMSwgNywgMTMsIDYsIDE0LCA0LCAxNCwgMywgMTMsIDEsIDEwLCAwLCA3LCAwLCA0LCAxLCAzLCAzXV0sXG4gICAgXCJ0XCI6IFsxMiwgWzUsIDIxLCA1LCA0LCA2LCAxLCA4LCAwLCAxMCwgMCwgLTEsIC0xLCAyLCAxNCwgOSwgMTRdXSxcbiAgICBcInVcIjogWzE5LCBbNCwgMTQsIDQsIDQsIDUsIDEsIDcsIDAsIDEwLCAwLCAxMiwgMSwgMTUsIDQsIC0xLCAtMSwgMTUsIDE0LCAxNSwgMF1dLFxuICAgIFwidlwiOiBbMTYsIFsyLCAxNCwgOCwgMCwgLTEsIC0xLCAxNCwgMTQsIDgsIDBdXSxcbiAgICBcIndcIjogWzIyLCBbMywgMTQsIDcsIDAsIC0xLCAtMSwgMTEsIDE0LCA3LCAwLCAtMSwgLTEsIDExLCAxNCwgMTUsIDAsIC0xLCAtMSwgMTksIDE0LCAxNSwgMF1dLFxuICAgIFwieFwiOiBbMTcsIFszLCAxNCwgMTQsIDAsIC0xLCAtMSwgMTQsIDE0LCAzLCAwXV0sXG4gICAgXCJ5XCI6IFsxNiwgWzIsIDE0LCA4LCAwLCAtMSwgLTEsIDE0LCAxNCwgOCwgMCwgNiwgLTQsIDQsIC02LCAyLCAtNywgMSwgLTddXSxcbiAgICBcInpcIjogWzE3LCBbMTQsIDE0LCAzLCAwLCAtMSwgLTEsIDMsIDE0LCAxNCwgMTQsIC0xLCAtMSwgMywgMCwgMTQsIDBdXSxcbiAgICBcIntcIjogWzE0LCBbOSwgMjUsIDcsIDI0LCA2LCAyMywgNSwgMjEsIDUsIDE5LCA2LCAxNywgNywgMTYsIDgsIDE0LCA4LCAxMiwgNiwgMTAsIC0xLCAtMSwgNywgMjQsIDYsIDIyLCA2LCAyMCwgNywgMTgsIDgsIDE3LCA5LCAxNSwgOSwgMTMsIDgsIDExLCA0LCA5LCA4LCA3LCA5LCA1LCA5LCAzLCA4LCAxLCA3LCAwLCA2LCAtMiwgNiwgLTQsIDcsIC02LCAtMSwgLTEsIDYsIDgsIDgsIDYsIDgsIDQsIDcsIDIsIDYsIDEsIDUsIC0xLCA1LCAtMywgNiwgLTUsIDcsIC02LCA5LCAtN11dLFxuICAgIFwifFwiOiBbOCwgWzQsIDI1LCA0LCAtN11dLFxuICAgIFwifVwiOiBbMTQsIFs1LCAyNSwgNywgMjQsIDgsIDIzLCA5LCAyMSwgOSwgMTksIDgsIDE3LCA3LCAxNiwgNiwgMTQsIDYsIDEyLCA4LCAxMCwgLTEsIC0xLCA3LCAyNCwgOCwgMjIsIDgsIDIwLCA3LCAxOCwgNiwgMTcsIDUsIDE1LCA1LCAxMywgNiwgMTEsIDEwLCA5LCA2LCA3LCA1LCA1LCA1LCAzLCA2LCAxLCA3LCAwLCA4LCAtMiwgOCwgLTQsIDcsIC02LCAtMSwgLTEsIDgsIDgsIDYsIDYsIDYsIDQsIDcsIDIsIDgsIDEsIDksIC0xLCA5LCAtMywgOCwgLTUsIDcsIC02LCA1LCAtN11dLFxuICAgIFwiflwiOiBbMjQsIFszLCA2LCAzLCA4LCA0LCAxMSwgNiwgMTIsIDgsIDEyLCAxMCwgMTEsIDE0LCA4LCAxNiwgNywgMTgsIDcsIDIwLCA4LCAyMSwgMTAsIC0xLCAtMSwgMywgOCwgNCwgMTAsIDYsIDExLCA4LCAxMSwgMTAsIDEwLCAxNCwgNywgMTYsIDYsIDE4LCA2LCAyMCwgNywgMjEsIDEwLCAyMSwgMTJdXVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0VmVydGljZXModGV4dCwgbGVmdCwgYmFzZWxpbmUsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxO1xuXG4gICAgdmFyIHN0cm9rZXMgPSBbXSxcbiAgICAgICAgaSwgbGVuLCBqLCBsZW4yLCBnbHlwaCwgeCwgeSwgcHJldjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRleHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZ2x5cGggPSBzaW1wbGV4Rm9udFt0ZXh0W2ldXTtcbiAgICAgICAgaWYgKCFnbHlwaCkgY29udGludWU7XG4gICAgICAgIHByZXYgPSBudWxsO1xuXG4gICAgICAgIGZvciAoaiA9IDAsIGxlbjIgPSBnbHlwaFsxXS5sZW5ndGg7IGogPCBsZW4yOyBqICs9IDIpIHtcbiAgICAgICAgICAgIGlmIChnbHlwaFsxXVtqXSA9PT0gLTEgJiYgZ2x5cGhbMV1baiArIDFdID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHByZXYgPSBudWxsO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHggPSBsZWZ0ICsgZ2x5cGhbMV1bal0gKiBzY2FsZTtcbiAgICAgICAgICAgICAgICB5ID0gYmFzZWxpbmUgLSBnbHlwaFsxXVtqICsgMV0gKiBzY2FsZTtcbiAgICAgICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgICAgICBzdHJva2VzLnB1c2gocHJldi54LCBwcmV2LnksIHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2ID0ge3g6IHgsIHk6IHl9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxlZnQgKz0gZ2x5cGhbMF0gKiBzY2FsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3Ryb2tlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGpzaGludCAtVzA3OVxudmFyIG1hcGJveGdsID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxubWFwYm94Z2wudmVyc2lvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG5cbm1hcGJveGdsLk1hcCA9IHJlcXVpcmUoJy4vdWkvbWFwJyk7XG5tYXBib3hnbC5Db250cm9sID0gcmVxdWlyZSgnLi91aS9jb250cm9sL2NvbnRyb2wnKTtcbm1hcGJveGdsLk5hdmlnYXRpb24gPSByZXF1aXJlKCcuL3VpL2NvbnRyb2wvbmF2aWdhdGlvbicpO1xubWFwYm94Z2wuR2VvbG9jYXRlID0gcmVxdWlyZSgnLi91aS9jb250cm9sL2dlb2xvY2F0ZScpO1xubWFwYm94Z2wuQXR0cmlidXRpb24gPSByZXF1aXJlKCcuL3VpL2NvbnRyb2wvYXR0cmlidXRpb24nKTtcbm1hcGJveGdsLlNjYWxlID0gcmVxdWlyZSgnLi91aS9jb250cm9sL3NjYWxlJyk7XG5tYXBib3hnbC5Qb3B1cCA9IHJlcXVpcmUoJy4vdWkvcG9wdXAnKTtcbm1hcGJveGdsLk1hcmtlciA9IHJlcXVpcmUoJy4vdWkvbWFya2VyJyk7XG5cbm1hcGJveGdsLlN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZS9zdHlsZScpO1xuXG5tYXBib3hnbC5MbmdMYXQgPSByZXF1aXJlKCcuL2dlby9sbmdfbGF0Jyk7XG5tYXBib3hnbC5MbmdMYXRCb3VuZHMgPSByZXF1aXJlKCcuL2dlby9sbmdfbGF0X2JvdW5kcycpO1xubWFwYm94Z2wuUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tYXBib3hnbC5FdmVudGVkID0gcmVxdWlyZSgnLi91dGlsL2V2ZW50ZWQnKTtcbm1hcGJveGdsLnV0aWwgPSByZXF1aXJlKCcuL3V0aWwvdXRpbCcpO1xuXG5tYXBib3hnbC5zdXBwb3J0ZWQgPSByZXF1aXJlKCcuL3V0aWwvYnJvd3NlcicpLnN1cHBvcnRlZDtcblxudmFyIGFqYXggPSByZXF1aXJlKCcuL3V0aWwvYWpheCcpO1xubWFwYm94Z2wudXRpbC5nZXRKU09OID0gYWpheC5nZXRKU09OO1xubWFwYm94Z2wudXRpbC5nZXRBcnJheUJ1ZmZlciA9IGFqYXguZ2V0QXJyYXlCdWZmZXI7XG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL3V0aWwvY29uZmlnJyk7XG5tYXBib3hnbC5jb25maWcgPSBjb25maWc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShtYXBib3hnbCwgJ2FjY2Vzc1Rva2VuJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBjb25maWcuQUNDRVNTX1RPS0VOOyB9LFxuICAgIHNldDogZnVuY3Rpb24odG9rZW4pIHsgY29uZmlnLkFDQ0VTU19UT0tFTiA9IHRva2VuOyB9XG59KTtcblxuLyoqXG4gKiBHZXRzIGFuZCBzZXRzIHRoZSBtYXAncyBbYWNjZXNzIHRva2VuXShodHRwczovL3d3dy5tYXBib3guY29tL2hlbHAvZGVmaW5lLWFjY2Vzcy10b2tlbi8pLlxuICpcbiAqIEB2YXIge3N0cmluZ30gYWNjZXNzVG9rZW5cbiAqIEBleGFtcGxlXG4gKiBtYXBib3hnbC5hY2Nlc3NUb2tlbiA9IG15QWNjZXNzVG9rZW47XG4gKi9cblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiBNYXBib3ggR0wgSlMgaW4gdXNlIGFzIHNwZWNpZmllZCBpbiBgcGFja2FnZS5qc29uYCxcbiAqIGBDSEFOR0VMT0cubWRgLCBhbmQgdGhlIEdpdEh1YiByZWxlYXNlLlxuICpcbiAqIEB2YXIge3N0cmluZ30gdmVyc2lvblxuICovXG5cbi8qKlxuICogUmV0dXJucyBhIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBicm93c2VyIFtzdXBwb3J0cyBNYXBib3ggR0wgSlNdKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vaGVscC9tYXBib3gtYnJvd3Nlci1zdXBwb3J0LyNtYXBib3gtZ2wtanMpLlxuICpcbiAqIEBmdW5jdGlvbiBzdXBwb3J0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ9ZmFsc2VdIElmIGB0cnVlYCxcbiAqICAgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGBmYWxzZWAgaWYgdGhlIHBlcmZvcm1hbmNlIG9mIE1hcGJveCBHTCBKUyB3b3VsZFxuICogICBiZSBkcmFtYXRpY2FsbHkgd29yc2UgdGhhbiBleHBlY3RlZCAoaS5lLiBhIHNvZnR3YXJlIHJlbmRlcmVyIHdvdWxkIGJlIHVzZWQpLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqIEBleGFtcGxlXG4gKiBtYXBib3hnbC5zdXBwb3J0ZWQoKSAvLyA9IHRydWVcbiAqL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odW5pZm9ybXMpIHtcbiAgICB2YXIgcHJhZ21hcyA9IHsgZGVmaW5lOiB7fSwgaW5pdGlhbGl6ZToge30gfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5pZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHVuaWZvcm0gPSB1bmlmb3Jtc1tpXTtcbiAgICAgICAgYXNzZXJ0KHVuaWZvcm0ubmFtZS5zbGljZSgwLCAyKSA9PT0gJ3VfJyk7XG5cbiAgICAgICAgdmFyIHR5cGUgPSAne3ByZWNpc2lvbn0gJyArICh1bmlmb3JtLmNvbXBvbmVudHMgPT09IDEgPyAnZmxvYXQnIDogJ3ZlYycgKyB1bmlmb3JtLmNvbXBvbmVudHMpO1xuICAgICAgICBwcmFnbWFzLmRlZmluZVt1bmlmb3JtLm5hbWUuc2xpY2UoMildID0gJ3VuaWZvcm0gJyArIHR5cGUgKyAnICcgKyB1bmlmb3JtLm5hbWUgKyAnO1xcbic7XG4gICAgICAgIHByYWdtYXMuaW5pdGlhbGl6ZVt1bmlmb3JtLm5hbWUuc2xpY2UoMildID0gdHlwZSArICcgJyArIHVuaWZvcm0ubmFtZS5zbGljZSgyKSArICcgPSAnICsgdW5pZm9ybS5uYW1lICsgJztcXG4nO1xuICAgIH1cblxuICAgIHJldHVybiBwcmFnbWFzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBpeGVsc1RvVGlsZVVuaXRzID0gcmVxdWlyZSgnLi4vc291cmNlL3BpeGVsc190b190aWxlX3VuaXRzJyk7XG52YXIgY3JlYXRlVW5pZm9ybVByYWdtYXMgPSByZXF1aXJlKCcuL2NyZWF0ZV91bmlmb3JtX3ByYWdtYXMnKTtcblxudmFyIHRpbGVTaXplID0gNTEyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRyYXdCYWNrZ3JvdW5kO1xuXG5mdW5jdGlvbiBkcmF3QmFja2dyb3VuZChwYWludGVyLCBzb3VyY2UsIGxheWVyKSB7XG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcbiAgICB2YXIgdHJhbnNmb3JtID0gcGFpbnRlci50cmFuc2Zvcm07XG4gICAgdmFyIGNvbG9yID0gbGF5ZXIucGFpbnRbJ2JhY2tncm91bmQtY29sb3InXTtcbiAgICB2YXIgaW1hZ2UgPSBsYXllci5wYWludFsnYmFja2dyb3VuZC1wYXR0ZXJuJ107XG4gICAgdmFyIG9wYWNpdHkgPSBsYXllci5wYWludFsnYmFja2dyb3VuZC1vcGFjaXR5J107XG4gICAgdmFyIHByb2dyYW07XG5cbiAgICB2YXIgaW1hZ2VQb3NBID0gaW1hZ2UgPyBwYWludGVyLnNwcml0ZUF0bGFzLmdldFBvc2l0aW9uKGltYWdlLmZyb20sIHRydWUpIDogbnVsbDtcbiAgICB2YXIgaW1hZ2VQb3NCID0gaW1hZ2UgPyBwYWludGVyLnNwcml0ZUF0bGFzLmdldFBvc2l0aW9uKGltYWdlLnRvLCB0cnVlKSA6IG51bGw7XG5cbiAgICBwYWludGVyLnNldERlcHRoU3VibGF5ZXIoMCk7XG4gICAgaWYgKGltYWdlUG9zQSAmJiBpbWFnZVBvc0IpIHtcblxuICAgICAgICBpZiAocGFpbnRlci5pc09wYXF1ZVBhc3MpIHJldHVybjtcblxuICAgICAgICAvLyBEcmF3IHRleHR1cmUgZmlsbFxuICAgICAgICBwcm9ncmFtID0gcGFpbnRlci51c2VQcm9ncmFtKCdwYXR0ZXJuJyk7XG4gICAgICAgIGdsLnVuaWZvcm0xaShwcm9ncmFtLnVfaW1hZ2UsIDApO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHByb2dyYW0udV9wYXR0ZXJuX3RsX2EsIGltYWdlUG9zQS50bCk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYocHJvZ3JhbS51X3BhdHRlcm5fYnJfYSwgaW1hZ2VQb3NBLmJyKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfcGF0dGVybl90bF9iLCBpbWFnZVBvc0IudGwpO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHByb2dyYW0udV9wYXR0ZXJuX2JyX2IsIGltYWdlUG9zQi5icik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfb3BhY2l0eSwgb3BhY2l0eSk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9taXgsIGltYWdlLnQpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0yZnYocHJvZ3JhbS51X3BhdHRlcm5fc2l6ZV9hLCBpbWFnZVBvc0Euc2l6ZSk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYocHJvZ3JhbS51X3BhdHRlcm5fc2l6ZV9iLCBpbWFnZVBvc0Iuc2l6ZSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfc2NhbGVfYSwgaW1hZ2UuZnJvbVNjYWxlKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9zY2FsZV9iLCBpbWFnZS50b1NjYWxlKTtcblxuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICAgICAgcGFpbnRlci5zcHJpdGVBdGxhcy5iaW5kKGdsLCB0cnVlKTtcblxuICAgICAgICBwYWludGVyLnRpbGVFeHRlbnRQYXR0ZXJuVkFPLmJpbmQoZ2wsIHByb2dyYW0sIHBhaW50ZXIudGlsZUV4dGVudEJ1ZmZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRHJhdyBmaWxsaW5nIHJlY3RhbmdsZS5cbiAgICAgICAgaWYgKHBhaW50ZXIuaXNPcGFxdWVQYXNzICE9PSAoY29sb3JbM10gPT09IDEpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHByYWdtYXMgPSBjcmVhdGVVbmlmb3JtUHJhZ21hcyhbXG4gICAgICAgICAgICB7bmFtZTogJ3VfY29sb3InLCBjb21wb25lbnRzOiA0fSxcbiAgICAgICAgICAgIHtuYW1lOiAndV9vcGFjaXR5JywgY29tcG9uZW50czogMX1cbiAgICAgICAgXSk7XG4gICAgICAgIHByb2dyYW0gPSBwYWludGVyLnVzZVByb2dyYW0oJ2ZpbGwnLCBbXSwgcHJhZ21hcywgcHJhZ21hcyk7XG4gICAgICAgIGdsLnVuaWZvcm00ZnYocHJvZ3JhbS51X2NvbG9yLCBjb2xvcik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfb3BhY2l0eSwgb3BhY2l0eSk7XG4gICAgICAgIHBhaW50ZXIudGlsZUV4dGVudFZBTy5iaW5kKGdsLCBwcm9ncmFtLCBwYWludGVyLnRpbGVFeHRlbnRCdWZmZXIpO1xuICAgIH1cblxuICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcblxuICAgIC8vIFdlIG5lZWQgdG8gZHJhdyB0aGUgYmFja2dyb3VuZCBpbiB0aWxlcyBpbiBvcmRlciB0byB1c2UgY2FsY3VsYXRlUG9zTWF0cml4XG4gICAgLy8gd2hpY2ggYXBwbGllcyB0aGUgcHJvamVjdGlvbiBtYXRyaXggKHRyYW5zZm9ybS5wcm9qTWF0cml4KS4gT3RoZXJ3aXNlXG4gICAgLy8gdGhlIGRlcHRoIGFuZCBzdGVuY2lsIGJ1ZmZlcnMgZ2V0IGludG8gYSBiYWQgc3RhdGUuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVmYWN0b3JlZCBpbnRvIGEgc2luZ2xlIGRyYXcgY2FsbCBvbmNlIGVhcmN1dCBsYW5kcyBhbmRcbiAgICAvLyB3ZSBkb24ndCBoYXZlIHNvIG11Y2ggZ29pbmcgb24gaW4gdGhlIHN0ZW5jaWwgYnVmZmVyLlxuICAgIHZhciBjb29yZHMgPSB0cmFuc2Zvcm0uY292ZXJpbmdUaWxlcyh7IHRpbGVTaXplOiB0aWxlU2l6ZSB9KTtcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvb3Jkcy5sZW5ndGg7IGMrKykge1xuICAgICAgICB2YXIgY29vcmQgPSBjb29yZHNbY107XG4gICAgICAgIC8vIHZhciBwaXhlbHNUb1RpbGVVbml0c0JvdW5kID0gcGl4ZWxzVG9UaWxlVW5pdHMuYmluZCh7Y29vcmQ6Y29vcmQsIHRpbGVTaXplOiB0aWxlU2l6ZX0pO1xuICAgICAgICBpZiAoaW1hZ2VQb3NBICYmIGltYWdlUG9zQikge1xuICAgICAgICAgICAgdmFyIHRpbGUgPSB7Y29vcmQ6Y29vcmQsIHRpbGVTaXplOiB0aWxlU2l6ZX07XG5cbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfdGlsZV91bml0c190b19waXhlbHMsIDEgLyBwaXhlbHNUb1RpbGVVbml0cyh0aWxlLCAxLCBwYWludGVyLnRyYW5zZm9ybS50aWxlWm9vbSkpO1xuXG4gICAgICAgICAgICB2YXIgdGlsZVNpemVBdE5lYXJlc3Rab29tID0gdGlsZS50aWxlU2l6ZSAqIE1hdGgucG93KDIsIHBhaW50ZXIudHJhbnNmb3JtLnRpbGVab29tIC0gdGlsZS5jb29yZC56KTtcblxuICAgICAgICAgICAgdmFyIHBpeGVsWCA9IHRpbGVTaXplQXROZWFyZXN0Wm9vbSAqICh0aWxlLmNvb3JkLnggKyBjb29yZC53ICogTWF0aC5wb3coMiwgdGlsZS5jb29yZC56KSk7XG4gICAgICAgICAgICB2YXIgcGl4ZWxZID0gdGlsZVNpemVBdE5lYXJlc3Rab29tICogdGlsZS5jb29yZC55O1xuICAgICAgICAgICAgLy8gc3BsaXQgdGhlIHBpeGVsIGNvb3JkIGludG8gdHdvIHBhaXJzIG9mIDE2IGJpdCBudW1iZXJzLiBUaGUgZ2xzbCBzcGVjIG9ubHkgZ3VhcmFudGVlcyAxNiBiaXRzIG9mIHByZWNpc2lvbi5cbiAgICAgICAgICAgIGdsLnVuaWZvcm0yZihwcm9ncmFtLnVfcGl4ZWxfY29vcmRfdXBwZXIsIHBpeGVsWCA+PiAxNiwgcGl4ZWxZID4+IDE2KTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0yZihwcm9ncmFtLnVfcGl4ZWxfY29vcmRfbG93ZXIsIHBpeGVsWCAmIDB4RkZGRiwgcGl4ZWxZICYgMHhGRkZGKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYocHJvZ3JhbS51X21hdHJpeCwgZmFsc2UsIHBhaW50ZXIudHJhbnNmb3JtLmNhbGN1bGF0ZVBvc01hdHJpeChjb29yZCkpO1xuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCBwYWludGVyLnRpbGVFeHRlbnRCdWZmZXIubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBnbC5zdGVuY2lsTWFzaygweDAwKTtcbiAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMHg4MCwgMHg4MCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhd0NpcmNsZXM7XG5cbmZ1bmN0aW9uIGRyYXdDaXJjbGVzKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkcykge1xuICAgIGlmIChwYWludGVyLmlzT3BhcXVlUGFzcykgcmV0dXJuO1xuXG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcblxuICAgIHBhaW50ZXIuc2V0RGVwdGhTdWJsYXllcigwKTtcbiAgICBwYWludGVyLmRlcHRoTWFzayhmYWxzZSk7XG5cbiAgICAvLyBBbGxvdyBjaXJjbGVzIHRvIGJlIGRyYXduIGFjcm9zcyBib3VuZGFyaWVzLCBzbyB0aGF0XG4gICAgLy8gbGFyZ2UgY2lyY2xlcyBhcmUgbm90IGNsaXBwZWQgdG8gdGlsZXNcbiAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29vcmQgPSBjb29yZHNbaV07XG5cbiAgICAgICAgdmFyIHRpbGUgPSBzb3VyY2UuZ2V0VGlsZShjb29yZCk7XG4gICAgICAgIHZhciBidWNrZXQgPSB0aWxlLmdldEJ1Y2tldChsYXllcik7XG4gICAgICAgIGlmICghYnVja2V0KSBjb250aW51ZTtcbiAgICAgICAgdmFyIGJ1ZmZlckdyb3VwcyA9IGJ1Y2tldC5idWZmZXJHcm91cHMuY2lyY2xlO1xuICAgICAgICBpZiAoIWJ1ZmZlckdyb3VwcykgY29udGludWU7XG5cbiAgICAgICAgdmFyIHByb2dyYW1PcHRpb25zID0gYnVja2V0LnBhaW50QXR0cmlidXRlcy5jaXJjbGVbbGF5ZXIuaWRdO1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IHBhaW50ZXIudXNlUHJvZ3JhbShcbiAgICAgICAgICAgICdjaXJjbGUnLFxuICAgICAgICAgICAgcHJvZ3JhbU9wdGlvbnMuZGVmaW5lcyxcbiAgICAgICAgICAgIHByb2dyYW1PcHRpb25zLnZlcnRleFByYWdtYXMsXG4gICAgICAgICAgICBwcm9ncmFtT3B0aW9ucy5mcmFnbWVudFByYWdtYXNcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAobGF5ZXIucGFpbnRbJ2NpcmNsZS1waXRjaC1zY2FsZSddID09PSAnbWFwJykge1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFpKHByb2dyYW0udV9zY2FsZV93aXRoX21hcCwgdHJ1ZSk7XG4gICAgICAgICAgICBnbC51bmlmb3JtMmYocHJvZ3JhbS51X2V4dHJ1ZGVfc2NhbGUsXG4gICAgICAgICAgICAgICAgcGFpbnRlci50cmFuc2Zvcm0ucGl4ZWxzVG9HTFVuaXRzWzBdICogcGFpbnRlci50cmFuc2Zvcm0uYWx0aXR1ZGUsXG4gICAgICAgICAgICAgICAgcGFpbnRlci50cmFuc2Zvcm0ucGl4ZWxzVG9HTFVuaXRzWzFdICogcGFpbnRlci50cmFuc2Zvcm0uYWx0aXR1ZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFpKHByb2dyYW0udV9zY2FsZV93aXRoX21hcCwgZmFsc2UpO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfZXh0cnVkZV9zY2FsZSwgcGFpbnRlci50cmFuc2Zvcm0ucGl4ZWxzVG9HTFVuaXRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfZGV2aWNlcGl4ZWxyYXRpbywgYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvKTtcblxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHByb2dyYW0udV9tYXRyaXgsIGZhbHNlLCBwYWludGVyLnRyYW5zbGF0ZVBvc01hdHJpeChcbiAgICAgICAgICAgIGNvb3JkLnBvc01hdHJpeCxcbiAgICAgICAgICAgIHRpbGUsXG4gICAgICAgICAgICBsYXllci5wYWludFsnY2lyY2xlLXRyYW5zbGF0ZSddLFxuICAgICAgICAgICAgbGF5ZXIucGFpbnRbJ2NpcmNsZS10cmFuc2xhdGUtYW5jaG9yJ11cbiAgICAgICAgKSk7XG5cbiAgICAgICAgYnVja2V0LnNldFVuaWZvcm1zKGdsLCAnY2lyY2xlJywgcHJvZ3JhbSwgbGF5ZXIsIHt6b29tOiBwYWludGVyLnRyYW5zZm9ybS56b29tfSk7XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBidWZmZXJHcm91cHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IGJ1ZmZlckdyb3Vwc1trXTtcbiAgICAgICAgICAgIGdyb3VwLnZhb3NbbGF5ZXIuaWRdLmJpbmQoZ2wsIHByb2dyYW0sIGdyb3VwLmxheW91dFZlcnRleEJ1ZmZlciwgZ3JvdXAuZWxlbWVudEJ1ZmZlciwgZ3JvdXAucGFpbnRWZXJ0ZXhCdWZmZXJzW2xheWVyLmlkXSk7XG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBncm91cC5lbGVtZW50QnVmZmVyLmxlbmd0aCAqIDMsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBkcmF3Q29sbGlzaW9uRGVidWc7XG5cbmZ1bmN0aW9uIGRyYXdDb2xsaXNpb25EZWJ1ZyhwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZHMpIHtcbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuICAgIHZhciBwcm9ncmFtID0gcGFpbnRlci51c2VQcm9ncmFtKCdjb2xsaXNpb25ib3gnKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb29yZCA9IGNvb3Jkc1tpXTtcbiAgICAgICAgdmFyIHRpbGUgPSBzb3VyY2UuZ2V0VGlsZShjb29yZCk7XG4gICAgICAgIHZhciBidWNrZXQgPSB0aWxlLmdldEJ1Y2tldChsYXllcik7XG4gICAgICAgIGlmICghYnVja2V0KSBjb250aW51ZTtcbiAgICAgICAgdmFyIGJ1ZmZlckdyb3VwcyA9IGJ1Y2tldC5idWZmZXJHcm91cHMuY29sbGlzaW9uQm94O1xuXG4gICAgICAgIGlmICghYnVmZmVyR3JvdXBzIHx8ICFidWZmZXJHcm91cHMubGVuZ3RoKSBjb250aW51ZTtcbiAgICAgICAgdmFyIGdyb3VwID0gYnVmZmVyR3JvdXBzWzBdO1xuICAgICAgICBpZiAoZ3JvdXAubGF5b3V0VmVydGV4QnVmZmVyLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG5cbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9ncmFtLnVfbWF0cml4LCBmYWxzZSwgY29vcmQucG9zTWF0cml4KTtcblxuICAgICAgICBwYWludGVyLmVuYWJsZVRpbGVDbGlwcGluZ01hc2soY29vcmQpO1xuXG4gICAgICAgIHBhaW50ZXIubGluZVdpZHRoKDEpO1xuICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X3NjYWxlLCBNYXRoLnBvdygyLCBwYWludGVyLnRyYW5zZm9ybS56b29tIC0gdGlsZS5jb29yZC56KSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfem9vbSwgcGFpbnRlci50cmFuc2Zvcm0uem9vbSAqIDEwKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9tYXh6b29tLCAodGlsZS5jb29yZC56ICsgMSkgKiAxMCk7XG5cbiAgICAgICAgZ3JvdXAudmFvc1tsYXllci5pZF0uYmluZChnbCwgcHJvZ3JhbSwgZ3JvdXAubGF5b3V0VmVydGV4QnVmZmVyKTtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5MSU5FUywgMCwgZ3JvdXAubGF5b3V0VmVydGV4QnVmZmVyLmxlbmd0aCk7XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdGV4dFZlcnRpY2VzID0gcmVxdWlyZSgnLi4vbGliL2RlYnVndGV4dCcpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXInKTtcbnZhciBtYXQ0ID0gcmVxdWlyZSgnZ2wtbWF0cml4JykubWF0NDtcbnZhciBFWFRFTlQgPSByZXF1aXJlKCcuLi9kYXRhL2J1Y2tldCcpLkVYVEVOVDtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuLi9kYXRhL2J1ZmZlcicpO1xudmFyIFZlcnRleEFycmF5T2JqZWN0ID0gcmVxdWlyZSgnLi92ZXJ0ZXhfYXJyYXlfb2JqZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZHJhd0RlYnVnO1xuXG5mdW5jdGlvbiBkcmF3RGVidWcocGFpbnRlciwgc291cmNlLCBjb29yZHMpIHtcbiAgICBpZiAocGFpbnRlci5pc09wYXF1ZVBhc3MpIHJldHVybjtcbiAgICBpZiAoIXBhaW50ZXIub3B0aW9ucy5kZWJ1ZykgcmV0dXJuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZHJhd0RlYnVnVGlsZShwYWludGVyLCBzb3VyY2UsIGNvb3Jkc1tpXSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmF3RGVidWdUaWxlKHBhaW50ZXIsIHNvdXJjZSwgY29vcmQpIHtcbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuXG4gICAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuICAgIHBhaW50ZXIubGluZVdpZHRoKDEgKiBicm93c2VyLmRldmljZVBpeGVsUmF0aW8pO1xuXG4gICAgdmFyIHBvc01hdHJpeCA9IGNvb3JkLnBvc01hdHJpeDtcbiAgICB2YXIgcHJvZ3JhbSA9IHBhaW50ZXIudXNlUHJvZ3JhbSgnZGVidWcnKTtcblxuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYocHJvZ3JhbS51X21hdHJpeCwgZmFsc2UsIHBvc01hdHJpeCk7XG4gICAgZ2wudW5pZm9ybTRmKHByb2dyYW0udV9jb2xvciwgMSwgMCwgMCwgMSk7XG4gICAgcGFpbnRlci5kZWJ1Z1ZBTy5iaW5kKGdsLCBwcm9ncmFtLCBwYWludGVyLmRlYnVnQnVmZmVyKTtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLkxJTkVfU1RSSVAsIDAsIHBhaW50ZXIuZGVidWdCdWZmZXIubGVuZ3RoKTtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IHRleHRWZXJ0aWNlcyhjb29yZC50b1N0cmluZygpLCA1MCwgMjAwLCA1KTtcbiAgICB2YXIgZGVidWdUZXh0QXJyYXkgPSBuZXcgcGFpbnRlci5Qb3NBcnJheSgpO1xuICAgIGZvciAodmFyIHYgPSAwOyB2IDwgdmVydGljZXMubGVuZ3RoOyB2ICs9IDIpIHtcbiAgICAgICAgZGVidWdUZXh0QXJyYXkuZW1wbGFjZUJhY2sodmVydGljZXNbdl0sIHZlcnRpY2VzW3YgKyAxXSk7XG4gICAgfVxuICAgIHZhciBkZWJ1Z1RleHRCdWZmZXIgPSBuZXcgQnVmZmVyKGRlYnVnVGV4dEFycmF5LnNlcmlhbGl6ZSgpLCBwYWludGVyLlBvc0FycmF5LnNlcmlhbGl6ZSgpLCBCdWZmZXIuQnVmZmVyVHlwZS5WRVJURVgpO1xuICAgIHZhciBkZWJ1Z1RleHRWQU8gPSBuZXcgVmVydGV4QXJyYXlPYmplY3QoKTtcbiAgICBkZWJ1Z1RleHRWQU8uYmluZChnbCwgcHJvZ3JhbSwgZGVidWdUZXh0QnVmZmVyKTtcbiAgICBnbC51bmlmb3JtNGYocHJvZ3JhbS51X2NvbG9yLCAxLCAxLCAxLCAxKTtcblxuICAgIC8vIERyYXcgdGhlIGhhbG8gd2l0aCBtdWx0aXBsZSAxcHggbGluZXMgaW5zdGVhZCBvZiBvbmUgd2lkZXIgbGluZSBiZWNhdXNlXG4gICAgLy8gdGhlIGdsIHNwZWMgZG9lc24ndCBndWFyYW50ZWUgc3VwcG9ydCBmb3IgbGluZXMgd2l0aCB3aWR0aCA+IDEuXG4gICAgdmFyIHRpbGVTaXplID0gc291cmNlLmdldFRpbGUoY29vcmQpLnRpbGVTaXplO1xuICAgIHZhciBvbmVQaXhlbCA9IEVYVEVOVCAvIChNYXRoLnBvdygyLCBwYWludGVyLnRyYW5zZm9ybS56b29tIC0gY29vcmQueikgKiB0aWxlU2l6ZSk7XG4gICAgdmFyIHRyYW5zbGF0aW9ucyA9IFtbLTEsIC0xXSwgWy0xLCAxXSwgWzEsIC0xXSwgWzEsIDFdXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zbGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSB0cmFuc2xhdGlvbnNbaV07XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYocHJvZ3JhbS51X21hdHJpeCwgZmFsc2UsIG1hdDQudHJhbnNsYXRlKFtdLCBwb3NNYXRyaXgsIFtvbmVQaXhlbCAqIHRyYW5zbGF0aW9uWzBdLCBvbmVQaXhlbCAqIHRyYW5zbGF0aW9uWzFdLCAwXSkpO1xuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLkxJTkVTLCAwLCBkZWJ1Z1RleHRCdWZmZXIubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBnbC51bmlmb3JtNGYocHJvZ3JhbS51X2NvbG9yLCAwLCAwLCAwLCAxKTtcbiAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHByb2dyYW0udV9tYXRyaXgsIGZhbHNlLCBwb3NNYXRyaXgpO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuTElORVMsIDAsIGRlYnVnVGV4dEJ1ZmZlci5sZW5ndGgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0MyA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLm1hdDM7XG52YXIgbWF0NCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLm1hdDQ7XG52YXIgdmVjMyA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLnZlYzM7XG52YXIgcGl4ZWxzVG9UaWxlVW5pdHMgPSByZXF1aXJlKCcuLi9zb3VyY2UvcGl4ZWxzX3RvX3RpbGVfdW5pdHMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuLi9kYXRhL2J1ZmZlcicpO1xudmFyIFZlcnRleEFycmF5T2JqZWN0ID0gcmVxdWlyZSgnLi92ZXJ0ZXhfYXJyYXlfb2JqZWN0Jyk7XG52YXIgU3RydWN0QXJyYXlUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9zdHJ1Y3RfYXJyYXknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkcmF3O1xuXG5mdW5jdGlvbiBkcmF3KHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkcykge1xuICAgIGlmIChsYXllci5wYWludFsnZXh0cnVzaW9uLWxheWVyLW9wYWNpdHknXSA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG4gICAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuICAgIHBhaW50ZXIuZGVwdGhNYXNrKHRydWUpO1xuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IHRleHR1cmUgdG8gd2hpY2ggdG8gcmVuZGVyIHRoZSBleHRydXNpb24gbGF5ZXIuIFRoaXMgYXBwcm9hY2hcbiAgICAvLyBhbGxvd3MgdXMgdG8gYWRqdXN0IG9wYWNpdHkgb24gYSBwZXItbGF5ZXIgYmFzaXMgKGVsaW1pbmF0aW5nIHRoZSBpbnRlcmlvclxuICAgIC8vIHdhbGxzIHBlci1mZWF0dXJlIG9wYWNpdHkgcHJvYmxlbSlcbiAgICB2YXIgdGV4dHVyZSA9IG5ldyBQcmVyZW5kZXJlZEV4dHJ1c2lvbkxheWVyKGdsLCBwYWludGVyLCBsYXllcik7XG4gICAgdGV4dHVyZS5iaW5kRnJhbWVidWZmZXIoKTtcblxuICAgIGdsLmNsZWFyU3RlbmNpbCgweDgwKTtcbiAgICBnbC5zdGVuY2lsTWFzaygweEZGKTtcbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCk7XG4gICAgZ2wuc3RlbmNpbE1hc2soMHgwMCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkcmF3RXh0cnVzaW9uKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkc1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKCFwYWludGVyLmlzT3BhcXVlUGFzcyAmJiBsYXllci5wYWludFsnZXh0cnVzaW9uLWFudGlhbGlhcyddKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29vcmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBkcmF3RXh0cnVzaW9uU3Ryb2tlKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkc1tqXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVbmJpbmQgdGhlIGZyYW1lYnVmZmVyIGFzIGEgcmVuZGVyIHRhcmdldCBhbmQgcmVuZGVyIGl0IHRvIHRoZSBtYXBcbiAgICB0ZXh0dXJlLnVuYmluZEZyYW1lYnVmZmVyKCk7XG4gICAgdGV4dHVyZS5yZW5kZXJUb01hcCgpO1xufVxuXG5mdW5jdGlvbiBQcmVyZW5kZXJlZEV4dHJ1c2lvbkxheWVyKGdsLCBwYWludGVyLCBsYXllcikge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLndpZHRoID0gcGFpbnRlci53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHBhaW50ZXIuaGVpZ2h0O1xuICAgIHRoaXMucGFpbnRlciA9IHBhaW50ZXI7XG4gICAgdGhpcy5sYXllciA9IGxheWVyO1xuXG4gICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcbiAgICB0aGlzLmZibyA9IG51bGw7XG4gICAgdGhpcy5mYm9zID0gdGhpcy5wYWludGVyLnByZUZib3NbdGhpcy53aWR0aF0gJiYgdGhpcy5wYWludGVyLnByZUZib3NbdGhpcy53aWR0aF1bdGhpcy5oZWlnaHRdO1xufVxuXG5QcmVyZW5kZXJlZEV4dHJ1c2lvbkxheWVyLnByb3RvdHlwZS5iaW5kRnJhbWVidWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdGhpcy50ZXh0dXJlID0gdGhpcy5wYWludGVyLmdldFRleHR1cmUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMSk7XG5cbiAgICBpZiAoIXRoaXMudGV4dHVyZSkge1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgdGhpcy50ZXh0dXJlLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmZib3MpIHtcbiAgICAgICAgdGhpcy5mYm8gPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgICB2YXIgc3RlbmNpbCA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuICAgICAgICB2YXIgZGVwdGhSZW5kZXJCdWZmZXIgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIHN0ZW5jaWwpO1xuICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgZGVwdGhSZW5kZXJCdWZmZXIpO1xuICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuUkdCQTQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX0NPTVBPTkVOVDE2LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mYm8pO1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlJFTkRFUkJVRkZFUiwgc3RlbmNpbCk7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIGRlcHRoUmVuZGVyQnVmZmVyKTtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmJvID0gdGhpcy5mYm9zLnBvcCgpO1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZmJvKTtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUsIDApO1xuICAgIH1cbn07XG5cblByZXJlbmRlcmVkRXh0cnVzaW9uTGF5ZXIucHJvdG90eXBlLnVuYmluZEZyYW1lYnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5wYWludGVyLmJpbmREZWZhdWx0RnJhbWVidWZmZXIoKTtcbiAgICBpZiAodGhpcy5mYm9zKSB7XG4gICAgICAgIHRoaXMuZmJvcy5wdXNoKHRoaXMuZmJvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMucGFpbnRlci5wcmVGYm9zW3RoaXMud2lkdGhdKSB0aGlzLnBhaW50ZXIucHJlRmJvc1t0aGlzLndpZHRoXSA9IHt9O1xuICAgICAgICB0aGlzLnBhaW50ZXIucHJlRmJvc1t0aGlzLndpZHRoXVt0aGlzLmhlaWdodF0gPSBbdGhpcy5mYm9dO1xuICAgIH1cbiAgICB0aGlzLnBhaW50ZXIuc2F2ZVRleHR1cmUodGhpcy50ZXh0dXJlKTtcbn07XG5cblByZXJlbmRlcmVkRXh0cnVzaW9uTGF5ZXIucHJvdG90eXBlLlRleHR1cmVCb3VuZHNBcnJheSA9IG5ldyBTdHJ1Y3RBcnJheVR5cGUoe1xuICAgIG1lbWJlcnM6IFtcbiAgICAgICAgeyBuYW1lOiAnYV9wb3MnLCB0eXBlOiAnSW50MTYnLCBjb21wb25lbnRzOiAyIH1cbiAgICBdXG59KTtcblxuUHJlcmVuZGVyZWRFeHRydXNpb25MYXllci5wcm90b3R5cGUucmVuZGVyVG9NYXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIHZhciBwYWludGVyID0gdGhpcy5wYWludGVyO1xuICAgIHZhciBwcm9ncmFtID0gcGFpbnRlci51c2VQcm9ncmFtKCdleHRydXNpb250ZXh0dXJlJyk7XG5cbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuXG4gICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9vcGFjaXR5LCB0aGlzLmxheWVyLnBhaW50WydleHRydXNpb24tbGF5ZXItb3BhY2l0eSddKTtcbiAgICBnbC51bmlmb3JtMWkocHJvZ3JhbS51X3RleHR1cmUsIDEpO1xuXG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9ncmFtLnVfbWF0cml4LCBmYWxzZSwgbWF0NC5vcnRobyhcbiAgICAgICAgbWF0NC5jcmVhdGUoKSxcbiAgICAgICAgMCxcbiAgICAgICAgcGFpbnRlci53aWR0aCxcbiAgICAgICAgcGFpbnRlci5oZWlnaHQsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDEpXG4gICAgKTtcblxuICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cbiAgICBnbC51bmlmb3JtMWkocHJvZ3JhbS51X3hkaW0sIHBhaW50ZXIud2lkdGgpO1xuICAgIGdsLnVuaWZvcm0xaShwcm9ncmFtLnVfeWRpbSwgcGFpbnRlci5oZWlnaHQpO1xuXG4gICAgdmFyIGFycmF5ID0gbmV3IHRoaXMuVGV4dHVyZUJvdW5kc0FycmF5KCk7XG4gICAgYXJyYXkuZW1wbGFjZUJhY2soMCwgMCk7XG4gICAgYXJyYXkuZW1wbGFjZUJhY2socGFpbnRlci53aWR0aCwgMCk7XG4gICAgYXJyYXkuZW1wbGFjZUJhY2soMCwgcGFpbnRlci5oZWlnaHQpO1xuICAgIGFycmF5LmVtcGxhY2VCYWNrKHBhaW50ZXIud2lkdGgsIHBhaW50ZXIuaGVpZ2h0KTtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcihhcnJheS5zZXJpYWxpemUoKSwgdGhpcy5UZXh0dXJlQm91bmRzQXJyYXkuc2VyaWFsaXplKCksIEJ1ZmZlci5CdWZmZXJUeXBlLlZFUlRFWCk7XG5cbiAgICB2YXIgdmFvID0gbmV3IFZlcnRleEFycmF5T2JqZWN0KCk7XG4gICAgdmFvLmJpbmQoZ2wsIHByb2dyYW0sIGJ1ZmZlcik7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG5cbiAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG59O1xuXG5mdW5jdGlvbiBkcmF3RXh0cnVzaW9uKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3JkKSB7XG4gICAgdmFyIHRpbGUgPSBzb3VyY2UuZ2V0VGlsZShjb29yZCk7XG4gICAgdmFyIGJ1Y2tldCA9IHRpbGUuZ2V0QnVja2V0KGxheWVyKTtcbiAgICBpZiAoIWJ1Y2tldCkgcmV0dXJuO1xuICAgIHZhciBidWZmZXJHcm91cHMgPSBidWNrZXQuYnVmZmVyR3JvdXBzLmV4dHJ1c2lvbjtcbiAgICBpZiAoIWJ1ZmZlckdyb3VwcykgcmV0dXJuO1xuXG4gICAgaWYgKHBhaW50ZXIuaXNPcGFxdWVQYXNzKSByZXR1cm47XG5cbiAgICBwYWludGVyLnNldERlcHRoU3VibGF5ZXIoMik7XG5cbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuXG4gICAgdmFyIGltYWdlID0gbGF5ZXIucGFpbnRbJ2V4dHJ1c2lvbi1wYXR0ZXJuJ107XG5cbiAgICB2YXIgcHJvZ3JhbU9wdGlvbnMgPSBidWNrZXQucGFpbnRBdHRyaWJ1dGVzLmV4dHJ1c2lvbltsYXllci5pZF07XG4gICAgdmFyIHByb2dyYW0gPSBwYWludGVyLnVzZVByb2dyYW0oXG4gICAgICAgIGltYWdlID8gJ2V4dHJ1c2lvbnBhdHRlcm4nIDogJ2V4dHJ1c2lvbicsXG4gICAgICAgIHByb2dyYW1PcHRpb25zLmRlZmluZXMsXG4gICAgICAgIHByb2dyYW1PcHRpb25zLnZlcnRleFByYWdtYXMsXG4gICAgICAgIHByb2dyYW1PcHRpb25zLmZyYWdtZW50UHJhZ21hc1xuICAgICk7XG5cbiAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgc2V0UGF0dGVybihpbWFnZSwgdGlsZSwgY29vcmQsIHBhaW50ZXIsIHByb2dyYW0pO1xuICAgIH1cblxuICAgIHNldE1hdHJpeChwcm9ncmFtLCBwYWludGVyLCBjb29yZCwgdGlsZSwgbGF5ZXIpO1xuICAgIHNldExpZ2h0aW5nKHByb2dyYW0sIHBhaW50ZXIpO1xuXG4gICAgYnVja2V0LnNldFVuaWZvcm1zKGdsLCAnZXh0cnVzaW9uJywgcHJvZ3JhbSwgbGF5ZXIsIHt6b29tOiBwYWludGVyLnRyYW5zZm9ybS56b29tfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlckdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ3JvdXAgPSBidWZmZXJHcm91cHNbaV07XG4gICAgICAgIGdyb3VwLnZhb3NbbGF5ZXIuaWRdLmJpbmQoZ2wsIHByb2dyYW0sIGdyb3VwLmxheW91dFZlcnRleEJ1ZmZlciwgZ3JvdXAuZWxlbWVudEJ1ZmZlciwgZ3JvdXAucGFpbnRWZXJ0ZXhCdWZmZXJzW2xheWVyLmlkXSk7XG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIGdyb3VwLmVsZW1lbnRCdWZmZXIubGVuZ3RoICogMywgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhd0V4dHJ1c2lvblN0cm9rZShwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZCkge1xuICAgIHZhciB0aWxlID0gc291cmNlLmdldFRpbGUoY29vcmQpO1xuICAgIHZhciBidWNrZXQgPSB0aWxlLmdldEJ1Y2tldChsYXllcik7XG4gICAgaWYgKCFidWNrZXQpIHJldHVybjtcblxuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG4gICAgdmFyIGJ1ZmZlckdyb3VwcyA9IGJ1Y2tldC5idWZmZXJHcm91cHMuZXh0cnVzaW9uO1xuXG4gICAgcGFpbnRlci5zZXREZXB0aFN1YmxheWVyKDEpO1xuICAgIHBhaW50ZXIubGluZVdpZHRoKDIpO1xuXG4gICAgdmFyIG91dGxpbmVEZWZpbmVzID0gWydPVVRMSU5FJ107XG5cbiAgICB2YXIgaW1hZ2UgPSBsYXllci5wYWludFsnZXh0cnVzaW9uLXBhdHRlcm4nXTtcbiAgICB2YXIgY29sb3IgPSBsYXllci5wYWludFsnZXh0cnVzaW9uLW91dGxpbmUtY29sb3InXTtcbiAgICBpZiAoIWNvbG9yKSBvdXRsaW5lRGVmaW5lcy5wdXNoKCdERUZBVUxUX0NPTE9SJyk7XG5cbiAgICB2YXIgcHJvZ3JhbU9wdGlvbnMgPSBidWNrZXQucGFpbnRBdHRyaWJ1dGVzLmV4dHJ1c2lvbltsYXllci5pZF07XG4gICAgdmFyIG91dGxpbmVQcm9ncmFtID0gcGFpbnRlci51c2VQcm9ncmFtKFxuICAgICAgICAvLyBUT0RPIGV4dHJ1c2lvbiBwYXR0ZXJuIHdpdGggYW50aWFsaWFzICYgbm8gY29sb3Igc3BlY2lmaWVkP1xuICAgICAgICAoaW1hZ2UgJiYgIWNvbG9yKSA/ICdleHRydXNpb25wYXR0ZXJuJyA6ICdleHRydXNpb24nLFxuICAgICAgICBwcm9ncmFtT3B0aW9ucy5kZWZpbmVzLmNvbmNhdChvdXRsaW5lRGVmaW5lcyksXG4gICAgICAgIHByb2dyYW1PcHRpb25zLnZlcnRleFByYWdtYXMsXG4gICAgICAgIHByb2dyYW1PcHRpb25zLmZyYWdtZW50UHJhZ21hc1xuICAgICk7XG5cbiAgICBzZXRMaWdodGluZyhvdXRsaW5lUHJvZ3JhbSwgcGFpbnRlcik7XG4gICAgc2V0TWF0cml4KG91dGxpbmVQcm9ncmFtLCBwYWludGVyLCBjb29yZCwgdGlsZSwgbGF5ZXIpO1xuXG4gICAgYnVja2V0LnNldFVuaWZvcm1zKGdsLCAnZXh0cnVzaW9uJywgb3V0bGluZVByb2dyYW0sIGxheWVyLCB7em9vbTogcGFpbnRlci50cmFuc2Zvcm0uem9vbX0pO1xuXG4gICAgaWYgKGNvbG9yKSBnbC51bmlmb3JtNGZ2KG91dGxpbmVQcm9ncmFtLnVfb3V0bGluZV9jb2xvciwgY29sb3IpO1xuXG4gICAgcGFpbnRlci5lbmFibGVUaWxlQ2xpcHBpbmdNYXNrKGNvb3JkKTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYnVmZmVyR3JvdXBzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBncm91cCA9IGJ1ZmZlckdyb3Vwc1trXTtcbiAgICAgICAgZ3JvdXAuc2Vjb25kVmFvc1tsYXllci5pZF0uYmluZChnbCwgb3V0bGluZVByb2dyYW0sIGdyb3VwLmxheW91dFZlcnRleEJ1ZmZlciwgZ3JvdXAuZWxlbWVudEJ1ZmZlcjIsIGdyb3VwLnBhaW50VmVydGV4QnVmZmVyc1tsYXllci5pZF0pO1xuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuTElORVMsIGdyb3VwLmVsZW1lbnRCdWZmZXIyLmxlbmd0aCAqIDIsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldE1hdHJpeChwcm9ncmFtLCBwYWludGVyLCBjb29yZCwgdGlsZSwgbGF5ZXIpIHtcbiAgICB2YXIgelNjYWxlID0gTWF0aC5wb3coMiwgcGFpbnRlci50cmFuc2Zvcm0uem9vbSkgLyA1MDAwMDtcblxuICAgIHBhaW50ZXIuZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9ncmFtLnVfbWF0cml4LCBmYWxzZSwgbWF0NC5zY2FsZShcbiAgICAgICAgbWF0NC5jcmVhdGUoKSxcbiAgICAgICAgcGFpbnRlci50cmFuc2xhdGVQb3NNYXRyaXgoXG4gICAgICAgICAgICBjb29yZC5wb3NNYXRyaXgsXG4gICAgICAgICAgICB0aWxlLFxuICAgICAgICAgICAgbGF5ZXIucGFpbnRbJ2V4dHJ1c2lvbi10cmFuc2xhdGUnXSxcbiAgICAgICAgICAgIGxheWVyLnBhaW50WydleHRydXNpb24tdHJhbnNsYXRlLWFuY2hvciddXG4gICAgICAgICksXG4gICAgICAgIFsxLCAxLCB6U2NhbGUsIDFdKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIHNldExpZ2h0aW5nKHByb2dyYW0sIHBhaW50ZXIpIHtcbiAgICB2YXIgX2xkID0gcGFpbnRlci5saWdodC5saWdodERpcmVjdGlvbixcbiAgICAgICAgbGlnaHRkaXIgPSBbX2xkLngsIF9sZC55LCBfbGQuel07XG4gICAgdmFyIGxpZ2h0TWF0ID0gbWF0My5jcmVhdGUoKTtcbiAgICBpZiAocGFpbnRlci5saWdodC5saWdodEFuY2hvciA9PT0gJ3ZpZXdwb3J0JykgbWF0My5mcm9tUm90YXRpb24obGlnaHRNYXQsIC1wYWludGVyLnRyYW5zZm9ybS5hbmdsZSk7XG4gICAgdmVjMy50cmFuc2Zvcm1NYXQzKGxpZ2h0ZGlyLCBsaWdodGRpciwgbGlnaHRNYXQpO1xuICAgIHBhaW50ZXIuZ2wudW5pZm9ybTNmdihwcm9ncmFtLnVfbGlnaHRkaXIsIGxpZ2h0ZGlyKTtcbn1cblxuXG5mdW5jdGlvbiBzZXRQYXR0ZXJuKGltYWdlLCB0aWxlLCBjb29yZCwgcGFpbnRlciwgcHJvZ3JhbSkge1xuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG5cbiAgICB2YXIgaW1hZ2VQb3NBID0gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS5mcm9tLCB0cnVlKTtcbiAgICB2YXIgaW1hZ2VQb3NCID0gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS50bywgdHJ1ZSk7XG4gICAgaWYgKCFpbWFnZVBvc0EgfHwgIWltYWdlUG9zQikgcmV0dXJuO1xuXG4gICAgZ2wudW5pZm9ybTFpKHByb2dyYW0udV9pbWFnZSwgMCk7XG4gICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfcGF0dGVybl90bF9hLCBpbWFnZVBvc0EudGwpO1xuICAgIGdsLnVuaWZvcm0yZnYocHJvZ3JhbS51X3BhdHRlcm5fYnJfYSwgaW1hZ2VQb3NBLmJyKTtcbiAgICBnbC51bmlmb3JtMmZ2KHByb2dyYW0udV9wYXR0ZXJuX3RsX2IsIGltYWdlUG9zQi50bCk7XG4gICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfcGF0dGVybl9icl9iLCBpbWFnZVBvc0IuYnIpO1xuICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfbWl4LCBpbWFnZS50KTtcblxuICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfdGlsZV91bml0c190b19waXhlbHMsIDEgLyBwaXhlbHNUb1RpbGVVbml0cyh0aWxlLCAxLCBwYWludGVyLnRyYW5zZm9ybS50aWxlWm9vbSkpO1xuICAgIGdsLnVuaWZvcm0yZnYocHJvZ3JhbS51X3BhdHRlcm5fc2l6ZV9hLCBpbWFnZVBvc0Euc2l6ZSk7XG4gICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfcGF0dGVybl9zaXplX2IsIGltYWdlUG9zQi5zaXplKTtcbiAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X3NjYWxlX2EsIGltYWdlLmZyb21TY2FsZSk7XG4gICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9zY2FsZV9iLCBpbWFnZS50b1NjYWxlKTtcblxuICAgIHZhciB0aWxlU2l6ZUF0TmVhcmVzdFpvb20gPSB0aWxlLnRpbGVTaXplICogTWF0aC5wb3coMiwgcGFpbnRlci50cmFuc2Zvcm0udGlsZVpvb20gLSB0aWxlLmNvb3JkLnopO1xuXG4gICAgdmFyIHBpeGVsWCA9IHRpbGVTaXplQXROZWFyZXN0Wm9vbSAqICh0aWxlLmNvb3JkLnggKyBjb29yZC53ICogTWF0aC5wb3coMiwgdGlsZS5jb29yZC56KSk7XG4gICAgdmFyIHBpeGVsWSA9IHRpbGVTaXplQXROZWFyZXN0Wm9vbSAqIHRpbGUuY29vcmQueTtcbiAgICAvLyBzcGxpdCB0aGUgcGl4ZWwgY29vcmQgaW50byB0d28gcGFpcnMgb2YgMTYgYml0IG51bWJlcnMuIFRoZSBnbHNsIHNwZWMgb25seSBndWFyYW50ZWVzIDE2IGJpdHMgb2YgcHJlY2lzaW9uLlxuICAgIGdsLnVuaWZvcm0yZihwcm9ncmFtLnVfcGl4ZWxfY29vcmRfdXBwZXIsIHBpeGVsWCA+PiAxNiwgcGl4ZWxZID4+IDE2KTtcbiAgICBnbC51bmlmb3JtMmYocHJvZ3JhbS51X3BpeGVsX2Nvb3JkX2xvd2VyLCBwaXhlbFggJiAweEZGRkYsIHBpeGVsWSAmIDB4RkZGRik7XG5cbiAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X2hlaWdodF9mYWN0b3IsIC1NYXRoLnBvdygyLCBwYWludGVyLnRyYW5zZm9ybS50aWxlWm9vbSkgLyB0aWxlU2l6ZUF0TmVhcmVzdFpvb20gPj4gMyk7XG5cbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICBwYWludGVyLnNwcml0ZUF0bGFzLmJpbmQoZ2wsIHRydWUpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGl4ZWxzVG9UaWxlVW5pdHMgPSByZXF1aXJlKCcuLi9zb3VyY2UvcGl4ZWxzX3RvX3RpbGVfdW5pdHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkcmF3O1xuXG5mdW5jdGlvbiBkcmF3KHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkcykge1xuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG4gICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG5cbiAgICB2YXIgaXNPcGFxdWU7XG4gICAgaWYgKGxheWVyLnBhaW50WydmaWxsLXBhdHRlcm4nXSkge1xuICAgICAgICBpc09wYXF1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlzT3BhcXVlID0gKFxuICAgICAgICAgICAgbGF5ZXIuaXNQYWludFZhbHVlRmVhdHVyZUNvbnN0YW50KCdmaWxsLWNvbG9yJykgJiZcbiAgICAgICAgICAgIGxheWVyLmlzUGFpbnRWYWx1ZUZlYXR1cmVDb25zdGFudCgnZmlsbC1vcGFjaXR5JykgJiZcbiAgICAgICAgICAgIGxheWVyLnBhaW50WydmaWxsLWNvbG9yJ11bM10gPT09IDEgJiZcbiAgICAgICAgICAgIGxheWVyLnBhaW50WydmaWxsLW9wYWNpdHknXSA9PT0gMVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIERyYXcgZmlsbFxuICAgIGlmIChwYWludGVyLmlzT3BhcXVlUGFzcyA9PT0gaXNPcGFxdWUpIHtcbiAgICAgICAgLy8gT25jZSB3ZSBzd2l0Y2ggdG8gZWFyY3V0IGRyYXdpbmcgd2UgY2FuIHB1bGwgbW9zdCBvZiB0aGUgV2ViR0wgc2V0dXBcbiAgICAgICAgLy8gb3V0c2lkZSBvZiB0aGlzIGNvb3JkcyBsb29wLlxuICAgICAgICBwYWludGVyLnNldERlcHRoU3VibGF5ZXIoMSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkcmF3RmlsbChwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZHNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYWludGVyLmlzT3BhcXVlUGFzcyAmJiBsYXllci5wYWludFsnZmlsbC1hbnRpYWxpYXMnXSkge1xuICAgICAgICBwYWludGVyLmxpbmVXaWR0aCgyKTtcbiAgICAgICAgcGFpbnRlci5kZXB0aE1hc2soZmFsc2UpO1xuXG4gICAgICAgIHZhciBpc091dGxpbmVDb2xvckRlZmluZWQgPSBsYXllci5nZXRQYWludFByb3BlcnR5KCdmaWxsLW91dGxpbmUtY29sb3InKTtcbiAgICAgICAgaWYgKGlzT3V0bGluZUNvbG9yRGVmaW5lZCB8fCAhbGF5ZXIucGFpbnRbJ2ZpbGwtcGF0dGVybiddKSB7XG4gICAgICAgICAgICBpZiAoaXNPdXRsaW5lQ29sb3JEZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZGVmaW5lZCBhIGRpZmZlcmVudCBjb2xvciBmb3IgdGhlIGZpbGwgb3V0bGluZSwgd2UgYXJlXG4gICAgICAgICAgICAgICAgLy8gZ29pbmcgdG8gaWdub3JlIHRoZSBiaXRzIGluIDB4MDcgYW5kIGp1c3QgY2FyZSBhYm91dCB0aGUgZ2xvYmFsXG4gICAgICAgICAgICAgICAgLy8gY2xpcHBpbmcgbWFzay5cbiAgICAgICAgICAgICAgICBwYWludGVyLnNldERlcHRoU3VibGF5ZXIoMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2Ugb25seSB3YW50IHRvIGRyYXdGaWxsIHRoZSBhbnRpYWxpYXNlZCBwYXJ0cyB0aGF0IGFyZVxuICAgICAgICAgICAgICAgIC8vICpvdXRzaWRlKiB0aGUgY3VycmVudCBzaGFwZS4gVGhpcyBpcyBpbXBvcnRhbnQgaW4gY2FzZSB0aGUgZmlsbFxuICAgICAgICAgICAgICAgIC8vIG9yIHN0cm9rZSBjb2xvciBpcyB0cmFuc2x1Y2VudC4gSWYgd2Ugd291bGRuJ3QgY2xpcCB0byBvdXRzaWRlXG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgc2hhcGUsIHNvbWUgcGl4ZWxzIGZyb20gdGhlIG91dGxpbmUgc3Ryb2tlIG92ZXJsYXBwZWRcbiAgICAgICAgICAgICAgICAvLyB0aGUgKG5vbi1hbnRpYWxpYXNlZCkgZmlsbC5cbiAgICAgICAgICAgICAgICBwYWludGVyLnNldERlcHRoU3VibGF5ZXIoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHdlIG9ubHkgd2FudCB0byBkcmF3RmlsbCB0aGUgYW50aWFsaWFzZWQgcGFydHMgdGhhdCBhcmVcbiAgICAgICAgICAgIC8vICpvdXRzaWRlKiB0aGUgY3VycmVudCBzaGFwZS4gVGhpcyBpcyBpbXBvcnRhbnQgaW4gY2FzZSB0aGUgZmlsbFxuICAgICAgICAgICAgLy8gb3Igc3Ryb2tlIGNvbG9yIGlzIHRyYW5zbHVjZW50LiBJZiB3ZSB3b3VsZG4ndCBjbGlwIHRvIG91dHNpZGVcbiAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHNoYXBlLCBzb21lIHBpeGVscyBmcm9tIHRoZSBvdXRsaW5lIHN0cm9rZSBvdmVybGFwcGVkXG4gICAgICAgICAgICAvLyB0aGUgKG5vbi1hbnRpYWxpYXNlZCkgZmlsbC5cbiAgICAgICAgICAgIHBhaW50ZXIuc2V0RGVwdGhTdWJsYXllcigwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29vcmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBkcmF3U3Ryb2tlKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkc1tqXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdGaWxsKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3JkKSB7XG4gICAgdmFyIHRpbGUgPSBzb3VyY2UuZ2V0VGlsZShjb29yZCk7XG4gICAgdmFyIGJ1Y2tldCA9IHRpbGUuZ2V0QnVja2V0KGxheWVyKTtcbiAgICBpZiAoIWJ1Y2tldCkgcmV0dXJuO1xuICAgIHZhciBidWZmZXJHcm91cHMgPSBidWNrZXQuYnVmZmVyR3JvdXBzLmZpbGw7XG4gICAgaWYgKCFidWZmZXJHcm91cHMpIHJldHVybjtcblxuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG5cbiAgICB2YXIgaW1hZ2UgPSBsYXllci5wYWludFsnZmlsbC1wYXR0ZXJuJ107XG4gICAgdmFyIHByb2dyYW07XG5cbiAgICBpZiAoIWltYWdlKSB7XG5cbiAgICAgICAgdmFyIHByb2dyYW1PcHRpb25zID0gYnVja2V0LnBhaW50QXR0cmlidXRlcy5maWxsW2xheWVyLmlkXTtcbiAgICAgICAgcHJvZ3JhbSA9IHBhaW50ZXIudXNlUHJvZ3JhbShcbiAgICAgICAgICAgICdmaWxsJyxcbiAgICAgICAgICAgIHByb2dyYW1PcHRpb25zLmRlZmluZXMsXG4gICAgICAgICAgICBwcm9ncmFtT3B0aW9ucy52ZXJ0ZXhQcmFnbWFzLFxuICAgICAgICAgICAgcHJvZ3JhbU9wdGlvbnMuZnJhZ21lbnRQcmFnbWFzXG4gICAgICAgICk7XG4gICAgICAgIGJ1Y2tldC5zZXRVbmlmb3JtcyhnbCwgJ2ZpbGwnLCBwcm9ncmFtLCBsYXllciwge3pvb206IHBhaW50ZXIudHJhbnNmb3JtLnpvb219KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERyYXcgdGV4dHVyZSBmaWxsXG4gICAgICAgIHByb2dyYW0gPSBwYWludGVyLnVzZVByb2dyYW0oJ3BhdHRlcm4nKTtcbiAgICAgICAgc2V0UGF0dGVybihpbWFnZSwgbGF5ZXIucGFpbnRbJ2ZpbGwtb3BhY2l0eSddLCB0aWxlLCBjb29yZCwgcGFpbnRlciwgcHJvZ3JhbSk7XG5cbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgICAgIHBhaW50ZXIuc3ByaXRlQXRsYXMuYmluZChnbCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9ncmFtLnVfbWF0cml4LCBmYWxzZSwgcGFpbnRlci50cmFuc2xhdGVQb3NNYXRyaXgoXG4gICAgICAgIGNvb3JkLnBvc01hdHJpeCxcbiAgICAgICAgdGlsZSxcbiAgICAgICAgbGF5ZXIucGFpbnRbJ2ZpbGwtdHJhbnNsYXRlJ10sXG4gICAgICAgIGxheWVyLnBhaW50WydmaWxsLXRyYW5zbGF0ZS1hbmNob3InXVxuICAgICkpO1xuXG4gICAgcGFpbnRlci5lbmFibGVUaWxlQ2xpcHBpbmdNYXNrKGNvb3JkKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyR3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBncm91cCA9IGJ1ZmZlckdyb3Vwc1tpXTtcbiAgICAgICAgZ3JvdXAudmFvc1tsYXllci5pZF0uYmluZChnbCwgcHJvZ3JhbSwgZ3JvdXAubGF5b3V0VmVydGV4QnVmZmVyLCBncm91cC5lbGVtZW50QnVmZmVyLCBncm91cC5wYWludFZlcnRleEJ1ZmZlcnNbbGF5ZXIuaWRdKTtcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgZ3JvdXAuZWxlbWVudEJ1ZmZlci5sZW5ndGgsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdTdHJva2UocGFpbnRlciwgc291cmNlLCBsYXllciwgY29vcmQpIHtcbiAgICB2YXIgdGlsZSA9IHNvdXJjZS5nZXRUaWxlKGNvb3JkKTtcbiAgICB2YXIgYnVja2V0ID0gdGlsZS5nZXRCdWNrZXQobGF5ZXIpO1xuICAgIGlmICghYnVja2V0KSByZXR1cm47XG5cbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuICAgIHZhciBidWZmZXJHcm91cHMgPSBidWNrZXQuYnVmZmVyR3JvdXBzLmZpbGw7XG5cbiAgICB2YXIgaW1hZ2UgPSBsYXllci5wYWludFsnZmlsbC1wYXR0ZXJuJ107XG4gICAgdmFyIG9wYWNpdHkgPSBsYXllci5wYWludFsnZmlsbC1vcGFjaXR5J107XG4gICAgdmFyIGlzT3V0bGluZUNvbG9yRGVmaW5lZCA9IGxheWVyLmdldFBhaW50UHJvcGVydHkoJ2ZpbGwtb3V0bGluZS1jb2xvcicpO1xuXG4gICAgdmFyIHByb2dyYW07XG4gICAgaWYgKGltYWdlICYmICFpc091dGxpbmVDb2xvckRlZmluZWQpIHtcbiAgICAgICAgcHJvZ3JhbSA9IHBhaW50ZXIudXNlUHJvZ3JhbSgnb3V0bGluZXBhdHRlcm4nKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmKHByb2dyYW0udV93b3JsZCwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9ncmFtT3B0aW9ucyA9IGJ1Y2tldC5wYWludEF0dHJpYnV0ZXMuZmlsbFtsYXllci5pZF07XG4gICAgICAgIHByb2dyYW0gPSBwYWludGVyLnVzZVByb2dyYW0oXG4gICAgICAgICAgICAnb3V0bGluZScsXG4gICAgICAgICAgICBwcm9ncmFtT3B0aW9ucy5kZWZpbmVzLFxuICAgICAgICAgICAgcHJvZ3JhbU9wdGlvbnMudmVydGV4UHJhZ21hcyxcbiAgICAgICAgICAgIHByb2dyYW1PcHRpb25zLmZyYWdtZW50UHJhZ21hc1xuICAgICAgICApO1xuICAgICAgICBnbC51bmlmb3JtMmYocHJvZ3JhbS51X3dvcmxkLCBnbC5kcmF3aW5nQnVmZmVyV2lkdGgsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQpO1xuICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X29wYWNpdHksIG9wYWNpdHkpO1xuICAgICAgICBidWNrZXQuc2V0VW5pZm9ybXMoZ2wsICdmaWxsJywgcHJvZ3JhbSwgbGF5ZXIsIHt6b29tOiBwYWludGVyLnRyYW5zZm9ybS56b29tfSk7XG4gICAgfVxuXG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9ncmFtLnVfbWF0cml4LCBmYWxzZSwgcGFpbnRlci50cmFuc2xhdGVQb3NNYXRyaXgoXG4gICAgICAgIGNvb3JkLnBvc01hdHJpeCxcbiAgICAgICAgdGlsZSxcbiAgICAgICAgbGF5ZXIucGFpbnRbJ2ZpbGwtdHJhbnNsYXRlJ10sXG4gICAgICAgIGxheWVyLnBhaW50WydmaWxsLXRyYW5zbGF0ZS1hbmNob3InXVxuICAgICkpO1xuXG4gICAgaWYgKGltYWdlKSB7IHNldFBhdHRlcm4oaW1hZ2UsIG9wYWNpdHksIHRpbGUsIGNvb3JkLCBwYWludGVyLCBwcm9ncmFtKTsgfVxuXG4gICAgcGFpbnRlci5lbmFibGVUaWxlQ2xpcHBpbmdNYXNrKGNvb3JkKTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYnVmZmVyR3JvdXBzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBncm91cCA9IGJ1ZmZlckdyb3Vwc1trXTtcbiAgICAgICAgZ3JvdXAuc2Vjb25kVmFvc1tsYXllci5pZF0uYmluZChnbCwgcHJvZ3JhbSwgZ3JvdXAubGF5b3V0VmVydGV4QnVmZmVyLCBncm91cC5lbGVtZW50QnVmZmVyMiwgZ3JvdXAucGFpbnRWZXJ0ZXhCdWZmZXJzW2xheWVyLmlkXSk7XG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5MSU5FUywgZ3JvdXAuZWxlbWVudEJ1ZmZlcjIubGVuZ3RoICogMiwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBzZXRQYXR0ZXJuKGltYWdlLCBvcGFjaXR5LCB0aWxlLCBjb29yZCwgcGFpbnRlciwgcHJvZ3JhbSkge1xuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG5cbiAgICB2YXIgaW1hZ2VQb3NBID0gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS5mcm9tLCB0cnVlKTtcbiAgICB2YXIgaW1hZ2VQb3NCID0gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS50bywgdHJ1ZSk7XG4gICAgaWYgKCFpbWFnZVBvc0EgfHwgIWltYWdlUG9zQikgcmV0dXJuO1xuXG4gICAgZ2wudW5pZm9ybTFpKHByb2dyYW0udV9pbWFnZSwgMCk7XG4gICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfcGF0dGVybl90bF9hLCBpbWFnZVBvc0EudGwpO1xuICAgIGdsLnVuaWZvcm0yZnYocHJvZ3JhbS51X3BhdHRlcm5fYnJfYSwgaW1hZ2VQb3NBLmJyKTtcbiAgICBnbC51bmlmb3JtMmZ2KHByb2dyYW0udV9wYXR0ZXJuX3RsX2IsIGltYWdlUG9zQi50bCk7XG4gICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfcGF0dGVybl9icl9iLCBpbWFnZVBvc0IuYnIpO1xuICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfb3BhY2l0eSwgb3BhY2l0eSk7XG4gICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9taXgsIGltYWdlLnQpO1xuXG4gICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV90aWxlX3VuaXRzX3RvX3BpeGVscywgMSAvIHBpeGVsc1RvVGlsZVVuaXRzKHRpbGUsIDEsIHBhaW50ZXIudHJhbnNmb3JtLnRpbGVab29tKSk7XG4gICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfcGF0dGVybl9zaXplX2EsIGltYWdlUG9zQS5zaXplKTtcbiAgICBnbC51bmlmb3JtMmZ2KHByb2dyYW0udV9wYXR0ZXJuX3NpemVfYiwgaW1hZ2VQb3NCLnNpemUpO1xuICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfc2NhbGVfYSwgaW1hZ2UuZnJvbVNjYWxlKTtcbiAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X3NjYWxlX2IsIGltYWdlLnRvU2NhbGUpO1xuXG4gICAgdmFyIHRpbGVTaXplQXROZWFyZXN0Wm9vbSA9IHRpbGUudGlsZVNpemUgKiBNYXRoLnBvdygyLCBwYWludGVyLnRyYW5zZm9ybS50aWxlWm9vbSAtIHRpbGUuY29vcmQueik7XG5cbiAgICB2YXIgcGl4ZWxYID0gdGlsZVNpemVBdE5lYXJlc3Rab29tICogKHRpbGUuY29vcmQueCArIGNvb3JkLncgKiBNYXRoLnBvdygyLCB0aWxlLmNvb3JkLnopKTtcbiAgICB2YXIgcGl4ZWxZID0gdGlsZVNpemVBdE5lYXJlc3Rab29tICogdGlsZS5jb29yZC55O1xuICAgIC8vIHNwbGl0IHRoZSBwaXhlbCBjb29yZCBpbnRvIHR3byBwYWlycyBvZiAxNiBiaXQgbnVtYmVycy4gVGhlIGdsc2wgc3BlYyBvbmx5IGd1YXJhbnRlZXMgMTYgYml0cyBvZiBwcmVjaXNpb24uXG4gICAgZ2wudW5pZm9ybTJmKHByb2dyYW0udV9waXhlbF9jb29yZF91cHBlciwgcGl4ZWxYID4+IDE2LCBwaXhlbFkgPj4gMTYpO1xuICAgIGdsLnVuaWZvcm0yZihwcm9ncmFtLnVfcGl4ZWxfY29vcmRfbG93ZXIsIHBpeGVsWCAmIDB4RkZGRiwgcGl4ZWxZICYgMHhGRkZGKTtcblxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgIHBhaW50ZXIuc3ByaXRlQXRsYXMuYmluZChnbCwgdHJ1ZSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgbWF0MiA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLm1hdDI7XG52YXIgcGl4ZWxzVG9UaWxlVW5pdHMgPSByZXF1aXJlKCcuLi9zb3VyY2UvcGl4ZWxzX3RvX3RpbGVfdW5pdHMnKTtcblxuLyoqXG4gKiBEcmF3IGEgbGluZS4gVW5kZXIgdGhlIGhvb2QgdGhpcyB3aWxsIHJlYWQgZWxlbWVudHMgZnJvbVxuICogYSB0aWxlLCBkYXNoIHRleHR1cmVzIGZyb20gYSBsaW5lQXRsYXMsIGFuZCBzdHlsZSBwcm9wZXJ0aWVzIGZyb20gYSBsYXllci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWludGVyXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NNYXRyaXhcbiAqIEBwYXJhbSB7VGlsZX0gdGlsZVxuICogQHJldHVybnMge3VuZGVmaW5lZH0gZHJhd3Mgd2l0aCB0aGUgcGFpbnRlclxuICogQHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkcmF3TGluZShwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZHMpIHtcbiAgICBpZiAocGFpbnRlci5pc09wYXF1ZVBhc3MpIHJldHVybjtcbiAgICBwYWludGVyLnNldERlcHRoU3VibGF5ZXIoMCk7XG4gICAgcGFpbnRlci5kZXB0aE1hc2soZmFsc2UpO1xuXG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcbiAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcblxuICAgIC8vIGRvbid0IGRyYXcgemVyby13aWR0aCBsaW5lc1xuICAgIGlmIChsYXllci5wYWludFsnbGluZS13aWR0aCddIDw9IDApIHJldHVybjtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgY29vcmRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGRyYXdMaW5lVGlsZShwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZHNba10pO1xuICAgIH1cblxufTtcblxuZnVuY3Rpb24gZHJhd0xpbmVUaWxlKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3JkKSB7XG4gICAgdmFyIHRpbGUgPSBzb3VyY2UuZ2V0VGlsZShjb29yZCk7XG4gICAgdmFyIGJ1Y2tldCA9IHRpbGUuZ2V0QnVja2V0KGxheWVyKTtcbiAgICBpZiAoIWJ1Y2tldCkgcmV0dXJuO1xuICAgIHZhciBidWZmZXJHcm91cHMgPSBidWNrZXQuYnVmZmVyR3JvdXBzLmxpbmU7XG4gICAgaWYgKCFidWZmZXJHcm91cHMpIHJldHVybjtcblxuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG5cbiAgICB2YXIgcHJvZ3JhbU9wdGlvbnMgPSBidWNrZXQucGFpbnRBdHRyaWJ1dGVzLmxpbmVbbGF5ZXIuaWRdO1xuXG4gICAgLy8gdGhlIGRpc3RhbmNlIG92ZXIgd2hpY2ggdGhlIGxpbmUgZWRnZSBmYWRlcyBvdXQuXG4gICAgLy8gUmV0aW5hIGRldmljZXMgbmVlZCBhIHNtYWxsZXIgZGlzdGFuY2UgdG8gYXZvaWQgYWxpYXNpbmcuXG4gICAgdmFyIGFudGlhbGlhc2luZyA9IDEgLyBicm93c2VyLmRldmljZVBpeGVsUmF0aW87XG5cbiAgICB2YXIgYmx1ciA9IGxheWVyLnBhaW50WydsaW5lLWJsdXInXSArIGFudGlhbGlhc2luZztcbiAgICB2YXIgY29sb3IgPSBsYXllci5wYWludFsnbGluZS1jb2xvciddO1xuXG4gICAgdmFyIHRyID0gcGFpbnRlci50cmFuc2Zvcm07XG5cbiAgICB2YXIgYW50aWFsaWFzaW5nTWF0cml4ID0gbWF0Mi5jcmVhdGUoKTtcbiAgICBtYXQyLnNjYWxlKGFudGlhbGlhc2luZ01hdHJpeCwgYW50aWFsaWFzaW5nTWF0cml4LCBbMSwgTWF0aC5jb3ModHIuX3BpdGNoKV0pO1xuICAgIG1hdDIucm90YXRlKGFudGlhbGlhc2luZ01hdHJpeCwgYW50aWFsaWFzaW5nTWF0cml4LCBwYWludGVyLnRyYW5zZm9ybS5hbmdsZSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgaG93IG11Y2ggbG9uZ2VyIHRoZSByZWFsIHdvcmxkIGRpc3RhbmNlIGlzIGF0IHRoZSB0b3Agb2YgdGhlIHNjcmVlblxuICAgIC8vIHRoYW4gYXQgdGhlIG1pZGRsZSBvZiB0aGUgc2NyZWVuLlxuICAgIHZhciB0b3BlZGdlbGVuZ3RoID0gTWF0aC5zcXJ0KHRyLmhlaWdodCAqIHRyLmhlaWdodCAvIDQgICogKDEgKyB0ci5hbHRpdHVkZSAqIHRyLmFsdGl0dWRlKSk7XG4gICAgdmFyIHggPSB0ci5oZWlnaHQgLyAyICogTWF0aC50YW4odHIuX3BpdGNoKTtcbiAgICB2YXIgZXh0cmEgPSAodG9wZWRnZWxlbmd0aCArIHgpIC8gdG9wZWRnZWxlbmd0aCAtIDE7XG5cbiAgICB2YXIgZGFzaGFycmF5ID0gbGF5ZXIucGFpbnRbJ2xpbmUtZGFzaGFycmF5J107XG4gICAgdmFyIGltYWdlID0gbGF5ZXIucGFpbnRbJ2xpbmUtcGF0dGVybiddO1xuICAgIHZhciBwcm9ncmFtLCBwb3NBLCBwb3NCLCBpbWFnZVBvc0EsIGltYWdlUG9zQjtcblxuICAgIGlmIChkYXNoYXJyYXkpIHtcbiAgICAgICAgcHJvZ3JhbSA9IHBhaW50ZXIudXNlUHJvZ3JhbShcbiAgICAgICAgICAgICdsaW5lc2RmcGF0dGVybicsXG4gICAgICAgICAgICBwcm9ncmFtT3B0aW9ucy5kZWZpbmVzLFxuICAgICAgICAgICAgcHJvZ3JhbU9wdGlvbnMudmVydGV4UHJhZ21hcyxcbiAgICAgICAgICAgIHByb2dyYW1PcHRpb25zLmZyYWdtZW50UHJhZ21hc1xuICAgICAgICApO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfbGluZXdpZHRoLCBsYXllci5wYWludFsnbGluZS13aWR0aCddIC8gMik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfZ2Fwd2lkdGgsIGxheWVyLnBhaW50WydsaW5lLWdhcC13aWR0aCddIC8gMik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfYW50aWFsaWFzaW5nLCBhbnRpYWxpYXNpbmcgLyAyKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9ibHVyLCBibHVyKTtcbiAgICAgICAgZ2wudW5pZm9ybTRmdihwcm9ncmFtLnVfY29sb3IsIGNvbG9yKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9vcGFjaXR5LCBsYXllci5wYWludFsnbGluZS1vcGFjaXR5J10pO1xuXG4gICAgICAgIHBvc0EgPSBwYWludGVyLmxpbmVBdGxhcy5nZXREYXNoKGRhc2hhcnJheS5mcm9tLCBsYXllci5sYXlvdXRbJ2xpbmUtY2FwJ10gPT09ICdyb3VuZCcpO1xuICAgICAgICBwb3NCID0gcGFpbnRlci5saW5lQXRsYXMuZ2V0RGFzaChkYXNoYXJyYXkudG8sIGxheWVyLmxheW91dFsnbGluZS1jYXAnXSA9PT0gJ3JvdW5kJyk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTFpKHByb2dyYW0udV9pbWFnZSwgMCk7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgICAgICBwYWludGVyLmxpbmVBdGxhcy5iaW5kKGdsKTtcblxuICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X3RleF95X2EsIHBvc0EueSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfdGV4X3lfYiwgcG9zQi55KTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9taXgsIGRhc2hhcnJheS50KTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9leHRyYSwgZXh0cmEpO1xuICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X29mZnNldCwgLWxheWVyLnBhaW50WydsaW5lLW9mZnNldCddKTtcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDJmdihwcm9ncmFtLnVfYW50aWFsaWFzaW5nbWF0cml4LCBmYWxzZSwgYW50aWFsaWFzaW5nTWF0cml4KTtcblxuICAgIH0gZWxzZSBpZiAoaW1hZ2UpIHtcbiAgICAgICAgaW1hZ2VQb3NBID0gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS5mcm9tLCB0cnVlKTtcbiAgICAgICAgaW1hZ2VQb3NCID0gcGFpbnRlci5zcHJpdGVBdGxhcy5nZXRQb3NpdGlvbihpbWFnZS50bywgdHJ1ZSk7XG4gICAgICAgIGlmICghaW1hZ2VQb3NBIHx8ICFpbWFnZVBvc0IpIHJldHVybjtcblxuICAgICAgICBwcm9ncmFtID0gcGFpbnRlci51c2VQcm9ncmFtKFxuICAgICAgICAgICAgJ2xpbmVwYXR0ZXJuJyxcbiAgICAgICAgICAgIHByb2dyYW1PcHRpb25zLmRlZmluZXMsXG4gICAgICAgICAgICBwcm9ncmFtT3B0aW9ucy52ZXJ0ZXhQcmFnbWFzLFxuICAgICAgICAgICAgcHJvZ3JhbU9wdGlvbnMuZnJhZ21lbnRQcmFnbWFzXG4gICAgICAgICk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTFpKHByb2dyYW0udV9pbWFnZSwgMCk7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgICAgICBwYWludGVyLnNwcml0ZUF0bGFzLmJpbmQoZ2wsIHRydWUpO1xuXG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfbGluZXdpZHRoLCBsYXllci5wYWludFsnbGluZS13aWR0aCddIC8gMik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfZ2Fwd2lkdGgsIGxheWVyLnBhaW50WydsaW5lLWdhcC13aWR0aCddIC8gMik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfYW50aWFsaWFzaW5nLCBhbnRpYWxpYXNpbmcgLyAyKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9ibHVyLCBibHVyKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfcGF0dGVybl90bF9hLCBpbWFnZVBvc0EudGwpO1xuICAgICAgICBnbC51bmlmb3JtMmZ2KHByb2dyYW0udV9wYXR0ZXJuX2JyX2EsIGltYWdlUG9zQS5icik7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYocHJvZ3JhbS51X3BhdHRlcm5fdGxfYiwgaW1hZ2VQb3NCLnRsKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfcGF0dGVybl9icl9iLCBpbWFnZVBvc0IuYnIpO1xuICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X2ZhZGUsIGltYWdlLnQpO1xuICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X29wYWNpdHksIGxheWVyLnBhaW50WydsaW5lLW9wYWNpdHknXSk7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfZXh0cmEsIGV4dHJhKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9vZmZzZXQsIC1sYXllci5wYWludFsnbGluZS1vZmZzZXQnXSk7XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYocHJvZ3JhbS51X2FudGlhbGlhc2luZ21hdHJpeCwgZmFsc2UsIGFudGlhbGlhc2luZ01hdHJpeCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9ncmFtID0gcGFpbnRlci51c2VQcm9ncmFtKFxuICAgICAgICAgICAgJ2xpbmUnLFxuICAgICAgICAgICAgcHJvZ3JhbU9wdGlvbnMuZGVmaW5lcyxcbiAgICAgICAgICAgIHByb2dyYW1PcHRpb25zLnZlcnRleFByYWdtYXMsXG4gICAgICAgICAgICBwcm9ncmFtT3B0aW9ucy5mcmFnbWVudFByYWdtYXNcbiAgICAgICAgKTtcblxuICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X2xpbmV3aWR0aCwgbGF5ZXIucGFpbnRbJ2xpbmUtd2lkdGgnXSAvIDIpO1xuICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X2dhcHdpZHRoLCBsYXllci5wYWludFsnbGluZS1nYXAtd2lkdGgnXSAvIDIpO1xuICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X2FudGlhbGlhc2luZywgYW50aWFsaWFzaW5nIC8gMik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfYmx1ciwgYmx1cik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfZXh0cmEsIGV4dHJhKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9vZmZzZXQsIC1sYXllci5wYWludFsnbGluZS1vZmZzZXQnXSk7XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYocHJvZ3JhbS51X2FudGlhbGlhc2luZ21hdHJpeCwgZmFsc2UsIGFudGlhbGlhc2luZ01hdHJpeCk7XG4gICAgICAgIGdsLnVuaWZvcm00ZnYocHJvZ3JhbS51X2NvbG9yLCBjb2xvcik7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfb3BhY2l0eSwgbGF5ZXIucGFpbnRbJ2xpbmUtb3BhY2l0eSddKTtcbiAgICB9XG5cbiAgICBwYWludGVyLmVuYWJsZVRpbGVDbGlwcGluZ01hc2soY29vcmQpO1xuXG4gICAgLy8gc2V0IHVuaWZvcm1zIHRoYXQgYXJlIGRpZmZlcmVudCBmb3IgZWFjaCB0aWxlXG4gICAgdmFyIHBvc01hdHJpeCA9IHBhaW50ZXIudHJhbnNsYXRlUG9zTWF0cml4KGNvb3JkLnBvc01hdHJpeCwgdGlsZSwgbGF5ZXIucGFpbnRbJ2xpbmUtdHJhbnNsYXRlJ10sIGxheWVyLnBhaW50WydsaW5lLXRyYW5zbGF0ZS1hbmNob3InXSk7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9ncmFtLnVfbWF0cml4LCBmYWxzZSwgcG9zTWF0cml4KTtcblxuICAgIHZhciByYXRpbyA9IDEgLyBwaXhlbHNUb1RpbGVVbml0cyh0aWxlLCAxLCBwYWludGVyLnRyYW5zZm9ybS56b29tKTtcblxuICAgIGlmIChkYXNoYXJyYXkpIHtcbiAgICAgICAgdmFyIHdpZHRoQSA9IHBvc0Eud2lkdGggKiBkYXNoYXJyYXkuZnJvbVNjYWxlO1xuICAgICAgICB2YXIgd2lkdGhCID0gcG9zQi53aWR0aCAqIGRhc2hhcnJheS50b1NjYWxlO1xuICAgICAgICB2YXIgc2NhbGVBID0gWzEgLyBwaXhlbHNUb1RpbGVVbml0cyh0aWxlLCB3aWR0aEEsIHBhaW50ZXIudHJhbnNmb3JtLnRpbGVab29tKSwgLXBvc0EuaGVpZ2h0IC8gMl07XG4gICAgICAgIHZhciBzY2FsZUIgPSBbMSAvIHBpeGVsc1RvVGlsZVVuaXRzKHRpbGUsIHdpZHRoQiwgcGFpbnRlci50cmFuc2Zvcm0udGlsZVpvb20pLCAtcG9zQi5oZWlnaHQgLyAyXTtcbiAgICAgICAgdmFyIGdhbW1hID0gcGFpbnRlci5saW5lQXRsYXMud2lkdGggLyAoTWF0aC5taW4od2lkdGhBLCB3aWR0aEIpICogMjU2ICogYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvKSAvIDI7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfcmF0aW8sIHJhdGlvKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfcGF0dGVybnNjYWxlX2EsIHNjYWxlQSk7XG4gICAgICAgIGdsLnVuaWZvcm0yZnYocHJvZ3JhbS51X3BhdHRlcm5zY2FsZV9iLCBzY2FsZUIpO1xuICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X3NkZmdhbW1hLCBnYW1tYSk7XG5cbiAgICB9IGVsc2UgaWYgKGltYWdlKSB7XG4gICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfcmF0aW8sIHJhdGlvKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfcGF0dGVybl9zaXplX2EsIFtcbiAgICAgICAgICAgIHBpeGVsc1RvVGlsZVVuaXRzKHRpbGUsIGltYWdlUG9zQS5zaXplWzBdICogaW1hZ2UuZnJvbVNjYWxlLCBwYWludGVyLnRyYW5zZm9ybS50aWxlWm9vbSksXG4gICAgICAgICAgICBpbWFnZVBvc0Iuc2l6ZVsxXVxuICAgICAgICBdKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfcGF0dGVybl9zaXplX2IsIFtcbiAgICAgICAgICAgIHBpeGVsc1RvVGlsZVVuaXRzKHRpbGUsIGltYWdlUG9zQi5zaXplWzBdICogaW1hZ2UudG9TY2FsZSwgcGFpbnRlci50cmFuc2Zvcm0udGlsZVpvb20pLFxuICAgICAgICAgICAgaW1hZ2VQb3NCLnNpemVbMV1cbiAgICAgICAgXSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X3JhdGlvLCByYXRpbyk7XG4gICAgfVxuXG4gICAgYnVja2V0LnNldFVuaWZvcm1zKGdsLCAnbGluZScsIHByb2dyYW0sIGxheWVyLCB7em9vbTogcGFpbnRlci50cmFuc2Zvcm0uem9vbX0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJHcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdyb3VwID0gYnVmZmVyR3JvdXBzW2ldO1xuICAgICAgICBncm91cC52YW9zW2xheWVyLmlkXS5iaW5kKGdsLCBwcm9ncmFtLCBncm91cC5sYXlvdXRWZXJ0ZXhCdWZmZXIsIGdyb3VwLmVsZW1lbnRCdWZmZXIsIGdyb3VwLnBhaW50VmVydGV4QnVmZmVyc1tsYXllci5pZF0pO1xuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBncm91cC5lbGVtZW50QnVmZmVyLmxlbmd0aCAqIDMsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbiAgICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgU3RydWN0QXJyYXlUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9zdHJ1Y3RfYXJyYXknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkcmF3UmFzdGVyO1xuXG5mdW5jdGlvbiBkcmF3UmFzdGVyKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkcykge1xuICAgIGlmIChwYWludGVyLmlzT3BhcXVlUGFzcykgcmV0dXJuO1xuXG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcblxuICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICBwYWludGVyLmRlcHRoTWFzayh0cnVlKTtcblxuICAgIC8vIENoYW5nZSBkZXB0aCBmdW5jdGlvbiB0byBwcmV2ZW50IGRvdWJsZSBkcmF3aW5nIGluIGFyZWFzIHdoZXJlIHRpbGVzIG92ZXJsYXAuXG4gICAgZ2wuZGVwdGhGdW5jKGdsLkxFU1MpO1xuXG4gICAgdmFyIG1pblRpbGVaID0gY29vcmRzLmxlbmd0aCAmJiBjb29yZHNbMF0uejtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb29yZCA9IGNvb3Jkc1tpXTtcbiAgICAgICAgLy8gc2V0IHRoZSBsb3dlciB6b29tIGxldmVsIHRvIHN1YmxheWVyIDAsIGFuZCBoaWdoZXIgem9vbSBsZXZlbHMgdG8gaGlnaGVyIHN1YmxheWVyc1xuICAgICAgICBwYWludGVyLnNldERlcHRoU3VibGF5ZXIoY29vcmQueiAtIG1pblRpbGVaKTtcbiAgICAgICAgZHJhd1Jhc3RlclRpbGUocGFpbnRlciwgc291cmNlLCBsYXllciwgY29vcmQpO1xuICAgIH1cblxuICAgIGdsLmRlcHRoRnVuYyhnbC5MRVFVQUwpO1xufVxuXG5kcmF3UmFzdGVyLlJhc3RlckJvdW5kc0FycmF5ID0gbmV3IFN0cnVjdEFycmF5VHlwZSh7XG4gICAgbWVtYmVyczogW1xuICAgICAgICB7IG5hbWU6ICdhX3BvcycsIHR5cGU6ICdJbnQxNicsIGNvbXBvbmVudHM6IDIgfSxcbiAgICAgICAgeyBuYW1lOiAnYV90ZXh0dXJlX3BvcycsIHR5cGU6ICdJbnQxNicsIGNvbXBvbmVudHM6IDIgfVxuICAgIF1cbn0pO1xuXG5mdW5jdGlvbiBkcmF3UmFzdGVyVGlsZShwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZCkge1xuXG4gICAgdmFyIGdsID0gcGFpbnRlci5nbDtcblxuICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcblxuICAgIHZhciB0aWxlID0gc291cmNlLmdldFRpbGUoY29vcmQpO1xuICAgIHZhciBwb3NNYXRyaXggPSBwYWludGVyLnRyYW5zZm9ybS5jYWxjdWxhdGVQb3NNYXRyaXgoY29vcmQsIHNvdXJjZS5tYXh6b29tKTtcblxuICAgIHZhciBwcm9ncmFtID0gcGFpbnRlci51c2VQcm9ncmFtKCdyYXN0ZXInKTtcbiAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHByb2dyYW0udV9tYXRyaXgsIGZhbHNlLCBwb3NNYXRyaXgpO1xuXG4gICAgLy8gY29sb3IgcGFyYW1ldGVyc1xuICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfYnJpZ2h0bmVzc19sb3csIGxheWVyLnBhaW50WydyYXN0ZXItYnJpZ2h0bmVzcy1taW4nXSk7XG4gICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9icmlnaHRuZXNzX2hpZ2gsIGxheWVyLnBhaW50WydyYXN0ZXItYnJpZ2h0bmVzcy1tYXgnXSk7XG4gICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9zYXR1cmF0aW9uX2ZhY3Rvciwgc2F0dXJhdGlvbkZhY3RvcihsYXllci5wYWludFsncmFzdGVyLXNhdHVyYXRpb24nXSkpO1xuICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfY29udHJhc3RfZmFjdG9yLCBjb250cmFzdEZhY3RvcihsYXllci5wYWludFsncmFzdGVyLWNvbnRyYXN0J10pKTtcbiAgICBnbC51bmlmb3JtM2Z2KHByb2dyYW0udV9zcGluX3dlaWdodHMsIHNwaW5XZWlnaHRzKGxheWVyLnBhaW50WydyYXN0ZXItaHVlLXJvdGF0ZSddKSk7XG5cbiAgICB2YXIgcGFyZW50VGlsZSA9IHRpbGUuc291cmNlICYmIHRpbGUuc291cmNlLmZpbmRMb2FkZWRQYXJlbnQoY29vcmQsIDAsIHt9KSxcbiAgICAgICAgb3BhY2l0aWVzID0gZ2V0T3BhY2l0aWVzKHRpbGUsIHBhcmVudFRpbGUsIGxheWVyLCBwYWludGVyLnRyYW5zZm9ybSk7XG5cbiAgICB2YXIgcGFyZW50U2NhbGVCeSwgcGFyZW50VEw7XG5cbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aWxlLnRleHR1cmUpO1xuXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMSk7XG5cbiAgICBpZiAocGFyZW50VGlsZSkge1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBwYXJlbnRUaWxlLnRleHR1cmUpO1xuICAgICAgICBwYXJlbnRTY2FsZUJ5ID0gTWF0aC5wb3coMiwgcGFyZW50VGlsZS5jb29yZC56IC0gdGlsZS5jb29yZC56KTtcbiAgICAgICAgcGFyZW50VEwgPSBbdGlsZS5jb29yZC54ICogcGFyZW50U2NhbGVCeSAlIDEsIHRpbGUuY29vcmQueSAqIHBhcmVudFNjYWxlQnkgJSAxXTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRpbGUudGV4dHVyZSk7XG4gICAgICAgIG9wYWNpdGllc1sxXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gY3Jvc3MtZmFkZSBwYXJhbWV0ZXJzXG4gICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfdGxfcGFyZW50LCBwYXJlbnRUTCB8fCBbMCwgMF0pO1xuICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfc2NhbGVfcGFyZW50LCBwYXJlbnRTY2FsZUJ5IHx8IDEpO1xuICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfYnVmZmVyX3NjYWxlLCAxKTtcbiAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X29wYWNpdHkwLCBvcGFjaXRpZXNbMF0pO1xuICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfb3BhY2l0eTEsIG9wYWNpdGllc1sxXSk7XG4gICAgZ2wudW5pZm9ybTFpKHByb2dyYW0udV9pbWFnZTAsIDApO1xuICAgIGdsLnVuaWZvcm0xaShwcm9ncmFtLnVfaW1hZ2UxLCAxKTtcblxuICAgIHZhciBidWZmZXIgPSB0aWxlLmJvdW5kc0J1ZmZlciB8fCBwYWludGVyLnJhc3RlckJvdW5kc0J1ZmZlcjtcbiAgICB2YXIgdmFvID0gdGlsZS5ib3VuZHNWQU8gfHwgcGFpbnRlci5yYXN0ZXJCb3VuZHNWQU87XG4gICAgdmFvLmJpbmQoZ2wsIHByb2dyYW0sIGJ1ZmZlcik7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgYnVmZmVyLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIHNwaW5XZWlnaHRzKGFuZ2xlKSB7XG4gICAgYW5nbGUgKj0gTWF0aC5QSSAvIDE4MDtcbiAgICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICByZXR1cm4gW1xuICAgICAgICAoMiAqIGMgKyAxKSAvIDMsXG4gICAgICAgICgtTWF0aC5zcXJ0KDMpICogcyAtIGMgKyAxKSAvIDMsXG4gICAgICAgIChNYXRoLnNxcnQoMykgKiBzIC0gYyArIDEpIC8gM1xuICAgIF07XG59XG5cbmZ1bmN0aW9uIGNvbnRyYXN0RmFjdG9yKGNvbnRyYXN0KSB7XG4gICAgcmV0dXJuIGNvbnRyYXN0ID4gMCA/XG4gICAgICAgIDEgLyAoMSAtIGNvbnRyYXN0KSA6XG4gICAgICAgIDEgKyBjb250cmFzdDtcbn1cblxuZnVuY3Rpb24gc2F0dXJhdGlvbkZhY3RvcihzYXR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHNhdHVyYXRpb24gPiAwID9cbiAgICAgICAgMSAtIDEgLyAoMS4wMDEgLSBzYXR1cmF0aW9uKSA6XG4gICAgICAgIC1zYXR1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRPcGFjaXRpZXModGlsZSwgcGFyZW50VGlsZSwgbGF5ZXIsIHRyYW5zZm9ybSkge1xuICAgIHZhciBvcGFjaXR5ID0gWzEsIDBdO1xuICAgIHZhciBmYWRlRHVyYXRpb24gPSBsYXllci5wYWludFsncmFzdGVyLWZhZGUtZHVyYXRpb24nXTtcblxuICAgIGlmICh0aWxlLnNvdXJjZSAmJiBmYWRlRHVyYXRpb24gPiAwKSB7XG4gICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgICB2YXIgc2luY2VUaWxlID0gKG5vdyAtIHRpbGUudGltZUFkZGVkKSAvIGZhZGVEdXJhdGlvbjtcbiAgICAgICAgdmFyIHNpbmNlUGFyZW50ID0gcGFyZW50VGlsZSA/IChub3cgLSBwYXJlbnRUaWxlLnRpbWVBZGRlZCkgLyBmYWRlRHVyYXRpb24gOiAtMTtcblxuICAgICAgICB2YXIgaWRlYWxaID0gdHJhbnNmb3JtLmNvdmVyaW5nWm9vbUxldmVsKHRpbGUuc291cmNlKTtcbiAgICAgICAgdmFyIHBhcmVudEZ1cnRoZXIgPSBwYXJlbnRUaWxlID8gTWF0aC5hYnMocGFyZW50VGlsZS5jb29yZC56IC0gaWRlYWxaKSA+IE1hdGguYWJzKHRpbGUuY29vcmQueiAtIGlkZWFsWikgOiBmYWxzZTtcblxuICAgICAgICBpZiAoIXBhcmVudFRpbGUgfHwgcGFyZW50RnVydGhlcikge1xuICAgICAgICAgICAgLy8gaWYgbm8gcGFyZW50IG9yIHBhcmVudCBpcyBvbGRlclxuICAgICAgICAgICAgb3BhY2l0eVswXSA9IHV0aWwuY2xhbXAoc2luY2VUaWxlLCAwLCAxKTtcbiAgICAgICAgICAgIG9wYWNpdHlbMV0gPSAxIC0gb3BhY2l0eVswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhcmVudCBpcyB5b3VuZ2VyLCB6b29taW5nIG91dFxuICAgICAgICAgICAgb3BhY2l0eVswXSA9IHV0aWwuY2xhbXAoMSAtIHNpbmNlUGFyZW50LCAwLCAxKTtcbiAgICAgICAgICAgIG9wYWNpdHlbMV0gPSAxIC0gb3BhY2l0eVswXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvcCA9IGxheWVyLnBhaW50WydyYXN0ZXItb3BhY2l0eSddO1xuICAgIG9wYWNpdHlbMF0gKj0gb3A7XG4gICAgb3BhY2l0eVsxXSAqPSBvcDtcblxuICAgIHJldHVybiBvcGFjaXR5O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xudmFyIGRyYXdDb2xsaXNpb25EZWJ1ZyA9IHJlcXVpcmUoJy4vZHJhd19jb2xsaXNpb25fZGVidWcnKTtcbnZhciBwaXhlbHNUb1RpbGVVbml0cyA9IHJlcXVpcmUoJy4uL3NvdXJjZS9waXhlbHNfdG9fdGlsZV91bml0cycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZHJhd1N5bWJvbHM7XG5cbmZ1bmN0aW9uIGRyYXdTeW1ib2xzKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkcykge1xuICAgIGlmIChwYWludGVyLmlzT3BhcXVlUGFzcykgcmV0dXJuO1xuXG4gICAgdmFyIGRyYXdBY3Jvc3NFZGdlcyA9ICEobGF5ZXIubGF5b3V0Wyd0ZXh0LWFsbG93LW92ZXJsYXAnXSB8fCBsYXllci5sYXlvdXRbJ2ljb24tYWxsb3ctb3ZlcmxhcCddIHx8XG4gICAgICAgIGxheWVyLmxheW91dFsndGV4dC1pZ25vcmUtcGxhY2VtZW50J10gfHwgbGF5ZXIubGF5b3V0WydpY29uLWlnbm9yZS1wbGFjZW1lbnQnXSk7XG5cbiAgICB2YXIgZ2wgPSBwYWludGVyLmdsO1xuXG4gICAgLy8gRGlzYWJsZSB0aGUgc3RlbmNpbCB0ZXN0IHNvIHRoYXQgbGFiZWxzIGFyZW4ndCBjbGlwcGVkIHRvIHRpbGUgYm91bmRhcmllcy5cbiAgICAvL1xuICAgIC8vIExheWVycyB3aXRoIGZlYXR1cmVzIHRoYXQgbWF5IGJlIGRyYXduIG92ZXJsYXBwaW5nIGFyZW4ndCBjbGlwcGVkLiBUaGVzZVxuICAgIC8vIGxheWVycyBhcmUgc29ydGVkIGluIHRoZSB5IGRpcmVjdGlvbiwgYW5kIHRvIGRyYXcgdGhlIGNvcnJlY3Qgb3JkZXJpbmcgbmVhclxuICAgIC8vIHRpbGUgZWRnZXMgdGhlIGljb25zIGFyZSBpbmNsdWRlZCBpbiBib3RoIHRpbGVzIGFuZCBjbGlwcGVkIHdoZW4gZHJhd2luZy5cbiAgICBpZiAoZHJhd0Fjcm9zc0VkZ2VzKSB7XG4gICAgICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICB9XG5cbiAgICBwYWludGVyLnNldERlcHRoU3VibGF5ZXIoMCk7XG4gICAgcGFpbnRlci5kZXB0aE1hc2soZmFsc2UpO1xuICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG5cbiAgICBkcmF3TGF5ZXJTeW1ib2xzKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3JkcywgZmFsc2UsXG4gICAgICAgICAgICBsYXllci5wYWludFsnaWNvbi10cmFuc2xhdGUnXSxcbiAgICAgICAgICAgIGxheWVyLnBhaW50WydpY29uLXRyYW5zbGF0ZS1hbmNob3InXSxcbiAgICAgICAgICAgIGxheWVyLmxheW91dFsnaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnQnXSxcbiAgICAgICAgICAgIC8vIGljb24tcGl0Y2gtYWxpZ25tZW50IGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWRcbiAgICAgICAgICAgIC8vIGFuZCB3ZSBzaW1wbHkgaW5oZXJpdCB0aGUgcm90YXRpb24gYWxpZ25tZW50XG4gICAgICAgICAgICBsYXllci5sYXlvdXRbJ2ljb24tcm90YXRpb24tYWxpZ25tZW50J10sXG4gICAgICAgICAgICBsYXllci5sYXlvdXRbJ2ljb24tc2l6ZSddLFxuICAgICAgICAgICAgbGF5ZXIucGFpbnRbJ2ljb24taGFsby13aWR0aCddLFxuICAgICAgICAgICAgbGF5ZXIucGFpbnRbJ2ljb24taGFsby1jb2xvciddLFxuICAgICAgICAgICAgbGF5ZXIucGFpbnRbJ2ljb24taGFsby1ibHVyJ10sXG4gICAgICAgICAgICBsYXllci5wYWludFsnaWNvbi1vcGFjaXR5J10sXG4gICAgICAgICAgICBsYXllci5wYWludFsnaWNvbi1jb2xvciddKTtcblxuICAgIGRyYXdMYXllclN5bWJvbHMocGFpbnRlciwgc291cmNlLCBsYXllciwgY29vcmRzLCB0cnVlLFxuICAgICAgICAgICAgbGF5ZXIucGFpbnRbJ3RleHQtdHJhbnNsYXRlJ10sXG4gICAgICAgICAgICBsYXllci5wYWludFsndGV4dC10cmFuc2xhdGUtYW5jaG9yJ10sXG4gICAgICAgICAgICBsYXllci5sYXlvdXRbJ3RleHQtcm90YXRpb24tYWxpZ25tZW50J10sXG4gICAgICAgICAgICBsYXllci5sYXlvdXRbJ3RleHQtcGl0Y2gtYWxpZ25tZW50J10sXG4gICAgICAgICAgICBsYXllci5sYXlvdXRbJ3RleHQtc2l6ZSddLFxuICAgICAgICAgICAgbGF5ZXIucGFpbnRbJ3RleHQtaGFsby13aWR0aCddLFxuICAgICAgICAgICAgbGF5ZXIucGFpbnRbJ3RleHQtaGFsby1jb2xvciddLFxuICAgICAgICAgICAgbGF5ZXIucGFpbnRbJ3RleHQtaGFsby1ibHVyJ10sXG4gICAgICAgICAgICBsYXllci5wYWludFsndGV4dC1vcGFjaXR5J10sXG4gICAgICAgICAgICBsYXllci5wYWludFsndGV4dC1jb2xvciddKTtcblxuICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcblxuICAgIGlmIChzb3VyY2UubWFwLnNob3dDb2xsaXNpb25Cb3hlcykge1xuICAgICAgICBkcmF3Q29sbGlzaW9uRGVidWcocGFpbnRlciwgc291cmNlLCBsYXllciwgY29vcmRzKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdMYXllclN5bWJvbHMocGFpbnRlciwgc291cmNlLCBsYXllciwgY29vcmRzLCBpc1RleHQsXG4gICAgICAgIHRyYW5zbGF0ZSxcbiAgICAgICAgdHJhbnNsYXRlQW5jaG9yLFxuICAgICAgICByb3RhdGlvbkFsaWdubWVudCxcbiAgICAgICAgcGl0Y2hBbGlnbm1lbnQsXG4gICAgICAgIHNpemUsXG4gICAgICAgIGhhbG9XaWR0aCxcbiAgICAgICAgaGFsb0NvbG9yLFxuICAgICAgICBoYWxvQmx1cixcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgY29sb3IpIHtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29vcmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciB0aWxlID0gc291cmNlLmdldFRpbGUoY29vcmRzW2pdKTtcbiAgICAgICAgdmFyIGJ1Y2tldCA9IHRpbGUuZ2V0QnVja2V0KGxheWVyKTtcbiAgICAgICAgaWYgKCFidWNrZXQpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgYm90aEJ1ZmZlckdyb3VwcyA9IGJ1Y2tldC5idWZmZXJHcm91cHM7XG4gICAgICAgIHZhciBidWZmZXJHcm91cHMgPSBpc1RleHQgPyBib3RoQnVmZmVyR3JvdXBzLmdseXBoIDogYm90aEJ1ZmZlckdyb3Vwcy5pY29uO1xuICAgICAgICBpZiAoIWJ1ZmZlckdyb3Vwcy5sZW5ndGgpIGNvbnRpbnVlO1xuXG4gICAgICAgIHBhaW50ZXIuZW5hYmxlVGlsZUNsaXBwaW5nTWFzayhjb29yZHNbal0pO1xuICAgICAgICBkcmF3U3ltYm9sKHBhaW50ZXIsIGxheWVyLCBjb29yZHNbal0ucG9zTWF0cml4LCB0aWxlLCBidWNrZXQsIGJ1ZmZlckdyb3VwcywgaXNUZXh0LFxuICAgICAgICAgICAgICAgIGlzVGV4dCB8fCBidWNrZXQuc2RmSWNvbnMsICFpc1RleHQgJiYgYnVja2V0Lmljb25zTmVlZExpbmVhcixcbiAgICAgICAgICAgICAgICBpc1RleHQgPyBidWNrZXQuYWRqdXN0ZWRUZXh0U2l6ZSA6IGJ1Y2tldC5hZGp1c3RlZEljb25TaXplLCBidWNrZXQuZm9udHN0YWNrLFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZSxcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVBbmNob3IsXG4gICAgICAgICAgICAgICAgcm90YXRpb25BbGlnbm1lbnQsXG4gICAgICAgICAgICAgICAgcGl0Y2hBbGlnbm1lbnQsXG4gICAgICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgICAgICBoYWxvV2lkdGgsXG4gICAgICAgICAgICAgICAgaGFsb0NvbG9yLFxuICAgICAgICAgICAgICAgIGhhbG9CbHVyLFxuICAgICAgICAgICAgICAgIG9wYWNpdHksXG4gICAgICAgICAgICAgICAgY29sb3IpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhd1N5bWJvbChwYWludGVyLCBsYXllciwgcG9zTWF0cml4LCB0aWxlLCBidWNrZXQsIGJ1ZmZlckdyb3VwcywgaXNUZXh0LCBzZGYsIGljb25zTmVlZExpbmVhciwgYWRqdXN0ZWRTaXplLCBmb250c3RhY2ssXG4gICAgICAgIHRyYW5zbGF0ZSxcbiAgICAgICAgdHJhbnNsYXRlQW5jaG9yLFxuICAgICAgICByb3RhdGlvbkFsaWdubWVudCxcbiAgICAgICAgcGl0Y2hBbGlnbm1lbnQsXG4gICAgICAgIHNpemUsXG4gICAgICAgIGhhbG9XaWR0aCxcbiAgICAgICAgaGFsb0NvbG9yLFxuICAgICAgICBoYWxvQmx1cixcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgY29sb3IpIHtcblxuICAgIHZhciBnbCA9IHBhaW50ZXIuZ2w7XG4gICAgdmFyIHRyID0gcGFpbnRlci50cmFuc2Zvcm07XG4gICAgdmFyIHJvdGF0ZVdpdGhNYXAgPSByb3RhdGlvbkFsaWdubWVudCA9PT0gJ21hcCc7XG4gICAgdmFyIHBpdGNoV2l0aE1hcCA9IHBpdGNoQWxpZ25tZW50ID09PSAnbWFwJztcblxuICAgIHZhciBkZWZhdWx0U2l6ZSA9IGlzVGV4dCA/IDI0IDogMTtcbiAgICB2YXIgZm9udFNjYWxlID0gc2l6ZSAvIGRlZmF1bHRTaXplO1xuXG4gICAgdmFyIGV4dHJ1ZGVTY2FsZSwgcywgZ2FtbWFTY2FsZTtcbiAgICBpZiAocGl0Y2hXaXRoTWFwKSB7XG4gICAgICAgIHMgPSBwaXhlbHNUb1RpbGVVbml0cyh0aWxlLCAxLCBwYWludGVyLnRyYW5zZm9ybS56b29tKSAqIGZvbnRTY2FsZTtcbiAgICAgICAgZ2FtbWFTY2FsZSA9IDEgLyBNYXRoLmNvcyh0ci5fcGl0Y2gpO1xuICAgICAgICBleHRydWRlU2NhbGUgPSBbcywgc107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcyA9IHBhaW50ZXIudHJhbnNmb3JtLmFsdGl0dWRlICogZm9udFNjYWxlO1xuICAgICAgICBnYW1tYVNjYWxlID0gMTtcbiAgICAgICAgZXh0cnVkZVNjYWxlID0gWyB0ci5waXhlbHNUb0dMVW5pdHNbMF0gKiBzLCB0ci5waXhlbHNUb0dMVW5pdHNbMV0gKiBzXTtcbiAgICB9XG5cbiAgICBpZiAoIWlzVGV4dCAmJiAhcGFpbnRlci5zdHlsZS5zcHJpdGUubG9hZGVkKCkpXG4gICAgICAgIHJldHVybjtcblxuICAgIHZhciBwcm9ncmFtID0gcGFpbnRlci51c2VQcm9ncmFtKHNkZiA/ICdzZGYnIDogJ2ljb24nKTtcbiAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHByb2dyYW0udV9tYXRyaXgsIGZhbHNlLCBwYWludGVyLnRyYW5zbGF0ZVBvc01hdHJpeChwb3NNYXRyaXgsIHRpbGUsIHRyYW5zbGF0ZSwgdHJhbnNsYXRlQW5jaG9yKSk7XG4gICAgZ2wudW5pZm9ybTFpKHByb2dyYW0udV9yb3RhdGVfd2l0aF9tYXAsIHJvdGF0ZVdpdGhNYXApO1xuICAgIGdsLnVuaWZvcm0xaShwcm9ncmFtLnVfcGl0Y2hfd2l0aF9tYXAsIHBpdGNoV2l0aE1hcCk7XG4gICAgZ2wudW5pZm9ybTJmdihwcm9ncmFtLnVfZXh0cnVkZV9zY2FsZSwgZXh0cnVkZVNjYWxlKTtcblxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgIGdsLnVuaWZvcm0xaShwcm9ncmFtLnVfdGV4dHVyZSwgMCk7XG5cbiAgICBpZiAoaXNUZXh0KSB7XG4gICAgICAgIC8vIHVzZSB0aGUgZm9uc3RhY2sgdXNlZCB3aGVuIHBhcnNpbmcgdGhlIHRpbGUsIG5vdCB0aGUgZm9udHN0YWNrXG4gICAgICAgIC8vIGF0IHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgKGxheW91dFsndGV4dC1mb250J10pLlxuICAgICAgICB2YXIgZ2x5cGhBdGxhcyA9IGZvbnRzdGFjayAmJiBwYWludGVyLmdseXBoU291cmNlLmdldEdseXBoQXRsYXMoZm9udHN0YWNrKTtcbiAgICAgICAgaWYgKCFnbHlwaEF0bGFzKSByZXR1cm47XG5cbiAgICAgICAgZ2x5cGhBdGxhcy51cGRhdGVUZXh0dXJlKGdsKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmKHByb2dyYW0udV90ZXhzaXplLCBnbHlwaEF0bGFzLndpZHRoIC8gNCwgZ2x5cGhBdGxhcy5oZWlnaHQgLyA0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWFwTW92aW5nID0gcGFpbnRlci5vcHRpb25zLnJvdGF0aW5nIHx8IHBhaW50ZXIub3B0aW9ucy56b29taW5nO1xuICAgICAgICB2YXIgaWNvblNjYWxlZCA9IGZvbnRTY2FsZSAhPT0gMSB8fCBicm93c2VyLmRldmljZVBpeGVsUmF0aW8gIT09IHBhaW50ZXIuc3ByaXRlQXRsYXMucGl4ZWxSYXRpbyB8fCBpY29uc05lZWRMaW5lYXI7XG4gICAgICAgIHZhciBpY29uVHJhbnNmb3JtZWQgPSBwaXRjaFdpdGhNYXAgfHwgcGFpbnRlci50cmFuc2Zvcm0ucGl0Y2g7XG4gICAgICAgIHBhaW50ZXIuc3ByaXRlQXRsYXMuYmluZChnbCwgc2RmIHx8IG1hcE1vdmluZyB8fCBpY29uU2NhbGVkIHx8IGljb25UcmFuc2Zvcm1lZCk7XG4gICAgICAgIGdsLnVuaWZvcm0yZihwcm9ncmFtLnVfdGV4c2l6ZSwgcGFpbnRlci5zcHJpdGVBdGxhcy53aWR0aCAvIDQsIHBhaW50ZXIuc3ByaXRlQXRsYXMuaGVpZ2h0IC8gNCk7XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IG1pbi9tYXggem9vbXMgZm9yIHZhcmlhYmxlIGZvbnQgc2l6ZXNcbiAgICB2YXIgem9vbUFkanVzdCA9IE1hdGgubG9nKHNpemUgLyBhZGp1c3RlZFNpemUpIC8gTWF0aC5MTjIgfHwgMDtcbiAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X3pvb20sIChwYWludGVyLnRyYW5zZm9ybS56b29tIC0gem9vbUFkanVzdCkgKiAxMCk7IC8vIGN1cnJlbnQgem9vbSBsZXZlbFxuXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMSk7XG4gICAgcGFpbnRlci5mcmFtZUhpc3RvcnkuYmluZChnbCk7XG4gICAgZ2wudW5pZm9ybTFpKHByb2dyYW0udV9mYWRldGV4dHVyZSwgMSk7XG5cbiAgICB2YXIgZ3JvdXA7XG5cbiAgICBpZiAoc2RmKSB7XG4gICAgICAgIHZhciBzZGZQeCA9IDg7XG4gICAgICAgIHZhciBibHVyT2Zmc2V0ID0gMS4xOTtcbiAgICAgICAgdmFyIGhhbG9PZmZzZXQgPSA2O1xuICAgICAgICB2YXIgZ2FtbWEgPSAwLjEwNSAqIGRlZmF1bHRTaXplIC8gc2l6ZSAvIGJyb3dzZXIuZGV2aWNlUGl4ZWxSYXRpbztcblxuICAgICAgICBpZiAoaGFsb1dpZHRoKSB7XG4gICAgICAgICAgICAvLyBEcmF3IGhhbG8gdW5kZXJuZWF0aCB0aGUgdGV4dC5cbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZihwcm9ncmFtLnVfZ2FtbWEsIChoYWxvQmx1ciAqIGJsdXJPZmZzZXQgLyBmb250U2NhbGUgLyBzZGZQeCArIGdhbW1hKSAqIGdhbW1hU2NhbGUpO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTRmdihwcm9ncmFtLnVfY29sb3IsIGhhbG9Db2xvcik7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X29wYWNpdHksIG9wYWNpdHkpO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9idWZmZXIsIChoYWxvT2Zmc2V0IC0gaGFsb1dpZHRoIC8gZm9udFNjYWxlKSAvIHNkZlB4KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBidWZmZXJHcm91cHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBncm91cCA9IGJ1ZmZlckdyb3Vwc1tqXTtcbiAgICAgICAgICAgICAgICBncm91cC52YW9zW2xheWVyLmlkXS5iaW5kKGdsLCBwcm9ncmFtLCBncm91cC5sYXlvdXRWZXJ0ZXhCdWZmZXIsIGdyb3VwLmVsZW1lbnRCdWZmZXIpO1xuICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIGdyb3VwLmVsZW1lbnRCdWZmZXIubGVuZ3RoICogMywgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9nYW1tYSwgZ2FtbWEgKiBnYW1tYVNjYWxlKTtcbiAgICAgICAgZ2wudW5pZm9ybTRmdihwcm9ncmFtLnVfY29sb3IsIGNvbG9yKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9vcGFjaXR5LCBvcGFjaXR5KTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9idWZmZXIsICgyNTYgLSA2NCkgLyAyNTYpO1xuICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X3BpdGNoLCB0ci5waXRjaCAvIDM2MCAqIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9iZWFyaW5nLCB0ci5iZWFyaW5nIC8gMzYwICogMiAqIE1hdGguUEkpO1xuICAgICAgICBnbC51bmlmb3JtMWYocHJvZ3JhbS51X2FzcGVjdF9yYXRpbywgdHIud2lkdGggLyB0ci5oZWlnaHQpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyR3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBncm91cCA9IGJ1ZmZlckdyb3Vwc1tpXTtcbiAgICAgICAgICAgIGdyb3VwLnZhb3NbbGF5ZXIuaWRdLmJpbmQoZ2wsIHByb2dyYW0sIGdyb3VwLmxheW91dFZlcnRleEJ1ZmZlciwgZ3JvdXAuZWxlbWVudEJ1ZmZlcik7XG4gICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBncm91cC5lbGVtZW50QnVmZmVyLmxlbmd0aCAqIDMsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udV9vcGFjaXR5LCBvcGFjaXR5KTtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBidWZmZXJHcm91cHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGdyb3VwID0gYnVmZmVyR3JvdXBzW2tdO1xuICAgICAgICAgICAgZ3JvdXAudmFvc1tsYXllci5pZF0uYmluZChnbCwgcHJvZ3JhbSwgZ3JvdXAubGF5b3V0VmVydGV4QnVmZmVyLCBncm91cC5lbGVtZW50QnVmZmVyKTtcbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIGdyb3VwLmVsZW1lbnRCdWZmZXIubGVuZ3RoICogMywgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZyYW1lSGlzdG9yeTtcblxuZnVuY3Rpb24gRnJhbWVIaXN0b3J5KCkge1xuICAgIHRoaXMuY2hhbmdlVGltZXMgPSBuZXcgRmxvYXQ2NEFycmF5KDI1Nik7XG4gICAgdGhpcy5jaGFuZ2VPcGFjaXRpZXMgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgIHRoaXMub3BhY2l0aWVzID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDI1Nik7XG4gICAgdGhpcy5hcnJheSA9IG5ldyBVaW50OEFycmF5KHRoaXMub3BhY2l0aWVzLmJ1ZmZlcik7XG5cbiAgICB0aGlzLmZhZGVEdXJhdGlvbiA9IDMwMDtcbiAgICB0aGlzLnByZXZpb3VzWm9vbSA9IDA7XG4gICAgdGhpcy5maXJzdEZyYW1lID0gdHJ1ZTtcbn1cblxuRnJhbWVIaXN0b3J5LnByb3RvdHlwZS5yZWNvcmQgPSBmdW5jdGlvbih6b29tKSB7XG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBpZiAodGhpcy5maXJzdEZyYW1lKSB7XG4gICAgICAgIG5vdyA9IDA7XG4gICAgICAgIHRoaXMuZmlyc3RGcmFtZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHpvb20gPSBNYXRoLmZsb29yKHpvb20gKiAxMCk7XG5cbiAgICB2YXIgejtcbiAgICBpZiAoem9vbSA8IHRoaXMucHJldmlvdXNab29tKSB7XG4gICAgICAgIGZvciAoeiA9IHpvb20gKyAxOyB6IDw9IHRoaXMucHJldmlvdXNab29tOyB6KyspIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlVGltZXNbel0gPSBub3c7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZU9wYWNpdGllc1t6XSA9IHRoaXMub3BhY2l0aWVzW3pdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh6ID0gem9vbTsgeiA+IHRoaXMucHJldmlvdXNab29tOyB6LS0pIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlVGltZXNbel0gPSBub3c7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZU9wYWNpdGllc1t6XSA9IHRoaXMub3BhY2l0aWVzW3pdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh6ID0gMDsgeiA8IDI1NjsgeisrKSB7XG4gICAgICAgIHZhciB0aW1lU2luY2UgPSBub3cgLSB0aGlzLmNoYW5nZVRpbWVzW3pdO1xuICAgICAgICB2YXIgb3BhY2l0eUNoYW5nZSA9IHRpbWVTaW5jZSAvIHRoaXMuZmFkZUR1cmF0aW9uICogMjU1O1xuICAgICAgICBpZiAoeiA8PSB6b29tKSB7XG4gICAgICAgICAgICB0aGlzLm9wYWNpdGllc1t6XSA9IHRoaXMuY2hhbmdlT3BhY2l0aWVzW3pdICsgb3BhY2l0eUNoYW5nZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BhY2l0aWVzW3pdID0gdGhpcy5jaGFuZ2VPcGFjaXRpZXNbel0gLSBvcGFjaXR5Q2hhbmdlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICB0aGlzLnByZXZpb3VzWm9vbSA9IHpvb207XG59O1xuXG5GcmFtZUhpc3RvcnkucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihnbCkge1xuICAgIGlmICghdGhpcy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5BTFBIQSwgMjU2LCAxLCAwLCBnbC5BTFBIQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5hcnJheSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgICAgICBpZiAodGhpcy5jaGFuZ2VkKSB7XG4gICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIDI1NiwgMSwgZ2wuQUxQSEEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuYXJyYXkpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVBdGxhcztcblxuLyoqXG4gKiBBIExpbmVBdGxhcyBsZXRzIHVzIHJldXNlIHJlbmRlcmVkIGRhc2hlZCBsaW5lc1xuICogYnkgd3JpdGluZyBtYW55IG9mIHRoZW0gdG8gYSB0ZXh0dXJlIGFuZCB0aGVuIGZldGNoaW5nIHRoZWlyIHBvc2l0aW9uc1xuICogdXNpbmcgLmdldERhc2guXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBMaW5lQXRsYXMod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLm5leHRSb3cgPSAwO1xuXG4gICAgdGhpcy5ieXRlcyA9IDQ7XG4gICAgdGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0ICogdGhpcy5ieXRlcyk7XG5cbiAgICB0aGlzLnBvc2l0aW9ucyA9IHt9O1xufVxuXG5MaW5lQXRsYXMucHJvdG90eXBlLnNldFNwcml0ZSA9IGZ1bmN0aW9uKHNwcml0ZSkge1xuICAgIHRoaXMuc3ByaXRlID0gc3ByaXRlO1xufTtcblxuLyoqXG4gKiBHZXQgb3IgY3JlYXRlIGEgZGFzaCBsaW5lIHBhdHRlcm4uXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBkYXNoYXJyYXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcm91bmQgd2hldGhlciB0byBhZGQgY2lyY2xlIGNhcHMgaW4gYmV0d2VlbiBkYXNoIHNlZ21lbnRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwb3NpdGlvbiBvZiBkYXNoIHRleHR1cmUgaW4geyB5LCBoZWlnaHQsIHdpZHRoIH1cbiAqIEBwcml2YXRlXG4gKi9cbkxpbmVBdGxhcy5wcm90b3R5cGUuZ2V0RGFzaCA9IGZ1bmN0aW9uKGRhc2hhcnJheSwgcm91bmQpIHtcbiAgICB2YXIga2V5ID0gZGFzaGFycmF5LmpvaW4oXCIsXCIpICsgcm91bmQ7XG5cbiAgICBpZiAoIXRoaXMucG9zaXRpb25zW2tleV0pIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnNba2V5XSA9IHRoaXMuYWRkRGFzaChkYXNoYXJyYXksIHJvdW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb25zW2tleV07XG59O1xuXG5MaW5lQXRsYXMucHJvdG90eXBlLmFkZERhc2ggPSBmdW5jdGlvbihkYXNoYXJyYXksIHJvdW5kKSB7XG5cbiAgICB2YXIgbiA9IHJvdW5kID8gNyA6IDA7XG4gICAgdmFyIGhlaWdodCA9IDIgKiBuICsgMTtcbiAgICB2YXIgb2Zmc2V0ID0gMTI4O1xuXG4gICAgaWYgKHRoaXMubmV4dFJvdyArIGhlaWdodCA+IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgIHV0aWwud2Fybk9uY2UoJ0xpbmVBdGxhcyBvdXQgb2Ygc3BhY2UnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXNoYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoICs9IGRhc2hhcnJheVtpXTtcbiAgICB9XG5cbiAgICB2YXIgc3RyZXRjaCA9IHRoaXMud2lkdGggLyBsZW5ndGg7XG4gICAgdmFyIGhhbGZXaWR0aCA9IHN0cmV0Y2ggLyAyO1xuXG4gICAgLy8gSWYgZGFzaGFycmF5IGhhcyBhbiBvZGQgbGVuZ3RoLCBib3RoIHRoZSBmaXJzdCBhbmQgbGFzdCBwYXJ0c1xuICAgIC8vIGFyZSBkYXNoZXMgYW5kIHNob3VsZCBiZSBqb2luZWQgc2VhbWxlc3NseS5cbiAgICB2YXIgb2RkTGVuZ3RoID0gZGFzaGFycmF5Lmxlbmd0aCAlIDIgPT09IDE7XG5cbiAgICBmb3IgKHZhciB5ID0gLW47IHkgPD0gbjsgeSsrKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLm5leHRSb3cgKyBuICsgeTtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy53aWR0aCAqIHJvdztcblxuICAgICAgICB2YXIgbGVmdCA9IG9kZExlbmd0aCA/IC1kYXNoYXJyYXlbZGFzaGFycmF5Lmxlbmd0aCAtIDFdIDogMDtcbiAgICAgICAgdmFyIHJpZ2h0ID0gZGFzaGFycmF5WzBdO1xuICAgICAgICB2YXIgcGFydEluZGV4ID0gMTtcblxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMud2lkdGg7IHgrKykge1xuXG4gICAgICAgICAgICB3aGlsZSAocmlnaHQgPCB4IC8gc3RyZXRjaCkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0ICsgZGFzaGFycmF5W3BhcnRJbmRleF07XG5cbiAgICAgICAgICAgICAgICBpZiAob2RkTGVuZ3RoICYmIHBhcnRJbmRleCA9PT0gZGFzaGFycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgKz0gZGFzaGFycmF5WzBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcnRJbmRleCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGlzdExlZnQgPSBNYXRoLmFicyh4IC0gbGVmdCAqIHN0cmV0Y2gpO1xuICAgICAgICAgICAgdmFyIGRpc3RSaWdodCA9IE1hdGguYWJzKHggLSByaWdodCAqIHN0cmV0Y2gpO1xuICAgICAgICAgICAgdmFyIGRpc3QgPSBNYXRoLm1pbihkaXN0TGVmdCwgZGlzdFJpZ2h0KTtcbiAgICAgICAgICAgIHZhciBpbnNpZGUgPSAocGFydEluZGV4ICUgMikgPT09IDE7XG4gICAgICAgICAgICB2YXIgc2lnbmVkRGlzdGFuY2U7XG5cbiAgICAgICAgICAgIGlmIChyb3VuZCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBjaXJjbGUgY2Fwc1xuICAgICAgICAgICAgICAgIHZhciBkaXN0TWlkZGxlID0gbiA/IHkgLyBuICogKGhhbGZXaWR0aCArIDEpIDogMDtcbiAgICAgICAgICAgICAgICBpZiAoaW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0RWRnZSA9IGhhbGZXaWR0aCAtIE1hdGguYWJzKGRpc3RNaWRkbGUpO1xuICAgICAgICAgICAgICAgICAgICBzaWduZWREaXN0YW5jZSA9IE1hdGguc3FydChkaXN0ICogZGlzdCArIGRpc3RFZGdlICogZGlzdEVkZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25lZERpc3RhbmNlID0gaGFsZldpZHRoIC0gTWF0aC5zcXJ0KGRpc3QgKiBkaXN0ICsgZGlzdE1pZGRsZSAqIGRpc3RNaWRkbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2lnbmVkRGlzdGFuY2UgPSAoaW5zaWRlID8gMSA6IC0xKSAqIGRpc3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YVszICsgKGluZGV4ICsgeCkgKiA0XSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgc2lnbmVkRGlzdGFuY2UgKyBvZmZzZXQpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwb3MgPSB7XG4gICAgICAgIHk6ICh0aGlzLm5leHRSb3cgKyBuICsgMC41KSAvIHRoaXMuaGVpZ2h0LFxuICAgICAgICBoZWlnaHQ6IDIgKiBuIC8gdGhpcy5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBsZW5ndGhcbiAgICB9O1xuXG4gICAgdGhpcy5uZXh0Um93ICs9IGhlaWdodDtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHJldHVybiBwb3M7XG59O1xuXG5MaW5lQXRsYXMucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihnbCkge1xuICAgIGlmICghdGhpcy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuUkVQRUFUKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuUkVQRUFUKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLmRhdGEpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcblxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgbWF0NCA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLm1hdDQ7XG52YXIgRnJhbWVIaXN0b3J5ID0gcmVxdWlyZSgnLi9mcmFtZV9oaXN0b3J5Jyk7XG52YXIgU291cmNlQ2FjaGUgPSByZXF1aXJlKCcuLi9zb3VyY2Uvc291cmNlX2NhY2hlJyk7XG52YXIgRVhURU5UID0gcmVxdWlyZSgnLi4vZGF0YS9idWNrZXQnKS5FWFRFTlQ7XG52YXIgcGl4ZWxzVG9UaWxlVW5pdHMgPSByZXF1aXJlKCcuLi9zb3VyY2UvcGl4ZWxzX3RvX3RpbGVfdW5pdHMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgU3RydWN0QXJyYXlUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9zdHJ1Y3RfYXJyYXknKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuLi9kYXRhL2J1ZmZlcicpO1xudmFyIFZlcnRleEFycmF5T2JqZWN0ID0gcmVxdWlyZSgnLi92ZXJ0ZXhfYXJyYXlfb2JqZWN0Jyk7XG52YXIgUmFzdGVyQm91bmRzQXJyYXkgPSByZXF1aXJlKCcuL2RyYXdfcmFzdGVyJykuUmFzdGVyQm91bmRzQXJyYXk7XG52YXIgY3JlYXRlVW5pZm9ybVByYWdtYXMgPSByZXF1aXJlKCcuL2NyZWF0ZV91bmlmb3JtX3ByYWdtYXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYWludGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgcGFpbnRlciBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtDYW52YXN9IGdsIGFuIGV4cGVyaW1lbnRhbC13ZWJnbCBkcmF3aW5nIGNvbnRleHRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFBhaW50ZXIoZ2wsIHRyYW5zZm9ybSkge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcblxuICAgIHRoaXMucmV1c2FibGVUZXh0dXJlcyA9IHt9O1xuICAgIHRoaXMucHJlRmJvcyA9IHt9O1xuXG4gICAgdGhpcy5mcmFtZUhpc3RvcnkgPSBuZXcgRnJhbWVIaXN0b3J5KCk7XG4gICAgdGhpcy5saWdodCA9IHt9O1xuXG4gICAgdGhpcy5zZXR1cCgpO1xuXG4gICAgLy8gV2l0aGluIGVhY2ggbGF5ZXIgdGhlcmUgYXJlIG11bHRpcGxlIGRpc3RpbmN0IHotcGxhbmVzIHRoYXQgY2FuIGJlIGRyYXduIHRvLlxuICAgIC8vIFRoaXMgaXMgaW1wbGVtZW50ZWQgdXNpbmcgdGhlIFdlYkdMIGRlcHRoIGJ1ZmZlci5cbiAgICB0aGlzLm51bVN1YmxheWVycyA9IFNvdXJjZUNhY2hlLm1heFVuZGVyem9vbWluZyArIFNvdXJjZUNhY2hlLm1heE92ZXJ6b29taW5nICsgMTtcbiAgICB0aGlzLmRlcHRoRXBzaWxvbiA9IDEgLyBNYXRoLnBvdygyLCAxNik7XG5cbiAgICB0aGlzLmxpbmVXaWR0aFJhbmdlID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLkFMSUFTRURfTElORV9XSURUSF9SQU5HRSk7XG59XG5cbnV0aWwuZXh0ZW5kKFBhaW50ZXIucHJvdG90eXBlLCByZXF1aXJlKCcuL3BhaW50ZXIvdXNlX3Byb2dyYW0nKSk7XG5cbi8qXG4gKiBVcGRhdGUgdGhlIEdMIHZpZXdwb3J0LCBwcm9qZWN0aW9uIG1hdHJpeCwgYW5kIHRyYW5zZm9ybXMgdG8gY29tcGVuc2F0ZVxuICogZm9yIGEgbmV3IHdpZHRoIGFuZCBoZWlnaHQgdmFsdWUuXG4gKi9cblBhaW50ZXIucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoICogYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxufTtcblxuUGFpbnRlci5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuXG4gICAgZ2wudmVyYm9zZSA9IHRydWU7XG5cbiAgICAvLyBXZSBhcmUgYmxlbmRpbmcgdGhlIG5ldyBwaXhlbHMgKmJlaGluZCogdGhlIGV4aXN0aW5nIHBpeGVscy4gVGhhdCB3YXkgd2UgY2FuXG4gICAgLy8gZHJhdyBmcm9udC10by1iYWNrIGFuZCB1c2UgdGhlbiBzdGVuY2lsIGJ1ZmZlciB0byBjdWxsIG9wYXF1ZSBwaXhlbHMgZWFybHkuXG4gICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcblxuICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuXG4gICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgIGdsLmRlcHRoRnVuYyhnbC5MRVFVQUwpO1xuXG4gICAgdGhpcy5fZGVwdGhNYXNrID0gZmFsc2U7XG4gICAgZ2wuZGVwdGhNYXNrKGZhbHNlKTtcblxuICAgIHZhciBQb3NBcnJheSA9IHRoaXMuUG9zQXJyYXkgPSBuZXcgU3RydWN0QXJyYXlUeXBlKHtcbiAgICAgICAgbWVtYmVyczogW3sgbmFtZTogJ2FfcG9zJywgdHlwZTogJ0ludDE2JywgY29tcG9uZW50czogMiB9XVxuICAgIH0pO1xuXG4gICAgdmFyIHRpbGVFeHRlbnRBcnJheSA9IG5ldyBQb3NBcnJheSgpO1xuICAgIHRpbGVFeHRlbnRBcnJheS5lbXBsYWNlQmFjaygwLCAwKTtcbiAgICB0aWxlRXh0ZW50QXJyYXkuZW1wbGFjZUJhY2soRVhURU5ULCAwKTtcbiAgICB0aWxlRXh0ZW50QXJyYXkuZW1wbGFjZUJhY2soMCwgRVhURU5UKTtcbiAgICB0aWxlRXh0ZW50QXJyYXkuZW1wbGFjZUJhY2soRVhURU5ULCBFWFRFTlQpO1xuICAgIHRoaXMudGlsZUV4dGVudEJ1ZmZlciA9IG5ldyBCdWZmZXIodGlsZUV4dGVudEFycmF5LnNlcmlhbGl6ZSgpLCBQb3NBcnJheS5zZXJpYWxpemUoKSwgQnVmZmVyLkJ1ZmZlclR5cGUuVkVSVEVYKTtcbiAgICB0aGlzLnRpbGVFeHRlbnRWQU8gPSBuZXcgVmVydGV4QXJyYXlPYmplY3QoKTtcbiAgICB0aGlzLnRpbGVFeHRlbnRQYXR0ZXJuVkFPID0gbmV3IFZlcnRleEFycmF5T2JqZWN0KCk7XG5cbiAgICB2YXIgZGVidWdBcnJheSA9IG5ldyBQb3NBcnJheSgpO1xuICAgIGRlYnVnQXJyYXkuZW1wbGFjZUJhY2soMCwgMCk7XG4gICAgZGVidWdBcnJheS5lbXBsYWNlQmFjayhFWFRFTlQsIDApO1xuICAgIGRlYnVnQXJyYXkuZW1wbGFjZUJhY2soRVhURU5ULCBFWFRFTlQpO1xuICAgIGRlYnVnQXJyYXkuZW1wbGFjZUJhY2soMCwgRVhURU5UKTtcbiAgICBkZWJ1Z0FycmF5LmVtcGxhY2VCYWNrKDAsIDApO1xuICAgIHRoaXMuZGVidWdCdWZmZXIgPSBuZXcgQnVmZmVyKGRlYnVnQXJyYXkuc2VyaWFsaXplKCksIFBvc0FycmF5LnNlcmlhbGl6ZSgpLCBCdWZmZXIuQnVmZmVyVHlwZS5WRVJURVgpO1xuICAgIHRoaXMuZGVidWdWQU8gPSBuZXcgVmVydGV4QXJyYXlPYmplY3QoKTtcblxuICAgIHZhciByYXN0ZXJCb3VuZHNBcnJheSA9IG5ldyBSYXN0ZXJCb3VuZHNBcnJheSgpO1xuICAgIHJhc3RlckJvdW5kc0FycmF5LmVtcGxhY2VCYWNrKDAsIDAsIDAsIDApO1xuICAgIHJhc3RlckJvdW5kc0FycmF5LmVtcGxhY2VCYWNrKEVYVEVOVCwgMCwgMzI3NjcsIDApO1xuICAgIHJhc3RlckJvdW5kc0FycmF5LmVtcGxhY2VCYWNrKDAsIEVYVEVOVCwgMCwgMzI3NjcpO1xuICAgIHJhc3RlckJvdW5kc0FycmF5LmVtcGxhY2VCYWNrKEVYVEVOVCwgRVhURU5ULCAzMjc2NywgMzI3NjcpO1xuICAgIHRoaXMucmFzdGVyQm91bmRzQnVmZmVyID0gbmV3IEJ1ZmZlcihyYXN0ZXJCb3VuZHNBcnJheS5zZXJpYWxpemUoKSwgUmFzdGVyQm91bmRzQXJyYXkuc2VyaWFsaXplKCksIEJ1ZmZlci5CdWZmZXJUeXBlLlZFUlRFWCk7XG4gICAgdGhpcy5yYXN0ZXJCb3VuZHNWQU8gPSBuZXcgVmVydGV4QXJyYXlPYmplY3QoKTtcbn07XG5cbi8qXG4gKiBTZXQgdGhlIGxpZ2h0aW5nIHByb3BlcnRpZXMgKHVzZWQgZm9yIGV4dHJ1c2lvbnMpLlxuICovXG5QYWludGVyLnByb3RvdHlwZS5zZXRMaWdodGluZyA9IGZ1bmN0aW9uKGxpZ2h0T3B0aW9ucykge1xuICAgIGZvciAodmFyIGtleSBpbiBsaWdodE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5saWdodFtrZXldID0gbGlnaHRPcHRpb25zW2tleV07XG4gICAgfVxufTtcblxuLypcbiAqIFJlc2V0IHRoZSBjb2xvciBidWZmZXJzIG9mIHRoZSBkcmF3aW5nIGNhbnZhcy5cbiAqL1xuUGFpbnRlci5wcm90b3R5cGUuY2xlYXJDb2xvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbn07XG5cbi8qXG4gKiBSZXNldCB0aGUgZHJhd2luZyBjYW52YXMgYnkgY2xlYXJpbmcgdGhlIHN0ZW5jaWwgYnVmZmVyIHNvIHRoYXQgd2UgY2FuIGRyYXdcbiAqIG5ldyB0aWxlcyBhdCB0aGUgc2FtZSBsb2NhdGlvbiwgd2hpbGUgcmV0YWluaW5nIHByZXZpb3VzbHkgZHJhd24gcGl4ZWxzLlxuICovXG5QYWludGVyLnByb3RvdHlwZS5jbGVhclN0ZW5jaWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLmNsZWFyU3RlbmNpbCgweDApO1xuICAgIGdsLnN0ZW5jaWxNYXNrKDB4RkYpO1xuICAgIGdsLmNsZWFyKGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XG59O1xuXG5QYWludGVyLnByb3RvdHlwZS5jbGVhckRlcHRoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5jbGVhckRlcHRoKDEpO1xuICAgIHRoaXMuZGVwdGhNYXNrKHRydWUpO1xuICAgIGdsLmNsZWFyKGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xufTtcblxuUGFpbnRlci5wcm90b3R5cGUuX3JlbmRlclRpbGVDbGlwcGluZ01hc2tzID0gZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBnbC5jb2xvck1hc2soZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgIHRoaXMuZGVwdGhNYXNrKGZhbHNlKTtcbiAgICBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuXG4gICAgLy8gT25seSB3cml0ZSBjbGlwcGluZyBJRHMgdG8gdGhlIGxhc3QgNSBiaXRzLiBUaGUgZmlyc3QgdGhyZWUgYXJlIHVzZWQgZm9yIGRyYXdpbmcgZmlsbHMuXG4gICAgZ2wuc3RlbmNpbE1hc2soMHhGOCk7XG4gICAgLy8gVGVzdHMgd2lsbCBhbHdheXMgcGFzcywgYW5kIHJlZiB2YWx1ZSB3aWxsIGJlIHdyaXR0ZW4gdG8gc3RlbmNpbCBidWZmZXIuXG4gICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsIGdsLktFRVAsIGdsLlJFUExBQ0UpO1xuXG4gICAgdmFyIGlkTmV4dCA9IDE7XG4gICAgdGhpcy5fdGlsZUNsaXBwaW5nTWFza0lEcyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb29yZCA9IGNvb3Jkc1tpXTtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5fdGlsZUNsaXBwaW5nTWFza0lEc1tjb29yZC5pZF0gPSAoaWROZXh0KyspIDw8IDM7XG5cbiAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuQUxXQVlTLCBpZCwgMHhGOCk7XG5cbiAgICAgICAgdmFyIHByYWdtYXMgPSBjcmVhdGVVbmlmb3JtUHJhZ21hcyhbXG4gICAgICAgICAgICB7bmFtZTogJ3VfY29sb3InLCBjb21wb25lbnRzOiA0fSxcbiAgICAgICAgICAgIHtuYW1lOiAndV9vcGFjaXR5JywgY29tcG9uZW50czogMX1cbiAgICAgICAgXSk7XG4gICAgICAgIHZhciBwcm9ncmFtID0gdGhpcy51c2VQcm9ncmFtKCdmaWxsJywgW10sIHByYWdtYXMsIHByYWdtYXMpO1xuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHByb2dyYW0udV9tYXRyaXgsIGZhbHNlLCBjb29yZC5wb3NNYXRyaXgpO1xuXG4gICAgICAgIC8vIERyYXcgdGhlIGNsaXBwaW5nIG1hc2tcbiAgICAgICAgdGhpcy50aWxlRXh0ZW50VkFPLmJpbmQoZ2wsIHByb2dyYW0sIHRoaXMudGlsZUV4dGVudEJ1ZmZlcik7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIHRoaXMudGlsZUV4dGVudEJ1ZmZlci5sZW5ndGgpO1xuICAgIH1cblxuICAgIGdsLnN0ZW5jaWxNYXNrKDB4MDApO1xuICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICB0aGlzLmRlcHRoTWFzayh0cnVlKTtcbiAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG59O1xuXG5QYWludGVyLnByb3RvdHlwZS5lbmFibGVUaWxlQ2xpcHBpbmdNYXNrID0gZnVuY3Rpb24oY29vcmQpIHtcbiAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCB0aGlzLl90aWxlQ2xpcHBpbmdNYXNrSURzW2Nvb3JkLmlkXSwgMHhGOCk7XG59O1xuXG4vLyBPdmVycmlkZGVuIGJ5IGhlYWRsZXNzIHRlc3RzLlxuUGFpbnRlci5wcm90b3R5cGUucHJlcGFyZUJ1ZmZlcnMgPSBmdW5jdGlvbigpIHt9O1xuUGFpbnRlci5wcm90b3R5cGUuYmluZERlZmF1bHRGcmFtZWJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbn07XG5cbnZhciBkcmF3ID0ge1xuICAgIHN5bWJvbDogcmVxdWlyZSgnLi9kcmF3X3N5bWJvbCcpLFxuICAgIGNpcmNsZTogcmVxdWlyZSgnLi9kcmF3X2NpcmNsZScpLFxuICAgIGxpbmU6IHJlcXVpcmUoJy4vZHJhd19saW5lJyksXG4gICAgZmlsbDogcmVxdWlyZSgnLi9kcmF3X2ZpbGwnKSxcbiAgICBleHRydXNpb246IHJlcXVpcmUoJy4vZHJhd19leHRydXNpb24nKSxcbiAgICByYXN0ZXI6IHJlcXVpcmUoJy4vZHJhd19yYXN0ZXInKSxcbiAgICBiYWNrZ3JvdW5kOiByZXF1aXJlKCcuL2RyYXdfYmFja2dyb3VuZCcpLFxuICAgIGRlYnVnOiByZXF1aXJlKCcuL2RyYXdfZGVidWcnKVxufTtcblxuUGFpbnRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHRoaXMubGluZUF0bGFzID0gc3R5bGUubGluZUF0bGFzO1xuXG4gICAgdGhpcy5zcHJpdGVBdGxhcyA9IHN0eWxlLnNwcml0ZUF0bGFzO1xuICAgIHRoaXMuc3ByaXRlQXRsYXMuc2V0U3ByaXRlKHN0eWxlLnNwcml0ZSk7XG5cbiAgICB0aGlzLmdseXBoU291cmNlID0gc3R5bGUuZ2x5cGhTb3VyY2U7XG5cbiAgICB0aGlzLmZyYW1lSGlzdG9yeS5yZWNvcmQodGhpcy50cmFuc2Zvcm0uem9vbSk7XG5cbiAgICB0aGlzLnByZXBhcmVCdWZmZXJzKCk7XG4gICAgdGhpcy5jbGVhckNvbG9yKCk7XG4gICAgdGhpcy5jbGVhckRlcHRoKCk7XG5cbiAgICB0aGlzLnNob3dPdmVyZHJhd0luc3BlY3RvcihvcHRpb25zLnNob3dPdmVyZHJhd0luc3BlY3Rvcik7XG5cbiAgICB0aGlzLmRlcHRoUmFuZ2UgPSAoc3R5bGUuX29yZGVyLmxlbmd0aCArIDIpICogdGhpcy5udW1TdWJsYXllcnMgKiB0aGlzLmRlcHRoRXBzaWxvbjtcblxuICAgIHRoaXMucmVuZGVyUGFzcyh7aXNPcGFxdWVQYXNzOiB0cnVlfSk7XG4gICAgdGhpcy5yZW5kZXJQYXNzKHtpc09wYXF1ZVBhc3M6IGZhbHNlfSk7XG59O1xuXG5QYWludGVyLnByb3RvdHlwZS5yZW5kZXJQYXNzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBncm91cHMgPSB0aGlzLnN0eWxlLl9ncm91cHM7XG4gICAgdmFyIGlzT3BhcXVlUGFzcyA9IG9wdGlvbnMuaXNPcGFxdWVQYXNzO1xuICAgIHRoaXMuY3VycmVudExheWVyID0gaXNPcGFxdWVQYXNzID8gdGhpcy5zdHlsZS5fb3JkZXIubGVuZ3RoIDogLTE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbaXNPcGFxdWVQYXNzID8gZ3JvdXBzLmxlbmd0aCAtIDEgLSBpIDogaV07XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnN0eWxlLnNvdXJjZXNbZ3JvdXAuc291cmNlXTtcblxuICAgICAgICB2YXIgajtcbiAgICAgICAgdmFyIGNvb3JkcyA9IFtdO1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBjb29yZHMgPSBzb3VyY2UuZ2V0VmlzaWJsZUNvb3JkaW5hdGVzKCk7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29vcmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29vcmRzW2pdLnBvc01hdHJpeCA9IHRoaXMudHJhbnNmb3JtLmNhbGN1bGF0ZVBvc01hdHJpeChjb29yZHNbal0sIHNvdXJjZS5tYXh6b29tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xlYXJTdGVuY2lsKCk7XG4gICAgICAgICAgICBpZiAoc291cmNlLnByZXBhcmUpIHNvdXJjZS5wcmVwYXJlKCk7XG4gICAgICAgICAgICBpZiAoc291cmNlLmlzVGlsZUNsaXBwZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJUaWxlQ2xpcHBpbmdNYXNrcyhjb29yZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzT3BhcXVlUGFzcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9zaG93T3ZlcmRyYXdJbnNwZWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdsLmRpc2FibGUodGhpcy5nbC5CTEVORCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzT3BhcXVlUGFzcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkJMRU5EKTtcbiAgICAgICAgICAgIHRoaXMuaXNPcGFxdWVQYXNzID0gZmFsc2U7XG4gICAgICAgICAgICBjb29yZHMucmV2ZXJzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGdyb3VwLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBncm91cFtpc09wYXF1ZVBhc3MgPyBncm91cC5sZW5ndGggLSAxIC0gaiA6IGpdO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TGF5ZXIgKz0gaXNPcGFxdWVQYXNzID8gLTEgOiAxO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJMYXllcih0aGlzLCBzb3VyY2UsIGxheWVyLCBjb29yZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgZHJhdy5kZWJ1Zyh0aGlzLCBzb3VyY2UsIGNvb3Jkcyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5QYWludGVyLnByb3RvdHlwZS5kZXB0aE1hc2sgPSBmdW5jdGlvbihtYXNrKSB7XG4gICAgaWYgKG1hc2sgIT09IHRoaXMuX2RlcHRoTWFzaykge1xuICAgICAgICB0aGlzLl9kZXB0aE1hc2sgPSBtYXNrO1xuICAgICAgICB0aGlzLmdsLmRlcHRoTWFzayhtYXNrKTtcbiAgICB9XG59O1xuXG5QYWludGVyLnByb3RvdHlwZS5yZW5kZXJMYXllciA9IGZ1bmN0aW9uKHBhaW50ZXIsIHNvdXJjZSwgbGF5ZXIsIGNvb3Jkcykge1xuICAgIGlmIChsYXllci5pc0hpZGRlbih0aGlzLnRyYW5zZm9ybS56b29tKSkgcmV0dXJuO1xuICAgIGlmIChsYXllci50eXBlICE9PSAnYmFja2dyb3VuZCcgJiYgIWNvb3Jkcy5sZW5ndGgpIHJldHVybjtcbiAgICB0aGlzLmlkID0gbGF5ZXIuaWQ7XG4gICAgZHJhd1tsYXllci50eXBlXShwYWludGVyLCBzb3VyY2UsIGxheWVyLCBjb29yZHMpO1xufTtcblxuUGFpbnRlci5wcm90b3R5cGUuc2V0RGVwdGhTdWJsYXllciA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgZmFyRGVwdGggPSAxIC0gKCgxICsgdGhpcy5jdXJyZW50TGF5ZXIpICogdGhpcy5udW1TdWJsYXllcnMgKyBuKSAqIHRoaXMuZGVwdGhFcHNpbG9uO1xuICAgIHZhciBuZWFyRGVwdGggPSBmYXJEZXB0aCAtIDEgKyB0aGlzLmRlcHRoUmFuZ2U7XG4gICAgdGhpcy5nbC5kZXB0aFJhbmdlKG5lYXJEZXB0aCwgZmFyRGVwdGgpO1xufTtcblxuUGFpbnRlci5wcm90b3R5cGUudHJhbnNsYXRlUG9zTWF0cml4ID0gZnVuY3Rpb24obWF0cml4LCB0aWxlLCB0cmFuc2xhdGUsIGFuY2hvcikge1xuICAgIGlmICghdHJhbnNsYXRlWzBdICYmICF0cmFuc2xhdGVbMV0pIHJldHVybiBtYXRyaXg7XG5cbiAgICBpZiAoYW5jaG9yID09PSAndmlld3BvcnQnKSB7XG4gICAgICAgIHZhciBzaW5BID0gTWF0aC5zaW4oLXRoaXMudHJhbnNmb3JtLmFuZ2xlKTtcbiAgICAgICAgdmFyIGNvc0EgPSBNYXRoLmNvcygtdGhpcy50cmFuc2Zvcm0uYW5nbGUpO1xuICAgICAgICB0cmFuc2xhdGUgPSBbXG4gICAgICAgICAgICB0cmFuc2xhdGVbMF0gKiBjb3NBIC0gdHJhbnNsYXRlWzFdICogc2luQSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVswXSAqIHNpbkEgKyB0cmFuc2xhdGVbMV0gKiBjb3NBXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zbGF0aW9uID0gW1xuICAgICAgICBwaXhlbHNUb1RpbGVVbml0cyh0aWxlLCB0cmFuc2xhdGVbMF0sIHRoaXMudHJhbnNmb3JtLnpvb20pLFxuICAgICAgICBwaXhlbHNUb1RpbGVVbml0cyh0aWxlLCB0cmFuc2xhdGVbMV0sIHRoaXMudHJhbnNmb3JtLnpvb20pLFxuICAgICAgICAwXG4gICAgXTtcblxuICAgIHZhciB0cmFuc2xhdGVkTWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgbWF0NC50cmFuc2xhdGUodHJhbnNsYXRlZE1hdHJpeCwgbWF0cml4LCB0cmFuc2xhdGlvbik7XG4gICAgcmV0dXJuIHRyYW5zbGF0ZWRNYXRyaXg7XG59O1xuXG5QYWludGVyLnByb3RvdHlwZS5zYXZlVGV4dHVyZSA9IGZ1bmN0aW9uKHRleHR1cmUpIHtcbiAgICB2YXIgd2lkdGggPSB0ZXh0dXJlLndpZHRoID8gdGV4dHVyZS53aWR0aCA6IHRleHR1cmUuc2l6ZSxcbiAgICAgICAgaGVpZ2h0ID0gdGV4dHVyZS5oZWlnaHQgPyB0ZXh0dXJlLmhlaWdodCA6IHRleHR1cmUuc2l6ZTtcbiAgICB2YXIgd2lkdGhUZXh0dXJlcyA9IHRoaXMucmV1c2FibGVUZXh0dXJlc1t3aWR0aF07XG4gICAgaWYgKCF3aWR0aFRleHR1cmVzKSB7XG4gICAgICAgIHRoaXMucmV1c2FibGVUZXh0dXJlc1t3aWR0aF0gPSB7fTtcbiAgICAgICAgdGhpcy5yZXVzYWJsZVRleHR1cmVzW3dpZHRoXVtoZWlnaHRdID0gW3RleHR1cmVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0ZXh0dXJlcyA9IHdpZHRoVGV4dHVyZXNbaGVpZ2h0XTtcbiAgICAgICAgaWYgKCF0ZXh0dXJlcykge1xuICAgICAgICAgICAgd2lkdGhUZXh0dXJlc1toZWlnaHRdID0gW3RleHR1cmVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dHVyZXMucHVzaCh0ZXh0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblBhaW50ZXIucHJvdG90eXBlLmdldFRleHR1cmUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIHdpZHRoVGV4dHVyZXMgPSB0aGlzLnJldXNhYmxlVGV4dHVyZXNbd2lkdGhdO1xuICAgIGlmICh3aWR0aFRleHR1cmVzKSB7XG4gICAgICAgIHZhciB0ZXh0dXJlcyA9IHdpZHRoVGV4dHVyZXNbaGVpZ2h0IHx8IHdpZHRoXTtcbiAgICAgICAgcmV0dXJuIHRleHR1cmVzICYmIHRleHR1cmVzLmxlbmd0aCA+IDAgPyB0ZXh0dXJlcy5wb3AoKSA6IG51bGw7XG4gICAgfVxufTtcblxuUGFpbnRlci5wcm90b3R5cGUubGluZVdpZHRoID0gZnVuY3Rpb24od2lkdGgpIHtcbiAgICB0aGlzLmdsLmxpbmVXaWR0aCh1dGlsLmNsYW1wKHdpZHRoLCB0aGlzLmxpbmVXaWR0aFJhbmdlWzBdLCB0aGlzLmxpbmVXaWR0aFJhbmdlWzFdKSk7XG59O1xuXG5QYWludGVyLnByb3RvdHlwZS5zaG93T3ZlcmRyYXdJbnNwZWN0b3IgPSBmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgaWYgKCFlbmFibGVkICYmICF0aGlzLl9zaG93T3ZlcmRyYXdJbnNwZWN0b3IpIHJldHVybjtcbiAgICB0aGlzLl9zaG93T3ZlcmRyYXdJbnNwZWN0b3IgPSBlbmFibGVkO1xuXG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuQ09OU1RBTlRfQ09MT1IsIGdsLk9ORSk7XG4gICAgICAgIHZhciBudW1PdmVyZHJhd1N0ZXBzID0gODtcbiAgICAgICAgdmFyIGEgPSAxIC8gbnVtT3ZlcmRyYXdTdGVwcztcbiAgICAgICAgZ2wuYmxlbmRDb2xvcihhLCBhLCBhLCAwKTtcbiAgICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAxKTtcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcbnZhciBzaGFkZXJzID0gcmVxdWlyZSgnbWFwYm94LWdsLXNoYWRlcnMnKTtcblxudmFyIHV0aWxTb3VyY2UgPSBzaGFkZXJzLnV0aWw7XG5cbm1vZHVsZS5leHBvcnRzLl9jcmVhdGVQcm9ncmFtID0gZnVuY3Rpb24obmFtZSwgZGVmaW5lcywgdmVydGV4UHJhZ21hcywgZnJhZ21lbnRQcmFnbWFzKSB7XG4gICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICB2YXIgZGVmaW5pdGlvbiA9IHNoYWRlcnNbbmFtZV07XG5cbiAgICB2YXIgZGVmaW5lc1NvdXJjZSA9ICcjZGVmaW5lIE1BUEJPWF9HTF9KUztcXG4nO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGVmaW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgICBkZWZpbmVzU291cmNlICs9ICcjZGVmaW5lICcgKyBkZWZpbmVzW2pdICsgJztcXG4nO1xuICAgIH1cblxuICAgIHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgIGdsLnNoYWRlclNvdXJjZShmcmFnbWVudFNoYWRlciwgYXBwbHlQcmFnbWFzKGRlZmluZXNTb3VyY2UgKyBkZWZpbml0aW9uLmZyYWdtZW50U291cmNlLCBmcmFnbWVudFByYWdtYXMpKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICBhc3NlcnQoZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKGZyYWdtZW50U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUyksIGdsLmdldFNoYWRlckluZm9Mb2coZnJhZ21lbnRTaGFkZXIpKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuXG4gICAgdmFyIHZlcnRleFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSKTtcbiAgICBnbC5zaGFkZXJTb3VyY2UodmVydGV4U2hhZGVyLCBhcHBseVByYWdtYXMoZGVmaW5lc1NvdXJjZSArIHV0aWxTb3VyY2UgKyBkZWZpbml0aW9uLnZlcnRleFNvdXJjZSwgdmVydGV4UHJhZ21hcykpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIodmVydGV4U2hhZGVyKTtcbiAgICBhc3NlcnQoZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHZlcnRleFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpLCBnbC5nZXRTaGFkZXJJbmZvTG9nKHZlcnRleFNoYWRlcikpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuXG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgYXNzZXJ0KGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpLCBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG5cbiAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgIHZhciBudW1BdHRyaWJ1dGVzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfQVRUUklCVVRFUyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1BdHRyaWJ1dGVzOyBpKyspIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGdsLmdldEFjdGl2ZUF0dHJpYihwcm9ncmFtLCBpKTtcbiAgICAgICAgYXR0cmlidXRlc1thdHRyaWJ1dGUubmFtZV0gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyaWJ1dGUubmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHVuaWZvcm1zID0ge307XG4gICAgdmFyIG51bVVuaWZvcm1zID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMpO1xuICAgIGZvciAodmFyIHVpID0gMDsgdWkgPCBudW1Vbmlmb3JtczsgdWkrKykge1xuICAgICAgICB2YXIgdW5pZm9ybSA9IGdsLmdldEFjdGl2ZVVuaWZvcm0ocHJvZ3JhbSwgdWkpO1xuICAgICAgICB1bmlmb3Jtc1t1bmlmb3JtLm5hbWVdID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHVuaWZvcm0ubmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgcHJvZ3JhbTogcHJvZ3JhbSxcbiAgICAgICAgZGVmaW5pdGlvbjogZGVmaW5pdGlvbixcbiAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgICAgbnVtQXR0cmlidXRlczogbnVtQXR0cmlidXRlc1xuICAgIH0sIGF0dHJpYnV0ZXMsIHVuaWZvcm1zKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLl9jcmVhdGVQcm9ncmFtQ2FjaGVkID0gZnVuY3Rpb24obmFtZSwgZGVmaW5lcywgdmVydGV4UHJhZ21hcywgZnJhZ21lbnRQcmFnbWFzKSB7XG4gICAgdGhpcy5jYWNoZSA9IHRoaXMuY2FjaGUgfHwge307XG5cbiAgICB2YXIga2V5ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBkZWZpbmVzOiBkZWZpbmVzLFxuICAgICAgICB2ZXJ0ZXhQcmFnbWFzOiB2ZXJ0ZXhQcmFnbWFzLFxuICAgICAgICBmcmFnbWVudFByYWdtYXM6IGZyYWdtZW50UHJhZ21hc1xuICAgIH0pO1xuXG4gICAgaWYgKCF0aGlzLmNhY2hlW2tleV0pIHtcbiAgICAgICAgdGhpcy5jYWNoZVtrZXldID0gdGhpcy5fY3JlYXRlUHJvZ3JhbShuYW1lLCBkZWZpbmVzLCB2ZXJ0ZXhQcmFnbWFzLCBmcmFnbWVudFByYWdtYXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWNoZVtrZXldO1xufTtcblxubW9kdWxlLmV4cG9ydHMudXNlUHJvZ3JhbSA9IGZ1bmN0aW9uIChuZXh0UHJvZ3JhbU5hbWUsIGRlZmluZXMsIHZlcnRleFByYWdtYXMsIGZyYWdtZW50UHJhZ21hcykge1xuICAgIHZhciBnbCA9IHRoaXMuZ2w7XG5cbiAgICBkZWZpbmVzID0gZGVmaW5lcyB8fCBbXTtcbiAgICBpZiAodGhpcy5fc2hvd092ZXJkcmF3SW5zcGVjdG9yKSB7XG4gICAgICAgIGRlZmluZXMgPSBkZWZpbmVzLmNvbmNhdCgnT1ZFUkRSQVdfSU5TUEVDVE9SJyk7XG4gICAgfVxuXG4gICAgdmFyIG5leHRQcm9ncmFtID0gdGhpcy5fY3JlYXRlUHJvZ3JhbUNhY2hlZChuZXh0UHJvZ3JhbU5hbWUsIGRlZmluZXMsIHZlcnRleFByYWdtYXMsIGZyYWdtZW50UHJhZ21hcyk7XG4gICAgdmFyIHByZXZpb3VzUHJvZ3JhbSA9IHRoaXMuY3VycmVudFByb2dyYW07XG5cbiAgICBpZiAocHJldmlvdXNQcm9ncmFtICE9PSBuZXh0UHJvZ3JhbSkge1xuICAgICAgICBnbC51c2VQcm9ncmFtKG5leHRQcm9ncmFtLnByb2dyYW0pO1xuICAgICAgICB0aGlzLmN1cnJlbnRQcm9ncmFtID0gbmV4dFByb2dyYW07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRQcm9ncmFtO1xufTtcblxuZnVuY3Rpb24gYXBwbHlQcmFnbWFzKHNvdXJjZSwgcHJhZ21hcykge1xuICAgIHJldHVybiBzb3VyY2UucmVwbGFjZSgvI3ByYWdtYSBtYXBib3g6IChbXFx3XSspIChbXFx3XSspIChbXFx3XSspIChbXFx3XSspL2csIGZ1bmN0aW9uKG1hdGNoLCBvcGVyYXRpb24sIHByZWNpc2lvbiwgdHlwZSwgbmFtZSkge1xuICAgICAgICByZXR1cm4gcHJhZ21hc1tvcGVyYXRpb25dW25hbWVdLnJlcGxhY2UoL3t0eXBlfS9nLCB0eXBlKS5yZXBsYWNlKC97cHJlY2lzaW9ufS9nLCBwcmVjaXNpb24pO1xuICAgIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmVydGV4QXJyYXlPYmplY3Q7XG5cbmZ1bmN0aW9uIFZlcnRleEFycmF5T2JqZWN0KCkge1xuICAgIHRoaXMuYm91bmRQcm9ncmFtID0gbnVsbDtcbiAgICB0aGlzLmJvdW5kVmVydGV4QnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmJvdW5kVmVydGV4QnVmZmVyMiA9IG51bGw7XG4gICAgdGhpcy5ib3VuZEVsZW1lbnRCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMudmFvID0gbnVsbDtcbn1cblxuVmVydGV4QXJyYXlPYmplY3QucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihnbCwgcHJvZ3JhbSwgbGF5b3V0VmVydGV4QnVmZmVyLCBlbGVtZW50QnVmZmVyLCB2ZXJ0ZXhCdWZmZXIyKSB7XG5cbiAgICBpZiAoZ2wuZXh0VmVydGV4QXJyYXlPYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBnbC5leHRWZXJ0ZXhBcnJheU9iamVjdCA9IGdsLmdldEV4dGVuc2lvbihcIk9FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0XCIpO1xuICAgIH1cblxuICAgIHZhciBpc0ZyZXNoQmluZFJlcXVpcmVkID0gKFxuICAgICAgICAhdGhpcy52YW8gfHxcbiAgICAgICAgdGhpcy5ib3VuZFByb2dyYW0gIT09IHByb2dyYW0gfHxcbiAgICAgICAgdGhpcy5ib3VuZFZlcnRleEJ1ZmZlciAhPT0gbGF5b3V0VmVydGV4QnVmZmVyIHx8XG4gICAgICAgIHRoaXMuYm91bmRWZXJ0ZXhCdWZmZXIyICE9PSB2ZXJ0ZXhCdWZmZXIyIHx8XG4gICAgICAgIHRoaXMuYm91bmRFbGVtZW50QnVmZmVyICE9PSBlbGVtZW50QnVmZmVyXG4gICAgKTtcblxuICAgIGlmICghZ2wuZXh0VmVydGV4QXJyYXlPYmplY3QgfHwgaXNGcmVzaEJpbmRSZXF1aXJlZCkge1xuICAgICAgICB0aGlzLmZyZXNoQmluZChnbCwgcHJvZ3JhbSwgbGF5b3V0VmVydGV4QnVmZmVyLCBlbGVtZW50QnVmZmVyLCB2ZXJ0ZXhCdWZmZXIyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbC5leHRWZXJ0ZXhBcnJheU9iamVjdC5iaW5kVmVydGV4QXJyYXlPRVModGhpcy52YW8pO1xuICAgIH1cbn07XG5cblZlcnRleEFycmF5T2JqZWN0LnByb3RvdHlwZS5mcmVzaEJpbmQgPSBmdW5jdGlvbihnbCwgcHJvZ3JhbSwgbGF5b3V0VmVydGV4QnVmZmVyLCBlbGVtZW50QnVmZmVyLCB2ZXJ0ZXhCdWZmZXIyKSB7XG4gICAgdmFyIG51bVByZXZBdHRyaWJ1dGVzO1xuICAgIHZhciBudW1OZXh0QXR0cmlidXRlcyA9IHByb2dyYW0ubnVtQXR0cmlidXRlcztcblxuICAgIGlmIChnbC5leHRWZXJ0ZXhBcnJheU9iamVjdCkge1xuICAgICAgICBpZiAodGhpcy52YW8pIHRoaXMuZGVzdHJveShnbCk7XG4gICAgICAgIHRoaXMudmFvID0gZ2wuZXh0VmVydGV4QXJyYXlPYmplY3QuY3JlYXRlVmVydGV4QXJyYXlPRVMoKTtcbiAgICAgICAgZ2wuZXh0VmVydGV4QXJyYXlPYmplY3QuYmluZFZlcnRleEFycmF5T0VTKHRoaXMudmFvKTtcbiAgICAgICAgbnVtUHJldkF0dHJpYnV0ZXMgPSAwO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBhcmd1bWVudHMgc28gdGhhdCB3ZSBjYW4gdmVyaWZ5IHRoZW0gd2hlbiB0aGUgdmFvIGlzIGJvdW5kIGFnYWluXG4gICAgICAgIHRoaXMuYm91bmRQcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgICAgdGhpcy5ib3VuZFZlcnRleEJ1ZmZlciA9IGxheW91dFZlcnRleEJ1ZmZlcjtcbiAgICAgICAgdGhpcy5ib3VuZFZlcnRleEJ1ZmZlcjIgPSB2ZXJ0ZXhCdWZmZXIyO1xuICAgICAgICB0aGlzLmJvdW5kRWxlbWVudEJ1ZmZlciA9IGVsZW1lbnRCdWZmZXI7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBudW1QcmV2QXR0cmlidXRlcyA9IGdsLmN1cnJlbnROdW1BdHRyaWJ1dGVzIHx8IDA7XG5cbiAgICAgICAgLy8gRGlzYWJsZSBhbGwgYXR0cmlidXRlcyBmcm9tIHRoZSBwcmV2aW91cyBwcm9ncmFtIHRoYXQgYXJlbid0IHVzZWQgaW5cbiAgICAgICAgLy8gdGhlIG5ldyBwcm9ncmFtLiBOb3RlOiBhdHRyaWJ1dGUgaW5kaWNlcyBhcmUgKm5vdCogcHJvZ3JhbSBzcGVjaWZpYyFcbiAgICAgICAgZm9yICh2YXIgaSA9IG51bU5leHRBdHRyaWJ1dGVzOyBpIDwgbnVtUHJldkF0dHJpYnV0ZXM7IGkrKykge1xuICAgICAgICAgICAgLy8gV2ViR0wgYnJlYWtzIGlmIHlvdSBkaXNhYmxlIGF0dHJpYnV0ZSAwLlxuICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDMwNTIzMVxuICAgICAgICAgICAgYXNzZXJ0KGkgIT09IDApO1xuICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW5hYmxlIGFsbCBhdHRyaWJ1dGVzIGZvciB0aGUgbmV3IHByb2dyYW0uXG4gICAgZm9yICh2YXIgaiA9IG51bVByZXZBdHRyaWJ1dGVzOyBqIDwgbnVtTmV4dEF0dHJpYnV0ZXM7IGorKykge1xuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShqKTtcbiAgICB9XG5cbiAgICBsYXlvdXRWZXJ0ZXhCdWZmZXIuYmluZChnbCk7XG4gICAgbGF5b3V0VmVydGV4QnVmZmVyLnNldFZlcnRleEF0dHJpYlBvaW50ZXJzKGdsLCBwcm9ncmFtKTtcbiAgICBpZiAodmVydGV4QnVmZmVyMikge1xuICAgICAgICB2ZXJ0ZXhCdWZmZXIyLmJpbmQoZ2wpO1xuICAgICAgICB2ZXJ0ZXhCdWZmZXIyLnNldFZlcnRleEF0dHJpYlBvaW50ZXJzKGdsLCBwcm9ncmFtKTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnRCdWZmZXIpIHtcbiAgICAgICAgZWxlbWVudEJ1ZmZlci5iaW5kKGdsKTtcbiAgICB9XG5cbiAgICBnbC5jdXJyZW50TnVtQXR0cmlidXRlcyA9IG51bU5leHRBdHRyaWJ1dGVzO1xufTtcblxuVmVydGV4QXJyYXlPYmplY3QucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uKGdsKSB7XG4gICAgdmFyIGV4dCA9IGdsLmV4dFZlcnRleEFycmF5T2JqZWN0O1xuICAgIGlmIChleHQpIHtcbiAgICAgICAgZXh0LmJpbmRWZXJ0ZXhBcnJheU9FUyhudWxsKTtcbiAgICB9XG59O1xuXG5WZXJ0ZXhBcnJheU9iamVjdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKGdsKSB7XG4gICAgdmFyIGV4dCA9IGdsLmV4dFZlcnRleEFycmF5T2JqZWN0O1xuICAgIGlmIChleHQgJiYgdGhpcy52YW8pIHtcbiAgICAgICAgZXh0LmRlbGV0ZVZlcnRleEFycmF5T0VTKHRoaXMudmFvKTtcbiAgICAgICAgdGhpcy52YW8gPSBudWxsO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIHVybFJlc29sdmUgPSByZXF1aXJlKCdyZXNvbHZlLXVybCcpO1xudmFyIEVYVEVOVCA9IHJlcXVpcmUoJy4uL2RhdGEvYnVja2V0JykuRVhURU5UO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlb0pTT05Tb3VyY2U7XG5cbi8qKlxuICogQSBzb3VyY2UgY29udGFpbmluZyBHZW9KU09OLlxuICpcbiAqIEBjbGFzcyBHZW9KU09OU291cmNlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtvcHRpb25zLmRhdGFdIEEgR2VvSlNPTiBkYXRhIG9iamVjdCBvciBhIFVSTCB0byBvbmUuIFRoZSBsYXR0ZXIgaXMgcHJlZmVyYWJsZSBpbiB0aGUgY2FzZSBvZiBsYXJnZSBHZW9KU09OIG9iamVjdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4em9vbT0xOF0gVGhlIG1heGltdW0gem9vbSBsZXZlbCBhdCB3aGljaCB0byBwcmVzZXJ2ZSBkZXRhaWwgKDEtMjApLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmJ1ZmZlcj0xMjhdIFRoZSB0aWxlIGJ1ZmZlciwgbWVhc3VyZWQgaW4gcGl4ZWxzLiBUaGUgYnVmZmVyIGV4dGVuZHMgZWFjaFxuICogICB0aWxlJ3MgZGF0YSBqdXN0IHBhc3QgaXRzIHZpc2libGUgZWRnZXMsIGhlbHBpbmcgdG8gZW5zdXJlIHNlYW1sZXNzIHJlbmRlcmluZyBhY3Jvc3MgdGlsZSBib3VuZGFyaWVzLlxuICogICBUaGUgZGVmYXVsdCB2YWx1ZSwgMTI4LCBpcyBhIHNhZmUgdmFsdWUgZm9yIGxhYmVsIGxheWVycywgcHJldmVudGluZyB0ZXh0IGNsaXBwaW5nIGF0IGJvdW5kYXJpZXMuXG4gKiAgIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGJ1ZmZlcnMgYW5kIGNsaXBwaW5nIGluIHRoZVxuICogICBbTWFwYm94IFZlY3RvciBUaWxlIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vdmVjdG9yLXRpbGVzL3NwZWNpZmljYXRpb24vI2NsaXBwaW5nKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50b2xlcmFuY2U9MC4zNzVdIFRoZSBzaW1wbGlmaWNhdGlvbiB0b2xlcmFuY2UsIG1lYXN1cmVkIGluIHBpeGVscy5cbiAqICAgVGhpcyB2YWx1ZSBpcyBwYXNzZWQgaW50byBhIG1vZGlmaWVkIFtSYW1lcuKAk0RvdWdsYXPigJNQZXVja2VyIGFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFtZXIlRTIlODAlOTNEb3VnbGFzJUUyJTgwJTkzUGV1Y2tlcl9hbGdvcml0aG0pXG4gKiAgIHRvIHNpbXBsaWZ5IChpLmUuIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHBvaW50cykgaW4gY3VydmVzLiBIaWdoZXIgdmFsdWVzIHJlc3VsdCBpbiBncmVhdGVyIHNpbXBsaWZpY2F0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jbHVzdGVyXSBJZiBgdHJ1ZWAsIGEgY29sbGVjdGlvbiBvZiBwb2ludCBmZWF0dXJlcyB3aWxsIGJlIGNsdXN0ZXJlZCBpbnRvIGdyb3VwcyxcbiAqICAgYWNjb3JkaW5nIHRvIGBvcHRpb25zLmNsdXN0ZXJSYWRpdXNgLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNsdXN0ZXJSYWRpdXM9NTBdIFRoZSByYWRpdXMgb2YgZWFjaCBjbHVzdGVyIHdoZW4gY2x1c3RlcmluZyBwb2ludHMsIG1lYXN1cmVkIGluIHBpeGVscy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jbHVzdGVyTWF4Wm9vbV0gVGhlIG1heGltdW0gem9vbSBsZXZlbCB0byBjbHVzdGVyIHBvaW50cyBpbi4gQnkgZGVmYXVsdCwgdGhpcyB2YWx1ZSBpc1xuICogICBvbmUgem9vbSBsZXZlbCBsZXNzIHRoYW4gdGhlIG1hcCdzIGBtYXh6b29tYCwgc28gdGhhdCBhdCB0aGUgaGlnaGVzdCB6b29tIGxldmVsIGZlYXR1cmVzIGFyZSBub3QgY2x1c3RlcmVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBtYXAuYWRkU291cmNlKCdzb21lIGlkJywge1xuICogICAgIGRhdGE6ICdodHRwczovL2QyYWQ2YjR1cjd5dnBxLmNsb3VkZnJvbnQubmV0L25hdHVyYWxlYXJ0aC0zLjMuMC9uZV8xMG1fcG9ydHMuZ2VvanNvbidcbiAqIH0pO1xuICpcbiAqIEBleGFtcGxlXG4gKiBtYXAuYWRkU291cmNlKCdzb21lIGlkJywge1xuICogICAgdHlwZTogJ2dlb2pzb24nLFxuICogICAgZGF0YToge1xuICogICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgICAgICAgXCJmZWF0dXJlc1wiOiBbe1xuICogICAgICAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogW1xuICogICAgICAgICAgICAgICAgICAgIC03Ni41MzA2MzI5NzI3MTcyOSxcbiAqICAgICAgICAgICAgICAgICAgICAzOS4xODE3NDA3Nzk5NDEwOFxuICogICAgICAgICAgICAgICAgXVxuICogICAgICAgICAgICB9XG4gKiAgICAgICAgfV1cbiAqICAgIH1cbiAqIH0pO1xuICpcbiAqIEBleGFtcGxlXG4gKiBtYXAuZ2V0U291cmNlKCdzb21lIGlkJykuc2V0RGF0YSh7XG4gKiAgICAgZGF0YToge1xuICogICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgICAgICAgXCJmZWF0dXJlc1wiOiBbe1xuICogICAgICAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICAgICAgIFwicHJvcGVydGllc1wiOiB7IFwibmFtZVwiOiBcIk51bGwgSXNsYW5kXCIgfSxcbiAqICAgICAgICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbIDAsIDAgXVxuICogICAgICAgICAgICB9XG4gKiAgICAgICAgfV1cbiAqICAgICB9XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gR2VvSlNPTlNvdXJjZShpZCwgb3B0aW9ucywgZGlzcGF0Y2hlcikge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xuXG4gICAgdGhpcy5fZGF0YSA9IG9wdGlvbnMuZGF0YTtcblxuICAgIGlmIChvcHRpb25zLm1heHpvb20gIT09IHVuZGVmaW5lZCkgdGhpcy5tYXh6b29tID0gb3B0aW9ucy5tYXh6b29tO1xuICAgIGlmIChvcHRpb25zLnR5cGUpIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcblxuICAgIHZhciBzY2FsZSA9IEVYVEVOVCAvIHRoaXMudGlsZVNpemU7XG5cbiAgICAvLyBzZW50IHRvIHRoZSB3b3JrZXIsIGFsb25nIHdpdGggYHVybDogLi4uYCBvciBgZGF0YTogbGl0ZXJhbCBnZW9qc29uYCxcbiAgICAvLyBzbyB0aGF0IGl0IGNhbiBsb2FkL3BhcnNlL2luZGV4IHRoZSBnZW9qc29uIGRhdGFcbiAgICAvLyBleHRlbmRpbmcgd2l0aCBgb3B0aW9ucy53b3JrZXJPcHRpb25zYCBoZWxwcyB0byBtYWtlIGl0IGVhc3kgZm9yXG4gICAgLy8gdGhpcmQtcGFydHkgc291cmNlcyB0byBoYWNrL3JldXNlIEdlb0pTT05Tb3VyY2UuXG4gICAgdGhpcy53b3JrZXJPcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgIGNsdXN0ZXI6IG9wdGlvbnMuY2x1c3RlciB8fCBmYWxzZSxcbiAgICAgICAgZ2VvanNvblZ0T3B0aW9uczoge1xuICAgICAgICAgICAgYnVmZmVyOiAob3B0aW9ucy5idWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYnVmZmVyIDogMTI4KSAqIHNjYWxlLFxuICAgICAgICAgICAgdG9sZXJhbmNlOiAob3B0aW9ucy50b2xlcmFuY2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudG9sZXJhbmNlIDogMC4zNzUpICogc2NhbGUsXG4gICAgICAgICAgICBleHRlbnQ6IEVYVEVOVCxcbiAgICAgICAgICAgIG1heFpvb206IHRoaXMubWF4em9vbVxuICAgICAgICB9LFxuICAgICAgICBzdXBlcmNsdXN0ZXJPcHRpb25zOiB7XG4gICAgICAgICAgICBtYXhab29tOiBNYXRoLm1pbihvcHRpb25zLmNsdXN0ZXJNYXhab29tLCB0aGlzLm1heHpvb20gLSAxKSB8fCAodGhpcy5tYXh6b29tIC0gMSksXG4gICAgICAgICAgICBleHRlbnQ6IEVYVEVOVCxcbiAgICAgICAgICAgIHJhZGl1czogKG9wdGlvbnMuY2x1c3RlclJhZGl1cyB8fCA1MCkgKiBzY2FsZSxcbiAgICAgICAgICAgIGxvZzogZmFsc2VcbiAgICAgICAgfVxuICAgIH0sIG9wdGlvbnMud29ya2VyT3B0aW9ucyk7XG5cbiAgICB0aGlzLl91cGRhdGVXb3JrZXJEYXRhKGZ1bmN0aW9uIGRvbmUoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnZXJyb3InLCB7ZXJyb3I6IGVycn0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlyZSgnbG9hZCcpO1xuICAgIH0uYmluZCh0aGlzKSk7XG59XG5cbkdlb0pTT05Tb3VyY2UucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KEV2ZW50ZWQsIC8qKiBAbGVuZHMgR2VvSlNPTlNvdXJjZS5wcm90b3R5cGUgKi8ge1xuICAgIC8vIGB0eXBlYCBpcyBhIHByb3BlcnR5IHJhdGhlciB0aGFuIGEgY29uc3RhbnQgdG8gbWFrZSBpdCBlYXN5IGZvciAzcmRcbiAgICAvLyBwYXJ0aWVzIHRvIHVzZSBHZW9KU09OU291cmNlIHRvIGJ1aWxkIHRoZWlyIG93biBzb3VyY2UgdHlwZXMuXG4gICAgdHlwZTogJ2dlb2pzb24nLFxuICAgIG1pbnpvb206IDAsXG4gICAgbWF4em9vbTogMTgsXG4gICAgdGlsZVNpemU6IDUxMixcbiAgICBpc1RpbGVDbGlwcGVkOiB0cnVlLFxuICAgIHJlcGFyc2VPdmVyc2NhbGVkOiB0cnVlLFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIEdlb0pTT04gZGF0YSBhbmQgcmUtcmVuZGVycyB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBkYXRhIEEgR2VvSlNPTiBkYXRhIG9iamVjdCBvciBhIFVSTCB0byBvbmUuIFRoZSBsYXR0ZXIgaXMgcHJlZmVyYWJsZSBpbiB0aGUgY2FzZSBvZiBsYXJnZSBHZW9KU09OIGZpbGVzLlxuICAgICAqIEByZXR1cm5zIHtHZW9KU09OU291cmNlfSB0aGlzXG4gICAgICovXG4gICAgc2V0RGF0YTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcblxuICAgICAgICB0aGlzLl91cGRhdGVXb3JrZXJEYXRhKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maXJlKCdlcnJvcicsIHsgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmlyZSgnY2hhbmdlJyk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogUmVzcG9uc2libGUgZm9yIGludm9raW5nIFdvcmtlclNvdXJjZSdzIGdlb2pzb24ubG9hZERhdGEgdGFyZ2V0LCB3aGljaFxuICAgICAqIGhhbmRsZXMgbG9hZGluZyB0aGUgZ2VvanNvbiBkYXRhIGFuZCBwcmVwYXJpbmcgdG8gc2VydmUgaXQgdXAgYXMgdGlsZXMsXG4gICAgICogdXNpbmcgZ2VvanNvbi12dCBvciBzdXBlcmNsdXN0ZXIgYXMgYXBwcm9wcmlhdGUuXG4gICAgICovXG4gICAgX3VwZGF0ZVdvcmtlckRhdGE6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMud29ya2VyT3B0aW9ucyk7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgb3B0aW9ucy51cmwgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnID8gdXJsUmVzb2x2ZSh3aW5kb3cubG9jYXRpb24uaHJlZiwgZGF0YSkgOiBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0YXJnZXQge3RoaXMudHlwZX0ubG9hZERhdGEgcmF0aGVyIHRoYW4gbGl0ZXJhbGx5IGdlb2pzb24ubG9hZERhdGEsXG4gICAgICAgIC8vIHNvIHRoYXQgb3RoZXIgZ2VvanNvbi1saWtlIHNvdXJjZSB0eXBlcyBjYW4gZWFzaWx5IHJldXNlIHRoaXNcbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb25cbiAgICAgICAgdGhpcy53b3JrZXJJRCA9IHRoaXMuZGlzcGF0Y2hlci5zZW5kKHRoaXMudHlwZSArICcubG9hZERhdGEnLCBvcHRpb25zLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIGxvYWRUaWxlOiBmdW5jdGlvbiAodGlsZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG92ZXJzY2FsaW5nID0gdGlsZS5jb29yZC56ID4gdGhpcy5tYXh6b29tID8gTWF0aC5wb3coMiwgdGlsZS5jb29yZC56IC0gdGhpcy5tYXh6b29tKSA6IDE7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB1aWQ6IHRpbGUudWlkLFxuICAgICAgICAgICAgY29vcmQ6IHRpbGUuY29vcmQsXG4gICAgICAgICAgICB6b29tOiB0aWxlLmNvb3JkLnosXG4gICAgICAgICAgICBtYXhab29tOiB0aGlzLm1heHpvb20sXG4gICAgICAgICAgICB0aWxlU2l6ZTogdGhpcy50aWxlU2l6ZSxcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgICAgICAgIG92ZXJzY2FsaW5nOiBvdmVyc2NhbGluZyxcbiAgICAgICAgICAgIGFuZ2xlOiB0aGlzLm1hcC50cmFuc2Zvcm0uYW5nbGUsXG4gICAgICAgICAgICBwaXRjaDogdGhpcy5tYXAudHJhbnNmb3JtLnBpdGNoLFxuICAgICAgICAgICAgc2hvd0NvbGxpc2lvbkJveGVzOiB0aGlzLm1hcC5zaG93Q29sbGlzaW9uQm94ZXNcbiAgICAgICAgfTtcblxuICAgICAgICB0aWxlLndvcmtlcklEID0gdGhpcy5kaXNwYXRjaGVyLnNlbmQoJ2xvYWQgdGlsZScsIHBhcmFtcywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG5cbiAgICAgICAgICAgIHRpbGUudW5sb2FkVmVjdG9yRGF0YSh0aGlzLm1hcC5wYWludGVyKTtcblxuICAgICAgICAgICAgaWYgKHRpbGUuYWJvcnRlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGlsZS5sb2FkVmVjdG9yRGF0YShkYXRhLCB0aGlzLm1hcC5zdHlsZSk7XG5cbiAgICAgICAgICAgIGlmICh0aWxlLnJlZG9XaGVuRG9uZSkge1xuICAgICAgICAgICAgICAgIHRpbGUucmVkb1doZW5Eb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGlsZS5yZWRvUGxhY2VtZW50KHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG5cbiAgICAgICAgfS5iaW5kKHRoaXMpLCB0aGlzLndvcmtlcklEKTtcbiAgICB9LFxuXG4gICAgYWJvcnRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIHRpbGUuYWJvcnRlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIHVubG9hZFRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGlsZS51bmxvYWRWZWN0b3JEYXRhKHRoaXMubWFwLnBhaW50ZXIpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIuc2VuZCgncmVtb3ZlIHRpbGUnLCB7IHVpZDogdGlsZS51aWQsIHNvdXJjZTogdGhpcy5pZCB9LCBmdW5jdGlvbigpIHt9LCB0aWxlLndvcmtlcklEKTtcbiAgICB9LFxuXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuX2RhdGFcbiAgICAgICAgfTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBhamF4ID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4Jyk7XG52YXIgcmV3aW5kID0gcmVxdWlyZSgnZ2VvanNvbi1yZXdpbmQnKTtcbnZhciBHZW9KU09OV3JhcHBlciA9IHJlcXVpcmUoJy4vZ2VvanNvbl93cmFwcGVyJyk7XG52YXIgdnRwYmYgPSByZXF1aXJlKCd2dC1wYmYnKTtcbnZhciBzdXBlcmNsdXN0ZXIgPSByZXF1aXJlKCdzdXBlcmNsdXN0ZXInKTtcbnZhciBnZW9qc29udnQgPSByZXF1aXJlKCdnZW9qc29uLXZ0Jyk7XG5cbnZhciBWZWN0b3JUaWxlV29ya2VyU291cmNlID0gcmVxdWlyZSgnLi92ZWN0b3JfdGlsZV93b3JrZXJfc291cmNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gR2VvSlNPTldvcmtlclNvdXJjZTtcblxuLyoqXG4gKiBUaGUge0BsaW5rIFdvcmtlclNvdXJjZX0gaW1wbGVtZW50YXRpb24gdGhhdCBzdXBwb3J0cyB7QGxpbmsgR2VvSlNPTlNvdXJjZX0uXG4gKiBUaGlzIGNsYXNzIGlzIGRlc2lnbmVkIHRvIGJlIGVhc2lseSByZXVzZWQgdG8gc3VwcG9ydCBjdXN0b20gc291cmNlIHR5cGVzXG4gKiBmb3IgZGF0YSBmb3JtYXRzIHRoYXQgY2FuIGJlIHBhcnNlZC9jb252ZXJ0ZWQgaW50byBhbiBpbi1tZW1vcnkgR2VvSlNPTlxuICogcmVwcmVzZW50YXRpb24uICBUbyBkbyBzbywgY3JlYXRlIGl0IHdpdGhcbiAqIGBuZXcgR2VvSlNPTldvcmtlclNvdXJjZShhY3Rvciwgc3R5bGVMYXllcnMsIGN1c3RvbUxvYWRHZW9KU09ORnVuY3Rpb24pYC4gIEZvciBhIGZ1bGwgZXhhbXBsZSwgc2VlIFttYXBib3gtZ2wtdG9wb2pzb25dKGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9wbWVudHNlZWQvbWFwYm94LWdsLXRvcG9qc29uKS5cbiAqXG4gKiBAY2xhc3MgR2VvSlNPTldvcmtlclNvdXJjZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtsb2FkR2VvSlNPTl0gT3B0aW9uYWwgbWV0aG9kIGZvciBjdXN0b20gbG9hZGluZy9wYXJzaW5nIG9mIEdlb0pTT04gYmFzZWQgb24gcGFyYW1ldGVycyBwYXNzZWQgZnJvbSB0aGUgbWFpbi10aHJlYWQgU291cmNlLiAgU2VlIHtAbGluayBHZW9KU09OV29ya2VyU291cmNlI2xvYWRHZW9KU09OfS5cbiAqL1xuZnVuY3Rpb24gR2VvSlNPTldvcmtlclNvdXJjZSAoYWN0b3IsIHN0eWxlTGF5ZXJzLCBsb2FkR2VvSlNPTikge1xuICAgIGlmIChsb2FkR2VvSlNPTikgeyB0aGlzLmxvYWRHZW9KU09OID0gbG9hZEdlb0pTT047IH1cbiAgICBWZWN0b3JUaWxlV29ya2VyU291cmNlLmNhbGwodGhpcywgYWN0b3IsIHN0eWxlTGF5ZXJzKTtcbn1cblxuR2VvSlNPTldvcmtlclNvdXJjZS5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoVmVjdG9yVGlsZVdvcmtlclNvdXJjZSwgLyoqIEBsZW5kcyBHZW9KU09OV29ya2VyU291cmNlLnByb3RvdHlwZSAqLyB7XG4gICAgLy8gb2JqZWN0IG1hcHBpbmcgc291cmNlIGlkcyB0byBnZW9qc29uLXZ0LWxpa2UgdGlsZSBpbmRleGVzXG4gICAgX2dlb0pTT05JbmRleGVzOiB7fSxcblxuICAgIC8qKlxuICAgICAqIFNlZSB7QGxpbmsgVmVjdG9yVGlsZVdvcmtlclNvdXJjZSNsb2FkVGlsZX0uXG4gICAgICovXG4gICAgbG9hZFZlY3RvckRhdGE6IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBwYXJhbXMuc291cmNlLFxuICAgICAgICAgICAgY29vcmQgPSBwYXJhbXMuY29vcmQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9nZW9KU09OSW5kZXhlc1tzb3VyY2VdKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbCk7IC8vIHdlIGNvdWxkbid0IGxvYWQgdGhlIGZpbGVcblxuICAgICAgICB2YXIgZ2VvSlNPTlRpbGUgPSB0aGlzLl9nZW9KU09OSW5kZXhlc1tzb3VyY2VdLmdldFRpbGUoTWF0aC5taW4oY29vcmQueiwgcGFyYW1zLm1heFpvb20pLCBjb29yZC54LCBjb29yZC55KTtcbiAgICAgICAgaWYgKGdlb0pTT05UaWxlKSB7XG4gICAgICAgICAgICB2YXIgZ2VvanNvbldyYXBwZXIgPSBuZXcgR2VvSlNPTldyYXBwZXIoZ2VvSlNPTlRpbGUuZmVhdHVyZXMpO1xuICAgICAgICAgICAgZ2VvanNvbldyYXBwZXIubmFtZSA9ICdfZ2VvanNvblRpbGVMYXllcic7XG4gICAgICAgICAgICB2YXIgcGJmID0gdnRwYmYoeyBsYXllcnM6IHsgJ19nZW9qc29uVGlsZUxheWVyJzogZ2VvanNvbldyYXBwZXIgfX0pO1xuICAgICAgICAgICAgaWYgKHBiZi5ieXRlT2Zmc2V0ICE9PSAwIHx8IHBiZi5ieXRlTGVuZ3RoICE9PSBwYmYuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBDb21wYXRpYmlsaXR5IHdpdGggbm9kZSBCdWZmZXIgKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvcGJmL2lzc3Vlcy8zNSlcbiAgICAgICAgICAgICAgICBwYmYgPSBuZXcgVWludDhBcnJheShwYmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeyB0aWxlOiBnZW9qc29uV3JhcHBlciwgcmF3VGlsZURhdGE6IHBiZi5idWZmZXIgfSk7XG4gICAgICAgICAgICAvLyB0aWxlLnBhcnNlKGdlb2pzb25XcmFwcGVyLCB0aGlzLmxheWVyRmFtaWxpZXMsIHRoaXMuYWN0b3IsIHJhd1RpbGVEYXRhLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbCk7IC8vIG5vdGhpbmcgaW4gdGhlIGdpdmVuIHRpbGVcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIChpZiBhcHByb3ByaWF0ZSksIHBhcnNlcywgYW5kIGluZGV4IGdlb2pzb24gZGF0YSBpbnRvIHRpbGVzLiBUaGlzXG4gICAgICogcHJlcGFyYXRvcnkgbWV0aG9kIG11c3QgYmUgY2FsbGVkIGJlZm9yZSB7QGxpbmsgR2VvSlNPTldvcmtlclNvdXJjZSNsb2FkVGlsZX1cbiAgICAgKiBjYW4gY29ycmVjdGx5IHNlcnZlIHVwIHRpbGVzLlxuICAgICAqXG4gICAgICogRGVmZXJzIHRvIHtAbGluayBHZW9KU09OV29ya2VyU291cmNlI2xvYWRHZW9KU09OfSBmb3IgdGhlIGZldGNoaW5nL3BhcnNpbmcsXG4gICAgICogZXhwZWN0aW5nIGBjYWxsYmFjayhlcnJvciwgZGF0YSlgIHRvIGJlIGNhbGxlZCB3aXRoIGVpdGhlciBhbiBlcnJvciBvciBhXG4gICAgICogcGFyc2VkIEdlb0pTT04gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnNvdXJjZSBUaGUgaWQgb2YgdGhlIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIGxvYWREYXRhOiBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaGFuZGxlRGF0YSA9IGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKFwiSW5wdXQgZGF0YSBpcyBub3QgYSB2YWxpZCBHZW9KU09OIG9iamVjdC5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV3aW5kKGRhdGEsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5faW5kZXhEYXRhKGRhdGEsIHBhcmFtcywgZnVuY3Rpb24gKGVyciwgaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycik7IH1cbiAgICAgICAgICAgICAgICB0aGlzLl9nZW9KU09OSW5kZXhlc1twYXJhbXMuc291cmNlXSA9IGluZGV4ZWQ7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5sb2FkR2VvSlNPTihwYXJhbXMsIGhhbmRsZURhdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGZXRjaCBhbmQgcGFyc2UgR2VvSlNPTiBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHBhcmFtcy4gIENhbGxzIGBjYWxsYmFja2BcbiAgICAgKiB3aXRoIGAoZXJyLCBkYXRhKWAsIHdoZXJlIGBkYXRhYCBpcyBhIHBhcnNlZCBHZW9KU09OIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEdlb0pTT04gaXMgbG9hZGVkIGFuZCBwYXJzZWQgZnJvbSBgcGFyYW1zLnVybGAgaWYgaXQgZXhpc3RzLCBvciBlbHNlXG4gICAgICogZXhwZWN0ZWQgYXMgYSBsaXRlcmFsIChzdHJpbmcgb3Igb2JqZWN0KSBgcGFyYW1zLmRhdGFgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLnVybF0gQSBVUkwgdG8gdGhlIHJlbW90ZSBHZW9KU09OIGRhdGEuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXMuZGF0YV0gTGl0ZXJhbCBHZW9KU09OIGRhdGEuIE11c3QgYmUgcHJvdmlkZWQgaWYgYHBhcmFtcy51cmxgIGlzIG5vdC5cbiAgICAgKi9cbiAgICBsb2FkR2VvSlNPTjogZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gQmVjYXVzZSBvZiBzYW1lIG9yaWdpbiBpc3N1ZXMsIHVybHMgbXVzdCBlaXRoZXIgaW5jbHVkZSBhbiBleHBsaWNpdFxuICAgICAgICAvLyBvcmlnaW4gb3IgYWJzb2x1dGUgcGF0aC5cbiAgICAgICAgLy8gaWU6IC9mb28vYmFyLmpzb24gb3IgaHR0cDovL2V4YW1wbGUuY29tL2Jhci5qc29uXG4gICAgICAgIC8vIGJ1dCBub3QgLi4vZm9vL2Jhci5qc29uXG4gICAgICAgIGlmIChwYXJhbXMudXJsKSB7XG4gICAgICAgICAgICBhamF4LmdldEpTT04ocGFyYW1zLnVybCwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIEpTT04ucGFyc2UocGFyYW1zLmRhdGEpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKFwiSW5wdXQgZGF0YSBpcyBub3QgYSB2YWxpZCBHZW9KU09OIG9iamVjdC5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcIklucHV0IGRhdGEgaXMgbm90IGEgdmFsaWQgR2VvSlNPTiBvYmplY3QuXCIpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbmRleCB0aGUgZGF0YSB1c2luZyBlaXRoZXIgZ2VvanNvbi12dCBvciBzdXBlcmNsdXN0ZXJcbiAgICAgKiBAcGFyYW0ge0dlb0pTT059IGRhdGFcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIGZvcndhcmRlZCBmcm9tIGxvYWRUaWxlLlxuICAgICAqIEBwYXJhbSB7Y2FsbGJhY2t9IChlcnIsIGluZGV4ZWREYXRhKVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luZGV4RGF0YTogZnVuY3Rpb24gKGRhdGEsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuY2x1c3Rlcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHN1cGVyY2x1c3RlcihwYXJhbXMuc3VwZXJjbHVzdGVyT3B0aW9ucykubG9hZChkYXRhLmZlYXR1cmVzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGdlb2pzb252dChkYXRhLCBwYXJhbXMuZ2VvanNvblZ0T3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG52YXIgVmVjdG9yVGlsZUZlYXR1cmUgPSByZXF1aXJlKCd2ZWN0b3ItdGlsZScpLlZlY3RvclRpbGVGZWF0dXJlO1xudmFyIEVYVEVOVCA9IHJlcXVpcmUoJy4uL2RhdGEvYnVja2V0JykuRVhURU5UO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlb0pTT05XcmFwcGVyO1xuXG4vLyBjb25mb3JtIHRvIHZlY3RvcnRpbGUgYXBpXG5mdW5jdGlvbiBHZW9KU09OV3JhcHBlcihmZWF0dXJlcykge1xuICAgIHRoaXMuZmVhdHVyZXMgPSBmZWF0dXJlcztcbiAgICB0aGlzLmxlbmd0aCA9IGZlYXR1cmVzLmxlbmd0aDtcbiAgICB0aGlzLmV4dGVudCA9IEVYVEVOVDtcbn1cblxuR2VvSlNPTldyYXBwZXIucHJvdG90eXBlLmZlYXR1cmUgPSBmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIG5ldyBGZWF0dXJlV3JhcHBlcih0aGlzLmZlYXR1cmVzW2ldKTtcbn07XG5cbmZ1bmN0aW9uIEZlYXR1cmVXcmFwcGVyKGZlYXR1cmUpIHtcbiAgICB0aGlzLnR5cGUgPSBmZWF0dXJlLnR5cGU7XG4gICAgaWYgKGZlYXR1cmUudHlwZSA9PT0gMSkge1xuICAgICAgICB0aGlzLnJhd0dlb21ldHJ5ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZS5nZW9tZXRyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5yYXdHZW9tZXRyeS5wdXNoKFtmZWF0dXJlLmdlb21ldHJ5W2ldXSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJhd0dlb21ldHJ5ID0gZmVhdHVyZS5nZW9tZXRyeTtcbiAgICB9XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gZmVhdHVyZS50YWdzO1xuICAgIHRoaXMuZXh0ZW50ID0gRVhURU5UO1xufVxuXG5GZWF0dXJlV3JhcHBlci5wcm90b3R5cGUubG9hZEdlb21ldHJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJpbmdzID0gdGhpcy5yYXdHZW9tZXRyeTtcbiAgICB0aGlzLmdlb21ldHJ5ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByaW5nID0gcmluZ3NbaV0sXG4gICAgICAgICAgICBuZXdSaW5nID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmluZy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbmV3UmluZy5wdXNoKG5ldyBQb2ludChyaW5nW2pdWzBdLCByaW5nW2pdWzFdKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZW9tZXRyeS5wdXNoKG5ld1JpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeTtcbn07XG5cbkZlYXR1cmVXcmFwcGVyLnByb3RvdHlwZS5iYm94ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmdlb21ldHJ5KSB0aGlzLmxvYWRHZW9tZXRyeSgpO1xuXG4gICAgdmFyIHJpbmdzID0gdGhpcy5nZW9tZXRyeSxcbiAgICAgICAgeDEgPSBJbmZpbml0eSxcbiAgICAgICAgeDIgPSAtSW5maW5pdHksXG4gICAgICAgIHkxID0gSW5maW5pdHksXG4gICAgICAgIHkyID0gLUluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmluZyA9IHJpbmdzW2ldO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmluZy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGNvb3JkID0gcmluZ1tqXTtcblxuICAgICAgICAgICAgeDEgPSBNYXRoLm1pbih4MSwgY29vcmQueCk7XG4gICAgICAgICAgICB4MiA9IE1hdGgubWF4KHgyLCBjb29yZC54KTtcbiAgICAgICAgICAgIHkxID0gTWF0aC5taW4oeTEsIGNvb3JkLnkpO1xuICAgICAgICAgICAgeTIgPSBNYXRoLm1heCh5MiwgY29vcmQueSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3gxLCB5MSwgeDIsIHkyXTtcbn07XG5cbkZlYXR1cmVXcmFwcGVyLnByb3RvdHlwZS50b0dlb0pTT04gPSBWZWN0b3JUaWxlRmVhdHVyZS5wcm90b3R5cGUudG9HZW9KU09OO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIFRpbGVDb29yZCA9IHJlcXVpcmUoJy4vdGlsZV9jb29yZCcpO1xudmFyIExuZ0xhdCA9IHJlcXVpcmUoJy4uL2dlby9sbmdfbGF0Jyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xudmFyIEV2ZW50ZWQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50ZWQnKTtcbnZhciBhamF4ID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4Jyk7XG52YXIgRVhURU5UID0gcmVxdWlyZSgnLi4vZGF0YS9idWNrZXQnKS5FWFRFTlQ7XG52YXIgUmFzdGVyQm91bmRzQXJyYXkgPSByZXF1aXJlKCcuLi9yZW5kZXIvZHJhd19yYXN0ZXInKS5SYXN0ZXJCb3VuZHNBcnJheTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCcuLi9kYXRhL2J1ZmZlcicpO1xudmFyIFZlcnRleEFycmF5T2JqZWN0ID0gcmVxdWlyZSgnLi4vcmVuZGVyL3ZlcnRleF9hcnJheV9vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZVNvdXJjZTtcblxuLyoqXG4gKiBBIGRhdGEgc291cmNlIGNvbnRhaW5pbmcgYW4gaW1hZ2UuXG4gKiAoU2VlIHRoZSBbU3R5bGUgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtc3R5bGUtc3BlYy8jc291cmNlcy1pbWFnZSkgZm9yIGRldGFpbGVkIGRvY3VtZW50YXRpb24gb2Ygb3B0aW9ucy4pXG4gKlxuICogQGludGVyZmFjZSBJbWFnZVNvdXJjZVxuICogQGV4YW1wbGVcbiAqIC8vIGFkZCB0byBtYXBcbiAqIG1hcC5hZGRTb3VyY2UoJ3NvbWUgaWQnLCB7XG4gKiAgICB0eXBlOiAnaW1hZ2UnLFxuICogICAgdXJsOiAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS9pbWFnZXMvZm9vLnBuZycsXG4gKiAgICBjb29yZGluYXRlczogW1xuICogICAgICAgIFstNzYuNTQsIDM5LjE4XSxcbiAqICAgICAgICBbLTc2LjUyLCAzOS4xOF0sXG4gKiAgICAgICAgWy03Ni41MiwgMzkuMTddLFxuICogICAgICAgIFstNzYuNTQsIDM5LjE3XVxuICogICAgXVxuICogfSk7XG4gKlxuICogLy8gdXBkYXRlXG4gKiB2YXIgbXlTb3VyY2UgPSBtYXAuZ2V0U291cmNlKCdzb21lIGlkJyk7XG4gKiBteVNvdXJjZS5zZXRDb29yZGluYXRlcyhbXG4gKiAgICAgWy03Ni41NDMzNTczNzIyODM5NCwgMzkuMTg1Nzk5MDcyMjk3NDhdLFxuICogICAgIFstNzYuNTI4MDM2NTk0MzkwODcsIDM5LjE4MzgzNjQ4NDc1ODddLFxuICogICAgIFstNzYuNTI5NTM4NjMxNDM5MiwgMzkuMTc2ODMzOTI1MDc2MDZdLFxuICogICAgIFstNzYuNTQ1MjAyNzMyMDg2MTgsIDM5LjE3ODc2MzQ0MTA2NjQyXVxuICogXSk7XG4gKlxuICogbWFwLnJlbW92ZVNvdXJjZSgnc29tZSBpZCcpOyAgLy8gcmVtb3ZlXG4gKi9cbmZ1bmN0aW9uIEltYWdlU291cmNlKGlkLCBvcHRpb25zLCBkaXNwYXRjaGVyKSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXI7XG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybDtcbiAgICB0aGlzLmNvb3JkaW5hdGVzID0gb3B0aW9ucy5jb29yZGluYXRlcztcblxuICAgIGFqYXguZ2V0SW1hZ2Uob3B0aW9ucy51cmwsIGZ1bmN0aW9uKGVyciwgaW1hZ2UpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHRoaXMuZmlyZSgnZXJyb3InLCB7ZXJyb3I6IGVycn0pO1xuXG4gICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcblxuICAgICAgICB0aGlzLmltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMubWFwLl9yZXJlbmRlcigpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMuX2xvYWRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZmlyZSgnbG9hZCcpO1xuXG4gICAgICAgIGlmICh0aGlzLm1hcCkge1xuICAgICAgICAgICAgdGhpcy5zZXRDb29yZGluYXRlcyhvcHRpb25zLmNvb3JkaW5hdGVzKTtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG59XG5cbkltYWdlU291cmNlLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChFdmVudGVkLCAvKiogQGxlbmRzIEltYWdlU291cmNlLnByb3RvdHlwZSAqLyB7XG4gICAgbWluem9vbTogMCxcbiAgICBtYXh6b29tOiAyMixcbiAgICB0aWxlU2l6ZTogNTEyLFxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgICAgIGlmICh0aGlzLmltYWdlKSB7XG4gICAgICAgICAgICB0aGlzLnNldENvb3JkaW5hdGVzKHRoaXMuY29vcmRpbmF0ZXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGltYWdlJ3MgY29vcmRpbmF0ZXMgYW5kIHJlLXJlbmRlcnMgdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNvb3JkaW5hdGVzIEZvdXIgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLFxuICAgICAqICAgcmVwcmVzZW50ZWQgYXMgYXJyYXlzIG9mIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgbnVtYmVycywgd2hpY2ggZGVmaW5lIHRoZSBjb3JuZXJzIG9mIHRoZSBpbWFnZS5cbiAgICAgKiAgIFRoZSBjb29yZGluYXRlcyBzdGFydCBhdCB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBpbWFnZSBhbmQgcHJvY2VlZCBpbiBjbG9ja3dpc2Ugb3JkZXIuXG4gICAgICogICBUaGV5IGRvIG5vdCBoYXZlIHRvIHJlcHJlc2VudCBhIHJlY3RhbmdsZS5cbiAgICAgKiBAcmV0dXJucyB7SW1hZ2VTb3VyY2V9IHRoaXNcbiAgICAgKi9cbiAgICBzZXRDb29yZGluYXRlczogZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgdGhpcy5jb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB3aGljaCBtZXJjYXRvciB0aWxlIGlzIHN1aXRhYmxlIGZvciByZW5kZXJpbmcgdGhlIHZpZGVvIGluXG4gICAgICAgIC8vIGFuZCBjcmVhdGUgYSBidWZmZXIgd2l0aCB0aGUgY29ybmVyIGNvb3JkaW5hdGVzLiBUaGVzZSBjb29yZGluYXRlc1xuICAgICAgICAvLyBtYXkgYmUgb3V0c2lkZSB0aGUgdGlsZSwgYmVjYXVzZSByYXN0ZXIgdGlsZXMgYXJlbid0IGNsaXBwZWQgd2hlbiByZW5kZXJpbmcuXG5cbiAgICAgICAgdmFyIG1hcCA9IHRoaXMubWFwO1xuICAgICAgICB2YXIgY29ybmVyWjBDb29yZHMgPSBjb29yZGluYXRlcy5tYXAoZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXAudHJhbnNmb3JtLmxvY2F0aW9uQ29vcmRpbmF0ZShMbmdMYXQuY29udmVydChjb29yZCkpLnpvb21UbygwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGNlbnRlckNvb3JkID0gdGhpcy5jZW50ZXJDb29yZCA9IHV0aWwuZ2V0Q29vcmRpbmF0ZXNDZW50ZXIoY29ybmVyWjBDb29yZHMpO1xuICAgICAgICBjZW50ZXJDb29yZC5jb2x1bW4gPSBNYXRoLnJvdW5kKGNlbnRlckNvb3JkLmNvbHVtbik7XG4gICAgICAgIGNlbnRlckNvb3JkLnJvdyA9IE1hdGgucm91bmQoY2VudGVyQ29vcmQucm93KTtcblxuICAgICAgICB0aGlzLm1pbnpvb20gPSB0aGlzLm1heHpvb20gPSBjZW50ZXJDb29yZC56b29tO1xuICAgICAgICB0aGlzLl9jb29yZCA9IG5ldyBUaWxlQ29vcmQoY2VudGVyQ29vcmQuem9vbSwgY2VudGVyQ29vcmQuY29sdW1uLCBjZW50ZXJDb29yZC5yb3cpO1xuICAgICAgICB0aGlzLl90aWxlQ29vcmRzID0gY29ybmVyWjBDb29yZHMubWFwKGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgICAgICB2YXIgem9vbWVkQ29vcmQgPSBjb29yZC56b29tVG8oY2VudGVyQ29vcmQuem9vbSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoKHpvb21lZENvb3JkLmNvbHVtbiAtIGNlbnRlckNvb3JkLmNvbHVtbikgKiBFWFRFTlQpLFxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoKHpvb21lZENvb3JkLnJvdyAtIGNlbnRlckNvb3JkLnJvdykgKiBFWFRFTlQpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9zZXRUaWxlOiBmdW5jdGlvbiAodGlsZSkge1xuICAgICAgICB0aGlzLl9wcmVwYXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRpbGUgPSB0aWxlO1xuICAgICAgICB2YXIgbWF4SW50MTYgPSAzMjc2NztcbiAgICAgICAgdmFyIGFycmF5ID0gbmV3IFJhc3RlckJvdW5kc0FycmF5KCk7XG4gICAgICAgIGFycmF5LmVtcGxhY2VCYWNrKHRoaXMuX3RpbGVDb29yZHNbMF0ueCwgdGhpcy5fdGlsZUNvb3Jkc1swXS55LCAwLCAwKTtcbiAgICAgICAgYXJyYXkuZW1wbGFjZUJhY2sodGhpcy5fdGlsZUNvb3Jkc1sxXS54LCB0aGlzLl90aWxlQ29vcmRzWzFdLnksIG1heEludDE2LCAwKTtcbiAgICAgICAgYXJyYXkuZW1wbGFjZUJhY2sodGhpcy5fdGlsZUNvb3Jkc1szXS54LCB0aGlzLl90aWxlQ29vcmRzWzNdLnksIDAsIG1heEludDE2KTtcbiAgICAgICAgYXJyYXkuZW1wbGFjZUJhY2sodGhpcy5fdGlsZUNvb3Jkc1syXS54LCB0aGlzLl90aWxlQ29vcmRzWzJdLnksIG1heEludDE2LCBtYXhJbnQxNik7XG5cbiAgICAgICAgdGhpcy50aWxlLmJ1Y2tldHMgPSB7fTtcblxuICAgICAgICB0aGlzLnRpbGUuYm91bmRzQnVmZmVyID0gbmV3IEJ1ZmZlcihhcnJheS5zZXJpYWxpemUoKSwgUmFzdGVyQm91bmRzQXJyYXkuc2VyaWFsaXplKCksIEJ1ZmZlci5CdWZmZXJUeXBlLlZFUlRFWCk7XG4gICAgICAgIHRoaXMudGlsZS5ib3VuZHNWQU8gPSBuZXcgVmVydGV4QXJyYXlPYmplY3QoKTtcbiAgICAgICAgdGhpcy50aWxlLnN0YXRlID0gJ2xvYWRlZCc7XG4gICAgfSxcblxuICAgIHByZXBhcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvYWRlZCB8fCAhdGhpcy5pbWFnZSB8fCAhdGhpcy5pbWFnZS5jb21wbGV0ZSkgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMudGlsZSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBwYWludGVyID0gdGhpcy5tYXAucGFpbnRlcjtcbiAgICAgICAgdmFyIGdsID0gcGFpbnRlci5nbDtcblxuICAgICAgICBpZiAoIXRoaXMuX3ByZXBhcmVkKSB7XG4gICAgICAgICAgICB0aGlzLnRpbGUudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGlsZS50ZXh0dXJlKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLmltYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGlsZS50ZXh0dXJlKTtcbiAgICAgICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5pbWFnZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbG9hZFRpbGU6IGZ1bmN0aW9uKHRpbGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgYSBzaW5nbGUgdGlsZSAtLSB3aG9vc2UgY29vcmRpbmF0ZXMgYXJlIHRoaXMuX2Nvb3JkIC0tIHRoYXRcbiAgICAgICAgLy8gY292ZXJzIHRoZSBpbWFnZSB3ZSB3YW50IHRvIHJlbmRlci4gIElmIHRoYXQncyB0aGUgb25lIGJlaW5nXG4gICAgICAgIC8vIHJlcXVlc3RlZCwgc2V0IGl0IHVwIHdpdGggdGhlIGltYWdlOyBvdGhlcndpc2UsIG1hcmsgdGhlIHRpbGUgYXNcbiAgICAgICAgLy8gYGVycm9yZWRgIHRvIGluZGljYXRlIHRoYXQgd2UgaGF2ZSBubyBkYXRhIGZvciBpdC5cbiAgICAgICAgaWYgKHRoaXMuX2Nvb3JkICYmIHRoaXMuX2Nvb3JkLnRvU3RyaW5nKCkgPT09IHRpbGUuY29vcmQudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0VGlsZSh0aWxlKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGlsZS5zdGF0ZSA9ICdlcnJvcmVkJztcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICAgICAgdXJsczogdGhpcy51cmwsXG4gICAgICAgICAgICBjb29yZGluYXRlczogdGhpcy5jb29yZGluYXRlc1xuICAgICAgICB9O1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBhamF4ID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4Jyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xudmFyIG5vcm1hbGl6ZVVSTCA9IHJlcXVpcmUoJy4uL3V0aWwvbWFwYm94Jykubm9ybWFsaXplU291cmNlVVJMO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGxvYWRlZCA9IGZ1bmN0aW9uKGVyciwgdGlsZUpTT04pIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gdXRpbC5waWNrKHRpbGVKU09OLCBbJ3RpbGVzJywgJ21pbnpvb20nLCAnbWF4em9vbScsICdhdHRyaWJ1dGlvbiddKTtcblxuICAgICAgICBpZiAodGlsZUpTT04udmVjdG9yX2xheWVycykge1xuICAgICAgICAgICAgcmVzdWx0LnZlY3RvckxheWVycyA9IHRpbGVKU09OLnZlY3Rvcl9sYXllcnM7XG4gICAgICAgICAgICByZXN1bHQudmVjdG9yTGF5ZXJJZHMgPSByZXN1bHQudmVjdG9yTGF5ZXJzLm1hcChmdW5jdGlvbihsYXllcikgeyByZXR1cm4gbGF5ZXIuaWQ7IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMudXJsKSB7XG4gICAgICAgIGFqYXguZ2V0SlNPTihub3JtYWxpemVVUkwob3B0aW9ucy51cmwpLCBsb2FkZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJyb3dzZXIuZnJhbWUobG9hZGVkLmJpbmQobnVsbCwgbnVsbCwgb3B0aW9ucykpO1xuICAgIH1cbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1Y2tldCA9IHJlcXVpcmUoJy4uL2RhdGEvYnVja2V0Jyk7XG5cbi8qKlxuICogQ29udmVydHMgYSBwaXhlbCB2YWx1ZSBhdCBhIHRoZSBnaXZlbiB6b29tIGxldmVsIHRvIHRpbGUgdW5pdHMuXG4gKlxuICogVGhlIHNoYWRlcnMgbW9zdGx5IGNhbGN1bGF0ZSBldmVyeXRoaW5nIGluIHRpbGUgdW5pdHMgc28gc3R5bGVcbiAqIHByb3BlcnRpZXMgbmVlZCB0byBiZSBjb252ZXJ0ZWQgZnJvbSBwaXhlbHMgdG8gdGlsZSB1bml0cyB1c2luZyB0aGlzLlxuICpcbiAqIEZvciBleGFtcGxlLCBhIHRyYW5zbGF0aW9uIGJ5IDMwIHBpeGVscyBhdCB6b29tIDYuNSB3aWxsIGJlIGFcbiAqIHRyYW5zbGF0aW9uIGJ5IHBpeGVsc1RvVGlsZVVuaXRzKDMwLCA2LjUpIHRpbGUgdW5pdHMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHRpbGUgYSB7VGlsZSBvYmplY3R9IHdpbGwgd29yayB3ZWxsLCBidXQgYW55IG9iamVjdCB0aGF0IGZvbGxvd3MgdGhlIGZvcm1hdCB7Y29vcmQ6IHtUaWxlQ29yZCBvYmplY3R9LCB0aWxlU2l6ZToge251bWJlcn19IHdpbGwgd29ya1xuICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsVmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSB6XG4gKiBAcmV0dXJucyB7bnVtYmVyfSB2YWx1ZSBpbiB0aWxlIHVuaXRzXG4gKiBAcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRpbGUsIHBpeGVsVmFsdWUsIHopIHtcbiAgICByZXR1cm4gcGl4ZWxWYWx1ZSAqIChCdWNrZXQuRVhURU5UIC8gKHRpbGUudGlsZVNpemUgKiBNYXRoLnBvdygyLCB6IC0gdGlsZS5jb29yZC56KSkpO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFRpbGVDb29yZCA9IHJlcXVpcmUoJy4vdGlsZV9jb29yZCcpO1xuXG5leHBvcnRzLnJlbmRlcmVkID0gZnVuY3Rpb24oc291cmNlQ2FjaGUsIHN0eWxlTGF5ZXJzLCBxdWVyeUdlb21ldHJ5LCBwYXJhbXMsIHpvb20sIGJlYXJpbmcpIHtcbiAgICB2YXIgdGlsZXNJbiA9IHNvdXJjZUNhY2hlLnRpbGVzSW4ocXVlcnlHZW9tZXRyeSk7XG5cbiAgICB0aWxlc0luLnNvcnQoc29ydFRpbGVzSW4pO1xuXG4gICAgdmFyIHJlbmRlcmVkRmVhdHVyZUxheWVycyA9IFtdO1xuICAgIGZvciAodmFyIHIgPSAwOyByIDwgdGlsZXNJbi5sZW5ndGg7IHIrKykge1xuICAgICAgICB2YXIgdGlsZUluID0gdGlsZXNJbltyXTtcbiAgICAgICAgaWYgKCF0aWxlSW4udGlsZS5mZWF0dXJlSW5kZXgpIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlbmRlcmVkRmVhdHVyZUxheWVycy5wdXNoKHRpbGVJbi50aWxlLmZlYXR1cmVJbmRleC5xdWVyeSh7XG4gICAgICAgICAgICBxdWVyeUdlb21ldHJ5OiB0aWxlSW4ucXVlcnlHZW9tZXRyeSxcbiAgICAgICAgICAgIHNjYWxlOiB0aWxlSW4uc2NhbGUsXG4gICAgICAgICAgICB0aWxlU2l6ZTogdGlsZUluLnRpbGUudGlsZVNpemUsXG4gICAgICAgICAgICBiZWFyaW5nOiBiZWFyaW5nLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgfSwgc3R5bGVMYXllcnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlUmVuZGVyZWRGZWF0dXJlTGF5ZXJzKHJlbmRlcmVkRmVhdHVyZUxheWVycyk7XG59O1xuXG5leHBvcnRzLnNvdXJjZSA9IGZ1bmN0aW9uKHNvdXJjZUNhY2hlLCBwYXJhbXMpIHtcbiAgICB2YXIgdGlsZXMgPSBzb3VyY2VDYWNoZS5nZXRSZW5kZXJhYmxlSWRzKCkubWFwKGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2VDYWNoZS5nZXRUaWxlQnlJRChpZCk7XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICB2YXIgZGF0YVRpbGVzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdGlsZSA9IHRpbGVzW2ldO1xuICAgICAgICB2YXIgZGF0YUlEID0gbmV3IFRpbGVDb29yZChNYXRoLm1pbih0aWxlLnNvdXJjZU1heFpvb20sIHRpbGUuY29vcmQueiksIHRpbGUuY29vcmQueCwgdGlsZS5jb29yZC55LCAwKS5pZDtcbiAgICAgICAgaWYgKCFkYXRhVGlsZXNbZGF0YUlEXSkge1xuICAgICAgICAgICAgZGF0YVRpbGVzW2RhdGFJRF0gPSB0cnVlO1xuICAgICAgICAgICAgdGlsZS5xdWVyeVNvdXJjZUZlYXR1cmVzKHJlc3VsdCwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBzb3J0VGlsZXNJbihhLCBiKSB7XG4gICAgdmFyIGNvb3JkQSA9IGEuY29vcmQ7XG4gICAgdmFyIGNvb3JkQiA9IGIuY29vcmQ7XG4gICAgcmV0dXJuIChjb29yZEEueiAtIGNvb3JkQi56KSB8fCAoY29vcmRBLnkgLSBjb29yZEIueSkgfHwgKGNvb3JkQS53IC0gY29vcmRCLncpIHx8IChjb29yZEEueCAtIGNvb3JkQi54KTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VSZW5kZXJlZEZlYXR1cmVMYXllcnModGlsZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGlsZXNbMF0gfHwge307XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdGlsZSA9IHRpbGVzW2ldO1xuICAgICAgICBmb3IgKHZhciBsYXllcklEIGluIHRpbGUpIHtcbiAgICAgICAgICAgIHZhciB0aWxlRmVhdHVyZXMgPSB0aWxlW2xheWVySURdO1xuICAgICAgICAgICAgdmFyIHJlc3VsdEZlYXR1cmVzID0gcmVzdWx0W2xheWVySURdO1xuICAgICAgICAgICAgaWYgKHJlc3VsdEZlYXR1cmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRGZWF0dXJlcyA9IHJlc3VsdFtsYXllcklEXSA9IHRpbGVGZWF0dXJlcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZiA9IDA7IGYgPCB0aWxlRmVhdHVyZXMubGVuZ3RoOyBmKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0RmVhdHVyZXMucHVzaCh0aWxlRmVhdHVyZXNbZl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgYWpheCA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheCcpO1xudmFyIEV2ZW50ZWQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50ZWQnKTtcbnZhciBsb2FkVGlsZUpTT04gPSByZXF1aXJlKCcuL2xvYWRfdGlsZWpzb24nKTtcbnZhciBub3JtYWxpemVVUkwgPSByZXF1aXJlKCcuLi91dGlsL21hcGJveCcpLm5vcm1hbGl6ZVRpbGVVUkw7XG5cbm1vZHVsZS5leHBvcnRzID0gUmFzdGVyVGlsZVNvdXJjZTtcblxuZnVuY3Rpb24gUmFzdGVyVGlsZVNvdXJjZShpZCwgb3B0aW9ucywgZGlzcGF0Y2hlcikge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMsIHV0aWwucGljayhvcHRpb25zLCBbJ3VybCcsICdzY2hlbWUnLCAndGlsZVNpemUnXSkpO1xuICAgIGxvYWRUaWxlSlNPTihvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCB0aWxlSlNPTikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJlKCdlcnJvcicsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5leHRlbmQodGhpcywgdGlsZUpTT04pO1xuICAgICAgICB0aGlzLmZpcmUoJ2xvYWQnKTtcbiAgICB9LmJpbmQodGhpcykpO1xufVxuXG5SYXN0ZXJUaWxlU291cmNlLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChFdmVudGVkLCB7XG4gICAgbWluem9vbTogMCxcbiAgICBtYXh6b29tOiAyMixcbiAgICByb3VuZFpvb206IHRydWUsXG4gICAgc2NoZW1lOiAneHl6JyxcbiAgICB0aWxlU2l6ZTogNTEyLFxuICAgIF9sb2FkZWQ6IGZhbHNlLFxuXG4gICAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAncmFzdGVyJyxcbiAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgICAgICB0aWxlU2l6ZTogdGhpcy50aWxlU2l6ZVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBsb2FkVGlsZTogZnVuY3Rpb24odGlsZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHVybCA9IG5vcm1hbGl6ZVVSTCh0aWxlLmNvb3JkLnVybCh0aGlzLnRpbGVzLCBudWxsLCB0aGlzLnNjaGVtZSksIHRoaXMudXJsLCB0aGlzLnRpbGVTaXplKTtcblxuICAgICAgICB0aWxlLnJlcXVlc3QgPSBhamF4LmdldEltYWdlKHVybCwgZG9uZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICBmdW5jdGlvbiBkb25lKGVyciwgaW1nKSB7XG4gICAgICAgICAgICBkZWxldGUgdGlsZS5yZXF1ZXN0O1xuXG4gICAgICAgICAgICBpZiAodGlsZS5hYm9ydGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLm1hcC5wYWludGVyLmdsO1xuICAgICAgICAgICAgdGlsZS50ZXh0dXJlID0gdGhpcy5tYXAucGFpbnRlci5nZXRUZXh0dXJlKGltZy53aWR0aCk7XG4gICAgICAgICAgICBpZiAodGlsZS50ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGlsZS50ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGltZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbGUudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aWxlLnRleHR1cmUpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1QpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBpbWcpO1xuICAgICAgICAgICAgICAgIHRpbGUudGV4dHVyZS5zaXplID0gaW1nLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG5cbiAgICAgICAgICAgIHRoaXMubWFwLmFuaW1hdGlvbkxvb3Auc2V0KHRoaXMubWFwLnN0eWxlLnJhc3RlckZhZGVEdXJhdGlvbik7XG5cbiAgICAgICAgICAgIHRpbGUuc3RhdGUgPSAnbG9hZGVkJztcblxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJvcnRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIGlmICh0aWxlLnJlcXVlc3QpIHtcbiAgICAgICAgICAgIHRpbGUucmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICAgICAgZGVsZXRlIHRpbGUucmVxdWVzdDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB1bmxvYWRUaWxlOiBmdW5jdGlvbih0aWxlKSB7XG4gICAgICAgIGlmICh0aWxlLnRleHR1cmUpIHRoaXMubWFwLnBhaW50ZXIuc2F2ZVRleHR1cmUodGlsZS50ZXh0dXJlKTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcblxudmFyIHNvdXJjZVR5cGVzID0ge1xuICAgICd2ZWN0b3InOiByZXF1aXJlKCcuLi9zb3VyY2UvdmVjdG9yX3RpbGVfc291cmNlJyksXG4gICAgJ3Jhc3Rlcic6IHJlcXVpcmUoJy4uL3NvdXJjZS9yYXN0ZXJfdGlsZV9zb3VyY2UnKSxcbiAgICAnZ2VvanNvbic6IHJlcXVpcmUoJy4uL3NvdXJjZS9nZW9qc29uX3NvdXJjZScpLFxuICAgICd2aWRlbyc6IHJlcXVpcmUoJy4uL3NvdXJjZS92aWRlb19zb3VyY2UnKSxcbiAgICAnaW1hZ2UnOiByZXF1aXJlKCcuLi9zb3VyY2UvaW1hZ2Vfc291cmNlJylcbn07XG5cbi8qXG4gKiBDcmVhdGVzIGEgdGlsZWQgZGF0YSBzb3VyY2UgaW5zdGFuY2UgZ2l2ZW4gYW4gb3B0aW9ucyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIEEgc291cmNlIGRlZmluaXRpb24gb2JqZWN0IGNvbXBsaWFudCB3aXRoIFtgbWFwYm94LWdsLXN0eWxlLXNwZWNgXShodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1zdHlsZS1zcGVjLyNzb3VyY2VzKSBvciwgZm9yIGEgdGhpcmQtcGFydHkgc291cmNlIHR5cGUsIHdpdGggdGhhdCB0eXBlJ3MgcmVxdWlyZW1lbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudHlwZSBBIHNvdXJjZSB0eXBlIGxpa2UgYHJhc3RlcmAsIGB2ZWN0b3JgLCBgdmlkZW9gLCBldGMuXG4gKiBAcGFyYW0ge0Rpc3BhdGNoZXJ9IGRpc3BhdGNoZXJcbiAqIEByZXR1cm5zIHtTb3VyY2V9XG4gKi9cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24oaWQsIHNvdXJjZSwgZGlzcGF0Y2hlcikge1xuICAgIHNvdXJjZSA9IG5ldyBzb3VyY2VUeXBlc1tzb3VyY2UudHlwZV0oaWQsIHNvdXJjZSwgZGlzcGF0Y2hlcik7XG5cbiAgICBpZiAoc291cmNlLmlkICE9PSBpZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFNvdXJjZSBpZCB0byBiZSAnICsgaWQgKyAnIGluc3RlYWQgb2YgJyArIHNvdXJjZS5pZCk7XG4gICAgfVxuXG4gICAgdXRpbC5iaW5kQWxsKFsnbG9hZCcsICdhYm9ydCcsICd1bmxvYWQnLCAnc2VyaWFsaXplJywgJ3ByZXBhcmUnXSwgc291cmNlKTtcbiAgICByZXR1cm4gc291cmNlO1xufTtcblxuZXhwb3J0cy5nZXRUeXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gc291cmNlVHlwZXNbbmFtZV07XG59O1xuXG5leHBvcnRzLnNldFR5cGUgPSBmdW5jdGlvbiAobmFtZSwgdHlwZSkge1xuICAgIHNvdXJjZVR5cGVzW25hbWVdID0gdHlwZTtcbn07XG5cbi8qKlxuICogVGhlIGBTb3VyY2VgIGludGVyZmFjZSBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggc291cmNlIHR5cGUsIGluY2x1ZGluZyBcImNvcmVcIiB0eXBlcyAoYHZlY3RvcmAsIGByYXN0ZXJgLCBgdmlkZW9gLCBldGMuKSBhbmQgYWxsIGN1c3RvbSwgdGhpcmQtcGFydHkgdHlwZXMuXG4gKlxuICogQGNsYXNzIFNvdXJjZVxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGlkIGZvciB0aGUgc291cmNlLiBNdXN0IG5vdCBiZSB1c2VkIGJ5IGFueSBleGlzdGluZyBzb3VyY2UuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBTb3VyY2Ugb3B0aW9ucywgc3BlY2lmaWMgdG8gdGhlIHNvdXJjZSB0eXBlIChleGNlcHQgZm9yIGBvcHRpb25zLnR5cGVgLCB3aGljaCBpcyBhbHdheXMgcmVxdWlyZWQpLlxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudHlwZSBUaGUgc291cmNlIHR5cGUsIG1hdGNoaW5nIHRoZSB2YWx1ZSBvZiBgbmFtZWAgdXNlZCBpbiB7QGxpbmsgU3R5bGUjYWRkU291cmNlVHlwZX0uXG4gKiBAcGFyYW0ge0Rpc3BhdGNoZXJ9IGRpc3BhdGNoZXIgQSB7QGxpbmsgRGlzcGF0Y2hlcn0gaW5zdGFuY2UsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHNlbmQgbWVzc2FnZXMgdG8gdGhlIHdvcmtlcnMuXG4gKlxuICogQGZpcmVzIGxvYWQgdG8gaW5kaWNhdGUgc291cmNlIGRhdGEgaGFzIGJlZW4gbG9hZGVkLCBzbyB0aGF0IGl0J3Mgb2theSB0byBjYWxsIGBsb2FkVGlsZWBcbiAqIEBmaXJlcyBjaGFuZ2UgdG8gaW5kaWNhdGUgc291cmNlIGRhdGEgaGFzIGNoYW5nZWQsIHNvIHRoYXQgYW55IGN1cnJlbnQgY2FjaGVzIHNob3VsZCBiZSBmbHVzaGVkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgVGhlIGlkIGZvciB0aGUgc291cmNlLiAgTXVzdCBtYXRjaCB0aGUgaWQgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW56b29tXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4em9vbVxuICogQHByb3BlcnR5IHtib29sZWFufSBpc1RpbGVDbGlwcGVkIGBmYWxzZWAgaWYgdGlsZXMgY2FuIGJlIGRyYXduIG91dHNpZGUgdGhlaXIgYm91bmRhcmllcywgYHRydWVgIGlmIHRoZXkgY2Fubm90LlxuICogQHByb3BlcnR5IHtib29sZWFufSByZXBhcnNlT3ZlcnNjYWxlZCBgdHJ1ZWAgaWYgdGlsZXMgc2hvdWxkIGJlIHNlbnQgYmFjayB0byB0aGUgd29ya2VyIGZvciBlYWNoIG92ZXJ6b29tZWQgem9vbSBsZXZlbCwgYGZhbHNlYCBpZiBub3QuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHJvdW5kWm9vbSBgdHJ1ZWAgaWYgem9vbSBsZXZlbHMgYXJlIHJvdW5kZWQgdG8gdGhlIG5lYXJlc3QgaW50ZWdlciBpbiB0aGUgc291cmNlIGRhdGEsIGBmYWxzZWAgaWYgdGhleSBhcmUgZmxvb3ItZWQgdG8gdGhlIG5lYXJlc3QgaW50ZWdlci5cbiAqL1xuXG4vKipcbiAqIEFuIG9wdGlvbmFsIFVSTCB0byBhIHNjcmlwdCB3aGljaCwgd2hlbiBydW4gYnkgYSBXb3JrZXIsIHJlZ2lzdGVycyBhIHtAbGluayBXb3JrZXJTb3VyY2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGlzIFNvdXJjZSB0eXBlIGJ5IGNhbGxpbmcgYHNlbGYucmVnaXN0ZXJXb3JrZXJTb3VyY2Uod29ya2VyU291cmNlOiBXb3JrZXJTb3VyY2UpYC5cbiAqXG4gKiBAbWVtYmVyIHtVUkx8dW5kZWZpbmVkfSB3b3JrZXJTb3VyY2VVUkxcbiAqIEBtZW1iZXJvZiBTb3VyY2VcbiAqIEBzdGF0aWNcbiAqL1xuXG4vKipcbiAqIEBtZXRob2RcbiAqIEBuYW1lIGxvYWRUaWxlXG4gKiBAcGFyYW0ge1RpbGV9IHRpbGVcbiAqIEBwYXJhbSB7RnVudGlvbn0gY2FsbGJhY2sgQ2FsbGVkIHdoZW4gdGlsZSBoYXMgYmVlbiBsb2FkZWRcbiAqIEBtZW1iZXJvZiBTb3VyY2VcbiAqIEBpbnN0YW5jZVxuICovXG5cbi8qKlxuICogQG1ldGhvZFxuICogQG5hbWUgYWJvcnRUaWxlXG4gKiBAcGFyYW0ge1RpbGV9IHRpbGVcbiAqIEBtZW1iZXJvZiBTb3VyY2VcbiAqIEBpbnN0YW5jZVxuICovXG5cbi8qKlxuICogQG1ldGhvZFxuICogQG5hbWUgdW5sb2FkVGlsZVxuICogQHBhcmFtIHtUaWxlfSB0aWxlXG4gKiBAbWVtYmVyb2YgU291cmNlXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG4vKipcbiAqIEBtZXRob2RcbiAqIEBuYW1lIHNlcmlhbGl6ZVxuICogQHJldHVybnMge09iamVjdH0gQSBwbGFpbiAoc3RyaW5naWZpYWJsZSkgSlMgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc291cmNlLiBDcmVhdGluZyBhIHNvdXJjZSB1c2luZyB0aGUgcmV0dXJuZWQgb2JqZWN0IGFzIHRoZSBgb3B0aW9uc2Agc2hvdWxkIHJlc3VsdCBpbiBhIFNvdXJjZSB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gdGhpcyBvbmUuXG4gKiBAbWVtYmVyb2YgU291cmNlXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG4vKipcbiAqIEBtZXRob2RcbiAqIEBuYW1lIHByZXBhcmVcbiAqIEBtZW1iZXJvZiBTb3VyY2VcbiAqIEBpbnN0YW5jZVxuICovXG5cblxuXG4vKipcbiAqIE1heSBiZSBpbXBsZW1lbnRlZCBieSBjdXN0b20gc291cmNlIHR5cGVzIHRvIHByb3ZpZGUgY29kZSB0aGF0IGNhbiBiZSBydW4gb25cbiAqIHRoZSBXZWJXb3JrZXJzLiBJbiBhZGRpdGlvbiB0byBwcm92aWRpbmcgYSBjdXN0b21cbiAqIHtAbGluayBXb3JrZXJTb3VyY2UjbG9hZFRpbGV9LCBhbnkgb3RoZXIgbWV0aG9kcyBhdHRhY2hlZCB0byBhIGBXb3JrZXJTb3VyY2VgXG4gKiBpbXBsZW1lbnRhdGlvbiBtYXkgYWxzbyBiZSB0YXJnZXRlZCBieSB0aGUge0BsaW5rIFNvdXJjZX0gdmlhXG4gKiBgZGlzcGF0Y2hlci5zZW5kKCdzb3VyY2UtdHlwZS5tZXRob2RuYW1lJywgcGFyYW1zLCBjYWxsYmFjaylgLlxuICpcbiAqIEBzZWUge0BsaW5rIE1hcCNhZGRTb3VyY2VUeXBlfVxuICogQHByaXZhdGVcbiAqXG4gKiBAY2xhc3MgV29ya2VyU291cmNlXG4gKiBAcGFyYW0ge0FjdG9yfSBhY3RvclxuICogQHBhcmFtIHtvYmplY3R9IHN0eWxlTGF5ZXJzIEFuIGFjY2Vzc29yIHByb3ZpZGVkIGJ5IHRoZSBXb3JrZXIgdG8gZ2V0IHRoZSBjdXJyZW50IHN0eWxlIGxheWVycyBhbmQgbGF5ZXIgZmFtaWxpZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHlsZUxheWVycy5nZXRMYXllcnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0eWxlTGF5ZXJzLmdldExheWVyRmFtaWxpZXNcbiAqL1xuXG4vKipcbiAqIExvYWRzIGEgdGlsZSBmcm9tIHRoZSBnaXZlbiBwYXJhbXMgYW5kIHBhcnNlIGl0IGludG8gYnVja2V0cyByZWFkeSB0byBzZW5kXG4gKiBiYWNrIHRvIHRoZSBtYWluIHRocmVhZCBmb3IgcmVuZGVyaW5nLiAgU2hvdWxkIGNhbGwgdGhlIGNhbGxiYWNrIHdpdGg6XG4gKiBgeyBidWNrZXRzLCBmZWF0dXJlSW5kZXgsIGNvbGxpc2lvblRpbGUsIHN5bWJvbEluc3RhbmNlc0FycmF5LCBzeW1ib2xRdWFkc0FycmF5LCByYXdUaWxlRGF0YX1gLlxuICpcbiAqIEBtZXRob2RcbiAqIEBuYW1lIGxvYWRUaWxlXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIFBhcmFtZXRlcnMgc2VudCBieSB0aGUgbWFpbi10aHJlYWQgU291cmNlIGlkZW50aWZ5aW5nIHRoZSB0aWxlIHRvIGxvYWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQG1lbWJlcm9mIFdvcmtlclNvdXJjZVxuICogQGluc3RhbmNlXG4gKi9cblxuLyoqXG4gKiBSZS1wYXJzZXMgYSB0aWxlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQuICBZaWVsZHMgdGhlIHNhbWUgZGF0YSBhc1xuICoge0BsaW5rIFdvcmtlclNvdXJjZSNsb2FkVGlsZX0uXG4gKlxuICogQG1ldGhvZFxuICogQG5hbWUgcmVsb2FkVGlsZVxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBtZW1iZXJvZiBXb3JrZXJTb3VyY2VcbiAqIEBpbnN0YW5jZVxuICovXG5cbi8qKlxuICogQWJvcnRzIGxvYWRpbmcgYSB0aWxlIHRoYXQgaXMgaW4gcHJvZ3Jlc3MuXG4gKiBAbWV0aG9kXG4gKiBAbmFtZSBhYm9ydFRpbGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAqIEBtZW1iZXJvZiBXb3JrZXJTb3VyY2VcbiAqIEBpbnN0YW5jZVxuICovXG5cbi8qKlxuICogUmVtb3ZlcyB0aGlzIHRpbGUgZnJvbSBhbnkgbG9jYWwgY2FjaGVzLlxuICogQG1ldGhvZFxuICogQG5hbWUgcmVtb3ZlVGlsZVxuICogQG1lbWJlcm9mIFdvcmtlclNvdXJjZVxuICogQGluc3RhbmNlXG4gKi9cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFNvdXJjZSA9IHJlcXVpcmUoJy4vc291cmNlJyk7XG52YXIgVGlsZSA9IHJlcXVpcmUoJy4vdGlsZScpO1xudmFyIEV2ZW50ZWQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50ZWQnKTtcbnZhciBUaWxlQ29vcmQgPSByZXF1aXJlKCcuL3RpbGVfY29vcmQnKTtcbnZhciBDYWNoZSA9IHJlcXVpcmUoJy4uL3V0aWwvbHJ1X2NhY2hlJyk7XG52YXIgQ29vcmRpbmF0ZSA9IHJlcXVpcmUoJy4uL2dlby9jb29yZGluYXRlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIEVYVEVOVCA9IHJlcXVpcmUoJy4uL2RhdGEvYnVja2V0JykuRVhURU5UO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvdXJjZUNhY2hlO1xuXG4vKipcbiAqIEEgdGlsZSBweXJhbWlkIGlzIGEgc3BlY2lhbGl6ZWQgY2FjaGUgYW5kIGRhdGFzdHJ1Y3R1cmVcbiAqIHRoYXQgY29udGFpbnMgdGlsZXMuIEl0J3MgdXNlZCBieSBzb3VyY2VzIHRvIG1hbmFnZSB0aGVpclxuICogZGF0YS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gU291cmNlQ2FjaGUoaWQsIG9wdGlvbnMsIGRpc3BhdGNoZXIpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcblxuICAgIHZhciBzb3VyY2UgPSB0aGlzLl9zb3VyY2UgPSBTb3VyY2UuY3JlYXRlKGlkLCBvcHRpb25zLCBkaXNwYXRjaGVyKVxuICAgIC5vbignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFwICYmIHRoaXMuX3NvdXJjZS5vbkFkZCkgeyB0aGlzLl9zb3VyY2Uub25BZGQodGhpcy5tYXApOyB9XG5cbiAgICAgICAgdGhpcy5fc291cmNlTG9hZGVkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnRpbGVTaXplID0gc291cmNlLnRpbGVTaXplO1xuICAgICAgICB0aGlzLm1pbnpvb20gPSBzb3VyY2UubWluem9vbTtcbiAgICAgICAgdGhpcy5tYXh6b29tID0gc291cmNlLm1heHpvb207XG4gICAgICAgIHRoaXMucm91bmRab29tID0gc291cmNlLnJvdW5kWm9vbTtcbiAgICAgICAgdGhpcy5yZXBhcnNlT3ZlcnNjYWxlZCA9IHNvdXJjZS5yZXBhcnNlT3ZlcnNjYWxlZDtcbiAgICAgICAgdGhpcy5pc1RpbGVDbGlwcGVkID0gc291cmNlLmlzVGlsZUNsaXBwZWQ7XG4gICAgICAgIHRoaXMuYXR0cmlidXRpb24gPSBzb3VyY2UuYXR0cmlidXRpb247XG5cbiAgICAgICAgdGhpcy52ZWN0b3JMYXllcklkcyA9IHNvdXJjZS52ZWN0b3JMYXllcklkcztcblxuICAgICAgICB0aGlzLmZpcmUoJ2xvYWQnKTtcbiAgICB9LmJpbmQodGhpcykpXG4gICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZUVycm9yZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmZpcmUoJ2Vycm9yJywgZSk7XG4gICAgfS5iaW5kKHRoaXMpKVxuICAgIC5vbignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbG9hZCgpO1xuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRoaXMudHJhbnNmb3JtLCB0aGlzLm1hcCAmJiB0aGlzLm1hcC5zdHlsZS5yYXN0ZXJGYWRlRHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlyZSgnY2hhbmdlJyk7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIHRoaXMuX3RpbGVzID0ge307XG4gICAgdGhpcy5fY2FjaGUgPSBuZXcgQ2FjaGUoMCwgdGhpcy51bmxvYWRUaWxlLmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5faXNJZFJlbmRlcmFibGUgPSB0aGlzLl9pc0lkUmVuZGVyYWJsZS5iaW5kKHRoaXMpO1xufVxuXG5cblNvdXJjZUNhY2hlLm1heE92ZXJ6b29taW5nID0gMTA7XG5Tb3VyY2VDYWNoZS5tYXhVbmRlcnpvb21pbmcgPSAzO1xuXG5Tb3VyY2VDYWNoZS5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoRXZlbnRlZCwge1xuICAgIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgICAgICBpZiAodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZS5vbkFkZCkge1xuICAgICAgICAgICAgdGhpcy5fc291cmNlLm9uQWRkKG1hcCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgbm8gdGlsZSBkYXRhIGlzIHBlbmRpbmcsIHRpbGVzIHdpbGwgbm90IGNoYW5nZSB1bmxlc3NcbiAgICAgKiBhbiBhZGRpdGlvbmFsIEFQSSBjYWxsIGlzIHJlY2VpdmVkLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NvdXJjZUVycm9yZWQpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgaWYgKCF0aGlzLl9zb3VyY2VMb2FkZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIGZvciAodmFyIHQgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgICAgIHZhciB0aWxlID0gdGhpcy5fdGlsZXNbdF07XG4gICAgICAgICAgICBpZiAodGlsZS5zdGF0ZSAhPT0gJ2xvYWRlZCcgJiYgdGlsZS5zdGF0ZSAhPT0gJ2Vycm9yZWQnKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1NvdXJjZX0gVGhlIHVuZGVybHlpbmcgc291cmNlIG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0U291cmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XG4gICAgfSxcblxuICAgIGxvYWRUaWxlOiBmdW5jdGlvbiAodGlsZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5sb2FkVGlsZSh0aWxlLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIHVubG9hZFRpbGU6IGZ1bmN0aW9uICh0aWxlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zb3VyY2UudW5sb2FkVGlsZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UudW5sb2FkVGlsZSh0aWxlKTtcbiAgICB9LFxuXG4gICAgYWJvcnRUaWxlOiBmdW5jdGlvbiAodGlsZSkge1xuICAgICAgICBpZiAodGhpcy5fc291cmNlLmFib3J0VGlsZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UuYWJvcnRUaWxlKHRpbGUpO1xuICAgIH0sXG5cbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5zZXJpYWxpemUoKTtcbiAgICB9LFxuXG4gICAgcHJlcGFyZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fc291cmNlTG9hZGVkICYmIHRoaXMuX3NvdXJjZS5wcmVwYXJlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5wcmVwYXJlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbGwgdGlsZSBpZHMgb3JkZXJlZCB3aXRoIHotb3JkZXIsIGFuZCBjYXN0IHRvIG51bWJlcnNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gaWRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRJZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fdGlsZXMpLm1hcChOdW1iZXIpLnNvcnQoY29tcGFyZUtleVpvb20pO1xuICAgIH0sXG5cbiAgICBnZXRSZW5kZXJhYmxlSWRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SWRzKCkuZmlsdGVyKHRoaXMuX2lzSWRSZW5kZXJhYmxlKTtcbiAgICB9LFxuXG4gICAgX2lzSWRSZW5kZXJhYmxlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZXNbaWRdLmlzUmVuZGVyYWJsZSgpICYmICF0aGlzLl9jb3ZlcmVkVGlsZXNbaWRdO1xuICAgIH0sXG5cbiAgICByZWxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jYWNoZS5yZXNldCgpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX3RpbGVzKSB7XG4gICAgICAgICAgICB2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2ldO1xuXG4gICAgICAgICAgICAvLyBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIFwibG9hZGluZ1wiIHRpbGVzIGFuZCBcInJlbG9hZGluZ1wiIHRpbGVzIGlzXG4gICAgICAgICAgICAvLyB0aGF0IFwicmVsb2FkaW5nXCIgdGlsZXMgYXJlIFwicmVuZGVyYWJsZVwiLiBUaGVyZWZvcmUsIGEgXCJsb2FkaW5nXCJcbiAgICAgICAgICAgIC8vIHRpbGUgY2Fubm90IGJlY29tZSBhIFwicmVsb2FkaW5nXCIgdGlsZSB3aXRob3V0IGZpcnN0IGJlY29taW5nXG4gICAgICAgICAgICAvLyBhIFwibG9hZGVkXCIgdGlsZS5cbiAgICAgICAgICAgIGlmICh0aWxlLnN0YXRlICE9PSAnbG9hZGluZycpIHtcbiAgICAgICAgICAgICAgICB0aWxlLnN0YXRlID0gJ3JlbG9hZGluZyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubG9hZFRpbGUodGhpcy5fdGlsZXNbaV0sIHRoaXMuX3RpbGVMb2FkZWQuYmluZCh0aGlzLCB0aGlzLl90aWxlc1tpXSkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF90aWxlTG9hZGVkOiBmdW5jdGlvbiAodGlsZSwgZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRpbGUuc3RhdGUgPSAnZXJyb3JlZCc7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3RpbGUuZXJyb3InLCB7dGlsZTogdGlsZSwgZXJyb3I6IGVycn0pO1xuICAgICAgICAgICAgdGhpcy5fc291cmNlLmZpcmUoJ3RpbGUuZXJyb3InLCB7dGlsZTogdGlsZSwgZXJyb3I6IGVycn0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGlsZS5zb3VyY2UgPSB0aGlzO1xuICAgICAgICB0aWxlLnRpbWVBZGRlZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB0aGlzLmZpcmUoJ3RpbGUubG9hZCcsIHt0aWxlOiB0aWxlfSk7XG4gICAgICAgIHRoaXMuX3NvdXJjZS5maXJlKCd0aWxlLmxvYWQnLCB7dGlsZTogdGlsZX0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzcGVjaWZpYyB0aWxlIGJ5IFRpbGVDb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtUaWxlQ29vcmRpbmF0ZX0gY29vcmRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRUaWxlOiBmdW5jdGlvbihjb29yZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUaWxlQnlJRChjb29yZC5pZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIHNwZWNpZmljIHRpbGUgYnkgaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGlkXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0VGlsZUJ5SUQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aWxlc1tpZF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgem9vbSBsZXZlbCBhZGp1c3RlZCBmb3IgdGhlIGRpZmZlcmVuY2UgaW4gbWFwIGFuZCBzb3VyY2UgdGlsZXNpemVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHpvb20gbGV2ZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldFpvb206IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtLnpvb20gKyB0cmFuc2Zvcm0uc2NhbGVab29tKHRyYW5zZm9ybS50aWxlU2l6ZSAvIHRoaXMudGlsZVNpemUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmaW5kIGNoaWxkcmVuIG9mIHRoZSBnaXZlbiB0aWxlICh1cCB0byBtYXhDb3ZlcmluZ1pvb20pIHRoYXQgYXJlIGFscmVhZHkgbG9hZGVkO1xuICAgICAqIGFkZHMgZm91bmQgdGlsZXMgdG8gcmV0YWluIG9iamVjdDsgcmV0dXJucyB0cnVlIGlmIGFueSBjaGlsZCBpcyBmb3VuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4Q292ZXJpbmdab29tXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXRhaW5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgb3BlcmF0aW9uIHdhcyBjb21wbGV0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZmluZExvYWRlZENoaWxkcmVuOiBmdW5jdGlvbihjb29yZCwgbWF4Q292ZXJpbmdab29tLCByZXRhaW4pIHtcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5fdGlsZXMpIHtcbiAgICAgICAgICAgIHZhciB0aWxlID0gdGhpcy5fdGlsZXNbaWRdO1xuXG4gICAgICAgICAgICAvLyBvbmx5IGNvbnNpZGVyIHJlbmRlcmFibGUgdGlsZXMgb24gaGlnaGVyIHpvb20gbGV2ZWxzICh1cCB0byBtYXhDb3ZlcmluZ1pvb20pXG4gICAgICAgICAgICBpZiAocmV0YWluW2lkXSB8fCAhdGlsZS5pc1JlbmRlcmFibGUoKSB8fCB0aWxlLmNvb3JkLnogPD0gY29vcmQueiB8fCB0aWxlLmNvb3JkLnogPiBtYXhDb3ZlcmluZ1pvb20pIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBkaXNyZWdhcmQgdGlsZXMgdGhhdCBhcmUgbm90IGRlc2NlbmRhbnRzIG9mIHRoZSBnaXZlbiB0aWxlIGNvb3JkaW5hdGVcbiAgICAgICAgICAgIHZhciB6MiA9IE1hdGgucG93KDIsIE1hdGgubWluKHRpbGUuY29vcmQueiwgdGhpcy5tYXh6b29tKSAtIE1hdGgubWluKGNvb3JkLnosIHRoaXMubWF4em9vbSkpO1xuICAgICAgICAgICAgaWYgKE1hdGguZmxvb3IodGlsZS5jb29yZC54IC8gejIpICE9PSBjb29yZC54IHx8XG4gICAgICAgICAgICAgICAgTWF0aC5mbG9vcih0aWxlLmNvb3JkLnkgLyB6MikgIT09IGNvb3JkLnkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIGZvdW5kIGxvYWRlZCBjaGlsZFxuICAgICAgICAgICAgcmV0YWluW2lkXSA9IHRydWU7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBwYXJlbnRzOyByZXRhaW4gdGhlIHRvcG1vc3QgbG9hZGVkIG9uZSBpZiBmb3VuZFxuICAgICAgICAgICAgd2hpbGUgKHRpbGUgJiYgdGlsZS5jb29yZC56IC0gMSA+IGNvb3JkLnopIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50SWQgPSB0aWxlLmNvb3JkLnBhcmVudCh0aGlzLm1heHpvb20pLmlkO1xuICAgICAgICAgICAgICAgIHRpbGUgPSB0aGlzLl90aWxlc1twYXJlbnRJZF07XG5cbiAgICAgICAgICAgICAgICBpZiAodGlsZSAmJiB0aWxlLmlzUmVuZGVyYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXRhaW5baWRdO1xuICAgICAgICAgICAgICAgICAgICByZXRhaW5bcGFyZW50SWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGEgbG9hZGVkIHBhcmVudCBvZiB0aGUgZ2l2ZW4gdGlsZSAodXAgdG8gbWluQ292ZXJpbmdab29tKTtcbiAgICAgKiBhZGRzIHRoZSBmb3VuZCB0aWxlIHRvIHJldGFpbiBvYmplY3QgYW5kIHJldHVybnMgdGhlIHRpbGUgaWYgZm91bmRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluQ292ZXJpbmdab29tXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXRhaW5cbiAgICAgKiBAcmV0dXJucyB7VGlsZX0gdGlsZSBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZpbmRMb2FkZWRQYXJlbnQ6IGZ1bmN0aW9uKGNvb3JkLCBtaW5Db3ZlcmluZ1pvb20sIHJldGFpbikge1xuICAgICAgICBmb3IgKHZhciB6ID0gY29vcmQueiAtIDE7IHogPj0gbWluQ292ZXJpbmdab29tOyB6LS0pIHtcbiAgICAgICAgICAgIGNvb3JkID0gY29vcmQucGFyZW50KHRoaXMubWF4em9vbSk7XG4gICAgICAgICAgICB2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2Nvb3JkLmlkXTtcbiAgICAgICAgICAgIGlmICh0aWxlICYmIHRpbGUuaXNSZW5kZXJhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICByZXRhaW5bY29vcmQuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWNoZS5oYXMoY29vcmQuaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUaWxlKGNvb3JkKTtcbiAgICAgICAgICAgICAgICByZXRhaW5bY29vcmQuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGlsZXNbY29vcmQuaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIHRpbGUgY2FjaGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgdmlld3BvcnQncyBzaXplLlxuICAgICAqXG4gICAgICogTGFyZ2VyIHZpZXdwb3J0cyB1c2UgbW9yZSB0aWxlcyBhbmQgbmVlZCBsYXJnZXIgY2FjaGVzLiBMYXJnZXIgdmlld3BvcnRzXG4gICAgICogYXJlIG1vcmUgbGlrZWx5IHRvIGJlIGZvdW5kIG9uIGRldmljZXMgd2l0aCBtb3JlIG1lbW9yeSBhbmQgb24gcGFnZXMgd2hlcmVcbiAgICAgKiB0aGUgbWFwIGlzIG1vcmUgaW1wb3J0YW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB1cGRhdGVDYWNoZVNpemU6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgICB2YXIgd2lkdGhJblRpbGVzID0gTWF0aC5jZWlsKHRyYW5zZm9ybS53aWR0aCAvIHRyYW5zZm9ybS50aWxlU2l6ZSkgKyAxO1xuICAgICAgICB2YXIgaGVpZ2h0SW5UaWxlcyA9IE1hdGguY2VpbCh0cmFuc2Zvcm0uaGVpZ2h0IC8gdHJhbnNmb3JtLnRpbGVTaXplKSArIDE7XG4gICAgICAgIHZhciBhcHByb3hUaWxlc0luVmlldyA9IHdpZHRoSW5UaWxlcyAqIGhlaWdodEluVGlsZXM7XG4gICAgICAgIHZhciBjb21tb25ab29tUmFuZ2UgPSA1O1xuICAgICAgICB0aGlzLl9jYWNoZS5zZXRNYXhTaXplKE1hdGguZmxvb3IoYXBwcm94VGlsZXNJblZpZXcgKiBjb21tb25ab29tUmFuZ2UpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aWxlcyB0aGF0IGFyZSBvdXRzaWRlIHRoZSB2aWV3cG9ydCBhbmQgYWRkcyBuZXcgdGlsZXMgdGhhdFxuICAgICAqIGFyZSBpbnNpZGUgdGhlIHZpZXdwb3J0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbih0cmFuc2Zvcm0sIGZhZGVEdXJhdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMuX3NvdXJjZUxvYWRlZCkgeyByZXR1cm47IH1cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBjb29yZDtcbiAgICAgICAgdmFyIHRpbGU7XG5cbiAgICAgICAgdGhpcy51cGRhdGVDYWNoZVNpemUodHJhbnNmb3JtKTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIG92ZXJ6b29taW5nL3VuZGVyem9vbWluZyBhbW91bnRzLlxuICAgICAgICB2YXIgem9vbSA9ICh0aGlzLnJvdW5kWm9vbSA/IE1hdGgucm91bmQgOiBNYXRoLmZsb29yKSh0aGlzLmdldFpvb20odHJhbnNmb3JtKSk7XG4gICAgICAgIHZhciBtaW5Db3ZlcmluZ1pvb20gPSBNYXRoLm1heCh6b29tIC0gU291cmNlQ2FjaGUubWF4T3Zlcnpvb21pbmcsIHRoaXMubWluem9vbSk7XG4gICAgICAgIHZhciBtYXhDb3ZlcmluZ1pvb20gPSBNYXRoLm1heCh6b29tICsgU291cmNlQ2FjaGUubWF4VW5kZXJ6b29taW5nLCAgdGhpcy5taW56b29tKTtcblxuICAgICAgICAvLyBSZXRhaW4gaXMgYSBsaXN0IG9mIHRpbGVzIHRoYXQgd2Ugc2hvdWxkbid0IGRlbGV0ZSwgZXZlbiBpZiB0aGV5IGFyZSBub3RcbiAgICAgICAgLy8gdGhlIG1vc3QgaWRlYWwgdGlsZSBmb3IgdGhlIGN1cnJlbnQgdmlld3BvcnQuIFRoaXMgbWF5IGluY2x1ZGUgdGlsZXMgbGlrZVxuICAgICAgICAvLyBwYXJlbnQgb3IgY2hpbGQgdGlsZXMgdGhhdCBhcmUgKmFscmVhZHkqIGxvYWRlZC5cbiAgICAgICAgdmFyIHJldGFpbiA9IHt9O1xuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgLy8gQ292ZXJlZCBpcyBhIGxpc3Qgb2YgcmV0YWluZWQgdGlsZXMgd2hvJ3MgYXJlYXMgYXJlIGZ1bGwgY292ZXJlZCBieSBvdGhlcixcbiAgICAgICAgLy8gYmV0dGVyLCByZXRhaW5lZCB0aWxlcy4gVGhleSBhcmUgbm90IGRyYXduIHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX2NvdmVyZWRUaWxlcyA9IHt9O1xuXG4gICAgICAgIHZhciByZXF1aXJlZCA9IHRoaXMudXNlZCA/IHRyYW5zZm9ybS5jb3ZlcmluZ1RpbGVzKHRoaXMuX3NvdXJjZSkgOiBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlcXVpcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb29yZCA9IHJlcXVpcmVkW2ldO1xuICAgICAgICAgICAgdGlsZSA9IHRoaXMuYWRkVGlsZShjb29yZCk7XG5cbiAgICAgICAgICAgIHJldGFpbltjb29yZC5pZF0gPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAodGlsZS5pc1JlbmRlcmFibGUoKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gVGhlIHRpbGUgd2UgcmVxdWlyZSBpcyBub3QgeWV0IGxvYWRlZC5cbiAgICAgICAgICAgIC8vIFJldGFpbiBjaGlsZCBvciBwYXJlbnQgdGlsZXMgdGhhdCBjb3ZlciB0aGUgc2FtZSBhcmVhLlxuICAgICAgICAgICAgaWYgKCF0aGlzLmZpbmRMb2FkZWRDaGlsZHJlbihjb29yZCwgbWF4Q292ZXJpbmdab29tLCByZXRhaW4pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5kTG9hZGVkUGFyZW50KGNvb3JkLCBtaW5Db3ZlcmluZ1pvb20sIHJldGFpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyZW50c0ZvckZhZGluZyA9IHt9O1xuXG4gICAgICAgIHZhciBpZHMgPSBPYmplY3Qua2V5cyhyZXRhaW4pO1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGlkcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdmFyIGlkID0gaWRzW2tdO1xuICAgICAgICAgICAgY29vcmQgPSBUaWxlQ29vcmQuZnJvbUlEKGlkKTtcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLl90aWxlc1tpZF07XG4gICAgICAgICAgICBpZiAodGlsZSAmJiB0aWxlLnRpbWVBZGRlZCA+IG5vdyAtIChmYWRlRHVyYXRpb24gfHwgMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHRpbGUgaXMgc3RpbGwgZmFkaW5nIGluLiBGaW5kIHRpbGVzIHRvIGNyb3NzLWZhZGUgd2l0aCBpdC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kTG9hZGVkQ2hpbGRyZW4oY29vcmQsIG1heENvdmVyaW5nWm9vbSwgcmV0YWluKSkge1xuICAgICAgICAgICAgICAgICAgICByZXRhaW5baWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5maW5kTG9hZGVkUGFyZW50KGNvb3JkLCBtaW5Db3ZlcmluZ1pvb20sIHBhcmVudHNGb3JGYWRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZhZGVkUGFyZW50O1xuICAgICAgICBmb3IgKGZhZGVkUGFyZW50IGluIHBhcmVudHNGb3JGYWRpbmcpIHtcbiAgICAgICAgICAgIGlmICghcmV0YWluW2ZhZGVkUGFyZW50XSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGEgdGlsZSBpcyBvbmx5IG5lZWRlZCBmb3IgZmFkaW5nLCBtYXJrIGl0IGFzIGNvdmVyZWQgc28gdGhhdCBpdCBpc24ndCByZW5kZXJlZCBvbiBpdCdzIG93bi5cbiAgICAgICAgICAgICAgICB0aGlzLl9jb3ZlcmVkVGlsZXNbZmFkZWRQYXJlbnRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGZhZGVkUGFyZW50IGluIHBhcmVudHNGb3JGYWRpbmcpIHtcbiAgICAgICAgICAgIHJldGFpbltmYWRlZFBhcmVudF0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSB0aWxlcyB3ZSBkb24ndCBuZWVkIGFueW1vcmUuXG4gICAgICAgIHZhciByZW1vdmUgPSB1dGlsLmtleXNEaWZmZXJlbmNlKHRoaXMuX3RpbGVzLCByZXRhaW4pO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVRpbGUoK3JlbW92ZVtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgdGlsZSwgZ2l2ZW4gaXRzIGNvb3JkaW5hdGUsIHRvIHRoZSBweXJhbWlkLlxuICAgICAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRcbiAgICAgKiBAcmV0dXJucyB7Q29vcmRpbmF0ZX0gdGhlIGNvb3JkaW5hdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhZGRUaWxlOiBmdW5jdGlvbihjb29yZCkge1xuICAgICAgICB2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2Nvb3JkLmlkXTtcbiAgICAgICAgaWYgKHRpbGUpXG4gICAgICAgICAgICByZXR1cm4gdGlsZTtcblxuICAgICAgICB2YXIgd3JhcHBlZCA9IGNvb3JkLndyYXBwZWQoKTtcbiAgICAgICAgdGlsZSA9IHRoaXMuX3RpbGVzW3dyYXBwZWQuaWRdO1xuXG4gICAgICAgIGlmICghdGlsZSkge1xuICAgICAgICAgICAgdGlsZSA9IHRoaXMuX2NhY2hlLmdldCh3cmFwcGVkLmlkKTtcbiAgICAgICAgICAgIGlmICh0aWxlICYmIHRoaXMuX3JlZG9QbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWRvUGxhY2VtZW50KHRpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aWxlKSB7XG4gICAgICAgICAgICB2YXIgem9vbSA9IGNvb3JkLno7XG4gICAgICAgICAgICB2YXIgb3ZlcnNjYWxpbmcgPSB6b29tID4gdGhpcy5tYXh6b29tID8gTWF0aC5wb3coMiwgem9vbSAtIHRoaXMubWF4em9vbSkgOiAxO1xuICAgICAgICAgICAgdGlsZSA9IG5ldyBUaWxlKHdyYXBwZWQsIHRoaXMudGlsZVNpemUgKiBvdmVyc2NhbGluZywgdGhpcy5tYXh6b29tKTtcbiAgICAgICAgICAgIHRoaXMubG9hZFRpbGUodGlsZSwgdGhpcy5fdGlsZUxvYWRlZC5iaW5kKHRoaXMsIHRpbGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbGUudXNlcysrO1xuICAgICAgICB0aGlzLl90aWxlc1tjb29yZC5pZF0gPSB0aWxlO1xuICAgICAgICB0aGlzLmZpcmUoJ3RpbGUuYWRkJywge3RpbGU6IHRpbGV9KTtcbiAgICAgICAgdGhpcy5fc291cmNlLmZpcmUoJ3RpbGUuYWRkJywge3RpbGU6IHRpbGV9KTtcblxuICAgICAgICByZXR1cm4gdGlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgdGlsZSwgZ2l2ZW4gaXRzIGlkLCBmcm9tIHRoZSBweXJhbWlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBpZCB0aWxlIGlkXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH0gbm90aGluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmVtb3ZlVGlsZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdmFyIHRpbGUgPSB0aGlzLl90aWxlc1tpZF07XG4gICAgICAgIGlmICghdGlsZSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB0aWxlLnVzZXMtLTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3RpbGVzW2lkXTtcbiAgICAgICAgdGhpcy5maXJlKCd0aWxlLnJlbW92ZScsIHt0aWxlOiB0aWxlfSk7XG4gICAgICAgIHRoaXMuX3NvdXJjZS5maXJlKCd0aWxlLnJlbW92ZScsIHt0aWxlOiB0aWxlfSk7XG5cbiAgICAgICAgaWYgKHRpbGUudXNlcyA+IDApXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgaWYgKHRpbGUuaXNSZW5kZXJhYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlLmFkZCh0aWxlLmNvb3JkLndyYXBwZWQoKS5pZCwgdGlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aWxlLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5hYm9ydFRpbGUodGlsZSk7XG4gICAgICAgICAgICB0aGlzLnVubG9hZFRpbGUodGlsZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCB0aWxlcyBmcm9tIHRoaXMgcHlyYW1pZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2xlYXJUaWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuX3RpbGVzKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVUaWxlKGlkKTtcbiAgICAgICAgdGhpcy5fY2FjaGUucmVzZXQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VhcmNoIHRocm91Z2ggb3VyIGN1cnJlbnQgdGlsZXMgYW5kIGF0dGVtcHQgdG8gZmluZCB0aGUgdGlsZXMgdGhhdFxuICAgICAqIGNvdmVyIHRoZSBnaXZlbiBib3VuZHMuXG4gICAgICogQHBhcmFtIHtBcnJheTxDb29yZGluYXRlPn0gcXVlcnlHZW9tZXRyeSBjb29yZGluYXRlcyBvZiB0aGUgY29ybmVycyBvZiBib3VuZGluZyByZWN0YW5nbGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8T2JqZWN0Pn0gcmVzdWx0IGl0ZW1zIGhhdmUge3RpbGUsIG1pblgsIG1heFgsIG1pblksIG1heFl9LCB3aGVyZSBtaW4vbWF4IGJvdW5kaW5nIHZhbHVlcyBhcmUgdGhlIGdpdmVuIGJvdW5kcyB0cmFuc2Zvcm1lZCBpbiBpbnRvIHRoZSBjb29yZGluYXRlIHNwYWNlIG9mIHRoaXMgdGlsZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRpbGVzSW46IGZ1bmN0aW9uKHF1ZXJ5R2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIHRpbGVSZXN1bHRzID0ge307XG4gICAgICAgIHZhciBpZHMgPSB0aGlzLmdldElkcygpO1xuXG4gICAgICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuICAgICAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcbiAgICAgICAgdmFyIHogPSBxdWVyeUdlb21ldHJ5WzBdLnpvb207XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBxdWVyeUdlb21ldHJ5Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHF1ZXJ5R2VvbWV0cnlba107XG4gICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgcC5jb2x1bW4pO1xuICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHAucm93KTtcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBwLmNvbHVtbik7XG4gICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgcC5yb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0aWxlID0gdGhpcy5fdGlsZXNbaWRzW2ldXTtcbiAgICAgICAgICAgIHZhciBjb29yZCA9IFRpbGVDb29yZC5mcm9tSUQoaWRzW2ldKTtcblxuICAgICAgICAgICAgdmFyIHRpbGVTcGFjZUJvdW5kcyA9IFtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlVG9UaWxlUG9pbnQoY29vcmQsIHRpbGUuc291cmNlTWF4Wm9vbSwgbmV3IENvb3JkaW5hdGUobWluWCwgbWluWSwgeikpLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVUb1RpbGVQb2ludChjb29yZCwgdGlsZS5zb3VyY2VNYXhab29tLCBuZXcgQ29vcmRpbmF0ZShtYXhYLCBtYXhZLCB6KSlcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGlmICh0aWxlU3BhY2VCb3VuZHNbMF0ueCA8IEVYVEVOVCAmJiB0aWxlU3BhY2VCb3VuZHNbMF0ueSA8IEVYVEVOVCAmJlxuICAgICAgICAgICAgICAgIHRpbGVTcGFjZUJvdW5kc1sxXS54ID49IDAgJiYgdGlsZVNwYWNlQm91bmRzWzFdLnkgPj0gMCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHRpbGVTcGFjZVF1ZXJ5R2VvbWV0cnkgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHF1ZXJ5R2VvbWV0cnkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGlsZVNwYWNlUXVlcnlHZW9tZXRyeS5wdXNoKGNvb3JkaW5hdGVUb1RpbGVQb2ludChjb29yZCwgdGlsZS5zb3VyY2VNYXhab29tLCBxdWVyeUdlb21ldHJ5W2pdKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRpbGVSZXN1bHQgPSB0aWxlUmVzdWx0c1t0aWxlLmNvb3JkLmlkXTtcbiAgICAgICAgICAgICAgICBpZiAodGlsZVJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbGVSZXN1bHQgPSB0aWxlUmVzdWx0c1t0aWxlLmNvb3JkLmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbGU6IHRpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZDogY29vcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeUdlb21ldHJ5OiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlOiBNYXRoLnBvdygyLCB0aGlzLnRyYW5zZm9ybS56b29tIC0gdGlsZS5jb29yZC56KVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdyYXBwZWQgdGlsZXMgc2hhcmUgb25lIHRpbGVSZXN1bHQgb2JqZWN0IGJ1dCBjYW4gaGF2ZSBtdWx0aXBsZSBxdWVyeUdlb21ldHJ5IHBhcnRzXG4gICAgICAgICAgICAgICAgdGlsZVJlc3VsdC5xdWVyeUdlb21ldHJ5LnB1c2godGlsZVNwYWNlUXVlcnlHZW9tZXRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciB0IGluIHRpbGVSZXN1bHRzKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGlsZVJlc3VsdHNbdF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0sXG5cbiAgICByZWRvUGxhY2VtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHMgPSB0aGlzLmdldElkcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRpbGUgPSB0aGlzLmdldFRpbGVCeUlEKGlkc1tpXSk7XG4gICAgICAgICAgICB0aWxlLnJlZG9QbGFjZW1lbnQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0VmlzaWJsZUNvb3JkaW5hdGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmFibGVJZHMoKS5tYXAoVGlsZUNvb3JkLmZyb21JRCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQ29udmVydCBhIGNvb3JkaW5hdGUgdG8gYSBwb2ludCBpbiBhIHRpbGUncyBjb29yZGluYXRlIHNwYWNlLlxuICogQHBhcmFtIHtDb29yZGluYXRlfSB0aWxlQ29vcmRcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRcbiAqIEByZXR1cm5zIHtPYmplY3R9IHBvc2l0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb29yZGluYXRlVG9UaWxlUG9pbnQodGlsZUNvb3JkLCBzb3VyY2VNYXhab29tLCBjb29yZCkge1xuICAgIHZhciB6b29tZWRDb29yZCA9IGNvb3JkLnpvb21UbyhNYXRoLm1pbih0aWxlQ29vcmQueiwgc291cmNlTWF4Wm9vbSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6ICh6b29tZWRDb29yZC5jb2x1bW4gLSAodGlsZUNvb3JkLnggKyB0aWxlQ29vcmQudyAqIE1hdGgucG93KDIsIHRpbGVDb29yZC56KSkpICogRVhURU5ULFxuICAgICAgICB5OiAoem9vbWVkQ29vcmQucm93IC0gdGlsZUNvb3JkLnkpICogRVhURU5UXG4gICAgfTtcblxufVxuXG5mdW5jdGlvbiBjb21wYXJlS2V5Wm9vbShhLCBiKSB7XG4gICAgcmV0dXJuIChhICUgMzIpIC0gKGIgJSAzMik7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgQnVja2V0ID0gcmVxdWlyZSgnLi4vZGF0YS9idWNrZXQnKTtcbnZhciBGZWF0dXJlSW5kZXggPSByZXF1aXJlKCcuLi9kYXRhL2ZlYXR1cmVfaW5kZXgnKTtcbnZhciB2dCA9IHJlcXVpcmUoJ3ZlY3Rvci10aWxlJyk7XG52YXIgUHJvdG9idWYgPSByZXF1aXJlKCdwYmYnKTtcbnZhciBHZW9KU09ORmVhdHVyZSA9IHJlcXVpcmUoJy4uL3V0aWwvdmVjdG9ydGlsZV90b19nZW9qc29uJyk7XG52YXIgZmVhdHVyZUZpbHRlciA9IHJlcXVpcmUoJ2ZlYXR1cmUtZmlsdGVyJyk7XG52YXIgQ29sbGlzaW9uVGlsZSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9jb2xsaXNpb25fdGlsZScpO1xudmFyIENvbGxpc2lvbkJveEFycmF5ID0gcmVxdWlyZSgnLi4vc3ltYm9sL2NvbGxpc2lvbl9ib3gnKTtcbnZhciBTeW1ib2xJbnN0YW5jZXNBcnJheSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9zeW1ib2xfaW5zdGFuY2VzJyk7XG52YXIgU3ltYm9sUXVhZHNBcnJheSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9zeW1ib2xfcXVhZHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaWxlO1xuXG4vKipcbiAqIEEgdGlsZSBvYmplY3QgaXMgdGhlIGNvbWJpbmF0aW9uIG9mIGEgQ29vcmRpbmF0ZSwgd2hpY2ggZGVmaW5lc1xuICogaXRzIHBsYWNlLCBhcyB3ZWxsIGFzIGEgdW5pcXVlIElEIGFuZCBkYXRhIHRyYWNraW5nIGZvciBpdHMgY29udGVudFxuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBUaWxlKGNvb3JkLCBzaXplLCBzb3VyY2VNYXhab29tKSB7XG4gICAgdGhpcy5jb29yZCA9IGNvb3JkO1xuICAgIHRoaXMudWlkID0gdXRpbC51bmlxdWVJZCgpO1xuICAgIHRoaXMudXNlcyA9IDA7XG4gICAgdGhpcy50aWxlU2l6ZSA9IHNpemU7XG4gICAgdGhpcy5zb3VyY2VNYXhab29tID0gc291cmNlTWF4Wm9vbTtcbiAgICB0aGlzLmJ1Y2tldHMgPSB7fTtcblxuICAgIC8vIGB0aGlzLnN0YXRlYCBtdXN0IGJlIG9uZSBvZlxuICAgIC8vXG4gICAgLy8gLSBgbG9hZGluZ2A6ICAgVGlsZSBkYXRhIGlzIGluIHRoZSBwcm9jZXNzIG9mIGxvYWRpbmcuXG4gICAgLy8gLSBgbG9hZGVkYDogICAgVGlsZSBkYXRhIGhhcyBiZWVuIGxvYWRlZC4gVGlsZSBjYW4gYmUgcmVuZGVyZWQuXG4gICAgLy8gLSBgcmVsb2FkaW5nYDogVGlsZSBkYXRhIGhhcyBiZWVuIGxvYWRlZCBhbmQgaXMgYmVpbmcgdXBkYXRlZC4gVGlsZSBjYW4gYmUgcmVuZGVyZWQuXG4gICAgLy8gLSBgdW5sb2FkZWRgOiAgVGlsZSBkYXRhIGhhcyBiZWVuIGRlbGV0ZWQuXG4gICAgLy8gLSBgZXJyb3JlZGA6ICAgVGlsZSBkYXRhIHdhcyBub3QgbG9hZGVkIGJlY2F1c2Ugb2YgYW4gZXJyb3IuXG4gICAgdGhpcy5zdGF0ZSA9ICdsb2FkaW5nJztcbn1cblxuVGlsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGRhdGEgb2JqZWN0IHdpdGggYSAnYnVmZmVycycgcHJvcGVydHksIGxvYWQgaXQgaW50b1xuICAgICAqIHRoaXMgdGlsZSdzIGVsZW1lbnRHcm91cHMgYW5kIGJ1ZmZlcnMgcHJvcGVydGllcyBhbmQgc2V0IGxvYWRlZFxuICAgICAqIHRvIHRydWUuIElmIHRoZSBkYXRhIGlzIG51bGwsIGxpa2UgaW4gdGhlIGNhc2Ugb2YgYW4gZW1wdHlcbiAgICAgKiBHZW9KU09OIHRpbGUsIG5vLW9wIGJ1dCBzdGlsbCBzZXQgbG9hZGVkIHRvIHRydWUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbG9hZFZlY3RvckRhdGE6IGZ1bmN0aW9uKGRhdGEsIHN0eWxlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnbG9hZGVkJztcblxuICAgICAgICAvLyBlbXB0eSBHZW9KU09OIHRpbGVcbiAgICAgICAgaWYgKCFkYXRhKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5jb2xsaXNpb25Cb3hBcnJheSA9IG5ldyBDb2xsaXNpb25Cb3hBcnJheShkYXRhLmNvbGxpc2lvbkJveEFycmF5KTtcbiAgICAgICAgdGhpcy5jb2xsaXNpb25UaWxlID0gbmV3IENvbGxpc2lvblRpbGUoZGF0YS5jb2xsaXNpb25UaWxlLCB0aGlzLmNvbGxpc2lvbkJveEFycmF5KTtcbiAgICAgICAgdGhpcy5zeW1ib2xJbnN0YW5jZXNBcnJheSA9IG5ldyBTeW1ib2xJbnN0YW5jZXNBcnJheShkYXRhLnN5bWJvbEluc3RhbmNlc0FycmF5KTtcbiAgICAgICAgdGhpcy5zeW1ib2xRdWFkc0FycmF5ID0gbmV3IFN5bWJvbFF1YWRzQXJyYXkoZGF0YS5zeW1ib2xRdWFkc0FycmF5KTtcbiAgICAgICAgdGhpcy5mZWF0dXJlSW5kZXggPSBuZXcgRmVhdHVyZUluZGV4KGRhdGEuZmVhdHVyZUluZGV4LCBkYXRhLnJhd1RpbGVEYXRhLCB0aGlzLmNvbGxpc2lvblRpbGUpO1xuICAgICAgICB0aGlzLnJhd1RpbGVEYXRhID0gZGF0YS5yYXdUaWxlRGF0YTtcbiAgICAgICAgdGhpcy5idWNrZXRzID0gdW5zZXJpYWxpemVCdWNrZXRzKGRhdGEuYnVja2V0cywgc3R5bGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnaXZlbiBhIGRhdGEgb2JqZWN0IGFuZCBhIEdMIHBhaW50ZXIsIGRlc3Ryb3kgYW5kIHJlLWNyZWF0ZVxuICAgICAqIGFsbCBvZiBpdHMgYnVmZmVycy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWludGVyXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJlbG9hZFN5bWJvbERhdGE6IGZ1bmN0aW9uKGRhdGEsIHBhaW50ZXIsIHN0eWxlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAndW5sb2FkZWQnKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5jb2xsaXNpb25UaWxlID0gbmV3IENvbGxpc2lvblRpbGUoZGF0YS5jb2xsaXNpb25UaWxlLCB0aGlzLmNvbGxpc2lvbkJveEFycmF5KTtcbiAgICAgICAgdGhpcy5mZWF0dXJlSW5kZXguc2V0Q29sbGlzaW9uVGlsZSh0aGlzLmNvbGxpc2lvblRpbGUpO1xuXG4gICAgICAgIC8vIERlc3Ryb3kgYW5kIGRlbGV0ZSBleGlzdGluZyBzeW1ib2wgYnVja2V0c1xuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLmJ1Y2tldHMpIHtcbiAgICAgICAgICAgIHZhciBidWNrZXQgPSB0aGlzLmJ1Y2tldHNbaWRdO1xuICAgICAgICAgICAgaWYgKGJ1Y2tldC50eXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIGJ1Y2tldC5kZXN0cm95KHBhaW50ZXIuZ2wpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmJ1Y2tldHNbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIG5ldyBzeW1ib2wgYnVja2V0c1xuICAgICAgICB1dGlsLmV4dGVuZCh0aGlzLmJ1Y2tldHMsIHVuc2VyaWFsaXplQnVja2V0cyhkYXRhLmJ1Y2tldHMsIHN0eWxlKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc3VyZSB0aGF0IHRoaXMgdGlsZSBkb2Vzbid0IG93biBhbnkgZGF0YSB3aXRoaW4gYSBnaXZlblxuICAgICAqIHBhaW50ZXIsIHNvIHRoYXQgaXQgZG9lc24ndCBjb25zdW1lIGFueSBtZW1vcnkgb3IgbWFpbnRhaW5cbiAgICAgKiBhbnkgcmVmZXJlbmNlcyB0byB0aGUgcGFpbnRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFpbnRlciBnbCBwYWludGVyIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB1bmxvYWRWZWN0b3JEYXRhOiBmdW5jdGlvbihwYWludGVyKSB7XG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuYnVja2V0cykge1xuICAgICAgICAgICAgdmFyIGJ1Y2tldCA9IHRoaXMuYnVja2V0c1tpZF07XG4gICAgICAgICAgICBidWNrZXQuZGVzdHJveShwYWludGVyLmdsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29sbGlzaW9uQm94QXJyYXkgPSBudWxsO1xuICAgICAgICB0aGlzLnN5bWJvbFF1YWRzQXJyYXkgPSBudWxsO1xuICAgICAgICB0aGlzLnN5bWJvbEluc3RhbmNlc0FycmF5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb2xsaXNpb25UaWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mZWF0dXJlSW5kZXggPSBudWxsO1xuICAgICAgICB0aGlzLnJhd1RpbGVEYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5idWNrZXRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICd1bmxvYWRlZCc7XG4gICAgfSxcblxuICAgIHJlZG9QbGFjZW1lbnQ6IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ2xvYWRlZCcgfHwgdGhpcy5zdGF0ZSA9PT0gJ3JlbG9hZGluZycpIHtcbiAgICAgICAgICAgIHRoaXMucmVkb1doZW5Eb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUgPSAncmVsb2FkaW5nJztcblxuICAgICAgICBzb3VyY2UuZGlzcGF0Y2hlci5zZW5kKCdyZWRvIHBsYWNlbWVudCcsIHtcbiAgICAgICAgICAgIHVpZDogdGhpcy51aWQsXG4gICAgICAgICAgICBzb3VyY2U6IHNvdXJjZS5pZCxcbiAgICAgICAgICAgIGFuZ2xlOiBzb3VyY2UubWFwLnRyYW5zZm9ybS5hbmdsZSxcbiAgICAgICAgICAgIHBpdGNoOiBzb3VyY2UubWFwLnRyYW5zZm9ybS5waXRjaCxcbiAgICAgICAgICAgIHNob3dDb2xsaXNpb25Cb3hlczogc291cmNlLm1hcC5zaG93Q29sbGlzaW9uQm94ZXNcbiAgICAgICAgfSwgZG9uZS5iaW5kKHRoaXMpLCB0aGlzLndvcmtlcklEKTtcblxuICAgICAgICBmdW5jdGlvbiBkb25lKF8sIGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMucmVsb2FkU3ltYm9sRGF0YShkYXRhLCBzb3VyY2UubWFwLnBhaW50ZXIsIHNvdXJjZS5tYXAuc3R5bGUpO1xuICAgICAgICAgICAgc291cmNlLmZpcmUoJ3RpbGUubG9hZCcsIHt0aWxlOiB0aGlzfSk7XG5cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnbG9hZGVkJztcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZG9XaGVuRG9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVkb1BsYWNlbWVudChzb3VyY2UpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVkb1doZW5Eb25lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0QnVja2V0OiBmdW5jdGlvbihsYXllcikge1xuICAgICAgICByZXR1cm4gdGhpcy5idWNrZXRzICYmIHRoaXMuYnVja2V0c1tsYXllci5yZWYgfHwgbGF5ZXIuaWRdO1xuICAgIH0sXG5cbiAgICBxdWVyeVNvdXJjZUZlYXR1cmVzOiBmdW5jdGlvbihyZXN1bHQsIHBhcmFtcykge1xuICAgICAgICBpZiAoIXRoaXMucmF3VGlsZURhdGEpIHJldHVybjtcblxuICAgICAgICBpZiAoIXRoaXMudnRMYXllcnMpIHtcbiAgICAgICAgICAgIHRoaXMudnRMYXllcnMgPSBuZXcgdnQuVmVjdG9yVGlsZShuZXcgUHJvdG9idWYobmV3IFVpbnQ4QXJyYXkodGhpcy5yYXdUaWxlRGF0YSkpKS5sYXllcnM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLnZ0TGF5ZXJzLl9nZW9qc29uVGlsZUxheWVyIHx8IHRoaXMudnRMYXllcnNbcGFyYW1zLnNvdXJjZUxheWVyXTtcblxuICAgICAgICBpZiAoIWxheWVyKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGZpbHRlciA9IGZlYXR1cmVGaWx0ZXIocGFyYW1zLmZpbHRlcik7XG4gICAgICAgIHZhciBjb29yZCA9IHsgejogdGhpcy5jb29yZC56LCB4OiB0aGlzLmNvb3JkLngsIHk6IHRoaXMuY29vcmQueSB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlID0gbGF5ZXIuZmVhdHVyZShpKTtcbiAgICAgICAgICAgIGlmIChmaWx0ZXIoZmVhdHVyZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2VvanNvbkZlYXR1cmUgPSBuZXcgR2VvSlNPTkZlYXR1cmUoZmVhdHVyZSwgdGhpcy5jb29yZC56LCB0aGlzLmNvb3JkLngsIHRoaXMuY29vcmQueSk7XG4gICAgICAgICAgICAgICAgZ2VvanNvbkZlYXR1cmUudGlsZSA9IGNvb3JkO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlb2pzb25GZWF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpc1JlbmRlcmFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gJ2xvYWRlZCcgfHwgdGhpcy5zdGF0ZSA9PT0gJ3JlbG9hZGluZyc7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gdW5zZXJpYWxpemVCdWNrZXRzKGlucHV0LCBzdHlsZSkge1xuICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIGNhc2Ugd2hlcmUgdGhlIG1hcCdzIHN0eWxlIGhhcyBiZWVuIHNldCB0byBudWxsIHdoaWxlXG4gICAgLy8gdGhpcyBidWNrZXQgaGFzIGJlZW4gcGFyc2luZy5cbiAgICBpZiAoIXN0eWxlKSByZXR1cm47XG5cbiAgICB2YXIgb3V0cHV0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGF5ZXIgPSBzdHlsZS5nZXRMYXllcihpbnB1dFtpXS5sYXllcklkKTtcbiAgICAgICAgaWYgKCFsYXllcikgY29udGludWU7XG5cbiAgICAgICAgdmFyIGJ1Y2tldCA9IEJ1Y2tldC5jcmVhdGUodXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgbGF5ZXI6IGxheWVyLFxuICAgICAgICAgICAgY2hpbGRMYXllcnM6IGlucHV0W2ldLmNoaWxkTGF5ZXJJZHNcbiAgICAgICAgICAgICAgICAubWFwKHN0eWxlLmdldExheWVyLmJpbmQoc3R5bGUpKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24obGF5ZXIpIHsgcmV0dXJuIGxheWVyOyB9KVxuICAgICAgICB9LCBpbnB1dFtpXSkpO1xuICAgICAgICBvdXRwdXRbYnVja2V0LmlkXSA9IGJ1Y2tldDtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIFdob29UUyA9IHJlcXVpcmUoJ3dob290cy1qcycpO1xudmFyIENvb3JkaW5hdGUgPSByZXF1aXJlKCcuLi9nZW8vY29vcmRpbmF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbGVDb29yZDtcblxuZnVuY3Rpb24gVGlsZUNvb3JkKHosIHgsIHksIHcpIHtcbiAgICBhc3NlcnQoIWlzTmFOKHopICYmIHogPj0gMCAmJiB6ICUgMSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFpc05hTih4KSAmJiB4ID49IDAgJiYgeCAlIDEgPT09IDApO1xuICAgIGFzc2VydCghaXNOYU4oeSkgJiYgeSA+PSAwICYmIHkgJSAxID09PSAwKTtcblxuICAgIGlmIChpc05hTih3KSkgdyA9IDA7XG5cbiAgICB0aGlzLnogPSArejtcbiAgICB0aGlzLnggPSAreDtcbiAgICB0aGlzLnkgPSAreTtcbiAgICB0aGlzLncgPSArdztcblxuICAgIC8vIGNhbGN1bGF0ZSBpZFxuICAgIHcgKj0gMjtcbiAgICBpZiAodyA8IDApIHcgPSB3ICogLTEgLSAxO1xuICAgIHZhciBkaW0gPSAxIDw8IHRoaXMuejtcbiAgICB0aGlzLmlkID0gKChkaW0gKiBkaW0gKiB3ICsgZGltICogdGhpcy55ICsgdGhpcy54KSAqIDMyKSArIHRoaXMuejtcblxuICAgIC8vIGZvciBjYWNoaW5nIHBvcyBtYXRyaXggY2FsY3VsYXRpb24gd2hlbiByZW5kZXJpbmdcbiAgICB0aGlzLnBvc01hdHJpeCA9IG51bGw7XG59XG5cblRpbGVDb29yZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy56ICsgXCIvXCIgKyB0aGlzLnggKyBcIi9cIiArIHRoaXMueTtcbn07XG5cblRpbGVDb29yZC5wcm90b3R5cGUudG9Db29yZGluYXRlID0gZnVuY3Rpb24oc291cmNlTWF4Wm9vbSkge1xuICAgIHZhciB6b29tID0gTWF0aC5taW4odGhpcy56LCBzb3VyY2VNYXhab29tKTtcbiAgICB2YXIgdGlsZVNjYWxlID0gTWF0aC5wb3coMiwgem9vbSk7XG4gICAgdmFyIHJvdyA9IHRoaXMueTtcbiAgICB2YXIgY29sdW1uID0gdGhpcy54ICsgdGlsZVNjYWxlICogdGhpcy53O1xuICAgIHJldHVybiBuZXcgQ29vcmRpbmF0ZShjb2x1bW4sIHJvdywgem9vbSk7XG59O1xuXG4vLyBQYXJzZSBhIHBhY2tlZCBpbnRlZ2VyIGlkIGludG8gYSBUaWxlQ29vcmQgb2JqZWN0XG5UaWxlQ29vcmQuZnJvbUlEID0gZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgeiA9IGlkICUgMzIsIGRpbSA9IDEgPDwgejtcbiAgICB2YXIgeHkgPSAoKGlkIC0geikgLyAzMik7XG4gICAgdmFyIHggPSB4eSAlIGRpbSwgeSA9ICgoeHkgLSB4KSAvIGRpbSkgJSBkaW07XG4gICAgdmFyIHcgPSBNYXRoLmZsb29yKHh5IC8gKGRpbSAqIGRpbSkpO1xuICAgIGlmICh3ICUgMiAhPT0gMCkgdyA9IHcgKiAtMSAtIDE7XG4gICAgdyAvPSAyO1xuICAgIHJldHVybiBuZXcgVGlsZUNvb3JkKHosIHgsIHksIHcpO1xufTtcblxuZnVuY3Rpb24gZ2V0UXVhZGtleSh6LCB4LCB5KSB7XG4gICAgdmFyIHF1YWRrZXkgPSAnJywgbWFzaztcbiAgICBmb3IgKHZhciBpID0gejsgaSA+IDA7IGktLSkge1xuICAgICAgICBtYXNrID0gMSA8PCAoaSAtIDEpO1xuICAgICAgICBxdWFka2V5ICs9ICgoeCAmIG1hc2sgPyAxIDogMCkgKyAoeSAmIG1hc2sgPyAyIDogMCkpO1xuICAgIH1cbiAgICByZXR1cm4gcXVhZGtleTtcbn1cblxuLy8gZ2l2ZW4gYSBsaXN0IG9mIHVybHMsIGNob29zZSBhIHVybCB0ZW1wbGF0ZSBhbmQgcmV0dXJuIGEgdGlsZSBVUkxcblRpbGVDb29yZC5wcm90b3R5cGUudXJsID0gZnVuY3Rpb24odXJscywgc291cmNlTWF4Wm9vbSwgc2NoZW1lKSB7XG4gICAgdmFyIGJib3ggPSBXaG9vVFMuZ2V0VGlsZUJCb3godGhpcy54LCB0aGlzLnksIHRoaXMueik7XG4gICAgdmFyIHF1YWRrZXkgPSBnZXRRdWFka2V5KHRoaXMueiwgdGhpcy54LCB0aGlzLnkpO1xuXG4gICAgcmV0dXJuIHVybHNbKHRoaXMueCArIHRoaXMueSkgJSB1cmxzLmxlbmd0aF1cbiAgICAgICAgLnJlcGxhY2UoJ3twcmVmaXh9JywgKHRoaXMueCAlIDE2KS50b1N0cmluZygxNikgKyAodGhpcy55ICUgMTYpLnRvU3RyaW5nKDE2KSlcbiAgICAgICAgLnJlcGxhY2UoJ3t6fScsIE1hdGgubWluKHRoaXMueiwgc291cmNlTWF4Wm9vbSB8fCB0aGlzLnopKVxuICAgICAgICAucmVwbGFjZSgne3h9JywgdGhpcy54KVxuICAgICAgICAucmVwbGFjZSgne3l9Jywgc2NoZW1lID09PSAndG1zJyA/IChNYXRoLnBvdygyLCB0aGlzLnopIC0gdGhpcy55IC0gMSkgOiB0aGlzLnkpXG4gICAgICAgIC5yZXBsYWNlKCd7cXVhZGtleX0nLCBxdWFka2V5KVxuICAgICAgICAucmVwbGFjZSgne2Jib3gtZXBzZy0zODU3fScsIGJib3gpO1xufTtcblxuLy8gUmV0dXJuIHRoZSBjb29yZGluYXRlIG9mIHRoZSBwYXJlbnQgdGlsZVxuVGlsZUNvb3JkLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbihzb3VyY2VNYXhab29tKSB7XG4gICAgaWYgKHRoaXMueiA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyB0aGUgaWQgcmVwcmVzZW50cyBhbiBvdmVyc2NhbGVkIHRpbGUsIHJldHVybiB0aGUgc2FtZSBjb29yZGluYXRlcyB3aXRoIGEgbG93ZXIgelxuICAgIGlmICh0aGlzLnogPiBzb3VyY2VNYXhab29tKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGlsZUNvb3JkKHRoaXMueiAtIDEsIHRoaXMueCwgdGhpcy55LCB0aGlzLncpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVGlsZUNvb3JkKHRoaXMueiAtIDEsIE1hdGguZmxvb3IodGhpcy54IC8gMiksIE1hdGguZmxvb3IodGhpcy55IC8gMiksIHRoaXMudyk7XG59O1xuXG5UaWxlQ29vcmQucHJvdG90eXBlLndyYXBwZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFRpbGVDb29yZCh0aGlzLnosIHRoaXMueCwgdGhpcy55LCAwKTtcbn07XG5cbi8vIFJldHVybiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHRpbGUncyBjaGlsZHJlblxuVGlsZUNvb3JkLnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uKHNvdXJjZU1heFpvb20pIHtcblxuICAgIGlmICh0aGlzLnogPj0gc291cmNlTWF4Wm9vbSkge1xuICAgICAgICAvLyByZXR1cm4gYSBzaW5nbGUgdGlsZSBjb29yZCByZXByZXNlbnRpbmcgYSBhbiBvdmVyc2NhbGVkIHRpbGVcbiAgICAgICAgcmV0dXJuIFtuZXcgVGlsZUNvb3JkKHRoaXMueiArIDEsIHRoaXMueCwgdGhpcy55LCB0aGlzLncpXTtcbiAgICB9XG5cbiAgICB2YXIgeiA9IHRoaXMueiArIDE7XG4gICAgdmFyIHggPSB0aGlzLnggKiAyO1xuICAgIHZhciB5ID0gdGhpcy55ICogMjtcbiAgICByZXR1cm4gW1xuICAgICAgICBuZXcgVGlsZUNvb3JkKHosIHgsIHksIHRoaXMudyksXG4gICAgICAgIG5ldyBUaWxlQ29vcmQoeiwgeCArIDEsIHksIHRoaXMudyksXG4gICAgICAgIG5ldyBUaWxlQ29vcmQoeiwgeCwgeSArIDEsIHRoaXMudyksXG4gICAgICAgIG5ldyBUaWxlQ29vcmQoeiwgeCArIDEsIHkgKyAxLCB0aGlzLncpXG4gICAgXTtcbn07XG5cbi8vIFRha2VuIGZyb20gcG9seW1hcHMgc3JjL0xheWVyLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2ltcGxlZ2VvL3BvbHltYXBzL2Jsb2IvbWFzdGVyL3NyYy9MYXllci5qcyNMMzMzLUwzODNcblxuZnVuY3Rpb24gZWRnZShhLCBiKSB7XG4gICAgaWYgKGEucm93ID4gYi5yb3cpIHsgdmFyIHQgPSBhOyBhID0gYjsgYiA9IHQ7IH1cbiAgICByZXR1cm4ge1xuICAgICAgICB4MDogYS5jb2x1bW4sXG4gICAgICAgIHkwOiBhLnJvdyxcbiAgICAgICAgeDE6IGIuY29sdW1uLFxuICAgICAgICB5MTogYi5yb3csXG4gICAgICAgIGR4OiBiLmNvbHVtbiAtIGEuY29sdW1uLFxuICAgICAgICBkeTogYi5yb3cgLSBhLnJvd1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIHNjYW5TcGFucyhlMCwgZTEsIHltaW4sIHltYXgsIHNjYW5MaW5lKSB7XG4gICAgdmFyIHkwID0gTWF0aC5tYXgoeW1pbiwgTWF0aC5mbG9vcihlMS55MCkpO1xuICAgIHZhciB5MSA9IE1hdGgubWluKHltYXgsIE1hdGguY2VpbChlMS55MSkpO1xuXG4gICAgLy8gc29ydCBlZGdlcyBieSB4LWNvb3JkaW5hdGVcbiAgICBpZiAoKGUwLngwID09PSBlMS54MCAmJiBlMC55MCA9PT0gZTEueTApID9cbiAgICAgICAgICAgIChlMC54MCArIGUxLmR5IC8gZTAuZHkgKiBlMC5keCA8IGUxLngxKSA6XG4gICAgICAgICAgICAoZTAueDEgLSBlMS5keSAvIGUwLmR5ICogZTAuZHggPCBlMS54MCkpIHtcbiAgICAgICAgdmFyIHQgPSBlMDsgZTAgPSBlMTsgZTEgPSB0O1xuICAgIH1cblxuICAgIC8vIHNjYW4gbGluZXMhXG4gICAgdmFyIG0wID0gZTAuZHggLyBlMC5keTtcbiAgICB2YXIgbTEgPSBlMS5keCAvIGUxLmR5O1xuICAgIHZhciBkMCA9IGUwLmR4ID4gMDsgLy8gdXNlIHkgKyAxIHRvIGNvbXB1dGUgeDBcbiAgICB2YXIgZDEgPSBlMS5keCA8IDA7IC8vIHVzZSB5ICsgMSB0byBjb21wdXRlIHgxXG4gICAgZm9yICh2YXIgeSA9IHkwOyB5IDwgeTE7IHkrKykge1xuICAgICAgICB2YXIgeDAgPSBtMCAqIE1hdGgubWF4KDAsIE1hdGgubWluKGUwLmR5LCB5ICsgZDAgLSBlMC55MCkpICsgZTAueDA7XG4gICAgICAgIHZhciB4MSA9IG0xICogTWF0aC5tYXgoMCwgTWF0aC5taW4oZTEuZHksIHkgKyBkMSAtIGUxLnkwKSkgKyBlMS54MDtcbiAgICAgICAgc2NhbkxpbmUoTWF0aC5mbG9vcih4MSksIE1hdGguY2VpbCh4MCksIHkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2NhblRyaWFuZ2xlKGEsIGIsIGMsIHltaW4sIHltYXgsIHNjYW5MaW5lKSB7XG4gICAgdmFyIGFiID0gZWRnZShhLCBiKSxcbiAgICAgICAgYmMgPSBlZGdlKGIsIGMpLFxuICAgICAgICBjYSA9IGVkZ2UoYywgYSk7XG5cbiAgICB2YXIgdDtcblxuICAgIC8vIHNvcnQgZWRnZXMgYnkgeS1sZW5ndGhcbiAgICBpZiAoYWIuZHkgPiBiYy5keSkgeyB0ID0gYWI7IGFiID0gYmM7IGJjID0gdDsgfVxuICAgIGlmIChhYi5keSA+IGNhLmR5KSB7IHQgPSBhYjsgYWIgPSBjYTsgY2EgPSB0OyB9XG4gICAgaWYgKGJjLmR5ID4gY2EuZHkpIHsgdCA9IGJjOyBiYyA9IGNhOyBjYSA9IHQ7IH1cblxuICAgIC8vIHNjYW4gc3BhbiEgc2NhbiBzcGFuIVxuICAgIGlmIChhYi5keSkgc2NhblNwYW5zKGNhLCBhYiwgeW1pbiwgeW1heCwgc2NhbkxpbmUpO1xuICAgIGlmIChiYy5keSkgc2NhblNwYW5zKGNhLCBiYywgeW1pbiwgeW1heCwgc2NhbkxpbmUpO1xufVxuXG5UaWxlQ29vcmQuY292ZXIgPSBmdW5jdGlvbih6LCBib3VuZHMsIGFjdHVhbFopIHtcbiAgICB2YXIgdGlsZXMgPSAxIDw8IHo7XG4gICAgdmFyIHQgPSB7fTtcblxuICAgIGZ1bmN0aW9uIHNjYW5MaW5lKHgwLCB4MSwgeSkge1xuICAgICAgICB2YXIgeCwgd3gsIGNvb3JkO1xuICAgICAgICBpZiAoeSA+PSAwICYmIHkgPD0gdGlsZXMpIHtcbiAgICAgICAgICAgIGZvciAoeCA9IHgwOyB4IDwgeDE7IHgrKykge1xuICAgICAgICAgICAgICAgIHd4ID0gKHggJSB0aWxlcyArIHRpbGVzKSAlIHRpbGVzO1xuICAgICAgICAgICAgICAgIGNvb3JkID0gbmV3IFRpbGVDb29yZChhY3R1YWxaLCB3eCwgeSwgTWF0aC5mbG9vcih4IC8gdGlsZXMpKTtcbiAgICAgICAgICAgICAgICB0W2Nvb3JkLmlkXSA9IGNvb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGl2aWRlIHRoZSBzY3JlZW4gdXAgaW4gdHdvIHRyaWFuZ2xlcyBhbmQgc2NhbiBlYWNoIG9mIHRoZW06XG4gICAgLy8gKy0tLS9cbiAgICAvLyB8IC8gfFxuICAgIC8vIC8tLS0rXG4gICAgc2NhblRyaWFuZ2xlKGJvdW5kc1swXSwgYm91bmRzWzFdLCBib3VuZHNbMl0sIDAsIHRpbGVzLCBzY2FuTGluZSk7XG4gICAgc2NhblRyaWFuZ2xlKGJvdW5kc1syXSwgYm91bmRzWzNdLCBib3VuZHNbMF0sIDAsIHRpbGVzLCBzY2FuTGluZSk7XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXModCkubWFwKGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiB0W2lkXTtcbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIGxvYWRUaWxlSlNPTiA9IHJlcXVpcmUoJy4vbG9hZF90aWxlanNvbicpO1xudmFyIG5vcm1hbGl6ZVVSTCA9IHJlcXVpcmUoJy4uL3V0aWwvbWFwYm94Jykubm9ybWFsaXplVGlsZVVSTDtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3JUaWxlU291cmNlO1xuXG5mdW5jdGlvbiBWZWN0b3JUaWxlU291cmNlKGlkLCBvcHRpb25zLCBkaXNwYXRjaGVyKSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXI7XG4gICAgdXRpbC5leHRlbmQodGhpcywgdXRpbC5waWNrKG9wdGlvbnMsIFsndXJsJywgJ3NjaGVtZScsICd0aWxlU2l6ZSddKSk7XG4gICAgdGhpcy5fb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHsgdHlwZTogJ3ZlY3RvcicgfSwgb3B0aW9ucyk7XG5cbiAgICBpZiAodGhpcy50aWxlU2l6ZSAhPT0gNTEyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndmVjdG9yIHRpbGUgc291cmNlcyBtdXN0IGhhdmUgYSB0aWxlU2l6ZSBvZiA1MTInKTtcbiAgICB9XG5cbiAgICBsb2FkVGlsZUpTT04ob3B0aW9ucywgZnVuY3Rpb24gKGVyciwgdGlsZUpTT04pIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5leHRlbmQodGhpcywgdGlsZUpTT04pO1xuICAgICAgICB0aGlzLmZpcmUoJ2xvYWQnKTtcbiAgICB9LmJpbmQodGhpcykpO1xufVxuXG5WZWN0b3JUaWxlU291cmNlLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChFdmVudGVkLCB7XG4gICAgbWluem9vbTogMCxcbiAgICBtYXh6b29tOiAyMixcbiAgICBzY2hlbWU6ICd4eXonLFxuICAgIHRpbGVTaXplOiA1MTIsXG4gICAgcmVwYXJzZU92ZXJzY2FsZWQ6IHRydWUsXG4gICAgaXNUaWxlQ2xpcHBlZDogdHJ1ZSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1dGlsLmV4dGVuZCh7fSwgdGhpcy5fb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIGxvYWRUaWxlOiBmdW5jdGlvbih0aWxlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3ZlcnNjYWxpbmcgPSB0aWxlLmNvb3JkLnogPiB0aGlzLm1heHpvb20gPyBNYXRoLnBvdygyLCB0aWxlLmNvb3JkLnogLSB0aGlzLm1heHpvb20pIDogMTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHVybDogbm9ybWFsaXplVVJMKHRpbGUuY29vcmQudXJsKHRoaXMudGlsZXMsIHRoaXMubWF4em9vbSwgdGhpcy5zY2hlbWUpLCB0aGlzLnVybCksXG4gICAgICAgICAgICB1aWQ6IHRpbGUudWlkLFxuICAgICAgICAgICAgY29vcmQ6IHRpbGUuY29vcmQsXG4gICAgICAgICAgICB6b29tOiB0aWxlLmNvb3JkLnosXG4gICAgICAgICAgICB0aWxlU2l6ZTogdGhpcy50aWxlU2l6ZSAqIG92ZXJzY2FsaW5nLFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLmlkLFxuICAgICAgICAgICAgb3ZlcnNjYWxpbmc6IG92ZXJzY2FsaW5nLFxuICAgICAgICAgICAgYW5nbGU6IHRoaXMubWFwLnRyYW5zZm9ybS5hbmdsZSxcbiAgICAgICAgICAgIHBpdGNoOiB0aGlzLm1hcC50cmFuc2Zvcm0ucGl0Y2gsXG4gICAgICAgICAgICBzaG93Q29sbGlzaW9uQm94ZXM6IHRoaXMubWFwLnNob3dDb2xsaXNpb25Cb3hlc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aWxlLndvcmtlcklEKSB7XG4gICAgICAgICAgICBpZiAodGlsZS5zdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gc2NoZWR1bGUgdGlsZSByZWxvYWRpbmcgYWZ0ZXIgaXQgaGFzIGJlZW4gbG9hZGVkXG4gICAgICAgICAgICAgICAgdGlsZS5yZWxvYWRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucmF3VGlsZURhdGEgPSB0aWxlLnJhd1RpbGVEYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlci5zZW5kKCdyZWxvYWQgdGlsZScsIHBhcmFtcywgZG9uZS5iaW5kKHRoaXMpLCB0aWxlLndvcmtlcklEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbGUud29ya2VySUQgPSB0aGlzLmRpc3BhdGNoZXIuc2VuZCgnbG9hZCB0aWxlJywgcGFyYW1zLCBkb25lLmJpbmQodGhpcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZG9uZShlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh0aWxlLmFib3J0ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRpbGUubG9hZFZlY3RvckRhdGEoZGF0YSwgdGhpcy5tYXAuc3R5bGUpO1xuXG4gICAgICAgICAgICBpZiAodGlsZS5yZWRvV2hlbkRvbmUpIHtcbiAgICAgICAgICAgICAgICB0aWxlLnJlZG9XaGVuRG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRpbGUucmVkb1BsYWNlbWVudCh0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG5cbiAgICAgICAgICAgIGlmICh0aWxlLnJlbG9hZENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkVGlsZSh0aWxlLCB0aWxlLnJlbG9hZENhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB0aWxlLnJlbG9hZENhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhYm9ydFRpbGU6IGZ1bmN0aW9uKHRpbGUpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnNlbmQoJ2Fib3J0IHRpbGUnLCB7IHVpZDogdGlsZS51aWQsIHNvdXJjZTogdGhpcy5pZCB9LCBudWxsLCB0aWxlLndvcmtlcklEKTtcbiAgICB9LFxuXG4gICAgdW5sb2FkVGlsZTogZnVuY3Rpb24odGlsZSkge1xuICAgICAgICB0aWxlLnVubG9hZFZlY3RvckRhdGEodGhpcy5tYXAucGFpbnRlcik7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlci5zZW5kKCdyZW1vdmUgdGlsZScsIHsgdWlkOiB0aWxlLnVpZCwgc291cmNlOiB0aGlzLmlkIH0sIG51bGwsIHRpbGUud29ya2VySUQpO1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFqYXggPSByZXF1aXJlKCcuLi91dGlsL2FqYXgnKTtcbnZhciB2dCA9IHJlcXVpcmUoJ3ZlY3Rvci10aWxlJyk7XG52YXIgUHJvdG9idWYgPSByZXF1aXJlKCdwYmYnKTtcbnZhciBXb3JrZXJUaWxlID0gcmVxdWlyZSgnLi93b3JrZXJfdGlsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGVXb3JrZXJTb3VyY2U7XG5cbi8qKlxuICogVGhlIHtAbGluayBXb3JrZXJTb3VyY2V9IGltcGxlbWVudGF0aW9uIHRoYXQgc3VwcG9ydHMge0BsaW5rIFZlY3RvclRpbGVTb3VyY2V9LlxuICogVGhpcyBjbGFzcyBpcyBkZXNpZ25lZCB0byBiZSBlYXNpbHkgcmV1c2VkIHRvIHN1cHBvcnQgY3VzdG9tIHNvdXJjZSB0eXBlc1xuICogZm9yIGRhdGEgZm9ybWF0cyB0aGF0IGNhbiBiZSBwYXJzZWQvY29udmVydGVkIGludG8gYW4gaW4tbWVtb3J5IFZlY3RvclRpbGVcbiAqIHJlcHJlc2VudGF0aW9uLiAgVG8gZG8gc28sIGNyZWF0ZSBpdCB3aXRoXG4gKiBgbmV3IFZlY3RvclRpbGVXb3JrZXJTb3VyY2UoYWN0b3IsIHN0eWxlTGF5ZXJzLCBjdXN0b21Mb2FkVmVjdG9yRGF0YUZ1bmN0aW9uKWAuXG4gKlxuICogQGNsYXNzIFZlY3RvclRpbGVXb3JrZXJTb3VyY2VcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbG9hZFZlY3RvckRhdGFdIE9wdGlvbmFsIG1ldGhvZCBmb3IgY3VzdG9tIGxvYWRpbmcgb2YgYSBWZWN0b3JUaWxlIG9iamVjdCBiYXNlZCBvbiBwYXJhbWV0ZXJzIHBhc3NlZCBmcm9tIHRoZSBtYWluLXRocmVhZCBTb3VyY2UuICBTZWUge0BsaW5rIFZlY3RvclRpbGVXb3JrZXJTb3VyY2UjbG9hZFRpbGV9LiAgVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2ltcGx5IGxvYWRzIHRoZSBwYmYgYXQgYHBhcmFtcy51cmxgLlxuICovXG5mdW5jdGlvbiBWZWN0b3JUaWxlV29ya2VyU291cmNlIChhY3Rvciwgc3R5bGVMYXllcnMsIGxvYWRWZWN0b3JEYXRhKSB7XG4gICAgdGhpcy5hY3RvciA9IGFjdG9yO1xuICAgIHRoaXMuc3R5bGVMYXllcnMgPSBzdHlsZUxheWVycztcblxuICAgIGlmIChsb2FkVmVjdG9yRGF0YSkgeyB0aGlzLmxvYWRWZWN0b3JEYXRhID0gbG9hZFZlY3RvckRhdGE7IH1cblxuICAgIHRoaXMubG9hZGluZyA9IHt9O1xuICAgIHRoaXMubG9hZGVkID0ge307XG59XG5cblZlY3RvclRpbGVXb3JrZXJTb3VyY2UucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMge0BsaW5rIFdvcmtlclNvdXJjZSNsb2FkVGlsZX0uICBEZWxlZ2F0ZXMgdG8ge0BsaW5rIFZlY3RvclRpbGVXb3JrZXJTb3VyY2UjbG9hZFZlY3RvckRhdGF9ICh3aGljaCBieSBkZWZhdWx0IGV4cGVjdHMgYSBgcGFyYW1zLnVybGAgcHJvcGVydHkpIGZvciBmZXRjaGluZyBhbmQgcHJvZHVjaW5nIGEgVmVjdG9yVGlsZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5zb3VyY2UgVGhlIGlkIG9mIHRoZSBzb3VyY2UgZm9yIHdoaWNoIHdlJ3JlIGxvYWRpbmcgdGhpcyB0aWxlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMudWlkIFRoZSBVSUQgZm9yIHRoaXMgdGlsZS5cbiAgICAgKiBAcGFyYW0ge1RpbGVDb29yZH0gcGFyYW1zLmNvb3JkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy56b29tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5vdmVyc2NhbGluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuYW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnBpdGNoXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMuc2hvd0NvbGxpc2lvbkJveGVzXG4gICAgICovXG4gICAgbG9hZFRpbGU6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHBhcmFtcy5zb3VyY2UsXG4gICAgICAgICAgICB1aWQgPSBwYXJhbXMudWlkO1xuXG4gICAgICAgIGlmICghdGhpcy5sb2FkaW5nW3NvdXJjZV0pXG4gICAgICAgICAgICB0aGlzLmxvYWRpbmdbc291cmNlXSA9IHt9O1xuXG4gICAgICAgIHZhciB0aWxlID0gdGhpcy5sb2FkaW5nW3NvdXJjZV1bdWlkXSA9IG5ldyBXb3JrZXJUaWxlKHBhcmFtcyk7XG4gICAgICAgIHRpbGUuYWJvcnQgPSB0aGlzLmxvYWRWZWN0b3JEYXRhKHBhcmFtcywgZG9uZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICBmdW5jdGlvbiBkb25lKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubG9hZGluZ1tzb3VyY2VdW3VpZF07XG5cbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgaWYgKCFkYXRhKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbCk7XG5cbiAgICAgICAgICAgIHRpbGUuZGF0YSA9IGRhdGEudGlsZTtcbiAgICAgICAgICAgIHRpbGUucGFyc2UodGlsZS5kYXRhLCB0aGlzLnN0eWxlTGF5ZXJzLmdldExheWVyRmFtaWxpZXMoKSwgdGhpcy5hY3RvciwgZGF0YS5yYXdUaWxlRGF0YSwgY2FsbGJhY2spO1xuXG4gICAgICAgICAgICB0aGlzLmxvYWRlZFtzb3VyY2VdID0gdGhpcy5sb2FkZWRbc291cmNlXSB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVkW3NvdXJjZV1bdWlkXSA9IHRpbGU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyB7QGxpbmsgV29ya2VyU291cmNlI3JlbG9hZFRpbGV9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuc291cmNlIFRoZSBpZCBvZiB0aGUgc291cmNlIGZvciB3aGljaCB3ZSdyZSBsb2FkaW5nIHRoaXMgdGlsZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnVpZCBUaGUgVUlEIGZvciB0aGlzIHRpbGUuXG4gICAgICovXG4gICAgcmVsb2FkVGlsZTogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgbG9hZGVkID0gdGhpcy5sb2FkZWRbcGFyYW1zLnNvdXJjZV0sXG4gICAgICAgICAgICB1aWQgPSBwYXJhbXMudWlkO1xuICAgICAgICBpZiAobG9hZGVkICYmIGxvYWRlZFt1aWRdKSB7XG4gICAgICAgICAgICB2YXIgdGlsZSA9IGxvYWRlZFt1aWRdO1xuICAgICAgICAgICAgdGlsZS5wYXJzZSh0aWxlLmRhdGEsIHRoaXMuc3R5bGVMYXllcnMuZ2V0TGF5ZXJGYW1pbGllcygpLCB0aGlzLmFjdG9yLCBwYXJhbXMucmF3VGlsZURhdGEsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIHtAbGluayBXb3JrZXJTb3VyY2UjYWJvcnRUaWxlfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnNvdXJjZSBUaGUgaWQgb2YgdGhlIHNvdXJjZSBmb3Igd2hpY2ggd2UncmUgbG9hZGluZyB0aGlzIHRpbGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy51aWQgVGhlIFVJRCBmb3IgdGhpcyB0aWxlLlxuICAgICAqL1xuICAgIGFib3J0VGlsZTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHZhciBsb2FkaW5nID0gdGhpcy5sb2FkaW5nW3BhcmFtcy5zb3VyY2VdLFxuICAgICAgICAgICAgdWlkID0gcGFyYW1zLnVpZDtcbiAgICAgICAgaWYgKGxvYWRpbmcgJiYgbG9hZGluZ1t1aWRdICYmIGxvYWRpbmdbdWlkXS5hYm9ydCkge1xuICAgICAgICAgICAgbG9hZGluZ1t1aWRdLmFib3J0KCk7XG4gICAgICAgICAgICBkZWxldGUgbG9hZGluZ1t1aWRdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMge0BsaW5rIFdvcmtlclNvdXJjZSNyZW1vdmVUaWxlfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnNvdXJjZSBUaGUgaWQgb2YgdGhlIHNvdXJjZSBmb3Igd2hpY2ggd2UncmUgbG9hZGluZyB0aGlzIHRpbGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy51aWQgVGhlIFVJRCBmb3IgdGhpcyB0aWxlLlxuICAgICAqL1xuICAgIHJlbW92ZVRpbGU6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgbG9hZGVkID0gdGhpcy5sb2FkZWRbcGFyYW1zLnNvdXJjZV0sXG4gICAgICAgICAgICB1aWQgPSBwYXJhbXMudWlkO1xuICAgICAgICBpZiAobG9hZGVkICYmIGxvYWRlZFt1aWRdKSB7XG4gICAgICAgICAgICBkZWxldGUgbG9hZGVkW3VpZF07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMudXJsIFRoZSBVUkwgb2YgdGhlIHRpbGUgUEJGIHRvIGxvYWQuXG4gICAgICovXG4gICAgbG9hZFZlY3RvckRhdGE6IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB4aHIgPSBhamF4LmdldEFycmF5QnVmZmVyKHBhcmFtcy51cmwsIGRvbmUuYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhYm9ydCAoKSB7IHhoci5hYm9ydCgpOyB9O1xuICAgICAgICBmdW5jdGlvbiBkb25lKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKGVycikgeyByZXR1cm4gY2FsbGJhY2soZXJyKTsgfVxuICAgICAgICAgICAgdmFyIHRpbGUgPSAgbmV3IHZ0LlZlY3RvclRpbGUobmV3IFByb3RvYnVmKG5ldyBVaW50OEFycmF5KGRhdGEpKSk7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHsgdGlsZTogdGlsZSwgcmF3VGlsZURhdGE6IGRhdGEgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVkb1BsYWNlbWVudDogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgbG9hZGVkID0gdGhpcy5sb2FkZWRbcGFyYW1zLnNvdXJjZV0sXG4gICAgICAgICAgICBsb2FkaW5nID0gdGhpcy5sb2FkaW5nW3BhcmFtcy5zb3VyY2VdLFxuICAgICAgICAgICAgdWlkID0gcGFyYW1zLnVpZDtcblxuICAgICAgICBpZiAobG9hZGVkICYmIGxvYWRlZFt1aWRdKSB7XG4gICAgICAgICAgICB2YXIgdGlsZSA9IGxvYWRlZFt1aWRdO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRpbGUucmVkb1BsYWNlbWVudChwYXJhbXMuYW5nbGUsIHBhcmFtcy5waXRjaCwgcGFyYW1zLnNob3dDb2xsaXNpb25Cb3hlcyk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0LnJlc3VsdCwgcmVzdWx0LnRyYW5zZmVyYWJsZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAobG9hZGluZyAmJiBsb2FkaW5nW3VpZF0pIHtcbiAgICAgICAgICAgIGxvYWRpbmdbdWlkXS5hbmdsZSA9IHBhcmFtcy5hbmdsZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgVGlsZUNvb3JkID0gcmVxdWlyZSgnLi90aWxlX2Nvb3JkJyk7XG52YXIgTG5nTGF0ID0gcmVxdWlyZSgnLi4vZ2VvL2xuZ19sYXQnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG52YXIgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZCcpO1xudmFyIGFqYXggPSByZXF1aXJlKCcuLi91dGlsL2FqYXgnKTtcbnZhciBFWFRFTlQgPSByZXF1aXJlKCcuLi9kYXRhL2J1Y2tldCcpLkVYVEVOVDtcbnZhciBSYXN0ZXJCb3VuZHNBcnJheSA9IHJlcXVpcmUoJy4uL3JlbmRlci9kcmF3X3Jhc3RlcicpLlJhc3RlckJvdW5kc0FycmF5O1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJy4uL2RhdGEvYnVmZmVyJyk7XG52YXIgVmVydGV4QXJyYXlPYmplY3QgPSByZXF1aXJlKCcuLi9yZW5kZXIvdmVydGV4X2FycmF5X29iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZGVvU291cmNlO1xuXG4vKipcbiAqIEEgZGF0YSBzb3VyY2UgY29udGFpbmluZyB2aWRlby5cbiAqIChTZWUgdGhlIFtTdHlsZSBTcGVjaWZpY2F0aW9uXShodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1zdHlsZS1zcGVjLyNzb3VyY2VzLXZpZGVvKSBmb3IgZGV0YWlsZWQgZG9jdW1lbnRhdGlvbiBvZiBvcHRpb25zLilcbiAqIEBpbnRlcmZhY2UgVmlkZW9Tb3VyY2VcbiAqIEBleGFtcGxlXG4gKiAvLyBhZGQgdG8gbWFwXG4gKiBtYXAuYWRkU291cmNlKCdzb21lIGlkJywge1xuICogICAgdHlwZTogJ3ZpZGVvJyxcbiAqICAgIHVybDogW1xuICogICAgICAgICdodHRwczovL3d3dy5tYXBib3guY29tL3ZpZGVvcy9iYWx0aW1vcmUtc21va2UubXA0JyxcbiAqICAgICAgICAnaHR0cHM6Ly93d3cubWFwYm94LmNvbS92aWRlb3MvYmFsdGltb3JlLXNtb2tlLndlYm0nXG4gKiAgICBdLFxuICogICAgY29vcmRpbmF0ZXM6IFtcbiAqICAgICAgICBbLTc2LjU0LCAzOS4xOF0sXG4gKiAgICAgICAgWy03Ni41MiwgMzkuMThdLFxuICogICAgICAgIFstNzYuNTIsIDM5LjE3XSxcbiAqICAgICAgICBbLTc2LjU0LCAzOS4xN11cbiAqICAgIF1cbiAqIH0pO1xuICpcbiAqIC8vIHVwZGF0ZVxuICogdmFyIG15U291cmNlID0gbWFwLmdldFNvdXJjZSgnc29tZSBpZCcpO1xuICogbXlTb3VyY2Uuc2V0Q29vcmRpbmF0ZXMoW1xuICogICAgIFstNzYuNTQzMzU3MzcyMjgzOTQsIDM5LjE4NTc5OTA3MjI5NzQ4XSxcbiAqICAgICBbLTc2LjUyODAzNjU5NDM5MDg3LCAzOS4xODM4MzY0ODQ3NTg3XSxcbiAqICAgICBbLTc2LjUyOTUzODYzMTQzOTIsIDM5LjE3NjgzMzkyNTA3NjA2XSxcbiAqICAgICBbLTc2LjU0NTIwMjczMjA4NjE4LCAzOS4xNzg3NjM0NDEwNjY0Ml1cbiAqIF0pO1xuICpcbiAqIG1hcC5yZW1vdmVTb3VyY2UoJ3NvbWUgaWQnKTsgIC8vIHJlbW92ZVxuICovXG5mdW5jdGlvbiBWaWRlb1NvdXJjZShpZCwgb3B0aW9ucykge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnVybHMgPSBvcHRpb25zLnVybHM7XG4gICAgdGhpcy5jb29yZGluYXRlcyA9IG9wdGlvbnMuY29vcmRpbmF0ZXM7XG5cbiAgICBhamF4LmdldFZpZGVvKG9wdGlvbnMudXJscywgZnVuY3Rpb24oZXJyLCB2aWRlbykge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gdGhpcy5maXJlKCdlcnJvcicsIHtlcnJvcjogZXJyfSk7XG5cbiAgICAgICAgdGhpcy52aWRlbyA9IHZpZGVvO1xuICAgICAgICB0aGlzLnZpZGVvLmxvb3AgPSB0cnVlO1xuXG4gICAgICAgIHZhciBsb29wSUQ7XG5cbiAgICAgICAgLy8gc3RhcnQgcmVwYWludGluZyB3aGVuIHZpZGVvIHN0YXJ0cyBwbGF5aW5nXG4gICAgICAgIHRoaXMudmlkZW8uYWRkRXZlbnRMaXN0ZW5lcigncGxheWluZycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbG9vcElEID0gdGhpcy5tYXAuc3R5bGUuYW5pbWF0aW9uTG9vcC5zZXQoSW5maW5pdHkpO1xuICAgICAgICAgICAgdGhpcy5tYXAuX3JlcmVuZGVyKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gc3RvcCByZXBhaW50aW5nIHdoZW4gdmlkZW8gc3RvcHNcbiAgICAgICAgdGhpcy52aWRlby5hZGRFdmVudExpc3RlbmVyKCdwYXVzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5tYXAuc3R5bGUuYW5pbWF0aW9uTG9vcC5jYW5jZWwobG9vcElEKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICBpZiAodGhpcy5tYXApIHtcbiAgICAgICAgICAgIHRoaXMudmlkZW8ucGxheSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRDb29yZGluYXRlcyhvcHRpb25zLmNvb3JkaW5hdGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlyZSgnbG9hZCcpO1xuICAgIH0uYmluZCh0aGlzKSk7XG59XG5cblZpZGVvU291cmNlLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChFdmVudGVkLCAvKiogQGxlbmRzIFZpZGVvU291cmNlLnByb3RvdHlwZSAqL3tcbiAgICBtaW56b29tOiAwLFxuICAgIG1heHpvb206IDIyLFxuICAgIHRpbGVTaXplOiA1MTIsXG4gICAgcm91bmRab29tOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSFRNTCBgdmlkZW9gIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7SFRNTFZpZGVvRWxlbWVudH0gVGhlIEhUTUwgYHZpZGVvYCBlbGVtZW50LlxuICAgICAqL1xuICAgIGdldFZpZGVvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlkZW87XG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgaWYgKHRoaXMubWFwKSByZXR1cm47XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgICAgICBpZiAodGhpcy52aWRlbykge1xuICAgICAgICAgICAgdGhpcy52aWRlby5wbGF5KCk7XG4gICAgICAgICAgICB0aGlzLnNldENvb3JkaW5hdGVzKHRoaXMuY29vcmRpbmF0ZXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZpZGVvJ3MgY29vcmRpbmF0ZXMgYW5kIHJlLXJlbmRlcnMgdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNvb3JkaW5hdGVzIEZvdXIgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLFxuICAgICAqICAgcmVwcmVzZW50ZWQgYXMgYXJyYXlzIG9mIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgbnVtYmVycywgd2hpY2ggZGVmaW5lIHRoZSBjb3JuZXJzIG9mIHRoZSB2aWRlby5cbiAgICAgKiAgIFRoZSBjb29yZGluYXRlcyBzdGFydCBhdCB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB2aWRlbyBhbmQgcHJvY2VlZCBpbiBjbG9ja3dpc2Ugb3JkZXIuXG4gICAgICogICBUaGV5IGRvIG5vdCBoYXZlIHRvIHJlcHJlc2VudCBhIHJlY3RhbmdsZS5cbiAgICAgKiBAcmV0dXJucyB7VmlkZW9Tb3VyY2V9IHRoaXNcbiAgICAgKi9cbiAgICBzZXRDb29yZGluYXRlczogZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgdGhpcy5jb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB3aGljaCBtZXJjYXRvciB0aWxlIGlzIHN1aXRhYmxlIGZvciByZW5kZXJpbmcgdGhlIHZpZGVvIGluXG4gICAgICAgIC8vIGFuZCBjcmVhdGUgYSBidWZmZXIgd2l0aCB0aGUgY29ybmVyIGNvb3JkaW5hdGVzLiBUaGVzZSBjb29yZGluYXRlc1xuICAgICAgICAvLyBtYXkgYmUgb3V0c2lkZSB0aGUgdGlsZSwgYmVjYXVzZSByYXN0ZXIgdGlsZXMgYXJlbid0IGNsaXBwZWQgd2hlbiByZW5kZXJpbmcuXG5cbiAgICAgICAgdmFyIG1hcCA9IHRoaXMubWFwO1xuICAgICAgICB2YXIgY29ybmVyWjBDb29yZHMgPSBjb29yZGluYXRlcy5tYXAoZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXAudHJhbnNmb3JtLmxvY2F0aW9uQ29vcmRpbmF0ZShMbmdMYXQuY29udmVydChjb29yZCkpLnpvb21UbygwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGNlbnRlckNvb3JkID0gdGhpcy5jZW50ZXJDb29yZCA9IHV0aWwuZ2V0Q29vcmRpbmF0ZXNDZW50ZXIoY29ybmVyWjBDb29yZHMpO1xuICAgICAgICBjZW50ZXJDb29yZC5jb2x1bW4gPSBNYXRoLnJvdW5kKGNlbnRlckNvb3JkLmNvbHVtbik7XG4gICAgICAgIGNlbnRlckNvb3JkLnJvdyA9IE1hdGgucm91bmQoY2VudGVyQ29vcmQucm93KTtcblxuICAgICAgICB0aGlzLm1pbnpvb20gPSB0aGlzLm1heHpvb20gPSBjZW50ZXJDb29yZC56b29tO1xuICAgICAgICB0aGlzLl9jb29yZCA9IG5ldyBUaWxlQ29vcmQoY2VudGVyQ29vcmQuem9vbSwgY2VudGVyQ29vcmQuY29sdW1uLCBjZW50ZXJDb29yZC5yb3cpO1xuICAgICAgICB0aGlzLl90aWxlQ29vcmRzID0gY29ybmVyWjBDb29yZHMubWFwKGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgICAgICB2YXIgem9vbWVkQ29vcmQgPSBjb29yZC56b29tVG8oY2VudGVyQ29vcmQuem9vbSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoKHpvb21lZENvb3JkLmNvbHVtbiAtIGNlbnRlckNvb3JkLmNvbHVtbikgKiBFWFRFTlQpLFxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoKHpvb21lZENvb3JkLnJvdyAtIGNlbnRlckNvb3JkLnJvdykgKiBFWFRFTlQpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9zZXRUaWxlOiBmdW5jdGlvbiAodGlsZSkge1xuICAgICAgICB0aGlzLl9wcmVwYXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRpbGUgPSB0aWxlO1xuICAgICAgICB2YXIgbWF4SW50MTYgPSAzMjc2NztcbiAgICAgICAgdmFyIGFycmF5ID0gbmV3IFJhc3RlckJvdW5kc0FycmF5KCk7XG4gICAgICAgIGFycmF5LmVtcGxhY2VCYWNrKHRoaXMuX3RpbGVDb29yZHNbMF0ueCwgdGhpcy5fdGlsZUNvb3Jkc1swXS55LCAwLCAwKTtcbiAgICAgICAgYXJyYXkuZW1wbGFjZUJhY2sodGhpcy5fdGlsZUNvb3Jkc1sxXS54LCB0aGlzLl90aWxlQ29vcmRzWzFdLnksIG1heEludDE2LCAwKTtcbiAgICAgICAgYXJyYXkuZW1wbGFjZUJhY2sodGhpcy5fdGlsZUNvb3Jkc1szXS54LCB0aGlzLl90aWxlQ29vcmRzWzNdLnksIDAsIG1heEludDE2KTtcbiAgICAgICAgYXJyYXkuZW1wbGFjZUJhY2sodGhpcy5fdGlsZUNvb3Jkc1syXS54LCB0aGlzLl90aWxlQ29vcmRzWzJdLnksIG1heEludDE2LCBtYXhJbnQxNik7XG5cbiAgICAgICAgdGhpcy50aWxlLmJ1Y2tldHMgPSB7fTtcblxuICAgICAgICB0aGlzLnRpbGUuYm91bmRzQnVmZmVyID0gbmV3IEJ1ZmZlcihhcnJheS5zZXJpYWxpemUoKSwgUmFzdGVyQm91bmRzQXJyYXkuc2VyaWFsaXplKCksIEJ1ZmZlci5CdWZmZXJUeXBlLlZFUlRFWCk7XG4gICAgICAgIHRoaXMudGlsZS5ib3VuZHNWQU8gPSBuZXcgVmVydGV4QXJyYXlPYmplY3QoKTtcbiAgICAgICAgdGhpcy50aWxlLnN0YXRlID0gJ2xvYWRlZCc7XG4gICAgfSxcblxuICAgIHByZXBhcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy52aWRlby5yZWFkeVN0YXRlIDwgMikgcmV0dXJuOyAvLyBub3QgZW5vdWdoIGRhdGEgZm9yIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgaWYgKCF0aGlzLnRpbGUpIHJldHVybjtcblxuICAgICAgICB2YXIgZ2wgPSB0aGlzLm1hcC5wYWludGVyLmdsO1xuICAgICAgICBpZiAoIXRoaXMuX3ByZXBhcmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmVwYXJlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRpbGUudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGlsZS50ZXh0dXJlKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLnZpZGVvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGlsZS50ZXh0dXJlKTtcbiAgICAgICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy52aWRlbyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jdXJyZW50VGltZSA9IHRoaXMudmlkZW8uY3VycmVudFRpbWU7XG4gICAgfSxcblxuICAgIGxvYWRUaWxlOiBmdW5jdGlvbih0aWxlLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBXZSBoYXZlIGEgc2luZ2xlIHRpbGUgLS0gd2hvb3NlIGNvb3JkaW5hdGVzIGFyZSB0aGlzLl9jb29yZCAtLSB0aGF0XG4gICAgICAgIC8vIGNvdmVycyB0aGUgdmlkZW8gZnJhbWUgd2Ugd2FudCB0byByZW5kZXIuICBJZiB0aGF0J3MgdGhlIG9uZSBiZWluZ1xuICAgICAgICAvLyByZXF1ZXN0ZWQsIHNldCBpdCB1cCB3aXRoIHRoZSBpbWFnZTsgb3RoZXJ3aXNlLCBtYXJrIHRoZSB0aWxlIGFzXG4gICAgICAgIC8vIGBlcnJvcmVkYCB0byBpbmRpY2F0ZSB0aGF0IHdlIGhhdmUgbm8gZGF0YSBmb3IgaXQuXG4gICAgICAgIGlmICh0aGlzLl9jb29yZCAmJiB0aGlzLl9jb29yZC50b1N0cmluZygpID09PSB0aWxlLmNvb3JkLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFRpbGUodGlsZSk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbGUuc3RhdGUgPSAnZXJyb3JlZCc7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgICAgIHVybHM6IHRoaXMudXJscyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiB0aGlzLmNvb3JkaW5hdGVzXG4gICAgICAgIH07XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBBY3RvciA9IHJlcXVpcmUoJy4uL3V0aWwvYWN0b3InKTtcbnZhciBTdHlsZUxheWVyID0gcmVxdWlyZSgnLi4vc3R5bGUvc3R5bGVfbGF5ZXInKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG5cbnZhciBWZWN0b3JUaWxlV29ya2VyU291cmNlID0gcmVxdWlyZSgnLi92ZWN0b3JfdGlsZV93b3JrZXJfc291cmNlJyk7XG52YXIgR2VvSlNPTldvcmtlclNvdXJjZSA9IHJlcXVpcmUoJy4vZ2VvanNvbl93b3JrZXJfc291cmNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlV29ya2VyKHNlbGYpIHtcbiAgICByZXR1cm4gbmV3IFdvcmtlcihzZWxmKTtcbn07XG5cbmZ1bmN0aW9uIFdvcmtlcihzZWxmKSB7XG4gICAgdGhpcy5zZWxmID0gc2VsZjtcbiAgICB0aGlzLmFjdG9yID0gbmV3IEFjdG9yKHNlbGYsIHRoaXMpO1xuXG4gICAgLy8gc2ltcGxlIGFjY2Vzc29yIG9iamVjdCBmb3IgcGFzc2luZyB0byBXb3JrZXJTb3VyY2VzXG4gICAgdmFyIHN0eWxlTGF5ZXJzID0ge1xuICAgICAgICBnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubGF5ZXJzOyB9LmJpbmQodGhpcyksXG4gICAgICAgIGdldExheWVyRmFtaWxpZXM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubGF5ZXJGYW1pbGllczsgfS5iaW5kKHRoaXMpXG4gICAgfTtcblxuICAgIHRoaXMud29ya2VyU291cmNlcyA9IHtcbiAgICAgICAgdmVjdG9yOiBuZXcgVmVjdG9yVGlsZVdvcmtlclNvdXJjZSh0aGlzLmFjdG9yLCBzdHlsZUxheWVycyksXG4gICAgICAgIGdlb2pzb246IG5ldyBHZW9KU09OV29ya2VyU291cmNlKHRoaXMuYWN0b3IsIHN0eWxlTGF5ZXJzKVxuICAgIH07XG5cbiAgICB0aGlzLnNlbGYucmVnaXN0ZXJXb3JrZXJTb3VyY2UgPSBmdW5jdGlvbiAobmFtZSwgV29ya2VyU291cmNlKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtlclNvdXJjZXNbbmFtZV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya2VyIHNvdXJjZSB3aXRoIG5hbWUgXCInICsgbmFtZSArICdcIiBhbHJlYWR5IHJlZ2lzdGVyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53b3JrZXJTb3VyY2VzW25hbWVdID0gbmV3IFdvcmtlclNvdXJjZSh0aGlzLmFjdG9yLCBzdHlsZUxheWVycyk7XG4gICAgfS5iaW5kKHRoaXMpO1xufVxuXG51dGlsLmV4dGVuZChXb3JrZXIucHJvdG90eXBlLCB7XG4gICAgJ3NldCBsYXllcnMnOiBmdW5jdGlvbihsYXllcnMpIHtcbiAgICAgICAgdGhpcy5sYXllcnMgPSB7fTtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIC8vIEZpbHRlciBsYXllcnMgYW5kIGNyZWF0ZSBhbiBpZCAtPiBsYXllciBtYXBcbiAgICAgICAgdmFyIGNoaWxkTGF5ZXJJbmRpY2llcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldO1xuICAgICAgICAgICAgaWYgKGxheWVyLnR5cGUgPT09ICdmaWxsJyB8fCBsYXllci50eXBlID09PSAnbGluZScgfHwgbGF5ZXIudHlwZSA9PT0gJ2NpcmNsZScgfHwgbGF5ZXIudHlwZSA9PT0gJ3N5bWJvbCcgfHwgbGF5ZXIudHlwZSA9PT0gJ2V4dHJ1c2lvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTGF5ZXJJbmRpY2llcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldExheWVyKGxheWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgU3R5bGVMYXllciBwZXIgbGF5ZXJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZExheWVySW5kaWNpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHNldExheWVyKGxheWVyc1tjaGlsZExheWVySW5kaWNpZXNbal1dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNldExheWVyKHNlcmlhbGl6ZWRMYXllcikge1xuICAgICAgICAgICAgdmFyIHN0eWxlTGF5ZXIgPSBTdHlsZUxheWVyLmNyZWF0ZShcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkTGF5ZXIsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZExheWVyLnJlZiAmJiB0aGF0LmxheWVyc1tzZXJpYWxpemVkTGF5ZXIucmVmXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHN0eWxlTGF5ZXIudXBkYXRlUGFpbnRUcmFuc2l0aW9ucyh7fSwge3RyYW5zaXRpb246IGZhbHNlfSk7XG4gICAgICAgICAgICB0aGF0LmxheWVyc1tzdHlsZUxheWVyLmlkXSA9IHN0eWxlTGF5ZXI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxheWVyRmFtaWxpZXMgPSBjcmVhdGVMYXllckZhbWlsaWVzKHRoaXMubGF5ZXJzKTtcbiAgICB9LFxuXG4gICAgJ3VwZGF0ZSBsYXllcnMnOiBmdW5jdGlvbihsYXllcnMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIHZhciBsYXllcjtcblxuICAgICAgICAvLyBVcGRhdGUgcmVmIHBhcmVudHNcbiAgICAgICAgZm9yIChpZCBpbiBsYXllcnMpIHtcbiAgICAgICAgICAgIGxheWVyID0gbGF5ZXJzW2lkXTtcbiAgICAgICAgICAgIGlmIChsYXllci5yZWYpIHVwZGF0ZUxheWVyKGxheWVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSByZWYgY2hpbGRyZW5cbiAgICAgICAgZm9yIChpZCBpbiBsYXllcnMpIHtcbiAgICAgICAgICAgIGxheWVyID0gbGF5ZXJzW2lkXTtcbiAgICAgICAgICAgIGlmICghbGF5ZXIucmVmKSB1cGRhdGVMYXllcihsYXllcik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVMYXllcihsYXllcikge1xuICAgICAgICAgICAgdmFyIHJlZkxheWVyID0gdGhhdC5sYXllcnNbbGF5ZXIucmVmXTtcbiAgICAgICAgICAgIGlmICh0aGF0LmxheWVyc1tsYXllci5pZF0pIHtcbiAgICAgICAgICAgICAgICB0aGF0LmxheWVyc1tsYXllci5pZF0uc2V0KGxheWVyLCByZWZMYXllcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoYXQubGF5ZXJzW2xheWVyLmlkXSA9IFN0eWxlTGF5ZXIuY3JlYXRlKGxheWVyLCByZWZMYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGF0LmxheWVyc1tsYXllci5pZF0udXBkYXRlUGFpbnRUcmFuc2l0aW9ucyh7fSwge3RyYW5zaXRpb246IGZhbHNlfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxheWVyRmFtaWxpZXMgPSBjcmVhdGVMYXllckZhbWlsaWVzKHRoaXMubGF5ZXJzKTtcbiAgICB9LFxuXG4gICAgJ2xvYWQgdGlsZSc6IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHR5cGUgPSBwYXJhbXMudHlwZSB8fCAndmVjdG9yJztcbiAgICAgICAgdGhpcy53b3JrZXJTb3VyY2VzW3R5cGVdLmxvYWRUaWxlKHBhcmFtcywgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAncmVsb2FkIHRpbGUnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB0eXBlID0gcGFyYW1zLnR5cGUgfHwgJ3ZlY3Rvcic7XG4gICAgICAgIHRoaXMud29ya2VyU291cmNlc1t0eXBlXS5yZWxvYWRUaWxlKHBhcmFtcywgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAnYWJvcnQgdGlsZSc6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgdHlwZSA9IHBhcmFtcy50eXBlIHx8ICd2ZWN0b3InO1xuICAgICAgICB0aGlzLndvcmtlclNvdXJjZXNbdHlwZV0uYWJvcnRUaWxlKHBhcmFtcyk7XG4gICAgfSxcblxuICAgICdyZW1vdmUgdGlsZSc6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgdHlwZSA9IHBhcmFtcy50eXBlIHx8ICd2ZWN0b3InO1xuICAgICAgICB0aGlzLndvcmtlclNvdXJjZXNbdHlwZV0ucmVtb3ZlVGlsZShwYXJhbXMpO1xuICAgIH0sXG5cbiAgICAncmVkbyBwbGFjZW1lbnQnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB0eXBlID0gcGFyYW1zLnR5cGUgfHwgJ3ZlY3Rvcic7XG4gICAgICAgIHRoaXMud29ya2VyU291cmNlc1t0eXBlXS5yZWRvUGxhY2VtZW50KHBhcmFtcywgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGEge0BsaW5rIFdvcmtlclNvdXJjZX0gc2NyaXB0IGF0IHBhcmFtcy51cmwuICBUaGUgc2NyaXB0IGlzIHJ1blxuICAgICAqICh1c2luZyBpbXBvcnRTY3JpcHRzKSB3aXRoIGByZWdpc3RlcldvcmtlclNvdXJjZWAgaW4gc2NvcGUsIHdoaWNoIGlzIGFcbiAgICAgKiBmdW5jdGlvbiB0YWtpbmcgYChuYW1lLCB3b3JrZXJTb3VyY2VPYmplY3QpYC5cbiAgICAgKiAgQHByaXZhdGVcbiAgICAgKi9cbiAgICAnbG9hZCB3b3JrZXIgc291cmNlJzogZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zZWxmLmltcG9ydFNjcmlwdHMocGFyYW1zLnVybCk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVMYXllckZhbWlsaWVzKGxheWVycykge1xuICAgIHZhciBmYW1pbGllcyA9IHt9O1xuXG4gICAgZm9yICh2YXIgbGF5ZXJJZCBpbiBsYXllcnMpIHtcbiAgICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW2xheWVySWRdO1xuICAgICAgICB2YXIgcGFyZW50TGF5ZXJJZCA9IGxheWVyLnJlZiB8fCBsYXllci5pZDtcbiAgICAgICAgdmFyIHBhcmVudExheWVyID0gbGF5ZXJzW3BhcmVudExheWVySWRdO1xuXG4gICAgICAgIGlmIChwYXJlbnRMYXllci5sYXlvdXQgJiYgcGFyZW50TGF5ZXIubGF5b3V0LnZpc2liaWxpdHkgPT09ICdub25lJykgY29udGludWU7XG5cbiAgICAgICAgZmFtaWxpZXNbcGFyZW50TGF5ZXJJZF0gPSBmYW1pbGllc1twYXJlbnRMYXllcklkXSB8fCBbXTtcbiAgICAgICAgaWYgKGxheWVySWQgPT09IHBhcmVudExheWVySWQpIHtcbiAgICAgICAgICAgIGZhbWlsaWVzW3BhcmVudExheWVySWRdLnVuc2hpZnQobGF5ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmFtaWxpZXNbcGFyZW50TGF5ZXJJZF0ucHVzaChsYXllcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFtaWxpZXM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlSW5kZXggPSByZXF1aXJlKCcuLi9kYXRhL2ZlYXR1cmVfaW5kZXgnKTtcbnZhciBDb2xsaXNpb25UaWxlID0gcmVxdWlyZSgnLi4vc3ltYm9sL2NvbGxpc2lvbl90aWxlJyk7XG52YXIgQnVja2V0ID0gcmVxdWlyZSgnLi4vZGF0YS9idWNrZXQnKTtcbnZhciBDb2xsaXNpb25Cb3hBcnJheSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9jb2xsaXNpb25fYm94Jyk7XG52YXIgRGljdGlvbmFyeUNvZGVyID0gcmVxdWlyZSgnLi4vdXRpbC9kaWN0aW9uYXJ5X2NvZGVyJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIFN5bWJvbEluc3RhbmNlc0FycmF5ID0gcmVxdWlyZSgnLi4vc3ltYm9sL3N5bWJvbF9pbnN0YW5jZXMnKTtcbnZhciBTeW1ib2xRdWFkc0FycmF5ID0gcmVxdWlyZSgnLi4vc3ltYm9sL3N5bWJvbF9xdWFkcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmtlclRpbGU7XG5cbmZ1bmN0aW9uIFdvcmtlclRpbGUocGFyYW1zKSB7XG4gICAgdGhpcy5jb29yZCA9IHBhcmFtcy5jb29yZDtcbiAgICB0aGlzLnVpZCA9IHBhcmFtcy51aWQ7XG4gICAgdGhpcy56b29tID0gcGFyYW1zLnpvb207XG4gICAgdGhpcy50aWxlU2l6ZSA9IHBhcmFtcy50aWxlU2l6ZTtcbiAgICB0aGlzLnNvdXJjZSA9IHBhcmFtcy5zb3VyY2U7XG4gICAgdGhpcy5vdmVyc2NhbGluZyA9IHBhcmFtcy5vdmVyc2NhbGluZztcbiAgICB0aGlzLmFuZ2xlID0gcGFyYW1zLmFuZ2xlO1xuICAgIHRoaXMucGl0Y2ggPSBwYXJhbXMucGl0Y2g7XG4gICAgdGhpcy5zaG93Q29sbGlzaW9uQm94ZXMgPSBwYXJhbXMuc2hvd0NvbGxpc2lvbkJveGVzO1xufVxuXG5Xb3JrZXJUaWxlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGRhdGEsIGxheWVyRmFtaWxpZXMsIGFjdG9yLCByYXdUaWxlRGF0YSwgY2FsbGJhY2spIHtcblxuICAgIHRoaXMuc3RhdHVzID0gJ3BhcnNpbmcnO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICB0aGlzLmNvbGxpc2lvbkJveEFycmF5ID0gbmV3IENvbGxpc2lvbkJveEFycmF5KCk7XG4gICAgdGhpcy5zeW1ib2xJbnN0YW5jZXNBcnJheSA9IG5ldyBTeW1ib2xJbnN0YW5jZXNBcnJheSgpO1xuICAgIHRoaXMuc3ltYm9sUXVhZHNBcnJheSA9IG5ldyBTeW1ib2xRdWFkc0FycmF5KCk7XG4gICAgdmFyIGNvbGxpc2lvblRpbGUgPSBuZXcgQ29sbGlzaW9uVGlsZSh0aGlzLmFuZ2xlLCB0aGlzLnBpdGNoLCB0aGlzLmNvbGxpc2lvbkJveEFycmF5KTtcbiAgICB2YXIgZmVhdHVyZUluZGV4ID0gbmV3IEZlYXR1cmVJbmRleCh0aGlzLmNvb3JkLCB0aGlzLm92ZXJzY2FsaW5nLCBjb2xsaXNpb25UaWxlLCBkYXRhLmxheWVycyk7XG4gICAgdmFyIHNvdXJjZUxheWVyQ29kZXIgPSBuZXcgRGljdGlvbmFyeUNvZGVyKGRhdGEubGF5ZXJzID8gT2JqZWN0LmtleXMoZGF0YS5sYXllcnMpLnNvcnQoKSA6IFsnX2dlb2pzb25UaWxlTGF5ZXInXSk7XG5cbiAgICB2YXIgdGlsZSA9IHRoaXM7XG4gICAgdmFyIGJ1Y2tldHNCeUlkID0ge307XG4gICAgdmFyIGJ1Y2tldHNCeVNvdXJjZUxheWVyID0ge307XG4gICAgdmFyIGk7XG4gICAgdmFyIGxheWVyO1xuICAgIHZhciBzb3VyY2VMYXllcklkO1xuICAgIHZhciBidWNrZXQ7XG5cbiAgICAvLyBNYXAgbm9uLXJlZiBsYXllcnMgdG8gYnVja2V0cy5cbiAgICB2YXIgYnVja2V0SW5kZXggPSAwO1xuICAgIGZvciAodmFyIGxheWVySWQgaW4gbGF5ZXJGYW1pbGllcykge1xuICAgICAgICBsYXllciA9IGxheWVyRmFtaWxpZXNbbGF5ZXJJZF1bMF07XG5cbiAgICAgICAgaWYgKGxheWVyLnNvdXJjZSAhPT0gdGhpcy5zb3VyY2UpIGNvbnRpbnVlO1xuICAgICAgICBpZiAobGF5ZXIucmVmKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGxheWVyLm1pbnpvb20gJiYgdGhpcy56b29tIDwgbGF5ZXIubWluem9vbSkgY29udGludWU7XG4gICAgICAgIGlmIChsYXllci5tYXh6b29tICYmIHRoaXMuem9vbSA+PSBsYXllci5tYXh6b29tKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGxheWVyLmxheW91dCAmJiBsYXllci5sYXlvdXQudmlzaWJpbGl0eSA9PT0gJ25vbmUnKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGRhdGEubGF5ZXJzICYmICFkYXRhLmxheWVyc1tsYXllci5zb3VyY2VMYXllcl0pIGNvbnRpbnVlO1xuXG4gICAgICAgIGJ1Y2tldCA9IEJ1Y2tldC5jcmVhdGUoe1xuICAgICAgICAgICAgbGF5ZXI6IGxheWVyLFxuICAgICAgICAgICAgaW5kZXg6IGJ1Y2tldEluZGV4KyssXG4gICAgICAgICAgICBjaGlsZExheWVyczogbGF5ZXJGYW1pbGllc1tsYXllcklkXSxcbiAgICAgICAgICAgIHpvb206IHRoaXMuem9vbSxcbiAgICAgICAgICAgIG92ZXJzY2FsaW5nOiB0aGlzLm92ZXJzY2FsaW5nLFxuICAgICAgICAgICAgc2hvd0NvbGxpc2lvbkJveGVzOiB0aGlzLnNob3dDb2xsaXNpb25Cb3hlcyxcbiAgICAgICAgICAgIGNvbGxpc2lvbkJveEFycmF5OiB0aGlzLmNvbGxpc2lvbkJveEFycmF5LFxuICAgICAgICAgICAgc3ltYm9sUXVhZHNBcnJheTogdGhpcy5zeW1ib2xRdWFkc0FycmF5LFxuICAgICAgICAgICAgc3ltYm9sSW5zdGFuY2VzQXJyYXk6IHRoaXMuc3ltYm9sSW5zdGFuY2VzQXJyYXksXG4gICAgICAgICAgICBzb3VyY2VMYXllckluZGV4OiBzb3VyY2VMYXllckNvZGVyLmVuY29kZShsYXllci5zb3VyY2VMYXllciB8fCAnX2dlb2pzb25UaWxlTGF5ZXInKVxuICAgICAgICB9KTtcbiAgICAgICAgYnVja2V0LmNyZWF0ZUZpbHRlcigpO1xuXG4gICAgICAgIGJ1Y2tldHNCeUlkW2xheWVyLmlkXSA9IGJ1Y2tldDtcblxuICAgICAgICBpZiAoZGF0YS5sYXllcnMpIHsgLy8gdmVjdG9ydGlsZVxuICAgICAgICAgICAgc291cmNlTGF5ZXJJZCA9IGxheWVyLnNvdXJjZUxheWVyO1xuICAgICAgICAgICAgYnVja2V0c0J5U291cmNlTGF5ZXJbc291cmNlTGF5ZXJJZF0gPSBidWNrZXRzQnlTb3VyY2VMYXllcltzb3VyY2VMYXllcklkXSB8fCB7fTtcbiAgICAgICAgICAgIGJ1Y2tldHNCeVNvdXJjZUxheWVyW3NvdXJjZUxheWVySWRdW2xheWVyLmlkXSA9IGJ1Y2tldDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlYWQgZWFjaCBsYXllciwgYW5kIHNvcnQgaXRzIGZlYXR1cmVzIGludG8gYnVja2V0c1xuICAgIGlmIChkYXRhLmxheWVycykgeyAvLyB2ZWN0b3J0aWxlXG4gICAgICAgIGZvciAoc291cmNlTGF5ZXJJZCBpbiBidWNrZXRzQnlTb3VyY2VMYXllcikge1xuICAgICAgICAgICAgaWYgKGxheWVyLnZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgICAgICAgICB1dGlsLndhcm5PbmNlKFxuICAgICAgICAgICAgICAgICAgICAnVmVjdG9yIHRpbGUgc291cmNlIFwiJyArIHRoaXMuc291cmNlICsgJ1wiIGxheWVyIFwiJyArXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUxheWVySWQgKyAnXCIgZG9lcyBub3QgdXNlIHZlY3RvciB0aWxlIHNwZWMgdjIgJyArXG4gICAgICAgICAgICAgICAgICAgICdhbmQgdGhlcmVmb3JlIG1heSBoYXZlIHNvbWUgcmVuZGVyaW5nIGVycm9ycy4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxheWVyID0gZGF0YS5sYXllcnNbc291cmNlTGF5ZXJJZF07XG4gICAgICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBzb3J0TGF5ZXJJbnRvQnVja2V0cyhsYXllciwgYnVja2V0c0J5U291cmNlTGF5ZXJbc291cmNlTGF5ZXJJZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHsgLy8gZ2VvanNvblxuICAgICAgICBzb3J0TGF5ZXJJbnRvQnVja2V0cyhkYXRhLCBidWNrZXRzQnlJZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc29ydExheWVySW50b0J1Y2tldHMobGF5ZXIsIGJ1Y2tldHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBsYXllci5mZWF0dXJlKGkpO1xuICAgICAgICAgICAgZmVhdHVyZS5pbmRleCA9IGk7XG4gICAgICAgICAgICBmb3IgKHZhciBpZCBpbiBidWNrZXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1Y2tldHNbaWRdLmZpbHRlcihmZWF0dXJlKSlcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0c1tpZF0uZmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBidWNrZXRzID0gW10sXG4gICAgICAgIHN5bWJvbEJ1Y2tldHMgPSB0aGlzLnN5bWJvbEJ1Y2tldHMgPSBbXSxcbiAgICAgICAgb3RoZXJCdWNrZXRzID0gW107XG5cbiAgICBmZWF0dXJlSW5kZXguYnVja2V0TGF5ZXJJRHMgPSB7fTtcblxuICAgIGZvciAodmFyIGlkIGluIGJ1Y2tldHNCeUlkKSB7XG4gICAgICAgIGJ1Y2tldCA9IGJ1Y2tldHNCeUlkW2lkXTtcbiAgICAgICAgaWYgKGJ1Y2tldC5mZWF0dXJlcy5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgIGZlYXR1cmVJbmRleC5idWNrZXRMYXllcklEc1tidWNrZXQuaW5kZXhdID0gYnVja2V0LmNoaWxkTGF5ZXJzLm1hcChnZXRMYXllcklkKTtcblxuICAgICAgICBidWNrZXRzLnB1c2goYnVja2V0KTtcblxuICAgICAgICBpZiAoYnVja2V0LnR5cGUgPT09ICdzeW1ib2wnKVxuICAgICAgICAgICAgc3ltYm9sQnVja2V0cy5wdXNoKGJ1Y2tldCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG90aGVyQnVja2V0cy5wdXNoKGJ1Y2tldCk7XG4gICAgfVxuXG4gICAgdmFyIGljb25zID0ge307XG4gICAgdmFyIHN0YWNrcyA9IHt9O1xuICAgIHZhciBkZXBzID0gMDtcblxuXG4gICAgaWYgKHN5bWJvbEJ1Y2tldHMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgIC8vIEdldCBkZXBlbmRlbmNpZXMgZm9yIHN5bWJvbCBidWNrZXRzXG4gICAgICAgIGZvciAoaSA9IHN5bWJvbEJ1Y2tldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHN5bWJvbEJ1Y2tldHNbaV0udXBkYXRlSWNvbnMoaWNvbnMpO1xuICAgICAgICAgICAgc3ltYm9sQnVja2V0c1tpXS51cGRhdGVGb250KHN0YWNrcyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBmb250TmFtZSBpbiBzdGFja3MpIHtcbiAgICAgICAgICAgIHN0YWNrc1tmb250TmFtZV0gPSBPYmplY3Qua2V5cyhzdGFja3NbZm9udE5hbWVdKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpY29ucyA9IE9iamVjdC5rZXlzKGljb25zKTtcblxuICAgICAgICBhY3Rvci5zZW5kKCdnZXQgZ2x5cGhzJywge3VpZDogdGhpcy51aWQsIHN0YWNrczogc3RhY2tzfSwgZnVuY3Rpb24oZXJyLCBuZXdTdGFja3MpIHtcbiAgICAgICAgICAgIHN0YWNrcyA9IG5ld1N0YWNrcztcbiAgICAgICAgICAgIGdvdERlcGVuZGVuY3koZXJyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGljb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgYWN0b3Iuc2VuZCgnZ2V0IGljb25zJywge2ljb25zOiBpY29uc30sIGZ1bmN0aW9uKGVyciwgbmV3SWNvbnMpIHtcbiAgICAgICAgICAgICAgICBpY29ucyA9IG5ld0ljb25zO1xuICAgICAgICAgICAgICAgIGdvdERlcGVuZGVuY3koZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ290RGVwZW5kZW5jeSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaW1tZWRpYXRlbHkgcGFyc2Ugbm9uLXN5bWJvbCBidWNrZXRzICh0aGV5IGhhdmUgbm8gZGVwZW5kZW5jaWVzKVxuICAgIGZvciAoaSA9IG90aGVyQnVja2V0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBwYXJzZUJ1Y2tldCh0aGlzLCBvdGhlckJ1Y2tldHNbaV0pO1xuICAgIH1cblxuICAgIGlmIChzeW1ib2xCdWNrZXRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcblxuICAgIGZ1bmN0aW9uIGdvdERlcGVuZGVuY3koZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICBkZXBzKys7XG4gICAgICAgIGlmIChkZXBzID09PSAyKSB7XG4gICAgICAgICAgICAvLyBhbGwgc3ltYm9sIGJ1Y2tldCBkZXBlbmRlbmNpZXMgZmV0Y2hlZDsgcGFyc2UgdGhlbSBpbiBwcm9wZXIgb3JkZXJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzeW1ib2xCdWNrZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VCdWNrZXQodGlsZSwgc3ltYm9sQnVja2V0c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUJ1Y2tldCh0aWxlLCBidWNrZXQpIHtcbiAgICAgICAgYnVja2V0LnBvcHVsYXRlQXJyYXlzKGNvbGxpc2lvblRpbGUsIHN0YWNrcywgaWNvbnMpO1xuXG5cbiAgICAgICAgaWYgKGJ1Y2tldC50eXBlICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWNrZXQuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZSA9IGJ1Y2tldC5mZWF0dXJlc1tpXTtcbiAgICAgICAgICAgICAgICBmZWF0dXJlSW5kZXguaW5zZXJ0KGZlYXR1cmUsIGZlYXR1cmUuaW5kZXgsIGJ1Y2tldC5zb3VyY2VMYXllckluZGV4LCBidWNrZXQuaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnVja2V0LmZlYXR1cmVzID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgICB0aWxlLnN0YXR1cyA9ICdkb25lJztcblxuICAgICAgICBpZiAodGlsZS5yZWRvUGxhY2VtZW50QWZ0ZXJEb25lKSB7XG4gICAgICAgICAgICB0aWxlLnJlZG9QbGFjZW1lbnQodGlsZS5hbmdsZSwgdGlsZS5waXRjaCwgbnVsbCk7XG4gICAgICAgICAgICB0aWxlLnJlZG9QbGFjZW1lbnRBZnRlckRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmZWF0dXJlSW5kZXhfID0gZmVhdHVyZUluZGV4LnNlcmlhbGl6ZSgpO1xuICAgICAgICB2YXIgY29sbGlzaW9uVGlsZV8gPSBjb2xsaXNpb25UaWxlLnNlcmlhbGl6ZSgpO1xuICAgICAgICB2YXIgY29sbGlzaW9uQm94QXJyYXkgPSB0aWxlLmNvbGxpc2lvbkJveEFycmF5LnNlcmlhbGl6ZSgpO1xuICAgICAgICB2YXIgc3ltYm9sSW5zdGFuY2VzQXJyYXkgPSB0aWxlLnN5bWJvbEluc3RhbmNlc0FycmF5LnNlcmlhbGl6ZSgpO1xuICAgICAgICB2YXIgc3ltYm9sUXVhZHNBcnJheSA9IHRpbGUuc3ltYm9sUXVhZHNBcnJheS5zZXJpYWxpemUoKTtcbiAgICAgICAgdmFyIHRyYW5zZmVyYWJsZXMgPSBbcmF3VGlsZURhdGFdLmNvbmNhdChmZWF0dXJlSW5kZXhfLnRyYW5zZmVyYWJsZXMpLmNvbmNhdChjb2xsaXNpb25UaWxlXy50cmFuc2ZlcmFibGVzKTtcbiAgICAgICAgdmFyIG5vbkVtcHR5QnVja2V0cyA9IGJ1Y2tldHMuZmlsdGVyKGlzQnVja2V0Tm9uRW1wdHkpO1xuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAgIGJ1Y2tldHM6IG5vbkVtcHR5QnVja2V0cy5tYXAoc2VyaWFsaXplQnVja2V0KSxcbiAgICAgICAgICAgIGZlYXR1cmVJbmRleDogZmVhdHVyZUluZGV4Xy5kYXRhLFxuICAgICAgICAgICAgY29sbGlzaW9uVGlsZTogY29sbGlzaW9uVGlsZV8uZGF0YSxcbiAgICAgICAgICAgIGNvbGxpc2lvbkJveEFycmF5OiBjb2xsaXNpb25Cb3hBcnJheSxcbiAgICAgICAgICAgIHN5bWJvbEluc3RhbmNlc0FycmF5OiBzeW1ib2xJbnN0YW5jZXNBcnJheSxcbiAgICAgICAgICAgIHN5bWJvbFF1YWRzQXJyYXk6IHN5bWJvbFF1YWRzQXJyYXksXG4gICAgICAgICAgICByYXdUaWxlRGF0YTogcmF3VGlsZURhdGFcbiAgICAgICAgfSwgZ2V0VHJhbnNmZXJhYmxlcyhub25FbXB0eUJ1Y2tldHMpLmNvbmNhdCh0cmFuc2ZlcmFibGVzKSk7XG4gICAgfVxufTtcblxuV29ya2VyVGlsZS5wcm90b3R5cGUucmVkb1BsYWNlbWVudCA9IGZ1bmN0aW9uKGFuZ2xlLCBwaXRjaCwgc2hvd0NvbGxpc2lvbkJveGVzKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSAnZG9uZScpIHtcbiAgICAgICAgdGhpcy5yZWRvUGxhY2VtZW50QWZ0ZXJEb25lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hbmdsZSA9IGFuZ2xlO1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgdmFyIGNvbGxpc2lvblRpbGUgPSBuZXcgQ29sbGlzaW9uVGlsZShhbmdsZSwgcGl0Y2gsIHRoaXMuY29sbGlzaW9uQm94QXJyYXkpO1xuXG4gICAgdmFyIGJ1Y2tldHMgPSB0aGlzLnN5bWJvbEJ1Y2tldHM7XG5cbiAgICBmb3IgKHZhciBpID0gYnVja2V0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWNrZXRzW2ldLnBsYWNlRmVhdHVyZXMoY29sbGlzaW9uVGlsZSwgc2hvd0NvbGxpc2lvbkJveGVzKTtcbiAgICB9XG5cbiAgICB2YXIgY29sbGlzaW9uVGlsZV8gPSBjb2xsaXNpb25UaWxlLnNlcmlhbGl6ZSgpO1xuICAgIHZhciBub25FbXB0eUJ1Y2tldHMgPSBidWNrZXRzLmZpbHRlcihpc0J1Y2tldE5vbkVtcHR5KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgYnVja2V0czogbm9uRW1wdHlCdWNrZXRzLm1hcChzZXJpYWxpemVCdWNrZXQpLFxuICAgICAgICAgICAgY29sbGlzaW9uVGlsZTogY29sbGlzaW9uVGlsZV8uZGF0YVxuICAgICAgICB9LFxuICAgICAgICB0cmFuc2ZlcmFibGVzOiBnZXRUcmFuc2ZlcmFibGVzKG5vbkVtcHR5QnVja2V0cykuY29uY2F0KGNvbGxpc2lvblRpbGVfLnRyYW5zZmVyYWJsZXMpXG4gICAgfTtcbn07XG5cbmZ1bmN0aW9uIGlzQnVja2V0Tm9uRW1wdHkoYnVja2V0KSB7XG4gICAgcmV0dXJuICFidWNrZXQuaXNFbXB0eSgpO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVCdWNrZXQoYnVja2V0KSB7XG4gICAgcmV0dXJuIGJ1Y2tldC5zZXJpYWxpemUoKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhbnNmZXJhYmxlcyhidWNrZXRzKSB7XG4gICAgdmFyIHRyYW5zZmVyYWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpIGluIGJ1Y2tldHMpIHtcbiAgICAgICAgYnVja2V0c1tpXS5nZXRUcmFuc2ZlcmFibGVzKHRyYW5zZmVyYWJsZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmZXJhYmxlcztcbn1cblxuZnVuY3Rpb24gZ2V0TGF5ZXJJZChsYXllcikge1xuICAgIHJldHVybiBsYXllci5pZDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBBbmltYXRpb25Mb29wO1xuXG5mdW5jdGlvbiBBbmltYXRpb25Mb29wKCkge1xuICAgIHRoaXMubiA9IDA7XG4gICAgdGhpcy50aW1lcyA9IFtdO1xufVxuXG4vLyBBcmUgYWxsIGFuaW1hdGlvbnMgZG9uZT9cbkFuaW1hdGlvbkxvb3AucHJvdG90eXBlLnN0b3BwZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRpbWVzID0gdGhpcy50aW1lcy5maWx0ZXIoZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdC50aW1lID49IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuICF0aGlzLnRpbWVzLmxlbmd0aDtcbn07XG5cbi8vIEFkZCBhIG5ldyBhbmltYXRpb24gdGhhdCB3aWxsIHJ1biB0IG1pbGxpc2Vjb25kc1xuLy8gUmV0dXJucyBhbiBpZCB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbmNlbCBpdCBsYXllclxuQW5pbWF0aW9uTG9vcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudGltZXMucHVzaCh7IGlkOiB0aGlzLm4sIHRpbWU6IHQgKyAobmV3IERhdGUoKSkuZ2V0VGltZSgpIH0pO1xuICAgIHJldHVybiB0aGlzLm4rKztcbn07XG5cbi8vIENhbmNlbCBhbiBhbmltYXRpb25cbkFuaW1hdGlvbkxvb3AucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uKG4pIHtcbiAgICB0aGlzLnRpbWVzID0gdGhpcy50aW1lcy5maWx0ZXIoZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdC5pZCAhPT0gbjtcbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudGVkID0gcmVxdWlyZSgnLi4vdXRpbC9ldmVudGVkJyk7XG52YXIgYWpheCA9IHJlcXVpcmUoJy4uL3V0aWwvYWpheCcpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlsL2Jyb3dzZXInKTtcbnZhciBub3JtYWxpemVVUkwgPSByZXF1aXJlKCcuLi91dGlsL21hcGJveCcpLm5vcm1hbGl6ZVNwcml0ZVVSTDtcblxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZVNwcml0ZTtcblxuZnVuY3Rpb24gSW1hZ2VTcHJpdGUoYmFzZSkge1xuICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgdGhpcy5yZXRpbmEgPSBicm93c2VyLmRldmljZVBpeGVsUmF0aW8gPiAxO1xuXG4gICAgdmFyIGZvcm1hdCA9IHRoaXMucmV0aW5hID8gJ0AyeCcgOiAnJztcblxuICAgIGFqYXguZ2V0SlNPTihub3JtYWxpemVVUkwoYmFzZSwgZm9ybWF0LCAnLmpzb24nKSwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnZXJyb3InLCB7ZXJyb3I6IGVycn0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuaW1nKSB0aGlzLmZpcmUoJ2xvYWQnKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgYWpheC5nZXRJbWFnZShub3JtYWxpemVVUkwoYmFzZSwgZm9ybWF0LCAnLnBuZycpLCBmdW5jdGlvbihlcnIsIGltZykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2Vycm9yJywge2Vycm9yOiBlcnJ9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZW11bHRpcGx5IHRoZSBzcHJpdGVcbiAgICAgICAgdmFyIGRhdGEgPSBpbWcuZ2V0RGF0YSgpO1xuICAgICAgICB2YXIgbmV3ZGF0YSA9IGltZy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IGRhdGFbaSArIDNdIC8gMjU1O1xuICAgICAgICAgICAgbmV3ZGF0YVtpICsgMF0gPSBkYXRhW2kgKyAwXSAqIGFscGhhO1xuICAgICAgICAgICAgbmV3ZGF0YVtpICsgMV0gPSBkYXRhW2kgKyAxXSAqIGFscGhhO1xuICAgICAgICAgICAgbmV3ZGF0YVtpICsgMl0gPSBkYXRhW2kgKyAyXSAqIGFscGhhO1xuICAgICAgICAgICAgbmV3ZGF0YVtpICsgM10gPSBkYXRhW2kgKyAzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW1nID0gaW1nO1xuICAgICAgICBpZiAodGhpcy5kYXRhKSB0aGlzLmZpcmUoJ2xvYWQnKTtcbiAgICB9LmJpbmQodGhpcykpO1xufVxuXG5JbWFnZVNwcml0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50ZWQpO1xuXG5JbWFnZVNwcml0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZTtcbn07XG5cbkltYWdlU3ByaXRlLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISEodGhpcy5kYXRhICYmIHRoaXMuaW1nKTtcbn07XG5cbkltYWdlU3ByaXRlLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbigvKmdsKi8pIHtcbiAgICBpZiAoYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvID4gMSAhPT0gdGhpcy5yZXRpbmEpIHtcbiAgICAgICAgdmFyIG5ld1Nwcml0ZSA9IG5ldyBJbWFnZVNwcml0ZSh0aGlzLmJhc2UpO1xuICAgICAgICBuZXdTcHJpdGUub24oJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuaW1nID0gbmV3U3ByaXRlLmltZztcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ld1Nwcml0ZS5kYXRhO1xuICAgICAgICAgICAgdGhpcy5yZXRpbmEgPSBuZXdTcHJpdGUucmV0aW5hO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIFNwcml0ZVBvc2l0aW9uKCkge31cblNwcml0ZVBvc2l0aW9uLnByb3RvdHlwZSA9IHsgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCwgcGl4ZWxSYXRpbzogMSwgc2RmOiBmYWxzZSB9O1xuXG5JbWFnZVNwcml0ZS5wcm90b3R5cGUuZ2V0U3ByaXRlUG9zaXRpb24gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmxvYWRlZCgpKSByZXR1cm4gbmV3IFNwcml0ZVBvc2l0aW9uKCk7XG5cbiAgICB2YXIgcG9zID0gdGhpcy5kYXRhICYmIHRoaXMuZGF0YVtuYW1lXTtcbiAgICBpZiAocG9zICYmIHRoaXMuaW1nKSByZXR1cm4gcG9zO1xuXG4gICAgcmV0dXJuIG5ldyBTcHJpdGVQb3NpdGlvbigpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBhcnNlQ29sb3JTdHJpbmcgPSByZXF1aXJlKCdjc3Njb2xvcnBhcnNlcicpLnBhcnNlQ1NTQ29sb3I7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIFN0eWxlRnVuY3Rpb24gPSByZXF1aXJlKCcuL3N0eWxlX2Z1bmN0aW9uJyk7XG5cbnZhciBjYWNoZSA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlQ29sb3IoaW5wdXQsIHRyYW5zZm9ybUNvbG9yKSB7XG5cbiAgICBpZiAoU3R5bGVGdW5jdGlvbi5pc0Z1bmN0aW9uRGVmaW5pdGlvbihpbnB1dCkpIHtcblxuICAgICAgICByZXR1cm4gdXRpbC5leHRlbmQoe30sIGlucHV0LCB7XG4gICAgICAgICAgICBzdG9wczogaW5wdXQuc3RvcHMubWFwKGZ1bmN0aW9uKHN0b3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3N0b3BbMF0sIHBhcnNlQ29sb3Ioc3RvcFsxXSwgdHJhbnNmb3JtQ29sb3IpXTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgaWYgKCFjYWNoZVtpbnB1dF0gfHwgdHJhbnNmb3JtQ29sb3IpIHtcbiAgICAgICAgICAgIHZhciByZ2JhID0gcGFyc2VDb2xvclN0cmluZyhpbnB1dCk7XG4gICAgICAgICAgICBpZiAoIXJnYmEpIHsgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbG9yICcgKyBpbnB1dCk7IH1cbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1Db2xvcikgcmdiYSA9IHRyYW5zZm9ybUNvbG9yKHJnYmEpO1xuXG4gICAgICAgICAgICAvLyBHTCBleHBlY3RzIGFsbCBjb21wb25lbnRzIHRvIGJlIGluIHRoZSByYW5nZSBbMCwgMV0gYW5kIHRvIGJlXG4gICAgICAgICAgICAvLyBtdWx0aXBsZWQgYnkgdGhlIGFscGhhIHZhbHVlLlxuICAgICAgICAgICAgY2FjaGVbaW5wdXRdID0gW1xuICAgICAgICAgICAgICAgIHJnYmFbMF0gLyAyNTUgKiByZ2JhWzNdLFxuICAgICAgICAgICAgICAgIHJnYmFbMV0gLyAyNTUgKiByZ2JhWzNdLFxuICAgICAgICAgICAgICAgIHJnYmFbMl0gLyAyNTUgKiByZ2JhWzNdLFxuICAgICAgICAgICAgICAgIHJnYmFbM11cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FjaGVbaW5wdXRdO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbG9yICcgKyBpbnB1dCk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50ZWQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50ZWQnKTtcbnZhciBTdHlsZUxheWVyID0gcmVxdWlyZSgnLi9zdHlsZV9sYXllcicpO1xudmFyIEltYWdlU3ByaXRlID0gcmVxdWlyZSgnLi9pbWFnZV9zcHJpdGUnKTtcbnZhciBHbHlwaFNvdXJjZSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9nbHlwaF9zb3VyY2UnKTtcbnZhciBTcHJpdGVBdGxhcyA9IHJlcXVpcmUoJy4uL3N5bWJvbC9zcHJpdGVfYXRsYXMnKTtcbnZhciBMaW5lQXRsYXMgPSByZXF1aXJlKCcuLi9yZW5kZXIvbGluZV9hdGxhcycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBhamF4ID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4Jyk7XG52YXIgbm9ybWFsaXplVVJMID0gcmVxdWlyZSgnLi4vdXRpbC9tYXBib3gnKS5ub3JtYWxpemVTdHlsZVVSTDtcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgRGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4uL3V0aWwvZGlzcGF0Y2hlcicpO1xudmFyIEFuaW1hdGlvbkxvb3AgPSByZXF1aXJlKCcuL2FuaW1hdGlvbl9sb29wJyk7XG52YXIgdmFsaWRhdGVTdHlsZSA9IHJlcXVpcmUoJy4vdmFsaWRhdGVfc3R5bGUnKTtcbnZhciBTb3VyY2UgPSByZXF1aXJlKCcuLi9zb3VyY2Uvc291cmNlJyk7XG52YXIgUXVlcnlGZWF0dXJlcyA9IHJlcXVpcmUoJy4uL3NvdXJjZS9xdWVyeV9mZWF0dXJlcycpO1xudmFyIFNvdXJjZUNhY2hlID0gcmVxdWlyZSgnLi4vc291cmNlL3NvdXJjZV9jYWNoZScpO1xudmFyIHN0eWxlU3BlYyA9IHJlcXVpcmUoJy4vc3R5bGVfc3BlYycpO1xudmFyIFN0eWxlRnVuY3Rpb24gPSByZXF1aXJlKCcuL3N0eWxlX2Z1bmN0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3R5bGU7XG5cbmZ1bmN0aW9uIFN0eWxlKHN0eWxlc2hlZXQsIGFuaW1hdGlvbkxvb3AsIHdvcmtlckNvdW50KSB7XG4gICAgdGhpcy5hbmltYXRpb25Mb29wID0gYW5pbWF0aW9uTG9vcCB8fCBuZXcgQW5pbWF0aW9uTG9vcCgpO1xuICAgIHRoaXMuZGlzcGF0Y2hlciA9IG5ldyBEaXNwYXRjaGVyKHdvcmtlckNvdW50IHx8IDEsIHRoaXMpO1xuICAgIHRoaXMuc3ByaXRlQXRsYXMgPSBuZXcgU3ByaXRlQXRsYXMoMTAyNCwgMTAyNCk7XG4gICAgdGhpcy5saW5lQXRsYXMgPSBuZXcgTGluZUF0bGFzKDI1NiwgNTEyKTtcblxuICAgIHRoaXMuX2xheWVycyA9IHt9O1xuICAgIHRoaXMuX29yZGVyICA9IFtdO1xuICAgIHRoaXMuX2dyb3VwcyA9IFtdO1xuICAgIHRoaXMuc291cmNlcyA9IHt9O1xuICAgIHRoaXMuem9vbUhpc3RvcnkgPSB7fTtcbiAgICB0aGlzLl9saWdodCA9IHt9O1xuXG4gICAgdXRpbC5iaW5kQWxsKFtcbiAgICAgICAgJ19mb3J3YXJkU291cmNlRXZlbnQnLFxuICAgICAgICAnX2ZvcndhcmRUaWxlRXZlbnQnLFxuICAgICAgICAnX2ZvcndhcmRMYXllckV2ZW50JyxcbiAgICAgICAgJ19yZWRvUGxhY2VtZW50J1xuICAgIF0sIHRoaXMpO1xuXG4gICAgdGhpcy5fcmVzZXRVcGRhdGVzKCk7XG5cbiAgICB2YXIgc3R5bGVzaGVldExvYWRlZCA9IGZ1bmN0aW9uKGVyciwgc3R5bGVzaGVldCkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2Vycm9yJywge2Vycm9yOiBlcnJ9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZGF0ZVN0eWxlLmVtaXRFcnJvcnModGhpcywgdmFsaWRhdGVTdHlsZShzdHlsZXNoZWV0KSkpIHJldHVybjtcblxuICAgICAgICB0aGlzLl9sb2FkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0eWxlc2hlZXQgPSBzdHlsZXNoZWV0O1xuXG4gICAgICAgIHRoaXMudXBkYXRlQ2xhc3NlcygpO1xuXG4gICAgICAgIHZhciBzb3VyY2VzID0gc3R5bGVzaGVldC5zb3VyY2VzO1xuICAgICAgICBmb3IgKHZhciBpZCBpbiBzb3VyY2VzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFNvdXJjZShpZCwgc291cmNlc1tpZF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0eWxlc2hlZXQubGlnaHQpIHtcbiAgICAgICAgICAgIGlmIChzdHlsZXNoZWV0LmxpZ2h0WydsaWdodC1hbmNob3InXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpZ2h0LmxpZ2h0QW5jaG9yID0gc3R5bGVzaGVldC5saWdodFsnbGlnaHQtYW5jaG9yJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3R5bGVzaGVldC5saWdodFsnbGlnaHQtZGlyZWN0aW9uJ10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saWdodC5saWdodERpcmVjdGlvbiA9IHN0eWxlc2hlZXQubGlnaHRbJ2xpZ2h0LWRpcmVjdGlvbiddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0eWxlc2hlZXQubGlnaHRbJ2xpZ2h0LWNvbG9yJ10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saWdodC5saWdodENvbG9yID0gc3R5bGVzaGVldC5saWdodFsnbGlnaHQtY29sb3InXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHlsZXNoZWV0LnNwcml0ZSkge1xuICAgICAgICAgICAgdGhpcy5zcHJpdGUgPSBuZXcgSW1hZ2VTcHJpdGUoc3R5bGVzaGVldC5zcHJpdGUpO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGUub24oJ2xvYWQnLCB0aGlzLmZpcmUuYmluZCh0aGlzLCAnY2hhbmdlJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nbHlwaFNvdXJjZSA9IG5ldyBHbHlwaFNvdXJjZShzdHlsZXNoZWV0LmdseXBocyk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUoKTtcbiAgICAgICAgdGhpcy5maXJlKCdsb2FkJyk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgaWYgKHR5cGVvZiBzdHlsZXNoZWV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBhamF4LmdldEpTT04obm9ybWFsaXplVVJMKHN0eWxlc2hlZXQpLCBzdHlsZXNoZWV0TG9hZGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBicm93c2VyLmZyYW1lKHN0eWxlc2hlZXRMb2FkZWQuYmluZCh0aGlzLCBudWxsLCBzdHlsZXNoZWV0KSk7XG4gICAgfVxuXG4gICAgdGhpcy5vbignc291cmNlLmxvYWQnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgc291cmNlID0gZXZlbnQuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlICYmIHNvdXJjZS52ZWN0b3JMYXllcklkcykge1xuICAgICAgICAgICAgZm9yICh2YXIgbGF5ZXJJZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbbGF5ZXJJZF07XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLnNvdXJjZSA9PT0gc291cmNlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlTGF5ZXIobGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5TdHlsZS5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoRXZlbnRlZCwge1xuICAgIF9sb2FkZWQ6IGZhbHNlLFxuXG4gICAgX3ZhbGlkYXRlTGF5ZXI6IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZXNbbGF5ZXIuc291cmNlXTtcblxuICAgICAgICBpZiAoIWxheWVyLnNvdXJjZUxheWVyKSByZXR1cm47XG4gICAgICAgIGlmICghc291cmNlKSByZXR1cm47XG4gICAgICAgIGlmICghc291cmNlLnZlY3RvckxheWVySWRzKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHNvdXJjZS52ZWN0b3JMYXllcklkcy5pbmRleE9mKGxheWVyLnNvdXJjZUxheWVyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgJ1NvdXJjZSBsYXllciBcIicgKyBsYXllci5zb3VyY2VMYXllciArICdcIiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2RvZXMgbm90IGV4aXN0IG9uIHNvdXJjZSBcIicgKyBzb3VyY2UuaWQgKyAnXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICdhcyBzcGVjaWZpZWQgYnkgc3R5bGUgbGF5ZXIgXCInICsgbGF5ZXIuaWQgKyAnXCInXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbG9hZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX3VwZGF0ZXMuc291cmNlcykubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuc291cmNlcylcbiAgICAgICAgICAgIGlmICghdGhpcy5zb3VyY2VzW2lkXS5sb2FkZWQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuc3ByaXRlICYmICF0aGlzLnNwcml0ZS5sb2FkZWQoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgX3Jlc29sdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGF5ZXIsIGxheWVySlNPTjtcblxuICAgICAgICB0aGlzLl9sYXllcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fb3JkZXIgID0gdGhpcy5zdHlsZXNoZWV0LmxheWVycy5tYXAoZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXllci5pZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmVzb2x2ZSBhbGwgbGF5ZXJzIFdJVEhPVVQgYSByZWZcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0eWxlc2hlZXQubGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsYXllckpTT04gPSB0aGlzLnN0eWxlc2hlZXQubGF5ZXJzW2ldO1xuICAgICAgICAgICAgaWYgKGxheWVySlNPTi5yZWYpIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGF5ZXIgPSBTdHlsZUxheWVyLmNyZWF0ZShsYXllckpTT04pO1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW2xheWVyLmlkXSA9IGxheWVyO1xuICAgICAgICAgICAgbGF5ZXIub24oJ2Vycm9yJywgdGhpcy5fZm9yd2FyZExheWVyRXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzb2x2ZSBhbGwgbGF5ZXJzIFdJVEggYSByZWZcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnN0eWxlc2hlZXQubGF5ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsYXllckpTT04gPSB0aGlzLnN0eWxlc2hlZXQubGF5ZXJzW2pdO1xuICAgICAgICAgICAgaWYgKCFsYXllckpTT04ucmVmKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciByZWZMYXllciA9IHRoaXMuZ2V0TGF5ZXIobGF5ZXJKU09OLnJlZik7XG4gICAgICAgICAgICBsYXllciA9IFN0eWxlTGF5ZXIuY3JlYXRlKGxheWVySlNPTiwgcmVmTGF5ZXIpO1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW2xheWVyLmlkXSA9IGxheWVyO1xuICAgICAgICAgICAgbGF5ZXIub24oJ2Vycm9yJywgdGhpcy5fZm9yd2FyZExheWVyRXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZ3JvdXBMYXllcnMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlV29ya2VyTGF5ZXJzKCk7XG4gICAgfSxcblxuICAgIF9ncm91cExheWVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBncm91cDtcblxuICAgICAgICB0aGlzLl9ncm91cHMgPSBbXTtcblxuICAgICAgICAvLyBTcGxpdCBpbnRvIGdyb3VwcyBvZiBjb25zZWN1dGl2ZSB0b3AtbGV2ZWwgbGF5ZXJzIHdpdGggdGhlIHNhbWUgc291cmNlLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX29yZGVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbdGhpcy5fb3JkZXJbaV1dO1xuXG4gICAgICAgICAgICBpZiAoIWdyb3VwIHx8IGxheWVyLnNvdXJjZSAhPT0gZ3JvdXAuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAgPSBbXTtcbiAgICAgICAgICAgICAgICBncm91cC5zb3VyY2UgPSBsYXllci5zb3VyY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ3JvdXBzLnB1c2goZ3JvdXApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBncm91cC5wdXNoKGxheWVyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdXBkYXRlV29ya2VyTGF5ZXJzOiBmdW5jdGlvbihpZHMpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLmJyb2FkY2FzdChpZHMgPyAndXBkYXRlIGxheWVycycgOiAnc2V0IGxheWVycycsIHRoaXMuX3NlcmlhbGl6ZUxheWVycyhpZHMpKTtcbiAgICB9LFxuXG4gICAgX3NlcmlhbGl6ZUxheWVyczogZnVuY3Rpb24oaWRzKSB7XG4gICAgICAgIGlkcyA9IGlkcyB8fCB0aGlzLl9vcmRlcjtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBbXTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7aW5jbHVkZVJlZlByb3BlcnRpZXM6IHRydWV9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKHRoaXMuX2xheWVyc1tpZHNbaV1dLnNlcmlhbGl6ZShvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfSxcblxuICAgIF9hcHBseUNsYXNzZXM6IGZ1bmN0aW9uKGNsYXNzZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpIHJldHVybjtcblxuICAgICAgICBjbGFzc2VzID0gY2xhc3NlcyB8fCBbXTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge3RyYW5zaXRpb246IHRydWV9O1xuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IHRoaXMuc3R5bGVzaGVldC50cmFuc2l0aW9uIHx8IHt9O1xuXG4gICAgICAgIHZhciBsYXllcnMgPSB0aGlzLl91cGRhdGVzLmFsbFBhaW50UHJvcHMgPyB0aGlzLl9sYXllcnMgOiB0aGlzLl91cGRhdGVzLnBhaW50UHJvcHM7XG5cbiAgICAgICAgZm9yICh2YXIgaWQgaW4gbGF5ZXJzKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuICAgICAgICAgICAgdmFyIHByb3BzID0gdGhpcy5fdXBkYXRlcy5wYWludFByb3BzW2lkXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3VwZGF0ZXMuYWxsUGFpbnRQcm9wcyB8fCBwcm9wcy5hbGwpIHtcbiAgICAgICAgICAgICAgICBsYXllci51cGRhdGVQYWludFRyYW5zaXRpb25zKGNsYXNzZXMsIG9wdGlvbnMsIHRyYW5zaXRpb24sIHRoaXMuYW5pbWF0aW9uTG9vcCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHBhaW50TmFtZSBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXllcnNbaWRdLnVwZGF0ZVBhaW50VHJhbnNpdGlvbihwYWludE5hbWUsIGNsYXNzZXMsIG9wdGlvbnMsIHRyYW5zaXRpb24sIHRoaXMuYW5pbWF0aW9uTG9vcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9yZWNhbGN1bGF0ZTogZnVuY3Rpb24oeikge1xuICAgICAgICBmb3IgKHZhciBzb3VyY2VJZCBpbiB0aGlzLnNvdXJjZXMpXG4gICAgICAgICAgICB0aGlzLnNvdXJjZXNbc291cmNlSWRdLnVzZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl91cGRhdGVab29tSGlzdG9yeSh6KTtcblxuICAgICAgICB0aGlzLnJhc3RlckZhZGVEdXJhdGlvbiA9IDMwMDtcbiAgICAgICAgZm9yICh2YXIgbGF5ZXJJZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1tsYXllcklkXTtcblxuICAgICAgICAgICAgbGF5ZXIucmVjYWxjdWxhdGUoeiwgdGhpcy56b29tSGlzdG9yeSk7XG4gICAgICAgICAgICBpZiAoIWxheWVyLmlzSGlkZGVuKHopICYmIGxheWVyLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlc1tsYXllci5zb3VyY2VdLnVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1heFpvb21UcmFuc2l0aW9uRHVyYXRpb24gPSAzMDA7XG4gICAgICAgIGlmIChNYXRoLmZsb29yKHRoaXMueikgIT09IE1hdGguZmxvb3IoeikpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uTG9vcC5zZXQobWF4Wm9vbVRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICB0aGlzLmZpcmUoJ3pvb20nKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZVpvb21IaXN0b3J5OiBmdW5jdGlvbih6KSB7XG5cbiAgICAgICAgdmFyIHpoID0gdGhpcy56b29tSGlzdG9yeTtcblxuICAgICAgICBpZiAoemgubGFzdEludGVnZXJab29tID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHRpbWVcbiAgICAgICAgICAgIHpoLmxhc3RJbnRlZ2VyWm9vbSA9IE1hdGguZmxvb3Ioeik7XG4gICAgICAgICAgICB6aC5sYXN0SW50ZWdlclpvb21UaW1lID0gMDtcbiAgICAgICAgICAgIHpoLmxhc3Rab29tID0gejtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgYW4gaW50ZWdlciB6b29tIGxldmVsIGFzIHBhc3NlZCBzaW5jZSB0aGUgbGFzdCBmcmFtZVxuICAgICAgICAvLyBhbmQgaWYgeWVzLCByZWNvcmQgaXQgd2l0aCB0aGUgdGltZS4gVXNlZCBmb3IgdHJhbnNpdGlvbmluZyBwYXR0ZXJucy5cbiAgICAgICAgaWYgKE1hdGguZmxvb3IoemgubGFzdFpvb20pIDwgTWF0aC5mbG9vcih6KSkge1xuICAgICAgICAgICAgemgubGFzdEludGVnZXJab29tID0gTWF0aC5mbG9vcih6KTtcbiAgICAgICAgICAgIHpoLmxhc3RJbnRlZ2VyWm9vbVRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoTWF0aC5mbG9vcih6aC5sYXN0Wm9vbSkgPiBNYXRoLmZsb29yKHopKSB7XG4gICAgICAgICAgICB6aC5sYXN0SW50ZWdlclpvb20gPSBNYXRoLmZsb29yKHogKyAxKTtcbiAgICAgICAgICAgIHpoLmxhc3RJbnRlZ2VyWm9vbVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgemgubGFzdFpvb20gPSB6O1xuICAgIH0sXG5cbiAgICBfY2hlY2tMb2FkZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3R5bGUgaXMgbm90IGRvbmUgbG9hZGluZycpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHF1ZXVlZCBzdHlsZSB1cGRhdGVzIGluIGEgYmF0Y2hcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24oY2xhc3Nlcywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMuX3VwZGF0ZXMuY2hhbmdlZCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuX3VwZGF0ZXMuYWxsTGF5ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9ncm91cExheWVycygpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlV29ya2VyTGF5ZXJzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlZElkcyA9IE9iamVjdC5rZXlzKHRoaXMuX3VwZGF0ZXMubGF5ZXJzKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVkSWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVdvcmtlckxheWVycyh1cGRhdGVkSWRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1cGRhdGVkU291cmNlSWRzID0gT2JqZWN0LmtleXModGhpcy5fdXBkYXRlcy5zb3VyY2VzKTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB1cGRhdGVkU291cmNlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWxvYWRTb3VyY2UodXBkYXRlZFNvdXJjZUlkc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fdXBkYXRlcy5ldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5fdXBkYXRlcy5ldmVudHNbaV07XG4gICAgICAgICAgICB0aGlzLmZpcmUoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hcHBseUNsYXNzZXMoY2xhc3Nlcywgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3VwZGF0ZXMuY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5maXJlKCdjaGFuZ2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Jlc2V0VXBkYXRlcygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcmVzZXRVcGRhdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlcyA9IHtcbiAgICAgICAgICAgIGV2ZW50czogW10sXG4gICAgICAgICAgICBsYXllcnM6IHt9LFxuICAgICAgICAgICAgc291cmNlczoge30sXG4gICAgICAgICAgICBwYWludFByb3BzOiB7fVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhZGRTb3VyY2U6IGZ1bmN0aW9uKGlkLCBzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tMb2FkZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlc1tpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBpcyBhbHJlYWR5IGEgc291cmNlIHdpdGggdGhpcyBJRCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc291cmNlLnR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHR5cGUgcHJvcGVydHkgbXVzdCBiZSBkZWZpbmVkLCBidXQgdGhlIG9ubHkgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIHdlcmUgZ2l2ZW46ICcgKyBPYmplY3Qua2V5cyhzb3VyY2UpICsgJy4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVpbHRJbnMgPSBbJ3ZlY3RvcicsICdyYXN0ZXInLCAnZ2VvanNvbicsICd2aWRlbycsICdpbWFnZSddO1xuICAgICAgICB2YXIgc2hvdWxkVmFsaWRhdGUgPSBidWlsdElucy5pbmRleE9mKHNvdXJjZS50eXBlKSA+PSAwO1xuICAgICAgICBpZiAoc2hvdWxkVmFsaWRhdGUgJiYgdGhpcy5faGFuZGxlRXJyb3JzKHZhbGlkYXRlU3R5bGUuc291cmNlLCAnc291cmNlcy4nICsgaWQsIHNvdXJjZSkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIHNvdXJjZSA9IG5ldyBTb3VyY2VDYWNoZShpZCwgc291cmNlLCB0aGlzLmRpc3BhdGNoZXIpO1xuICAgICAgICB0aGlzLnNvdXJjZXNbaWRdID0gc291cmNlO1xuICAgICAgICBzb3VyY2Uuc3R5bGUgPSB0aGlzO1xuICAgICAgICBzb3VyY2VcbiAgICAgICAgICAgIC5vbignbG9hZCcsIHRoaXMuX2ZvcndhcmRTb3VyY2VFdmVudClcbiAgICAgICAgICAgIC5vbignZXJyb3InLCB0aGlzLl9mb3J3YXJkU291cmNlRXZlbnQpXG4gICAgICAgICAgICAub24oJ2NoYW5nZScsIHRoaXMuX2ZvcndhcmRTb3VyY2VFdmVudClcbiAgICAgICAgICAgIC5vbigndGlsZS5hZGQnLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9uKCd0aWxlLmxvYWQnLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9uKCd0aWxlLmVycm9yJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgIC5vbigndGlsZS5yZW1vdmUnLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgLm9uKCd0aWxlLnN0YXRzJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudCk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlcy5ldmVudHMucHVzaChbJ3NvdXJjZS5hZGQnLCB7c291cmNlOiBzb3VyY2V9XSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZXMuY2hhbmdlZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHNvdXJjZSBmcm9tIHRoaXMgc3R5bGVzaGVldCwgZ2l2ZW4gaXRzIGlkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBpZCBvZiB0aGUgc291cmNlIHRvIHJlbW92ZVxuICAgICAqIEByZXR1cm5zIHtTdHlsZX0gdGhpcyBzdHlsZVxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiBubyBzb3VyY2UgaXMgZm91bmQgd2l0aCB0aGUgZ2l2ZW4gSURcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJlbW92ZVNvdXJjZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tMb2FkZWQoKTtcblxuICAgICAgICBpZiAodGhpcy5zb3VyY2VzW2lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIHNvdXJjZSB3aXRoIHRoaXMgSUQnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2VzW2lkXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc291cmNlc1tpZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl91cGRhdGVzLnNvdXJjZXNbaWRdO1xuICAgICAgICBzb3VyY2VcbiAgICAgICAgICAgIC5vZmYoJ2xvYWQnLCB0aGlzLl9mb3J3YXJkU291cmNlRXZlbnQpXG4gICAgICAgICAgICAub2ZmKCdlcnJvcicsIHRoaXMuX2ZvcndhcmRTb3VyY2VFdmVudClcbiAgICAgICAgICAgIC5vZmYoJ2NoYW5nZScsIHRoaXMuX2ZvcndhcmRTb3VyY2VFdmVudClcbiAgICAgICAgICAgIC5vZmYoJ3RpbGUuYWRkJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgIC5vZmYoJ3RpbGUubG9hZCcsIHRoaXMuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAub2ZmKCd0aWxlLmVycm9yJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgIC5vZmYoJ3RpbGUucmVtb3ZlJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgIC5vZmYoJ3RpbGUuc3RhdHMnLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KTtcblxuICAgICAgICB0aGlzLl91cGRhdGVzLmV2ZW50cy5wdXNoKFsnc291cmNlLnJlbW92ZScsIHtzb3VyY2U6IHNvdXJjZX1dKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlcy5jaGFuZ2VkID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgc291cmNlIGJ5IGlkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBpZCBvZiB0aGUgZGVzaXJlZCBzb3VyY2VcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBzb3VyY2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldFNvdXJjZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc1tpZF0gJiYgdGhpcy5zb3VyY2VzW2lkXS5nZXRTb3VyY2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbGF5ZXIgdG8gdGhlIG1hcCBzdHlsZS4gVGhlIGxheWVyIHdpbGwgYmUgaW5zZXJ0ZWQgYmVmb3JlIHRoZSBsYXllciB3aXRoXG4gICAgICogSUQgYGJlZm9yZWAsIG9yIGFwcGVuZGVkIGlmIGBiZWZvcmVgIGlzIG9taXR0ZWQuXG4gICAgICogQHBhcmFtIHtTdHlsZUxheWVyfE9iamVjdH0gbGF5ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGJlZm9yZSAgSUQgb2YgYW4gZXhpc3RpbmcgbGF5ZXIgdG8gaW5zZXJ0IGJlZm9yZVxuICAgICAqIEBmaXJlcyBsYXllci5hZGRcbiAgICAgKiBAcmV0dXJucyB7U3R5bGV9IGB0aGlzYFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYWRkTGF5ZXI6IGZ1bmN0aW9uKGxheWVyLCBiZWZvcmUpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tMb2FkZWQoKTtcblxuICAgICAgICBpZiAoIShsYXllciBpbnN0YW5jZW9mIFN0eWxlTGF5ZXIpKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGxheWVyIGlzIG5vdCBpbiB0aGUgc3R5bGUubGF5ZXJzIGFycmF5LCBzbyB3ZSBwYXNzIGFuIGltcG9zc2libGUgYXJyYXkgaW5kZXhcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVFcnJvcnModmFsaWRhdGVTdHlsZS5sYXllcixcbiAgICAgICAgICAgICAgICAgICAgJ2xheWVycy4nICsgbGF5ZXIuaWQsIGxheWVyLCBmYWxzZSwge2FycmF5SW5kZXg6IC0xfSkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgcmVmTGF5ZXIgPSBsYXllci5yZWYgJiYgdGhpcy5nZXRMYXllcihsYXllci5yZWYpO1xuICAgICAgICAgICAgbGF5ZXIgPSBTdHlsZUxheWVyLmNyZWF0ZShsYXllciwgcmVmTGF5ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlTGF5ZXIobGF5ZXIpO1xuXG4gICAgICAgIGxheWVyLm9uKCdlcnJvcicsIHRoaXMuX2ZvcndhcmRMYXllckV2ZW50KTtcblxuICAgICAgICB0aGlzLl9sYXllcnNbbGF5ZXIuaWRdID0gbGF5ZXI7XG4gICAgICAgIHRoaXMuX29yZGVyLnNwbGljZShiZWZvcmUgPyB0aGlzLl9vcmRlci5pbmRleE9mKGJlZm9yZSkgOiBJbmZpbml0eSwgMCwgbGF5ZXIuaWQpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZXMuYWxsTGF5ZXJzID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxheWVyLnNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlcy5zb3VyY2VzW2xheWVyLnNvdXJjZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZXMuZXZlbnRzLnB1c2goWydsYXllci5hZGQnLCB7bGF5ZXI6IGxheWVyfV0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUNsYXNzZXMobGF5ZXIuaWQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBsYXllciBmcm9tIHRoaXMgc3R5bGVzaGVldCwgZ2l2ZW4gaXRzIGlkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBpZCBvZiB0aGUgbGF5ZXIgdG8gcmVtb3ZlXG4gICAgICogQHJldHVybnMge1N0eWxlfSB0aGlzIHN0eWxlXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIG5vIGxheWVyIGlzIGZvdW5kIHdpdGggdGhlIGdpdmVuIElEXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZW1vdmVMYXllcjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tMb2FkZWQoKTtcblxuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbaWRdO1xuICAgICAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBpcyBubyBsYXllciB3aXRoIHRoaXMgSUQnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xheWVyc1tpXS5yZWYgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMYXllcihpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxheWVyLm9mZignZXJyb3InLCB0aGlzLl9mb3J3YXJkTGF5ZXJFdmVudCk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuX2xheWVyc1tpZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl91cGRhdGVzLmxheWVyc1tpZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl91cGRhdGVzLnBhaW50UHJvcHNbaWRdO1xuICAgICAgICB0aGlzLl9vcmRlci5zcGxpY2UodGhpcy5fb3JkZXIuaW5kZXhPZihpZCksIDEpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZXMuYWxsTGF5ZXJzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdXBkYXRlcy5ldmVudHMucHVzaChbJ2xheWVyLnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9XSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZXMuY2hhbmdlZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgc3R5bGUgbGF5ZXIgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGBpZGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBpZCBvZiB0aGUgZGVzaXJlZCBsYXllclxuICAgICAqIEByZXR1cm5zIHs/T2JqZWN0fSBhIGxheWVyLCBpZiBvbmUgd2l0aCB0aGUgZ2l2ZW4gYGlkYCBleGlzdHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldExheWVyOiBmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzW2lkXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgYSBsYXllciBoYXMgYSBgcmVmYCBwcm9wZXJ0eSB0aGF0IG1ha2VzIGl0IGRlcml2ZSBzb21lIHZhbHVlc1xuICAgICAqIGZyb20gYW5vdGhlciBsYXllciwgcmV0dXJuIHRoYXQgcmVmZXJlbnQgbGF5ZXIuIE90aGVyd2lzZSxcbiAgICAgKiByZXR1cm5zIHRoZSBsYXllciBpdHNlbGYuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIHRoZSBsYXllcidzIGlkXG4gICAgICogQHJldHVybnMge0xheWVyfSB0aGUgcmVmZXJlbnQgbGF5ZXIgb3IgdGhlIGxheWVyIGl0c2VsZlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0UmVmZXJlbnRMYXllcjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcihpZCk7XG4gICAgICAgIGlmIChsYXllci5yZWYpIHtcbiAgICAgICAgICAgIGxheWVyID0gdGhpcy5nZXRMYXllcihsYXllci5yZWYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9LFxuXG4gICAgc2V0TGF5ZXJab29tUmFuZ2U6IGZ1bmN0aW9uKGxheWVySWQsIG1pbnpvb20sIG1heHpvb20pIHtcbiAgICAgICAgdGhpcy5fY2hlY2tMb2FkZWQoKTtcblxuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldFJlZmVyZW50TGF5ZXIobGF5ZXJJZCk7XG5cbiAgICAgICAgaWYgKGxheWVyLm1pbnpvb20gPT09IG1pbnpvb20gJiYgbGF5ZXIubWF4em9vbSA9PT0gbWF4em9vbSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKG1pbnpvb20gIT0gbnVsbCkge1xuICAgICAgICAgICAgbGF5ZXIubWluem9vbSA9IG1pbnpvb207XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heHpvb20gIT0gbnVsbCkge1xuICAgICAgICAgICAgbGF5ZXIubWF4em9vbSA9IG1heHpvb207XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUxheWVyKGxheWVyKTtcbiAgICB9LFxuXG4gICAgc2V0RmlsdGVyOiBmdW5jdGlvbihsYXllcklkLCBmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tMb2FkZWQoKTtcblxuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldFJlZmVyZW50TGF5ZXIobGF5ZXJJZCk7XG5cbiAgICAgICAgaWYgKGZpbHRlciAhPT0gbnVsbCAmJiB0aGlzLl9oYW5kbGVFcnJvcnModmFsaWRhdGVTdHlsZS5maWx0ZXIsICdsYXllcnMuJyArIGxheWVyLmlkICsgJy5maWx0ZXInLCBmaWx0ZXIpKSByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAodXRpbC5kZWVwRXF1YWwobGF5ZXIuZmlsdGVyLCBmaWx0ZXIpKSByZXR1cm4gdGhpcztcbiAgICAgICAgbGF5ZXIuZmlsdGVyID0gdXRpbC5jbG9uZShmaWx0ZXIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVMYXllcihsYXllcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGxheWVyJ3MgZmlsdGVyIG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllciB0aGUgbGF5ZXIgdG8gaW5zcGVjdFxuICAgICAqIEByZXR1cm5zIHsqfSB0aGUgbGF5ZXIncyBmaWx0ZXIsIGlmIGFueVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0RmlsdGVyOiBmdW5jdGlvbihsYXllcikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZWZlcmVudExheWVyKGxheWVyKS5maWx0ZXI7XG4gICAgfSxcblxuICAgIHNldExheW91dFByb3BlcnR5OiBmdW5jdGlvbihsYXllcklkLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jaGVja0xvYWRlZCgpO1xuXG4gICAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0UmVmZXJlbnRMYXllcihsYXllcklkKTtcblxuICAgICAgICBpZiAodXRpbC5kZWVwRXF1YWwobGF5ZXIuZ2V0TGF5b3V0UHJvcGVydHkobmFtZSksIHZhbHVlKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgbGF5ZXIuc2V0TGF5b3V0UHJvcGVydHkobmFtZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlTGF5ZXIobGF5ZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBsYXlvdXQgcHJvcGVydHkncyB2YWx1ZSBmcm9tIGEgZ2l2ZW4gbGF5ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgdGhlIGxheWVyIHRvIGluc3BlY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgbGF5b3V0IHByb3BlcnR5XG4gICAgICogQHJldHVybnMgeyp9IHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0TGF5b3V0UHJvcGVydHk6IGZ1bmN0aW9uKGxheWVyLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlZmVyZW50TGF5ZXIobGF5ZXIpLmdldExheW91dFByb3BlcnR5KG5hbWUpO1xuICAgIH0sXG5cbiAgICBzZXRQYWludFByb3BlcnR5OiBmdW5jdGlvbihsYXllcklkLCBuYW1lLCB2YWx1ZSwga2xhc3MpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tMb2FkZWQoKTtcblxuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKGxheWVySWQpO1xuXG4gICAgICAgIGlmICh1dGlsLmRlZXBFcXVhbChsYXllci5nZXRQYWludFByb3BlcnR5KG5hbWUsIGtsYXNzKSwgdmFsdWUpKSByZXR1cm4gdGhpcztcblxuICAgICAgICB2YXIgd2FzRmVhdHVyZUNvbnN0YW50ID0gbGF5ZXIuaXNQYWludFZhbHVlRmVhdHVyZUNvbnN0YW50KG5hbWUpO1xuICAgICAgICBsYXllci5zZXRQYWludFByb3BlcnR5KG5hbWUsIHZhbHVlLCBrbGFzcyk7XG5cbiAgICAgICAgdmFyIGlzRmVhdHVyZUNvbnN0YW50ID0gIShcbiAgICAgICAgICAgIHZhbHVlICYmXG4gICAgICAgICAgICBTdHlsZUZ1bmN0aW9uLmlzRnVuY3Rpb25EZWZpbml0aW9uKHZhbHVlKSAmJlxuICAgICAgICAgICAgdmFsdWUucHJvcGVydHkgIT09ICckem9vbScgJiZcbiAgICAgICAgICAgIHZhbHVlLnByb3BlcnR5ICE9PSB1bmRlZmluZWRcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIWlzRmVhdHVyZUNvbnN0YW50IHx8ICF3YXNGZWF0dXJlQ29uc3RhbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZXMubGF5ZXJzW2xheWVySWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChsYXllci5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVzLnNvdXJjZXNbbGF5ZXIuc291cmNlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVDbGFzc2VzKGxheWVySWQsIG5hbWUpO1xuICAgIH0sXG5cbiAgICBnZXRQYWludFByb3BlcnR5OiBmdW5jdGlvbihsYXllciwgbmFtZSwga2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF5ZXIobGF5ZXIpLmdldFBhaW50UHJvcGVydHkobmFtZSwga2xhc3MpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVDbGFzc2VzOiBmdW5jdGlvbiAobGF5ZXJJZCwgcGFpbnROYW1lKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIGlmICghbGF5ZXJJZCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlcy5hbGxQYWludFByb3BzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHRoaXMuX3VwZGF0ZXMucGFpbnRQcm9wcztcbiAgICAgICAgICAgIGlmICghcHJvcHNbbGF5ZXJJZF0pIHByb3BzW2xheWVySWRdID0ge307XG4gICAgICAgICAgICBwcm9wc1tsYXllcklkXVtwYWludE5hbWUgfHwgJ2FsbCddID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuZmlsdGVyT2JqZWN0KHtcbiAgICAgICAgICAgIHZlcnNpb246IHRoaXMuc3R5bGVzaGVldC52ZXJzaW9uLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5zdHlsZXNoZWV0Lm5hbWUsXG4gICAgICAgICAgICBtZXRhZGF0YTogdGhpcy5zdHlsZXNoZWV0Lm1ldGFkYXRhLFxuICAgICAgICAgICAgbGlnaHQ6IHRoaXMuc3R5bGVzaGVldC5saWdodCxcbiAgICAgICAgICAgIGNlbnRlcjogdGhpcy5zdHlsZXNoZWV0LmNlbnRlcixcbiAgICAgICAgICAgIHpvb206IHRoaXMuc3R5bGVzaGVldC56b29tLFxuICAgICAgICAgICAgYmVhcmluZzogdGhpcy5zdHlsZXNoZWV0LmJlYXJpbmcsXG4gICAgICAgICAgICBwaXRjaDogdGhpcy5zdHlsZXNoZWV0LnBpdGNoLFxuICAgICAgICAgICAgc3ByaXRlOiB0aGlzLnN0eWxlc2hlZXQuc3ByaXRlLFxuICAgICAgICAgICAgZ2x5cGhzOiB0aGlzLnN0eWxlc2hlZXQuZ2x5cGhzLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogdGhpcy5zdHlsZXNoZWV0LnRyYW5zaXRpb24sXG4gICAgICAgICAgICBzb3VyY2VzOiB1dGlsLm1hcE9iamVjdCh0aGlzLnNvdXJjZXMsIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2Uuc2VyaWFsaXplKCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGxheWVyczogdGhpcy5fb3JkZXIubWFwKGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyc1tpZF0uc2VyaWFsaXplKCk7XG4gICAgICAgICAgICB9LCB0aGlzKVxuICAgICAgICB9LCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZDsgfSk7XG4gICAgfSxcblxuICAgIF91cGRhdGVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZXMubGF5ZXJzW2xheWVyLmlkXSA9IHRydWU7XG4gICAgICAgIGlmIChsYXllci5zb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZXMuc291cmNlc1tsYXllci5zb3VyY2VdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGVzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2ZsYXR0ZW5SZW5kZXJlZEZlYXR1cmVzOiBmdW5jdGlvbihzb3VyY2VSZXN1bHRzKSB7XG4gICAgICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBsID0gdGhpcy5fb3JkZXIubGVuZ3RoIC0gMTsgbCA+PSAwOyBsLS0pIHtcbiAgICAgICAgICAgIHZhciBsYXllcklEID0gdGhpcy5fb3JkZXJbbF07XG4gICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHNvdXJjZVJlc3VsdHMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXJGZWF0dXJlcyA9IHNvdXJjZVJlc3VsdHNbc11bbGF5ZXJJRF07XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyRmVhdHVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZiA9IDA7IGYgPCBsYXllckZlYXR1cmVzLmxlbmd0aDsgZisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGxheWVyRmVhdHVyZXNbZl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmZWF0dXJlcztcbiAgICB9LFxuXG4gICAgcXVlcnlSZW5kZXJlZEZlYXR1cmVzOiBmdW5jdGlvbihxdWVyeUdlb21ldHJ5LCBwYXJhbXMsIHpvb20sIGJlYXJpbmcpIHtcbiAgICAgICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMuZmlsdGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVFcnJvcnModmFsaWRhdGVTdHlsZS5maWx0ZXIsICdxdWVyeVJlbmRlcmVkRmVhdHVyZXMuZmlsdGVyJywgcGFyYW1zLmZpbHRlciwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5jbHVkZWRTb3VyY2VzID0ge307XG4gICAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLmxheWVycykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxheWVySWQgPSBwYXJhbXMubGF5ZXJzW2ldO1xuICAgICAgICAgICAgICAgIGluY2x1ZGVkU291cmNlc1t0aGlzLl9sYXllcnNbbGF5ZXJJZF0uc291cmNlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc291cmNlUmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLnNvdXJjZXMpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMubGF5ZXJzICYmICFpbmNsdWRlZFNvdXJjZXNbaWRdKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZXNbaWRdO1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBRdWVyeUZlYXR1cmVzLnJlbmRlcmVkKHNvdXJjZSwgdGhpcy5fbGF5ZXJzLCBxdWVyeUdlb21ldHJ5LCBwYXJhbXMsIHpvb20sIGJlYXJpbmcpO1xuICAgICAgICAgICAgc291cmNlUmVzdWx0cy5wdXNoKHJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9mbGF0dGVuUmVuZGVyZWRGZWF0dXJlcyhzb3VyY2VSZXN1bHRzKTtcbiAgICB9LFxuXG4gICAgcXVlcnlTb3VyY2VGZWF0dXJlczogZnVuY3Rpb24oc291cmNlSUQsIHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zICYmIHBhcmFtcy5maWx0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUVycm9ycyh2YWxpZGF0ZVN0eWxlLmZpbHRlciwgJ3F1ZXJ5U291cmNlRmVhdHVyZXMuZmlsdGVyJywgcGFyYW1zLmZpbHRlciwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlc1tzb3VyY2VJRF07XG4gICAgICAgIHJldHVybiBzb3VyY2UgPyBRdWVyeUZlYXR1cmVzLnNvdXJjZShzb3VyY2UsIHBhcmFtcykgOiBbXTtcbiAgICB9LFxuXG4gICAgYWRkU291cmNlVHlwZTogZnVuY3Rpb24gKG5hbWUsIFNvdXJjZVR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChTb3VyY2UuZ2V0VHlwZShuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignQSBzb3VyY2UgdHlwZSBjYWxsZWQgXCInICsgbmFtZSArICdcIiBhbHJlYWR5IGV4aXN0cy4nKSk7XG4gICAgICAgIH1cblxuICAgICAgICBTb3VyY2Uuc2V0VHlwZShuYW1lLCBTb3VyY2VUeXBlKTtcblxuICAgICAgICBpZiAoIVNvdXJjZVR5cGUud29ya2VyU291cmNlVVJMKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpc3BhdGNoZXIuYnJvYWRjYXN0KCdsb2FkIHdvcmtlciBzb3VyY2UnLCB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgdXJsOiBTb3VyY2VUeXBlLndvcmtlclNvdXJjZVVSTFxuICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIF9oYW5kbGVFcnJvcnM6IGZ1bmN0aW9uKHZhbGlkYXRlLCBrZXksIHZhbHVlLCB0aHJvd3MsIHByb3BzKSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSB0aHJvd3MgPyB2YWxpZGF0ZVN0eWxlLnRocm93RXJyb3JzIDogdmFsaWRhdGVTdHlsZS5lbWl0RXJyb3JzO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdmFsaWRhdGUuY2FsbCh2YWxpZGF0ZVN0eWxlLCB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgIHN0eWxlOiB0aGlzLnNlcmlhbGl6ZSgpLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgICAgfSwgcHJvcHMpKTtcbiAgICAgICAgcmV0dXJuIGFjdGlvbi5jYWxsKHZhbGlkYXRlU3R5bGUsIHRoaXMsIHJlc3VsdCk7XG4gICAgfSxcblxuICAgIF9yZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIucmVtb3ZlKCk7XG4gICAgfSxcblxuICAgIF9yZWxvYWRTb3VyY2U6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHRoaXMuc291cmNlc1tpZF0ucmVsb2FkKCk7XG4gICAgfSxcblxuICAgIF91cGRhdGVTb3VyY2VzOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5zb3VyY2VzKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZXNbaWRdLnVwZGF0ZSh0cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9yZWRvUGxhY2VtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5zb3VyY2VzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VzW2lkXS5yZWRvUGxhY2VtZW50KSB0aGlzLnNvdXJjZXNbaWRdLnJlZG9QbGFjZW1lbnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZm9yd2FyZFNvdXJjZUV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnc291cmNlLicgKyBlLnR5cGUsIHV0aWwuZXh0ZW5kKHtzb3VyY2U6IGUudGFyZ2V0LmdldFNvdXJjZSgpfSwgZSkpO1xuICAgIH0sXG5cbiAgICBfZm9yd2FyZFRpbGVFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmZpcmUoZS50eXBlLCB1dGlsLmV4dGVuZCh7c291cmNlOiBlLnRhcmdldH0sIGUpKTtcbiAgICB9LFxuXG4gICAgX2ZvcndhcmRMYXllckV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnbGF5ZXIuJyArIGUudHlwZSwgdXRpbC5leHRlbmQoe2xheWVyOiB7aWQ6IGUudGFyZ2V0LmlkfX0sIGUpKTtcbiAgICB9LFxuXG4gICAgLy8gQ2FsbGJhY2tzIGZyb20gd2ViIHdvcmtlcnNcblxuICAgICdnZXQgc3ByaXRlIGpzb24nOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzcHJpdGUgPSB0aGlzLnNwcml0ZTtcbiAgICAgICAgaWYgKHNwcml0ZS5sb2FkZWQoKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeyBzcHJpdGU6IHNwcml0ZS5kYXRhLCByZXRpbmE6IHNwcml0ZS5yZXRpbmEgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcHJpdGUub24oJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7IHNwcml0ZTogc3ByaXRlLmRhdGEsIHJldGluYTogc3ByaXRlLnJldGluYSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdnZXQgaWNvbnMnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzcHJpdGUgPSB0aGlzLnNwcml0ZTtcbiAgICAgICAgdmFyIHNwcml0ZUF0bGFzID0gdGhpcy5zcHJpdGVBdGxhcztcbiAgICAgICAgaWYgKHNwcml0ZS5sb2FkZWQoKSkge1xuICAgICAgICAgICAgc3ByaXRlQXRsYXMuc2V0U3ByaXRlKHNwcml0ZSk7XG4gICAgICAgICAgICBzcHJpdGVBdGxhcy5hZGRJY29ucyhwYXJhbXMuaWNvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNwcml0ZS5vbignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNwcml0ZUF0bGFzLnNldFNwcml0ZShzcHJpdGUpO1xuICAgICAgICAgICAgICAgIHNwcml0ZUF0bGFzLmFkZEljb25zKHBhcmFtcy5pY29ucywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2dldCBnbHlwaHMnOiBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzdGFja3MgPSBwYXJhbXMuc3RhY2tzLFxuICAgICAgICAgICAgcmVtYWluaW5nID0gT2JqZWN0LmtleXMoc3RhY2tzKS5sZW5ndGgsXG4gICAgICAgICAgICBhbGxHbHlwaHMgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBmb250TmFtZSBpbiBzdGFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuZ2x5cGhTb3VyY2UuZ2V0U2ltcGxlR2x5cGhzKGZvbnROYW1lLCBzdGFja3NbZm9udE5hbWVdLCBwYXJhbXMudWlkLCBkb25lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRvbmUoZXJyLCBnbHlwaHMsIGZvbnROYW1lKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSBjb25zb2xlLmVycm9yKGVycik7XG5cbiAgICAgICAgICAgIGFsbEdseXBoc1tmb250TmFtZV0gPSBnbHlwaHM7XG4gICAgICAgICAgICByZW1haW5pbmctLTtcblxuICAgICAgICAgICAgaWYgKHJlbWFpbmluZyA9PT0gMClcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBhbGxHbHlwaHMpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIE1hcGJveEdMRnVuY3Rpb24gPSByZXF1aXJlKCcuL3N0eWxlX2Z1bmN0aW9uJyk7XG52YXIgcGFyc2VDb2xvciA9IHJlcXVpcmUoJy4vcGFyc2VfY29sb3InKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3R5bGVEZWNsYXJhdGlvbjtcblxuZnVuY3Rpb24gU3R5bGVEZWNsYXJhdGlvbihwcm9wTmFtZSwgcmVmZXJlbmNlLCB2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB1dGlsLmNsb25lKHZhbHVlKTtcbiAgICB0aGlzLmlzRnVuY3Rpb24gPSBNYXBib3hHTEZ1bmN0aW9uLmlzRnVuY3Rpb25EZWZpbml0aW9uKHZhbHVlKTtcblxuICAgIC8vIGltbXV0YWJsZSByZXByZXNlbnRhdGlvbiBvZiB2YWx1ZS4gdXNlZCBmb3IgY29tcGFyaXNvblxuICAgIHRoaXMuanNvbiA9IEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWUpO1xuXG4gICAgdmFyIHBhcnNlZFZhbHVlO1xuICAgIGlmIChwcm9wTmFtZSA9PT0gJ2V4dHJ1c2lvbi1jb2xvcicpIHtcbiAgICAgICAgcGFyc2VkVmFsdWUgPSB0aGlzLnZhbHVlICYmIHBhcnNlQ29sb3IodGhpcy52YWx1ZSwgZnVuY3Rpb24ocmdiYSkge1xuICAgICAgICAgICAgcmV0dXJuIHJnYmEuc2xpY2UoMCwzKS5jb25jYXQoMSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFZhbHVlID0gcmVmZXJlbmNlLnR5cGUgPT09ICdjb2xvcicgJiYgdGhpcy52YWx1ZSA/IHBhcnNlQ29sb3IodGhpcy52YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG4gICAgdmFyIHNwZWNEZWZhdWx0ID0gcmVmZXJlbmNlLmRlZmF1bHQ7XG4gICAgaWYgKHNwZWNEZWZhdWx0ICYmIHJlZmVyZW5jZS50eXBlID09PSAnY29sb3InKSBzcGVjRGVmYXVsdCA9IHBhcnNlQ29sb3Ioc3BlY0RlZmF1bHQpO1xuICAgIHRoaXMuY2FsY3VsYXRlID0gTWFwYm94R0xGdW5jdGlvbltyZWZlcmVuY2UuZnVuY3Rpb24gfHwgJ3BpZWNld2lzZS1jb25zdGFudCddKHBhcnNlZFZhbHVlLCBzcGVjRGVmYXVsdCk7XG4gICAgdGhpcy5pc0ZlYXR1cmVDb25zdGFudCA9IHRoaXMuY2FsY3VsYXRlLmlzRmVhdHVyZUNvbnN0YW50O1xuICAgIHRoaXMuaXNab29tQ29uc3RhbnQgPSB0aGlzLmNhbGN1bGF0ZS5pc1pvb21Db25zdGFudDtcblxuICAgIGlmIChyZWZlcmVuY2UuZnVuY3Rpb24gPT09ICdwaWVjZXdpc2UtY29uc3RhbnQnICYmIHJlZmVyZW5jZS50cmFuc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlID0gdHJhbnNpdGlvbmVkKHRoaXMuY2FsY3VsYXRlKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNGZWF0dXJlQ29uc3RhbnQgJiYgIXRoaXMuaXNab29tQ29uc3RhbnQpIHtcbiAgICAgICAgdGhpcy5zdG9wWm9vbUxldmVscyA9IFtdO1xuICAgICAgICB2YXIgaW50ZXJwb2xhdGlvbkFtb3VudFN0b3BzID0gW107XG4gICAgICAgIHZhciBzdG9wcyA9IHRoaXMudmFsdWUuc3RvcHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5zdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHpvb20gPSBzdG9wc1tpXVswXS56b29tO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcFpvb21MZXZlbHMuaW5kZXhPZih6b29tKSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3Bab29tTGV2ZWxzLnB1c2goem9vbSk7XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbkFtb3VudFN0b3BzLnB1c2goW3pvb20sIGludGVycG9sYXRpb25BbW91bnRTdG9wcy5sZW5ndGhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlSW50ZXJwb2xhdGlvblQgPSBNYXBib3hHTEZ1bmN0aW9uLmludGVycG9sYXRlZCh7XG4gICAgICAgICAgICBzdG9wczogaW50ZXJwb2xhdGlvbkFtb3VudFN0b3BzLFxuICAgICAgICAgICAgYmFzZTogdmFsdWUuYmFzZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBzbW9vdGhseSB0cmFuc2l0aW9uIGJldHdlZW4gZGlzY3JldGUgdmFsdWVzLCBzdWNoXG4vLyBhcyBpbWFnZXMgYW5kIGRhc2hhcnJheXMuXG5mdW5jdGlvbiB0cmFuc2l0aW9uZWQoY2FsY3VsYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHZhciB6ID0gZ2xvYmFsUHJvcGVydGllcy56b29tO1xuICAgICAgICB2YXIgemggPSBnbG9iYWxQcm9wZXJ0aWVzLnpvb21IaXN0b3J5O1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBnbG9iYWxQcm9wZXJ0aWVzLmR1cmF0aW9uO1xuXG4gICAgICAgIHZhciBmcmFjdGlvbiA9IHogJSAxO1xuICAgICAgICB2YXIgdCA9IE1hdGgubWluKChEYXRlLm5vdygpIC0gemgubGFzdEludGVnZXJab29tVGltZSkgLyBkdXJhdGlvbiwgMSk7XG4gICAgICAgIHZhciBmcm9tU2NhbGUgPSAxO1xuICAgICAgICB2YXIgdG9TY2FsZSA9IDE7XG4gICAgICAgIHZhciBtaXgsIGZyb20sIHRvO1xuXG4gICAgICAgIGlmICh6ID4gemgubGFzdEludGVnZXJab29tKSB7XG4gICAgICAgICAgICBtaXggPSBmcmFjdGlvbiArICgxIC0gZnJhY3Rpb24pICogdDtcbiAgICAgICAgICAgIGZyb21TY2FsZSAqPSAyO1xuICAgICAgICAgICAgZnJvbSA9IGNhbGN1bGF0ZSh7em9vbTogeiAtIDF9LCBmZWF0dXJlUHJvcGVydGllcyk7XG4gICAgICAgICAgICB0byA9IGNhbGN1bGF0ZSh7em9vbTogen0sIGZlYXR1cmVQcm9wZXJ0aWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1peCA9IDEgLSAoMSAtIHQpICogZnJhY3Rpb247XG4gICAgICAgICAgICB0byA9IGNhbGN1bGF0ZSh7em9vbTogen0sIGZlYXR1cmVQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIGZyb20gPSBjYWxjdWxhdGUoe3pvb206IHogKyAxfSwgZmVhdHVyZVByb3BlcnRpZXMpO1xuICAgICAgICAgICAgZnJvbVNjYWxlIC89IDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkIHx8IHRvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICAgICAgZnJvbVNjYWxlOiBmcm9tU2NhbGUsXG4gICAgICAgICAgICAgICAgdG86IHRvLFxuICAgICAgICAgICAgICAgIHRvU2NhbGU6IHRvU2NhbGUsXG4gICAgICAgICAgICAgICAgdDogbWl4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIE1hcGJveEdMRnVuY3Rpb24gPSByZXF1aXJlKCdtYXBib3gtZ2wtZnVuY3Rpb24nKTtcblxuZXhwb3J0cy5pbnRlcnBvbGF0ZWQgPSBmdW5jdGlvbihwYXJhbWV0ZXJzLCBzcGVjRGVmYXVsdCkge1xuICAgIHZhciBpbm5lciA9IE1hcGJveEdMRnVuY3Rpb24uaW50ZXJwb2xhdGVkKHBhcmFtZXRlcnMsIHNwZWNEZWZhdWx0KTtcbiAgICB2YXIgb3V0ZXIgPSBmdW5jdGlvbihnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcykge1xuICAgICAgICByZXR1cm4gaW5uZXIoZ2xvYmFsUHJvcGVydGllcyAmJiBnbG9iYWxQcm9wZXJ0aWVzLnpvb20sIGZlYXR1cmVQcm9wZXJ0aWVzIHx8IHt9KTtcbiAgICB9O1xuICAgIG91dGVyLmlzRmVhdHVyZUNvbnN0YW50ID0gaW5uZXIuaXNGZWF0dXJlQ29uc3RhbnQ7XG4gICAgb3V0ZXIuaXNab29tQ29uc3RhbnQgPSBpbm5lci5pc1pvb21Db25zdGFudDtcbiAgICByZXR1cm4gb3V0ZXI7XG59O1xuXG5leHBvcnRzWydwaWVjZXdpc2UtY29uc3RhbnQnXSA9IGZ1bmN0aW9uKHBhcmFtZXRlcnMsIHNwZWNEZWZhdWx0KSB7XG4gICAgdmFyIGlubmVyID0gTWFwYm94R0xGdW5jdGlvblsncGllY2V3aXNlLWNvbnN0YW50J10ocGFyYW1ldGVycywgc3BlY0RlZmF1bHQpO1xuICAgIHZhciBvdXRlciA9IGZ1bmN0aW9uKGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHJldHVybiBpbm5lcihnbG9iYWxQcm9wZXJ0aWVzICYmIGdsb2JhbFByb3BlcnRpZXMuem9vbSwgZmVhdHVyZVByb3BlcnRpZXMgfHwge30pO1xuICAgIH07XG4gICAgb3V0ZXIuaXNGZWF0dXJlQ29uc3RhbnQgPSBpbm5lci5pc0ZlYXR1cmVDb25zdGFudDtcbiAgICBvdXRlci5pc1pvb21Db25zdGFudCA9IGlubmVyLmlzWm9vbUNvbnN0YW50O1xuICAgIHJldHVybiBvdXRlcjtcbn07XG5cbmV4cG9ydHMuaXNGdW5jdGlvbkRlZmluaXRpb24gPSBNYXBib3hHTEZ1bmN0aW9uLmlzRnVuY3Rpb25EZWZpbml0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIFN0eWxlVHJhbnNpdGlvbiA9IHJlcXVpcmUoJy4vc3R5bGVfdHJhbnNpdGlvbicpO1xudmFyIFN0eWxlRGVjbGFyYXRpb24gPSByZXF1aXJlKCcuL3N0eWxlX2RlY2xhcmF0aW9uJyk7XG52YXIgc3R5bGVTcGVjID0gcmVxdWlyZSgnLi9zdHlsZV9zcGVjJyk7XG52YXIgdmFsaWRhdGVTdHlsZSA9IHJlcXVpcmUoJy4vdmFsaWRhdGVfc3R5bGUnKTtcbnZhciBwYXJzZUNvbG9yID0gcmVxdWlyZSgnLi9wYXJzZV9jb2xvcicpO1xudmFyIEV2ZW50ZWQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50ZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHlsZUxheWVyO1xuXG52YXIgVFJBTlNJVElPTl9TVUZGSVggPSAnLXRyYW5zaXRpb24nO1xuXG5TdHlsZUxheWVyLmNyZWF0ZSA9IGZ1bmN0aW9uKGxheWVyLCByZWZMYXllcikge1xuICAgIHZhciBDbGFzc2VzID0ge1xuICAgICAgICBiYWNrZ3JvdW5kOiByZXF1aXJlKCcuL3N0eWxlX2xheWVyL2JhY2tncm91bmRfc3R5bGVfbGF5ZXInKSxcbiAgICAgICAgY2lyY2xlOiByZXF1aXJlKCcuL3N0eWxlX2xheWVyL2NpcmNsZV9zdHlsZV9sYXllcicpLFxuICAgICAgICBmaWxsOiByZXF1aXJlKCcuL3N0eWxlX2xheWVyL2ZpbGxfc3R5bGVfbGF5ZXInKSxcbiAgICAgICAgbGluZTogcmVxdWlyZSgnLi9zdHlsZV9sYXllci9saW5lX3N0eWxlX2xheWVyJyksXG4gICAgICAgIHJhc3RlcjogcmVxdWlyZSgnLi9zdHlsZV9sYXllci9yYXN0ZXJfc3R5bGVfbGF5ZXInKSxcbiAgICAgICAgc3ltYm9sOiByZXF1aXJlKCcuL3N0eWxlX2xheWVyL3N5bWJvbF9zdHlsZV9sYXllcicpLFxuICAgICAgICBleHRydXNpb246IHJlcXVpcmUoJy4vc3R5bGVfbGF5ZXIvZXh0cnVzaW9uX3N0eWxlX2xheWVyJylcbiAgICB9O1xuICAgIHJldHVybiBuZXcgQ2xhc3Nlc1socmVmTGF5ZXIgfHwgbGF5ZXIpLnR5cGVdKGxheWVyLCByZWZMYXllcik7XG59O1xuXG5mdW5jdGlvbiBTdHlsZUxheWVyKGxheWVyLCByZWZMYXllcikge1xuICAgIHRoaXMuc2V0KGxheWVyLCByZWZMYXllcik7XG59XG5cblN0eWxlTGF5ZXIucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KEV2ZW50ZWQsIHtcblxuICAgIHNldDogZnVuY3Rpb24obGF5ZXIsIHJlZkxheWVyKSB7XG4gICAgICAgIHRoaXMuaWQgPSBsYXllci5pZDtcbiAgICAgICAgdGhpcy5yZWYgPSBsYXllci5yZWY7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBsYXllci5tZXRhZGF0YTtcbiAgICAgICAgdGhpcy50eXBlID0gKHJlZkxheWVyIHx8IGxheWVyKS50eXBlO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IChyZWZMYXllciB8fCBsYXllcikuc291cmNlO1xuICAgICAgICB0aGlzLnNvdXJjZUxheWVyID0gKHJlZkxheWVyIHx8IGxheWVyKVsnc291cmNlLWxheWVyJ107XG4gICAgICAgIHRoaXMubWluem9vbSA9IChyZWZMYXllciB8fCBsYXllcikubWluem9vbTtcbiAgICAgICAgdGhpcy5tYXh6b29tID0gKHJlZkxheWVyIHx8IGxheWVyKS5tYXh6b29tO1xuICAgICAgICB0aGlzLmZpbHRlciA9IChyZWZMYXllciB8fCBsYXllcikuZmlsdGVyO1xuXG4gICAgICAgIHRoaXMucGFpbnQgPSB7fTtcbiAgICAgICAgdGhpcy5sYXlvdXQgPSB7fTtcblxuICAgICAgICB0aGlzLl9wYWludFNwZWNpZmljYXRpb25zID0gc3R5bGVTcGVjWydwYWludF8nICsgdGhpcy50eXBlXTtcbiAgICAgICAgdGhpcy5fbGF5b3V0U3BlY2lmaWNhdGlvbnMgPSBzdHlsZVNwZWNbJ2xheW91dF8nICsgdGhpcy50eXBlXTtcblxuICAgICAgICB0aGlzLl9wYWludFRyYW5zaXRpb25zID0ge307IC8vIHtbcHJvcGVydHlOYW1lXTogU3R5bGVUcmFuc2l0aW9ufVxuICAgICAgICB0aGlzLl9wYWludFRyYW5zaXRpb25PcHRpb25zID0ge307IC8vIHtbY2xhc3NOYW1lXToge1twcm9wZXJ0eU5hbWVdOiB7IGR1cmF0aW9uOk51bWJlciwgZGVsYXk6TnVtYmVyIH19fVxuICAgICAgICB0aGlzLl9wYWludERlY2xhcmF0aW9ucyA9IHt9OyAvLyB7W2NsYXNzTmFtZV06IHtbcHJvcGVydHlOYW1lXTogU3R5bGVEZWNsYXJhdGlvbn19XG4gICAgICAgIHRoaXMuX2xheW91dERlY2xhcmF0aW9ucyA9IHt9OyAvLyB7W3Byb3BlcnR5TmFtZV06IFN0eWxlRGVjbGFyYXRpb259XG4gICAgICAgIHRoaXMuX2xheW91dEZ1bmN0aW9ucyA9IHt9OyAvLyB7W3Byb3BlcnR5TmFtZV06IEJvb2xlYW59XG5cbiAgICAgICAgdmFyIHBhaW50TmFtZSwgbGF5b3V0TmFtZTtcblxuICAgICAgICAvLyBSZXNvbHZlIHBhaW50IGRlY2xhcmF0aW9uc1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGtleS5tYXRjaCgvXnBhaW50KD86XFwuKC4qKSk/JC8pO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtsYXNzID0gbWF0Y2hbMV0gfHwgJyc7XG4gICAgICAgICAgICAgICAgZm9yIChwYWludE5hbWUgaW4gbGF5ZXJba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBhaW50UHJvcGVydHkocGFpbnROYW1lLCBsYXllcltrZXldW3BhaW50TmFtZV0sIGtsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNvbHZlIGxheW91dCBkZWNsYXJhdGlvbnNcbiAgICAgICAgaWYgKHRoaXMucmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXREZWNsYXJhdGlvbnMgPSByZWZMYXllci5fbGF5b3V0RGVjbGFyYXRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsYXlvdXROYW1lIGluIGxheWVyLmxheW91dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TGF5b3V0UHJvcGVydHkobGF5b3V0TmFtZSwgbGF5ZXIubGF5b3V0W2xheW91dE5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBpbml0aWFsIGxheW91dC9wYWludCB2YWx1ZXNcbiAgICAgICAgZm9yIChwYWludE5hbWUgaW4gdGhpcy5fcGFpbnRTcGVjaWZpY2F0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5wYWludFtwYWludE5hbWVdID0gdGhpcy5nZXRQYWludFZhbHVlKHBhaW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsYXlvdXROYW1lIGluIHRoaXMuX2xheW91dFNwZWNpZmljYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMYXlvdXRWYWx1ZShsYXlvdXROYW1lKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRMYXlvdXRQcm9wZXJ0eTogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcblxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xheW91dERlY2xhcmF0aW9uc1tuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSAnbGF5ZXJzLicgKyB0aGlzLmlkICsgJy5sYXlvdXQuJyArIG5hbWU7XG4gICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlRXJyb3JzKHZhbGlkYXRlU3R5bGUubGF5b3V0UHJvcGVydHksIGtleSwgbmFtZSwgdmFsdWUpKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLl9sYXlvdXREZWNsYXJhdGlvbnNbbmFtZV0gPSBuZXcgU3R5bGVEZWNsYXJhdGlvbihuYW1lLCB0aGlzLl9sYXlvdXRTcGVjaWZpY2F0aW9uc1tuYW1lXSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZUxheW91dFZhbHVlKG5hbWUpO1xuICAgIH0sXG5cbiAgICBnZXRMYXlvdXRQcm9wZXJ0eTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5fbGF5b3V0RGVjbGFyYXRpb25zW25hbWVdICYmXG4gICAgICAgICAgICB0aGlzLl9sYXlvdXREZWNsYXJhdGlvbnNbbmFtZV0udmFsdWVcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgZ2V0TGF5b3V0VmFsdWU6IGZ1bmN0aW9uKG5hbWUsIGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHZhciBzcGVjaWZpY2F0aW9uID0gdGhpcy5fbGF5b3V0U3BlY2lmaWNhdGlvbnNbbmFtZV07XG4gICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMuX2xheW91dERlY2xhcmF0aW9uc1tuYW1lXTtcblxuICAgICAgICBpZiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNsYXJhdGlvbi5jYWxjdWxhdGUoZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNwZWNpZmljYXRpb24uZGVmYXVsdDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRQYWludFByb3BlcnR5OiBmdW5jdGlvbihuYW1lLCB2YWx1ZSwga2xhc3MpIHtcbiAgICAgICAgdmFyIHZhbGlkYXRlU3R5bGVLZXkgPSAnbGF5ZXJzLicgKyB0aGlzLmlkICsgKGtsYXNzID8gJ1tcInBhaW50LicgKyBrbGFzcyArICdcIl0uJyA6ICcucGFpbnQuJykgKyBuYW1lO1xuXG4gICAgICAgIGlmICh1dGlsLmVuZHNXaXRoKG5hbWUsIFRSQU5TSVRJT05fU1VGRklYKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wYWludFRyYW5zaXRpb25PcHRpb25zW2tsYXNzIHx8ICcnXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhaW50VHJhbnNpdGlvbk9wdGlvbnNba2xhc3MgfHwgJyddID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wYWludFRyYW5zaXRpb25PcHRpb25zW2tsYXNzIHx8ICcnXVtuYW1lXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZUVycm9ycyh2YWxpZGF0ZVN0eWxlLnBhaW50UHJvcGVydHksIHZhbGlkYXRlU3R5bGVLZXksIG5hbWUsIHZhbHVlKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhaW50VHJhbnNpdGlvbk9wdGlvbnNba2xhc3MgfHwgJyddW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3BhaW50RGVjbGFyYXRpb25zW2tsYXNzIHx8ICcnXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhaW50RGVjbGFyYXRpb25zW2tsYXNzIHx8ICcnXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fcGFpbnREZWNsYXJhdGlvbnNba2xhc3MgfHwgJyddW25hbWVdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlRXJyb3JzKHZhbGlkYXRlU3R5bGUucGFpbnRQcm9wZXJ0eSwgdmFsaWRhdGVTdHlsZUtleSwgbmFtZSwgdmFsdWUpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFpbnREZWNsYXJhdGlvbnNba2xhc3MgfHwgJyddW25hbWVdID0gbmV3IFN0eWxlRGVjbGFyYXRpb24obmFtZSwgdGhpcy5fcGFpbnRTcGVjaWZpY2F0aW9uc1tuYW1lXSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFBhaW50UHJvcGVydHk6IGZ1bmN0aW9uKG5hbWUsIGtsYXNzKSB7XG4gICAgICAgIGtsYXNzID0ga2xhc3MgfHwgJyc7XG4gICAgICAgIGlmICh1dGlsLmVuZHNXaXRoKG5hbWUsIFRSQU5TSVRJT05fU1VGRklYKSkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICB0aGlzLl9wYWludFRyYW5zaXRpb25PcHRpb25zW2tsYXNzXSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3BhaW50VHJhbnNpdGlvbk9wdGlvbnNba2xhc3NdW25hbWVdXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICB0aGlzLl9wYWludERlY2xhcmF0aW9uc1trbGFzc10gJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9wYWludERlY2xhcmF0aW9uc1trbGFzc11bbmFtZV0gJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9wYWludERlY2xhcmF0aW9uc1trbGFzc11bbmFtZV0udmFsdWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0UGFpbnRWYWx1ZTogZnVuY3Rpb24obmFtZSwgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpIHtcbiAgICAgICAgdmFyIHNwZWNpZmljYXRpb24gPSB0aGlzLl9wYWludFNwZWNpZmljYXRpb25zW25hbWVdO1xuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IHRoaXMuX3BhaW50VHJhbnNpdGlvbnNbbmFtZV07XG5cbiAgICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2l0aW9uLmNhbGN1bGF0ZShnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3BlY2lmaWNhdGlvbi50eXBlID09PSAnY29sb3InICYmIHNwZWNpZmljYXRpb24uZGVmYXVsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlQ29sb3Ioc3BlY2lmaWNhdGlvbi5kZWZhdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzcGVjaWZpY2F0aW9uLmRlZmF1bHQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0UGFpbnRWYWx1ZVN0b3Bab29tTGV2ZWxzOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcy5fcGFpbnRUcmFuc2l0aW9uc1tuYW1lXTtcbiAgICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2l0aW9uLmRlY2xhcmF0aW9uLnN0b3Bab29tTGV2ZWxzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFBhaW50SW50ZXJwb2xhdGlvblQ6IGZ1bmN0aW9uKG5hbWUsIHpvb20pIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLl9wYWludFRyYW5zaXRpb25zW25hbWVdO1xuICAgICAgICByZXR1cm4gdHJhbnNpdGlvbi5kZWNsYXJhdGlvbi5jYWxjdWxhdGVJbnRlcnBvbGF0aW9uVCh7IHpvb206IHpvb20gfSk7XG4gICAgfSxcblxuICAgIGlzUGFpbnRWYWx1ZUZlYXR1cmVDb25zdGFudDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IHRoaXMuX3BhaW50VHJhbnNpdGlvbnNbbmFtZV07XG5cbiAgICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2l0aW9uLmRlY2xhcmF0aW9uLmlzRmVhdHVyZUNvbnN0YW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNMYXlvdXRWYWx1ZUZlYXR1cmVDb25zdGFudDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgZGVjbGFyYXRpb24gPSB0aGlzLl9sYXlvdXREZWNsYXJhdGlvbnNbbmFtZV07XG5cbiAgICAgICAgaWYgKGRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjbGFyYXRpb24uaXNGZWF0dXJlQ29uc3RhbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpc1BhaW50VmFsdWVab29tQ29uc3RhbnQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLl9wYWludFRyYW5zaXRpb25zW25hbWVdO1xuXG4gICAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNpdGlvbi5kZWNsYXJhdGlvbi5pc1pvb21Db25zdGFudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuXG4gICAgaXNIaWRkZW46IGZ1bmN0aW9uKHpvb20pIHtcbiAgICAgICAgaWYgKHRoaXMubWluem9vbSAmJiB6b29tIDwgdGhpcy5taW56b29tKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMubWF4em9vbSAmJiB6b29tID49IHRoaXMubWF4em9vbSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLmxheW91dFsndmlzaWJpbGl0eSddID09PSAnbm9uZScpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5wYWludFt0aGlzLnR5cGUgKyAnLW9wYWNpdHknXSA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgdXBkYXRlUGFpbnRUcmFuc2l0aW9uczogZnVuY3Rpb24oY2xhc3Nlcywgb3B0aW9ucywgZ2xvYmFsT3B0aW9ucywgYW5pbWF0aW9uTG9vcCkge1xuICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMuX3BhaW50RGVjbGFyYXRpb25zWycnXSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdXRpbC5leHRlbmQoZGVjbGFyYXRpb25zLCB0aGlzLl9wYWludERlY2xhcmF0aW9uc1tjbGFzc2VzW2ldXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgZm9yIChuYW1lIGluIGRlY2xhcmF0aW9ucykgeyAvLyBhcHBseSBuZXcgZGVjbGFyYXRpb25zXG4gICAgICAgICAgICB0aGlzLl9hcHBseVBhaW50RGVjbGFyYXRpb24obmFtZSwgZGVjbGFyYXRpb25zW25hbWVdLCBvcHRpb25zLCBnbG9iYWxPcHRpb25zLCBhbmltYXRpb25Mb29wKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKG5hbWUgaW4gdGhpcy5fcGFpbnRUcmFuc2l0aW9ucykge1xuICAgICAgICAgICAgaWYgKCEobmFtZSBpbiBkZWNsYXJhdGlvbnMpKSAvLyBhcHBseSByZW1vdmVkIGRlY2xhcmF0aW9uc1xuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5UGFpbnREZWNsYXJhdGlvbihuYW1lLCBudWxsLCBvcHRpb25zLCBnbG9iYWxPcHRpb25zLCBhbmltYXRpb25Mb29wKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGVQYWludFRyYW5zaXRpb246IGZ1bmN0aW9uKG5hbWUsIGNsYXNzZXMsIG9wdGlvbnMsIGdsb2JhbE9wdGlvbnMsIGFuaW1hdGlvbkxvb3ApIHtcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9uID0gdGhpcy5fcGFpbnREZWNsYXJhdGlvbnNbJyddW25hbWVdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjbGFzc1BhaW50RGVjbGFyYXRpb25zID0gdGhpcy5fcGFpbnREZWNsYXJhdGlvbnNbY2xhc3Nlc1tpXV07XG4gICAgICAgICAgICBpZiAoY2xhc3NQYWludERlY2xhcmF0aW9ucyAmJiBjbGFzc1BhaW50RGVjbGFyYXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb24gPSBjbGFzc1BhaW50RGVjbGFyYXRpb25zW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FwcGx5UGFpbnREZWNsYXJhdGlvbihuYW1lLCBkZWNsYXJhdGlvbiwgb3B0aW9ucywgZ2xvYmFsT3B0aW9ucywgYW5pbWF0aW9uTG9vcCk7XG4gICAgfSxcblxuICAgIC8vIHVwZGF0ZSBhbGwgem9vbS1kZXBlbmRlbnQgbGF5b3V0L3BhaW50IHZhbHVlc1xuICAgIHJlY2FsY3VsYXRlOiBmdW5jdGlvbih6b29tLCB6b29tSGlzdG9yeSkge1xuICAgICAgICBmb3IgKHZhciBwYWludE5hbWUgaW4gdGhpcy5fcGFpbnRUcmFuc2l0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5wYWludFtwYWludE5hbWVdID0gdGhpcy5nZXRQYWludFZhbHVlKHBhaW50TmFtZSwge3pvb206IHpvb20sIHpvb21IaXN0b3J5OiB6b29tSGlzdG9yeX0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGxheW91dE5hbWUgaW4gdGhpcy5fbGF5b3V0RnVuY3Rpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dFtsYXlvdXROYW1lXSA9IHRoaXMuZ2V0TGF5b3V0VmFsdWUobGF5b3V0TmFtZSwge3pvb206IHpvb20sIHpvb21IaXN0b3J5OiB6b29tSGlzdG9yeX0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgb3V0cHV0ID0ge1xuICAgICAgICAgICAgJ2lkJzogdGhpcy5pZCxcbiAgICAgICAgICAgICdyZWYnOiB0aGlzLnJlZixcbiAgICAgICAgICAgICdtZXRhZGF0YSc6IHRoaXMubWV0YWRhdGEsXG4gICAgICAgICAgICAnbWluem9vbSc6IHRoaXMubWluem9vbSxcbiAgICAgICAgICAgICdtYXh6b29tJzogdGhpcy5tYXh6b29tXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIga2xhc3MgaW4gdGhpcy5fcGFpbnREZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrbGFzcyA9PT0gJycgPyAncGFpbnQnIDogJ3BhaW50LicgKyBrbGFzcztcbiAgICAgICAgICAgIG91dHB1dFtrZXldID0gdXRpbC5tYXBPYmplY3QodGhpcy5fcGFpbnREZWNsYXJhdGlvbnNba2xhc3NdLCBnZXREZWNsYXJhdGlvblZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5yZWYgfHwgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbmNsdWRlUmVmUHJvcGVydGllcykpIHtcbiAgICAgICAgICAgIHV0aWwuZXh0ZW5kKG91dHB1dCwge1xuICAgICAgICAgICAgICAgICd0eXBlJzogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgICdzb3VyY2UnOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAnc291cmNlLWxheWVyJzogdGhpcy5zb3VyY2VMYXllcixcbiAgICAgICAgICAgICAgICAnZmlsdGVyJzogdGhpcy5maWx0ZXIsXG4gICAgICAgICAgICAgICAgJ2xheW91dCc6IHV0aWwubWFwT2JqZWN0KHRoaXMuX2xheW91dERlY2xhcmF0aW9ucywgZ2V0RGVjbGFyYXRpb25WYWx1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHV0aWwuZmlsdGVyT2JqZWN0KG91dHB1dCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIShrZXkgPT09ICdsYXlvdXQnICYmICFPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIHNldCBwYWludCB0cmFuc2l0aW9uIGJhc2VkIG9uIGEgZ2l2ZW4gcGFpbnQgZGVjbGFyYXRpb25cbiAgICBfYXBwbHlQYWludERlY2xhcmF0aW9uOiBmdW5jdGlvbiAobmFtZSwgZGVjbGFyYXRpb24sIG9wdGlvbnMsIGdsb2JhbE9wdGlvbnMsIGFuaW1hdGlvbkxvb3ApIHtcbiAgICAgICAgdmFyIG9sZFRyYW5zaXRpb24gPSBvcHRpb25zLnRyYW5zaXRpb24gPyB0aGlzLl9wYWludFRyYW5zaXRpb25zW25hbWVdIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgc3BlYyA9IHRoaXMuX3BhaW50U3BlY2lmaWNhdGlvbnNbbmFtZV07XG5cbiAgICAgICAgaWYgKGRlY2xhcmF0aW9uID09PSBudWxsIHx8IGRlY2xhcmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uID0gbmV3IFN0eWxlRGVjbGFyYXRpb24obmFtZSwgc3BlYywgc3BlYy5kZWZhdWx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvbGRUcmFuc2l0aW9uICYmIG9sZFRyYW5zaXRpb24uZGVjbGFyYXRpb24uanNvbiA9PT0gZGVjbGFyYXRpb24uanNvbikgcmV0dXJuO1xuXG4gICAgICAgIHZhciB0cmFuc2l0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiAzMDAsXG4gICAgICAgICAgICBkZWxheTogMFxuICAgICAgICB9LCBnbG9iYWxPcHRpb25zLCB0aGlzLmdldFBhaW50UHJvcGVydHkobmFtZSArIFRSQU5TSVRJT05fU1VGRklYKSk7XG5cbiAgICAgICAgdmFyIG5ld1RyYW5zaXRpb24gPSB0aGlzLl9wYWludFRyYW5zaXRpb25zW25hbWVdID1cbiAgICAgICAgICAgIG5ldyBTdHlsZVRyYW5zaXRpb24oc3BlYywgZGVjbGFyYXRpb24sIG9sZFRyYW5zaXRpb24sIHRyYW5zaXRpb25PcHRpb25zKTtcblxuICAgICAgICBpZiAoIW5ld1RyYW5zaXRpb24uaW5zdGFudCgpKSB7XG4gICAgICAgICAgICBuZXdUcmFuc2l0aW9uLmxvb3BJRCA9IGFuaW1hdGlvbkxvb3Auc2V0KG5ld1RyYW5zaXRpb24uZW5kVGltZSAtIERhdGUubm93KCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICBhbmltYXRpb25Mb29wLmNhbmNlbChvbGRUcmFuc2l0aW9uLmxvb3BJRCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gdXBkYXRlIGxheW91dCB2YWx1ZSBpZiBpdCdzIGNvbnN0YW50LCBvciBtYXJrIGl0IGFzIHpvb20tZGVwZW5kZW50XG4gICAgX3VwZGF0ZUxheW91dFZhbHVlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBkZWNsYXJhdGlvbiA9IHRoaXMuX2xheW91dERlY2xhcmF0aW9uc1tuYW1lXTtcblxuICAgICAgICBpZiAoZGVjbGFyYXRpb24gJiYgZGVjbGFyYXRpb24uaXNGdW5jdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0RnVuY3Rpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9sYXlvdXRGdW5jdGlvbnNbbmFtZV07XG4gICAgICAgICAgICB0aGlzLmxheW91dFtuYW1lXSA9IHRoaXMuZ2V0TGF5b3V0VmFsdWUobmFtZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2hhbmRsZUVycm9yczogZnVuY3Rpb24odmFsaWRhdGUsIGtleSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlU3R5bGUuZW1pdEVycm9ycyh0aGlzLCB2YWxpZGF0ZS5jYWxsKHZhbGlkYXRlU3R5bGUsIHtcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgbGF5ZXJUeXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBvYmplY3RLZXk6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlYyxcbiAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvbWFwYm94LWdsLWpzL2lzc3Vlcy8yNDA3XG4gICAgICAgICAgICBzdHlsZToge2dseXBoczogdHJ1ZSwgc3ByaXRlOiB0cnVlfVxuICAgICAgICB9KSk7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uVmFsdWUoZGVjbGFyYXRpb24pIHtcbiAgICByZXR1cm4gZGVjbGFyYXRpb24udmFsdWU7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgU3R5bGVMYXllciA9IHJlcXVpcmUoJy4uL3N0eWxlX2xheWVyJyk7XG5cbmZ1bmN0aW9uIEJhY2tncm91bmRTdHlsZUxheWVyKCkge1xuICAgIFN0eWxlTGF5ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrZ3JvdW5kU3R5bGVMYXllcjtcblxuQmFja2dyb3VuZFN0eWxlTGF5ZXIucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KFN0eWxlTGF5ZXIsIHt9KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcbnZhciBTdHlsZUxheWVyID0gcmVxdWlyZSgnLi4vc3R5bGVfbGF5ZXInKTtcblxuZnVuY3Rpb24gQ2lyY2xlU3R5bGVMYXllcigpIHtcbiAgICBTdHlsZUxheWVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlU3R5bGVMYXllcjtcblxuQ2lyY2xlU3R5bGVMYXllci5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoU3R5bGVMYXllciwge30pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xudmFyIFN0eWxlTGF5ZXIgPSByZXF1aXJlKCcuLi9zdHlsZV9sYXllcicpO1xuXG5mdW5jdGlvbiBFeHRydXNpb25TdHlsZUxheWVyKCkge1xuICAgIFN0eWxlTGF5ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFeHRydXNpb25TdHlsZUxheWVyO1xuRXh0cnVzaW9uU3R5bGVMYXllci5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoU3R5bGVMYXllciwge30pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xudmFyIFN0eWxlTGF5ZXIgPSByZXF1aXJlKCcuLi9zdHlsZV9sYXllcicpO1xuXG5mdW5jdGlvbiBGaWxsU3R5bGVMYXllcigpIHtcbiAgICBTdHlsZUxheWVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbkZpbGxTdHlsZUxheWVyLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChTdHlsZUxheWVyLCB7XG5cbiAgICBnZXRQYWludFZhbHVlOiBmdW5jdGlvbihuYW1lLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcykge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ2ZpbGwtb3V0bGluZS1jb2xvcicgJiYgdGhpcy5nZXRQYWludFByb3BlcnR5KCdmaWxsLW91dGxpbmUtY29sb3InKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gU3R5bGVMYXllci5wcm90b3R5cGUuZ2V0UGFpbnRWYWx1ZS5jYWxsKHRoaXMsICdmaWxsLWNvbG9yJywgZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZVByb3BlcnRpZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFN0eWxlTGF5ZXIucHJvdG90eXBlLmdldFBhaW50VmFsdWUuY2FsbCh0aGlzLCBuYW1lLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0UGFpbnRWYWx1ZVN0b3Bab29tTGV2ZWxzOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lID09PSAnZmlsbC1vdXRsaW5lLWNvbG9yJyAmJiB0aGlzLmdldFBhaW50UHJvcGVydHkoJ2ZpbGwtb3V0bGluZS1jb2xvcicpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHlsZUxheWVyLnByb3RvdHlwZS5nZXRQYWludFZhbHVlU3RvcFpvb21MZXZlbHMuY2FsbCh0aGlzLCAnZmlsbC1jb2xvcicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFN0eWxlTGF5ZXIucHJvdG90eXBlLmdldFBhaW50VmFsdWVTdG9wWm9vbUxldmVscy5jYWxsKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0UGFpbnRJbnRlcnBvbGF0aW9uVDogZnVuY3Rpb24obmFtZSwgem9vbSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ2ZpbGwtb3V0bGluZS1jb2xvcicgJiYgdGhpcy5nZXRQYWludFByb3BlcnR5KCdmaWxsLW91dGxpbmUtY29sb3InKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gU3R5bGVMYXllci5wcm90b3R5cGUuZ2V0UGFpbnRJbnRlcnBvbGF0aW9uVC5jYWxsKHRoaXMsICdmaWxsLWNvbG9yJywgem9vbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gU3R5bGVMYXllci5wcm90b3R5cGUuZ2V0UGFpbnRJbnRlcnBvbGF0aW9uVC5jYWxsKHRoaXMsIG5hbWUsIHpvb20pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGlzUGFpbnRWYWx1ZUZlYXR1cmVDb25zdGFudDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ2ZpbGwtb3V0bGluZS1jb2xvcicgJiYgdGhpcy5nZXRQYWludFByb3BlcnR5KCdmaWxsLW91dGxpbmUtY29sb3InKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gU3R5bGVMYXllci5wcm90b3R5cGUuaXNQYWludFZhbHVlRmVhdHVyZUNvbnN0YW50LmNhbGwodGhpcywgJ2ZpbGwtY29sb3InKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBTdHlsZUxheWVyLnByb3RvdHlwZS5pc1BhaW50VmFsdWVGZWF0dXJlQ29uc3RhbnQuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpc1BhaW50VmFsdWVab29tQ29uc3RhbnQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdmaWxsLW91dGxpbmUtY29sb3InICYmIHRoaXMuZ2V0UGFpbnRQcm9wZXJ0eSgnZmlsbC1vdXRsaW5lLWNvbG9yJykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFN0eWxlTGF5ZXIucHJvdG90eXBlLmlzUGFpbnRWYWx1ZVpvb21Db25zdGFudC5jYWxsKHRoaXMsICdmaWxsLWNvbG9yJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gU3R5bGVMYXllci5wcm90b3R5cGUuaXNQYWludFZhbHVlWm9vbUNvbnN0YW50LmNhbGwodGhpcywgbmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbGxTdHlsZUxheWVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xudmFyIFN0eWxlTGF5ZXIgPSByZXF1aXJlKCcuLi9zdHlsZV9sYXllcicpO1xuXG5mdW5jdGlvbiBMaW5lU3R5bGVMYXllcigpIHtcbiAgICBTdHlsZUxheWVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZVN0eWxlTGF5ZXI7XG5cbkxpbmVTdHlsZUxheWVyLnByb3RvdHlwZSA9IHV0aWwuaW5oZXJpdChTdHlsZUxheWVyLCB7XG5cbiAgICBnZXRQYWludFZhbHVlOiBmdW5jdGlvbihuYW1lLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcykge1xuICAgICAgICB2YXIgdmFsdWUgPSBTdHlsZUxheWVyLnByb3RvdHlwZS5nZXRQYWludFZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gSWYgdGhlIGxpbmUgaXMgZGFzaGVkLCBzY2FsZSB0aGUgZGFzaCBsZW5ndGhzIGJ5IHRoZSBsaW5lXG4gICAgICAgIC8vIHdpZHRoIGF0IHRoZSBwcmV2aW91cyByb3VuZCB6b29tIGxldmVsLlxuICAgICAgICBpZiAodmFsdWUgJiYgbmFtZSA9PT0gJ2xpbmUtZGFzaGFycmF5Jykge1xuICAgICAgICAgICAgdmFyIGZsb29yZWRab29tID0gTWF0aC5mbG9vcihnbG9iYWxQcm9wZXJ0aWVzLnpvb20pO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Zsb29yZWRab29tICE9PSBmbG9vcmVkWm9vbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Zsb29yZWRab29tID0gZmxvb3JlZFpvb207XG4gICAgICAgICAgICAgICAgdGhpcy5fZmxvb3JlZExpbmVXaWR0aCA9IHRoaXMuZ2V0UGFpbnRWYWx1ZSgnbGluZS13aWR0aCcsIGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUuZnJvbVNjYWxlICo9IHRoaXMuX2Zsb29yZWRMaW5lV2lkdGg7XG4gICAgICAgICAgICB2YWx1ZS50b1NjYWxlICo9IHRoaXMuX2Zsb29yZWRMaW5lV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgU3R5bGVMYXllciA9IHJlcXVpcmUoJy4uL3N0eWxlX2xheWVyJyk7XG5cbmZ1bmN0aW9uIFJhc3RlclN0eWxlTGF5ZXIoKSB7XG4gICAgU3R5bGVMYXllci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJhc3RlclN0eWxlTGF5ZXI7XG5cblJhc3RlclN0eWxlTGF5ZXIucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KFN0eWxlTGF5ZXIsIHt9KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcbnZhciBTdHlsZUxheWVyID0gcmVxdWlyZSgnLi4vc3R5bGVfbGF5ZXInKTtcblxuZnVuY3Rpb24gU3ltYm9sU3R5bGVMYXllcigpIHtcbiAgICBTdHlsZUxheWVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sU3R5bGVMYXllcjtcblxuU3ltYm9sU3R5bGVMYXllci5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoU3R5bGVMYXllciwge1xuXG4gICAgaXNIaWRkZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoU3R5bGVMYXllci5wcm90b3R5cGUuaXNIaWRkZW4uYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgdmFyIGlzVGV4dEhpZGRlbiA9IHRoaXMucGFpbnRbJ3RleHQtb3BhY2l0eSddID09PSAwIHx8ICF0aGlzLmxheW91dFsndGV4dC1maWVsZCddO1xuICAgICAgICB2YXIgaXNJY29uSGlkZGVuID0gdGhpcy5wYWludFsnaWNvbi1vcGFjaXR5J10gPT09IDAgfHwgIXRoaXMubGF5b3V0WydpY29uLWltYWdlJ107XG4gICAgICAgIGlmIChpc1RleHRIaWRkZW4gJiYgaXNJY29uSGlkZGVuKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIGdldExheW91dFZhbHVlOiBmdW5jdGlvbihuYW1lLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcykge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3RleHQtcm90YXRpb24tYWxpZ25tZW50JyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGF5b3V0VmFsdWUoJ3N5bWJvbC1wbGFjZW1lbnQnLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcykgPT09ICdsaW5lJyAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmdldExheW91dFByb3BlcnR5KCd0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21hcCc7XG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2ljb24tcm90YXRpb24tYWxpZ25tZW50JyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGF5b3V0VmFsdWUoJ3N5bWJvbC1wbGFjZW1lbnQnLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcykgPT09ICdsaW5lJyAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmdldExheW91dFByb3BlcnR5KCdpY29uLXJvdGF0aW9uLWFsaWdubWVudCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21hcCc7XG4gICAgICAgIC8vIElmIHVuc3BlY2lmaWVkIGB0ZXh0LXBpdGNoLWFsaWdubWVudGAgaW5oZXJpdHMgYHRleHQtcm90YXRpb24tYWxpZ25tZW50YFxuICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd0ZXh0LXBpdGNoLWFsaWdubWVudCcgJiYgIXRoaXMuZ2V0TGF5b3V0UHJvcGVydHkoJ3RleHQtcGl0Y2gtYWxpZ25tZW50JykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExheW91dFZhbHVlKCd0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFN0eWxlTGF5ZXIucHJvdG90eXBlLmdldExheW91dFZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ21hcGJveC1nbC1zdHlsZS1zcGVjL3JlZmVyZW5jZS9sYXRlc3QubWluJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgaW50ZXJwb2xhdGUgPSByZXF1aXJlKCcuLi91dGlsL2ludGVycG9sYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3R5bGVUcmFuc2l0aW9uO1xuXG4vKlxuICogUmVwcmVzZW50cyBhIHRyYW5zaXRpb24gYmV0d2VlbiB0d28gZGVjbGFyYXRpb25zXG4gKi9cbmZ1bmN0aW9uIFN0eWxlVHJhbnNpdGlvbihyZWZlcmVuY2UsIGRlY2xhcmF0aW9uLCBvbGRUcmFuc2l0aW9uLCB2YWx1ZSkge1xuXG4gICAgdGhpcy5kZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gdGhpcy5lbmRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgIGlmIChyZWZlcmVuY2UuZnVuY3Rpb24gPT09ICdwaWVjZXdpc2UtY29uc3RhbnQnICYmIHJlZmVyZW5jZS50cmFuc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuaW50ZXJwID0gaW50ZXJwWm9vbVRyYW5zaXRpb25lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmludGVycCA9IGludGVycG9sYXRlW3JlZmVyZW5jZS50eXBlXTtcbiAgICB9XG5cbiAgICB0aGlzLm9sZFRyYW5zaXRpb24gPSBvbGRUcmFuc2l0aW9uO1xuICAgIHRoaXMuZHVyYXRpb24gPSB2YWx1ZS5kdXJhdGlvbiB8fCAwO1xuICAgIHRoaXMuZGVsYXkgPSB2YWx1ZS5kZWxheSB8fCAwO1xuXG4gICAgaWYgKCF0aGlzLmluc3RhbnQoKSkge1xuICAgICAgICB0aGlzLmVuZFRpbWUgPSB0aGlzLnN0YXJ0VGltZSArIHRoaXMuZHVyYXRpb24gKyB0aGlzLmRlbGF5O1xuICAgICAgICB0aGlzLmVhc2UgPSB1dGlsLmVhc2VDdWJpY0luT3V0O1xuICAgIH1cblxuICAgIGlmIChvbGRUcmFuc2l0aW9uICYmIG9sZFRyYW5zaXRpb24uZW5kVGltZSA8PSB0aGlzLnN0YXJ0VGltZSkge1xuICAgICAgICAvLyBPbGQgdHJhbnNpdGlvbiBpcyBkb25lIHJ1bm5pbmcsIHNvIHdlIGNhblxuICAgICAgICAvLyBkZWxldGUgaXRzIHJlZmVyZW5jZSB0byBpdHMgb2xkIHRyYW5zaXRpb24uXG5cbiAgICAgICAgZGVsZXRlIG9sZFRyYW5zaXRpb24ub2xkVHJhbnNpdGlvbjtcbiAgICB9XG59XG5cblN0eWxlVHJhbnNpdGlvbi5wcm90b3R5cGUuaW5zdGFudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5vbGRUcmFuc2l0aW9uIHx8ICF0aGlzLmludGVycCB8fCAodGhpcy5kdXJhdGlvbiA9PT0gMCAmJiB0aGlzLmRlbGF5ID09PSAwKTtcbn07XG5cbi8qXG4gKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSB0cmFuc2l0aW9uaW5nIHByb3BlcnR5IGF0IHpvb20gbGV2ZWwgYHpgIGFuZCBvcHRpb25hbCB0aW1lIGB0YFxuICovXG5TdHlsZVRyYW5zaXRpb24ucHJvdG90eXBlLmNhbGN1bGF0ZSA9IGZ1bmN0aW9uKGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5kZWNsYXJhdGlvbi5jYWxjdWxhdGUoXG4gICAgICAgIHV0aWwuZXh0ZW5kKHt9LCBnbG9iYWxQcm9wZXJ0aWVzLCB7ZHVyYXRpb246IHRoaXMuZHVyYXRpb259KSxcbiAgICAgICAgZmVhdHVyZVByb3BlcnRpZXNcbiAgICApO1xuXG4gICAgaWYgKHRoaXMuaW5zdGFudCgpKSByZXR1cm4gdmFsdWU7XG5cbiAgICB2YXIgdCA9IGdsb2JhbFByb3BlcnRpZXMudGltZSB8fCBEYXRlLm5vdygpO1xuXG4gICAgaWYgKHQgPCB0aGlzLmVuZFRpbWUpIHtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5vbGRUcmFuc2l0aW9uLmNhbGN1bGF0ZShcbiAgICAgICAgICAgIHV0aWwuZXh0ZW5kKHt9LCBnbG9iYWxQcm9wZXJ0aWVzLCB7dGltZTogdGhpcy5zdGFydFRpbWV9KSxcbiAgICAgICAgICAgIGZlYXR1cmVQcm9wZXJ0aWVzXG4gICAgICAgICk7XG4gICAgICAgIHZhciBlYXNlZCA9IHRoaXMuZWFzZSgodCAtIHRoaXMuc3RhcnRUaW1lIC0gdGhpcy5kZWxheSkgLyB0aGlzLmR1cmF0aW9uKTtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmludGVycChvbGRWYWx1ZSwgdmFsdWUsIGVhc2VkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG5cbn07XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBzbW9vdGhseSB0cmFuc2l0aW9uIGJldHdlZW4gZGlzY3JldGUgdmFsdWVzLCBzdWNoXG4vLyBhcyBpbWFnZXMgYW5kIGRhc2hhcnJheXMuXG5mdW5jdGlvbiBpbnRlcnBab29tVHJhbnNpdGlvbmVkKGZyb20sIHRvLCB0KSB7XG4gICAgaWYgKChmcm9tICYmIGZyb20udG8pID09PSB1bmRlZmluZWQgfHwgKHRvICYmIHRvLnRvKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb206IGZyb20udG8sXG4gICAgICAgICAgICBmcm9tU2NhbGU6IGZyb20udG9TY2FsZSxcbiAgICAgICAgICAgIHRvOiB0by50byxcbiAgICAgICAgICAgIHRvU2NhbGU6IHRvLnRvU2NhbGUsXG4gICAgICAgICAgICB0OiB0XG4gICAgICAgIH07XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ21hcGJveC1nbC1zdHlsZS1zcGVjL2xpYi92YWxpZGF0ZV9zdHlsZS5taW4nKTtcblxubW9kdWxlLmV4cG9ydHMuZW1pdEVycm9ycyA9IGZ1bmN0aW9uIHRocm93RXJyb3JzKGVtaXR0ZXIsIGVycm9ycykge1xuICAgIGlmIChlcnJvcnMgJiYgZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZW1pdHRlci5maXJlKCdlcnJvcicsIHsgZXJyb3I6IG5ldyBFcnJvcihlcnJvcnNbaV0ubWVzc2FnZSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLnRocm93RXJyb3JzID0gZnVuY3Rpb24gdGhyb3dFcnJvcnMoZW1pdHRlciwgZXJyb3JzKSB7XG4gICAgaWYgKGVycm9ycykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yc1tpXS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQW5jaG9yO1xuXG5mdW5jdGlvbiBBbmNob3IoeCwgeSwgYW5nbGUsIHNlZ21lbnQpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy5hbmdsZSA9IGFuZ2xlO1xuXG4gICAgaWYgKHNlZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNlZ21lbnQgPSBzZWdtZW50O1xuICAgIH1cbn1cblxuQW5jaG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUG9pbnQucHJvdG90eXBlKTtcblxuQW5jaG9yLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgQW5jaG9yKHRoaXMueCwgdGhpcy55LCB0aGlzLmFuZ2xlLCB0aGlzLnNlZ21lbnQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja01heEFuZ2xlO1xuXG4vKipcbiAqIExhYmVscyBwbGFjZWQgYXJvdW5kIHJlYWxseSBzaGFycCBhbmdsZXMgYXJlbid0IHJlYWRhYmxlLiBDaGVjayBpZiBhbnlcbiAqIHBhcnQgb2YgdGhlIHBvdGVudGlhbCBsYWJlbCBoYXMgYSBjb21iaW5lZCBhbmdsZSB0aGF0IGlzIHRvbyBiaWcuXG4gKlxuICogQHBhcmFtIHtBcnJheTxQb2ludD59IGxpbmVcbiAqIEBwYXJhbSB7QW5jaG9yfSBhbmNob3IgVGhlIHBvaW50IG9uIHRoZSBsaW5lIGFyb3VuZCB3aGljaCB0aGUgbGFiZWwgaXMgYW5jaG9yZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gbGFiZWxMZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgbGFiZWwgaW4gZ2VvbWV0cnkgdW5pdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gd2luZG93U2l6ZSBUaGUgY2hlY2sgZmFpbHMgaWYgdGhlIGNvbWJpbmVkIGFuZ2xlcyB3aXRoaW4gYSBwYXJ0IG9mIHRoZSBsaW5lIHRoYXQgaXMgYHdpbmRvd1NpemVgIGxvbmcgaXMgdG9vIGJpZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhBbmdsZSBUaGUgbWF4aW11bSBjb21iaW5lZCBhbmdsZSB0aGF0IGFueSB3aW5kb3cgYWxvbmcgdGhlIGxhYmVsIGlzIGFsbG93ZWQgdG8gaGF2ZS5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgbGFiZWwgc2hvdWxkIGJlIHBsYWNlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tNYXhBbmdsZShsaW5lLCBhbmNob3IsIGxhYmVsTGVuZ3RoLCB3aW5kb3dTaXplLCBtYXhBbmdsZSkge1xuXG4gICAgLy8gaG9yaXpvbnRhbCBsYWJlbHMgYWx3YXlzIHBhc3NcbiAgICBpZiAoYW5jaG9yLnNlZ21lbnQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWU7XG5cbiAgICB2YXIgcCA9IGFuY2hvcjtcbiAgICB2YXIgaW5kZXggPSBhbmNob3Iuc2VnbWVudCArIDE7XG4gICAgdmFyIGFuY2hvckRpc3RhbmNlID0gMDtcblxuICAgIC8vIG1vdmUgYmFja3dhcmRzIGFsb25nIHRoZSBsaW5lIHRvIHRoZSBmaXJzdCBzZWdtZW50IHRoZSBsYWJlbCBhcHBlYXJzIG9uXG4gICAgd2hpbGUgKGFuY2hvckRpc3RhbmNlID4gLWxhYmVsTGVuZ3RoIC8gMikge1xuICAgICAgICBpbmRleC0tO1xuXG4gICAgICAgIC8vIHRoZXJlIGlzbid0IGVub3VnaCByb29tIGZvciB0aGUgbGFiZWwgYWZ0ZXIgdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZVxuICAgICAgICBpZiAoaW5kZXggPCAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgYW5jaG9yRGlzdGFuY2UgLT0gbGluZVtpbmRleF0uZGlzdChwKTtcbiAgICAgICAgcCA9IGxpbmVbaW5kZXhdO1xuICAgIH1cblxuICAgIGFuY2hvckRpc3RhbmNlICs9IGxpbmVbaW5kZXhdLmRpc3QobGluZVtpbmRleCArIDFdKTtcbiAgICBpbmRleCsrO1xuXG4gICAgLy8gc3RvcmUgcmVjZW50IGNvcm5lcnMgYW5kIHRoZWlyIHRvdGFsIGFuZ2xlIGRpZmZlcmVuY2VcbiAgICB2YXIgcmVjZW50Q29ybmVycyA9IFtdO1xuICAgIHZhciByZWNlbnRBbmdsZURlbHRhID0gMDtcblxuICAgIC8vIG1vdmUgZm9yd2FyZHMgYnkgdGhlIGxlbmd0aCBvZiB0aGUgbGFiZWwgYW5kIGNoZWNrIGFuZ2xlcyBhbG9uZyB0aGUgd2F5XG4gICAgd2hpbGUgKGFuY2hvckRpc3RhbmNlIDwgbGFiZWxMZW5ndGggLyAyKSB7XG4gICAgICAgIHZhciBwcmV2ID0gbGluZVtpbmRleCAtIDFdO1xuICAgICAgICB2YXIgY3VycmVudCA9IGxpbmVbaW5kZXhdO1xuICAgICAgICB2YXIgbmV4dCA9IGxpbmVbaW5kZXggKyAxXTtcblxuICAgICAgICAvLyB0aGVyZSBpc24ndCBlbm91Z2ggcm9vbSBmb3IgdGhlIGxhYmVsIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSBsaW5lXG4gICAgICAgIGlmICghbmV4dCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciBhbmdsZURlbHRhID0gcHJldi5hbmdsZVRvKGN1cnJlbnQpIC0gY3VycmVudC5hbmdsZVRvKG5leHQpO1xuICAgICAgICAvLyByZXN0cmljdCBhbmdsZSB0byAtcGkuLnBpIHJhbmdlXG4gICAgICAgIGFuZ2xlRGVsdGEgPSBNYXRoLmFicygoKGFuZ2xlRGVsdGEgKyAzICogTWF0aC5QSSkgJSAoTWF0aC5QSSAqIDIpKSAtIE1hdGguUEkpO1xuXG4gICAgICAgIHJlY2VudENvcm5lcnMucHVzaCh7XG4gICAgICAgICAgICBkaXN0YW5jZTogYW5jaG9yRGlzdGFuY2UsXG4gICAgICAgICAgICBhbmdsZURlbHRhOiBhbmdsZURlbHRhXG4gICAgICAgIH0pO1xuICAgICAgICByZWNlbnRBbmdsZURlbHRhICs9IGFuZ2xlRGVsdGE7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGNvcm5lcnMgdGhhdCBhcmUgZmFyIGVub3VnaCBhd2F5IGZyb20gdGhlIGxpc3Qgb2YgcmVjZW50IGFuY2hvcnNcbiAgICAgICAgd2hpbGUgKGFuY2hvckRpc3RhbmNlIC0gcmVjZW50Q29ybmVyc1swXS5kaXN0YW5jZSA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHJlY2VudEFuZ2xlRGVsdGEgLT0gcmVjZW50Q29ybmVycy5zaGlmdCgpLmFuZ2xlRGVsdGE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgc3VtIG9mIGFuZ2xlcyB3aXRoaW4gdGhlIHdpbmRvdyBhcmVhIGV4Y2VlZHMgdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZS4gY2hlY2sgZmFpbHMuXG4gICAgICAgIGlmIChyZWNlbnRBbmdsZURlbHRhID4gbWF4QW5nbGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpbmRleCsrO1xuICAgICAgICBhbmNob3JEaXN0YW5jZSArPSBjdXJyZW50LmRpc3QobmV4dCk7XG4gICAgfVxuXG4gICAgLy8gbm8gcGFydCBvZiB0aGUgbGluZSBoYWQgYW4gYW5nbGUgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQuIGNoZWNrIHBhc3Nlcy5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGlwTGluZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJ0IG9mIGEgbXVsdGlsaW5lIHRoYXQgaW50ZXJzZWN0cyB3aXRoIHRoZSBwcm92aWRlZCByZWN0YW5ndWxhciBib3guXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxQb2ludD4+fSBsaW5lc1xuICogQHBhcmFtIHtudW1iZXJ9IHgxIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGJveFxuICogQHBhcmFtIHtudW1iZXJ9IHkxIHRoZSB0b3AgZWRnZSBvZiB0aGUgYm94XG4gKiBAcGFyYW0ge251bWJlcn0geDIgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIGJveFxuICogQHBhcmFtIHtudW1iZXJ9IHkyIHRoZSBib3R0b20gZWRnZSBvZiB0aGUgYm94XG4gKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8UG9pbnQ+Pn0gbGluZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsaXBMaW5lKGxpbmVzLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIHZhciBjbGlwcGVkTGluZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGluZXMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tsXTtcbiAgICAgICAgdmFyIGNsaXBwZWRMaW5lO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwMCA9IGxpbmVbaV07XG4gICAgICAgICAgICB2YXIgcDEgPSBsaW5lW2kgKyAxXTtcblxuXG4gICAgICAgICAgICBpZiAocDAueCA8IHgxICYmIHAxLnggPCB4MSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwMC54IDwgeDEpIHtcbiAgICAgICAgICAgICAgICBwMCA9IG5ldyBQb2ludCh4MSwgcDAueSArIChwMS55IC0gcDAueSkgKiAoKHgxIC0gcDAueCkgLyAocDEueCAtIHAwLngpKSkuX3JvdW5kKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAxLnggPCB4MSkge1xuICAgICAgICAgICAgICAgIHAxID0gbmV3IFBvaW50KHgxLCBwMC55ICsgKHAxLnkgLSBwMC55KSAqICgoeDEgLSBwMC54KSAvIChwMS54IC0gcDAueCkpKS5fcm91bmQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHAwLnkgPCB5MSAmJiBwMS55IDwgeTEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocDAueSA8IHkxKSB7XG4gICAgICAgICAgICAgICAgcDAgPSBuZXcgUG9pbnQocDAueCArIChwMS54IC0gcDAueCkgKiAoKHkxIC0gcDAueSkgLyAocDEueSAtIHAwLnkpKSwgeTEpLl9yb3VuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwMS55IDwgeTEpIHtcbiAgICAgICAgICAgICAgICBwMSA9IG5ldyBQb2ludChwMC54ICsgKHAxLnggLSBwMC54KSAqICgoeTEgLSBwMC55KSAvIChwMS55IC0gcDAueSkpLCB5MSkuX3JvdW5kKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwMC54ID49IHgyICYmIHAxLnggPj0geDIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocDAueCA+PSB4Mikge1xuICAgICAgICAgICAgICAgIHAwID0gbmV3IFBvaW50KHgyLCBwMC55ICsgKHAxLnkgLSBwMC55KSAqICgoeDIgLSBwMC54KSAvIChwMS54IC0gcDAueCkpKS5fcm91bmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocDEueCA+PSB4Mikge1xuICAgICAgICAgICAgICAgIHAxID0gbmV3IFBvaW50KHgyLCBwMC55ICsgKHAxLnkgLSBwMC55KSAqICgoeDIgLSBwMC54KSAvIChwMS54IC0gcDAueCkpKS5fcm91bmQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHAwLnkgPj0geTIgJiYgcDEueSA+PSB5Mikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwMC55ID49IHkyKSB7XG4gICAgICAgICAgICAgICAgcDAgPSBuZXcgUG9pbnQocDAueCArIChwMS54IC0gcDAueCkgKiAoKHkyIC0gcDAueSkgLyAocDEueSAtIHAwLnkpKSwgeTIpLl9yb3VuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwMS55ID49IHkyKSB7XG4gICAgICAgICAgICAgICAgcDEgPSBuZXcgUG9pbnQocDAueCArIChwMS54IC0gcDAueCkgKiAoKHkyIC0gcDAueSkgLyAocDEueSAtIHAwLnkpKSwgeTIpLl9yb3VuZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNsaXBwZWRMaW5lIHx8ICFwMC5lcXVhbHMoY2xpcHBlZExpbmVbY2xpcHBlZExpbmUubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgY2xpcHBlZExpbmUgPSBbcDBdO1xuICAgICAgICAgICAgICAgIGNsaXBwZWRMaW5lcy5wdXNoKGNsaXBwZWRMaW5lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xpcHBlZExpbmUucHVzaChwMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xpcHBlZExpbmVzO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3RydWN0QXJyYXlUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9zdHJ1Y3RfYXJyYXknKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG4vKipcbiAqIEEgY29sbGlzaW9uIGJveCByZXByZXNlbnRzIGFuIGFyZWEgb2YgdGhlIG1hcCB0aGF0IHRoYXQgaXMgY292ZXJlZCBieSBhXG4gKiBsYWJlbC4gQ29sbGlzaW9uRmVhdHVyZSB1c2VzIG9uZSBvciBtb3JlIG9mIHRoZXNlIGNvbGxpc2lvbiBib3hlcyB0b1xuICogcmVwcmVzZW50IGFsbCB0aGUgYXJlYSBjb3ZlcmVkIGJ5IGEgc2luZ2xlIGxhYmVsLiBUaGV5IGFyZSB1c2VkIHRvXG4gKiBwcmV2ZW50IGNvbGxpc2lvbnMgYmV0d2VlbiBsYWJlbHMuXG4gKlxuICogQSBjb2xsaXNpb24gYm94IGFjdHVhbGx5IHJlcHJlc2VudHMgYSAzZCB2b2x1bWUuIFRoZSBmaXJzdCB0d28gZGltZW5zaW9ucyxcbiAqIHggYW5kIHksIGFyZSBzcGVjaWZpZWQgd2l0aCBgYW5jaG9yYCBhbG9uZyB3aXRoIGB4MWAsIGB5MWAsIGB4MmAsIGB5MmAuXG4gKiBUaGUgdGhpcmQgZGltZW5zaW9uLCB6b29tLCBpcyBsaW1pdGVkIGJ5IGBtYXhTY2FsZWAgd2hpY2ggZGV0ZXJtaW5lc1xuICogaG93IGZhciBpbiB0aGUgeiBkaW1lbnNpb25zIHRoZSBib3ggZXh0ZW5kcy5cbiAqXG4gKiBBcyB5b3Ugem9vbSBpbiBvbiBhIG1hcCwgYWxsIHBvaW50cyBvbiB0aGUgbWFwIGdldCBmdXJ0aGVyIGFuZCBmdXJ0aGVyIGFwYXJ0XG4gKiBidXQgbGFiZWxzIHN0YXkgcm91Z2hseSB0aGUgc2FtZSBzaXplLiBMYWJlbHMgY292ZXIgbGVzcyByZWFsIHdvcmxkIGFyZWEgb25cbiAqIHRoZSBtYXAgYXQgaGlnaGVyIHpvb20gbGV2ZWxzIHRoYW4gdGhleSBkbyBhdCBsb3dlciB6b29tIGxldmVscy4gVGhpcyBpcyB3aHlcbiAqIGFyZWFzIGFyZSBhcmUgcmVwcmVzZW50ZWQgd2l0aCBhbiBhbmNob3IgcG9pbnQgYW5kIG9mZnNldHMgZnJvbSB0aGF0IHBvaW50XG4gKiBpbnN0ZWFkIG9mIGp1c3QgdXNpbmcgZm91ciBhYnNvbHV0ZSBwb2ludHMuXG4gKlxuICogTGluZSBsYWJlbHMgYXJlIHJlcHJlc2VudGVkIGJ5IGEgc2V0IG9mIHRoZXNlIGJveGVzIHNwYWNlZCBvdXQgYWxvbmcgYSBsaW5lLlxuICogV2hlbiB5b3Ugem9vbSBpbiwgbGluZSBsYWJlbHMgY292ZXIgbGVzcyByZWFsIHdvcmxkIGRpc3RhbmNlIGFsb25nIHRoZSBsaW5lXG4gKiB0aGFuIHRoZXkgdXNlZCB0by4gQ29sbGlzaW9uIGJveGVzIG5lYXIgdGhlIGVkZ2VzIHRoYXQgdXNlZCB0byBjb3ZlciBsYWJlbFxuICogbm8gbG9uZ2VyIGRvLiBJZiBhIGJveCBkb2Vzbid0IGNvdmVyIHRoZSBsYWJlbCBhbnltb3JlIGl0IHNob3VsZCBiZSBpZ25vcmVkXG4gKiB3aGVuIGRvaW5nIGNvbGxpc2lvbiBjaGVja3MuIGBtYXhTY2FsZWAgaXMgaG93IG11Y2ggeW91IGNhbiBzY2FsZSB0aGUgbWFwXG4gKiBiZWZvcmUgdGhlIGxhYmVsIGlzbid0IHdpdGhpbiB0aGUgYm94IGFueW1vcmUuXG4gKiBGb3IgZXhhbXBsZVxuICogbG93ZXIgem9vbTpcbiAqIGh0dHBzOi8vY2xvdWQuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fzc2V0cy8xNDIxNjUyLzgwNjAwOTQvNGQ5NzVmNzYtMGU5MS0xMWU1LTg0YjEtNGVkZWIzMGE1ODc1LnBuZ1xuICogc2xpZ2h0bHkgaGlnaGVyIHpvb206XG4gKiBodHRwczovL2Nsb3VkLmdpdGh1YnVzZXJjb250ZW50LmNvbS9hc3NldHMvMTQyMTY1Mi84MDYwMDYxLzI2YWUxYzM4LTBlOTEtMTFlNS04YzVhLTlmMzgwYmYyOWYwYS5wbmdcbiAqIEluIHRoZSB6b29tZWQgaW4gaW1hZ2UgdGhlIHR3byBncmV5IGJveGVzIG9uIGVpdGhlciBzaWRlIGRvbid0IGNvdmVyIHRoZVxuICogbGFiZWwgYW55bW9yZS4gVGhlaXIgbWF4U2NhbGUgaXMgc21hbGxlciB0aGFuIHRoZSBjdXJyZW50IHNjYWxlLlxuICpcbiAqXG4gKiBAY2xhc3MgQ29sbGlzaW9uQm94QXJyYXlcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIENvbGxpc2lvbkJveEFycmF5ID0gbW9kdWxlLmV4cG9ydHMgPSBuZXcgU3RydWN0QXJyYXlUeXBlKHtcbiAgICBtZW1iZXJzOiBbXG4gICAgICAgIC8vIHRoZSBib3ggaXMgY2VudGVyZWQgYXJvdW5kIHRoZSBhbmNob3IgcG9pbnRcbiAgICAgICAgeyB0eXBlOiAnSW50MTYnLCBuYW1lOiAnYW5jaG9yUG9pbnRYJyB9LFxuICAgICAgICB7IHR5cGU6ICdJbnQxNicsIG5hbWU6ICdhbmNob3JQb2ludFknIH0sXG5cbiAgICAgICAgLy8gZGlzdGFuY2VzIHRvIHRoZSBlZGdlcyBmcm9tIHRoZSBhbmNob3JcbiAgICAgICAgeyB0eXBlOiAnSW50MTYnLCBuYW1lOiAneDEnIH0sXG4gICAgICAgIHsgdHlwZTogJ0ludDE2JywgbmFtZTogJ3kxJyB9LFxuICAgICAgICB7IHR5cGU6ICdJbnQxNicsIG5hbWU6ICd4MicgfSxcbiAgICAgICAgeyB0eXBlOiAnSW50MTYnLCBuYW1lOiAneTInIH0sXG5cbiAgICAgICAgLy8gdGhlIGJveCBpcyBvbmx5IHZhbGlkIGZvciBzY2FsZXMgPCBtYXhTY2FsZS5cbiAgICAgICAgLy8gVGhlIGJveCBkb2VzIG5vdCBibG9jayBvdGhlciBib3hlcyBhdCBzY2FsZXMgPj0gbWF4U2NhbGU7XG4gICAgICAgIHsgdHlwZTogJ0Zsb2F0MzInLCBuYW1lOiAnbWF4U2NhbGUnIH0sXG5cbiAgICAgICAgLy8gdGhlIGluZGV4IG9mIHRoZSBmZWF0dXJlIGluIHRoZSBvcmlnaW5hbCB2ZWN0b3J0aWxlXG4gICAgICAgIHsgdHlwZTogJ1VpbnQzMicsIG5hbWU6ICdmZWF0dXJlSW5kZXgnIH0sXG4gICAgICAgIC8vIHRoZSBzb3VyY2UgbGF5ZXIgdGhlIGZlYXR1cmUgYXBwZWFycyBpblxuICAgICAgICB7IHR5cGU6ICdVaW50MTYnLCBuYW1lOiAnc291cmNlTGF5ZXJJbmRleCcgfSxcbiAgICAgICAgLy8gdGhlIGJ1Y2tldCB0aGUgZmVhdHVyZSBhcHBlYXJzIGluXG4gICAgICAgIHsgdHlwZTogJ1VpbnQxNicsIG5hbWU6ICdidWNrZXRJbmRleCcgfSxcblxuICAgICAgICAvLyByb3RhdGVkIGFuZCBzY2FsZWQgYmJveCB1c2VkIGZvciBpbmRleGluZ1xuICAgICAgICB7IHR5cGU6ICdJbnQxNicsIG5hbWU6ICdiYm94MCcgfSxcbiAgICAgICAgeyB0eXBlOiAnSW50MTYnLCBuYW1lOiAnYmJveDEnIH0sXG4gICAgICAgIHsgdHlwZTogJ0ludDE2JywgbmFtZTogJ2Jib3gyJyB9LFxuICAgICAgICB7IHR5cGU6ICdJbnQxNicsIG5hbWU6ICdiYm94MycgfSxcblxuICAgICAgICB7IHR5cGU6ICdGbG9hdDMyJywgbmFtZTogJ3BsYWNlbWVudFNjYWxlJyB9XG4gICAgXX0pO1xuXG51dGlsLmV4dGVuZEFsbChDb2xsaXNpb25Cb3hBcnJheS5wcm90b3R5cGUuU3RydWN0VHlwZS5wcm90b3R5cGUsIHtcbiAgICBnZXQgYW5jaG9yUG9pbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5hbmNob3JQb2ludFgsIHRoaXMuYW5jaG9yUG9pbnRZKTtcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsaXNpb25GZWF0dXJlO1xuXG4vKipcbiAqIEEgQ29sbGlzaW9uRmVhdHVyZSByZXByZXNlbnRzIHRoZSBhcmVhIG9mIHRoZSB0aWxlIGNvdmVyZWQgYnkgYSBzaW5nbGUgbGFiZWwuXG4gKiBJdCBpcyB1c2VkIHdpdGggQ29sbGlzaW9uVGlsZSB0byBjaGVjayBpZiB0aGUgbGFiZWwgb3ZlcmxhcHMgd2l0aCBhbnlcbiAqIHByZXZpb3VzIGxhYmVscy4gQSBDb2xsaXNpb25GZWF0dXJlIGlzIG1vc3RseSBqdXN0IGEgc2V0IG9mIENvbGxpc2lvbkJveFxuICogb2JqZWN0cy5cbiAqXG4gKiBAY2xhc3MgQ29sbGlzaW9uRmVhdHVyZVxuICogQHBhcmFtIHtBcnJheTxQb2ludD59IGxpbmUgVGhlIGdlb21ldHJ5IHRoZSBsYWJlbCBpcyBwbGFjZWQgb24uXG4gKiBAcGFyYW0ge0FuY2hvcn0gYW5jaG9yIFRoZSBwb2ludCBhbG9uZyB0aGUgbGluZSBhcm91bmQgd2hpY2ggdGhlIGxhYmVsIGlzIGFuY2hvcmVkLlxuICogQHBhcmFtIHtWZWN0b3JUaWxlRmVhdHVyZX0gZmVhdHVyZSBUaGUgVmVjdG9yVGlsZUZlYXR1cmUgdGhhdCB0aGlzIENvbGxpc2lvbkZlYXR1cmUgd2FzIGNyZWF0ZWQgZm9yLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBsYXllcklEcyBUaGUgSURzIG9mIHRoZSBsYXllcnMgdGhhdCB0aGlzIENvbGxpc2lvbkZlYXR1cmUgaXMgYSBwYXJ0IG9mLlxuICogQHBhcmFtIHtPYmplY3R9IHNoYXBlZCBUaGUgdGV4dCBvciBpY29uIHNoYXBpbmcgcmVzdWx0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3hTY2FsZSBBIG1hZ2ljIG51bWJlciB1c2VkIHRvIGNvbnZlcnQgZnJvbSBnbHlwaCBtZXRyaWNzIHVuaXRzIHRvIGdlb21ldHJ5IHVuaXRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmcgVGhlIGFtb3VudCBvZiBwYWRkaW5nIHRvIGFkZCBhcm91bmQgdGhlIGxhYmVsIGVkZ2VzLlxuICogQHBhcmFtIHtib29sZWFufSBhbGlnbkxpbmUgV2hldGhlciB0aGUgbGFiZWwgaXMgYWxpZ25lZCB3aXRoIHRoZSBsaW5lIG9yIHRoZSB2aWV3cG9ydC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBDb2xsaXNpb25GZWF0dXJlKGNvbGxpc2lvbkJveEFycmF5LCBsaW5lLCBhbmNob3IsIGZlYXR1cmVJbmRleCwgc291cmNlTGF5ZXJJbmRleCwgYnVja2V0SW5kZXgsIHNoYXBlZCwgYm94U2NhbGUsIHBhZGRpbmcsIGFsaWduTGluZSwgc3RyYWlnaHQpIHtcblxuICAgIHZhciB5MSA9IHNoYXBlZC50b3AgKiBib3hTY2FsZSAtIHBhZGRpbmc7XG4gICAgdmFyIHkyID0gc2hhcGVkLmJvdHRvbSAqIGJveFNjYWxlICsgcGFkZGluZztcbiAgICB2YXIgeDEgPSBzaGFwZWQubGVmdCAqIGJveFNjYWxlIC0gcGFkZGluZztcbiAgICB2YXIgeDIgPSBzaGFwZWQucmlnaHQgKiBib3hTY2FsZSArIHBhZGRpbmc7XG5cbiAgICB0aGlzLmJveFN0YXJ0SW5kZXggPSBjb2xsaXNpb25Cb3hBcnJheS5sZW5ndGg7XG5cbiAgICBpZiAoYWxpZ25MaW5lKSB7XG5cbiAgICAgICAgdmFyIGhlaWdodCA9IHkyIC0geTE7XG4gICAgICAgIHZhciBsZW5ndGggPSB4MiAtIHgxO1xuXG4gICAgICAgIGlmIChoZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAvLyBzZXQgbWluaW11bSBib3ggaGVpZ2h0IHRvIGF2b2lkIHZlcnkgbWFueSBzbWFsbCBsYWJlbHNcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGgubWF4KDEwICogYm94U2NhbGUsIGhlaWdodCk7XG5cbiAgICAgICAgICAgIGlmIChzdHJhaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIHVzZWQgZm9yIGljb24gbGFiZWxzIHRoYXQgYXJlIGFsaWduZWQgd2l0aCB0aGUgbGluZSwgYnV0IGRvbid0IGN1cnZlIGFsb25nIGl0XG4gICAgICAgICAgICAgICAgdmFyIHZlY3RvciA9IGxpbmVbYW5jaG9yLnNlZ21lbnQgKyAxXS5zdWIobGluZVthbmNob3Iuc2VnbWVudF0pLl91bml0KCkuX211bHQobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RyYWlnaHRMaW5lID0gW2FuY2hvci5zdWIodmVjdG9yKSwgYW5jaG9yLmFkZCh2ZWN0b3IpXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRMaW5lQ29sbGlzaW9uQm94ZXMoY29sbGlzaW9uQm94QXJyYXksIHN0cmFpZ2h0TGluZSwgYW5jaG9yLCAwLCBsZW5ndGgsIGhlaWdodCwgZmVhdHVyZUluZGV4LCBzb3VyY2VMYXllckluZGV4LCBidWNrZXRJbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHVzZWQgZm9yIHRleHQgbGFiZWxzIHRoYXQgY3VydmUgYWxvbmcgYSBsaW5lXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTGluZUNvbGxpc2lvbkJveGVzKGNvbGxpc2lvbkJveEFycmF5LCBsaW5lLCBhbmNob3IsIGFuY2hvci5zZWdtZW50LCBsZW5ndGgsIGhlaWdodCwgZmVhdHVyZUluZGV4LCBzb3VyY2VMYXllckluZGV4LCBidWNrZXRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbGxpc2lvbkJveEFycmF5LmVtcGxhY2VCYWNrKGFuY2hvci54LCBhbmNob3IueSwgeDEsIHkxLCB4MiwgeTIsIEluZmluaXR5LCBmZWF0dXJlSW5kZXgsIHNvdXJjZUxheWVySW5kZXgsIGJ1Y2tldEluZGV4LFxuICAgICAgICAgICAgICAgIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cblxuICAgIHRoaXMuYm94RW5kSW5kZXggPSBjb2xsaXNpb25Cb3hBcnJheS5sZW5ndGg7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc2V0IG9mIENvbGxpc2lvbkJveCBvYmplY3RzIGZvciBhIGxpbmUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxQb2ludD59IGxpbmVcbiAqIEBwYXJhbSB7QW5jaG9yfSBhbmNob3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbExlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSBsYWJlbCBpbiBnZW9tZXRyeSB1bml0cy5cbiAqIEBwYXJhbSB7QW5jaG9yfSBhbmNob3IgVGhlIHBvaW50IGFsb25nIHRoZSBsaW5lIGFyb3VuZCB3aGljaCB0aGUgbGFiZWwgaXMgYW5jaG9yZWQuXG4gKiBAcGFyYW0ge1ZlY3RvclRpbGVGZWF0dXJlfSBmZWF0dXJlIFRoZSBWZWN0b3JUaWxlRmVhdHVyZSB0aGF0IHRoaXMgQ29sbGlzaW9uRmVhdHVyZSB3YXMgY3JlYXRlZCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gYm94U2l6ZSBUaGUgc2l6ZSBvZiB0aGUgY29sbGlzaW9uIGJveGVzIHRoYXQgd2lsbCBiZSBjcmVhdGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbkNvbGxpc2lvbkZlYXR1cmUucHJvdG90eXBlLl9hZGRMaW5lQ29sbGlzaW9uQm94ZXMgPSBmdW5jdGlvbihjb2xsaXNpb25Cb3hBcnJheSwgbGluZSwgYW5jaG9yLCBzZWdtZW50LCBsYWJlbExlbmd0aCwgYm94U2l6ZSwgZmVhdHVyZUluZGV4LCBzb3VyY2VMYXllckluZGV4LCBidWNrZXRJbmRleCkge1xuICAgIHZhciBzdGVwID0gYm94U2l6ZSAvIDI7XG4gICAgdmFyIG5Cb3hlcyA9IE1hdGguZmxvb3IobGFiZWxMZW5ndGggLyBzdGVwKTtcblxuICAgIC8vIG9mZnNldCB0aGUgY2VudGVyIG9mIHRoZSBmaXJzdCBib3ggYnkgaGFsZiBhIGJveCBzbyB0aGF0IHRoZSBlZGdlIG9mIHRoZVxuICAgIC8vIGJveCBpcyBhdCB0aGUgZWRnZSBvZiB0aGUgbGFiZWwuXG4gICAgdmFyIGZpcnN0Qm94T2Zmc2V0ID0gLWJveFNpemUgLyAyO1xuXG4gICAgdmFyIGJib3hlcyA9IHRoaXMuYm94ZXM7XG5cbiAgICB2YXIgcCA9IGFuY2hvcjtcbiAgICB2YXIgaW5kZXggPSBzZWdtZW50ICsgMTtcbiAgICB2YXIgYW5jaG9yRGlzdGFuY2UgPSBmaXJzdEJveE9mZnNldDtcblxuICAgIC8vIG1vdmUgYmFja3dhcmRzIGFsb25nIHRoZSBsaW5lIHRvIHRoZSBmaXJzdCBzZWdtZW50IHRoZSBsYWJlbCBhcHBlYXJzIG9uXG4gICAgZG8ge1xuICAgICAgICBpbmRleC0tO1xuXG4gICAgICAgIC8vIHRoZXJlIGlzbid0IGVub3VnaCByb29tIGZvciB0aGUgbGFiZWwgYWZ0ZXIgdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZVxuICAgICAgICAvLyBjaGVja01heEFuZ2xlIHNob3VsZCBoYXZlIGFscmVhZHkgY2F1Z2h0IHRoaXNcbiAgICAgICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuIGJib3hlcztcblxuICAgICAgICBhbmNob3JEaXN0YW5jZSAtPSBsaW5lW2luZGV4XS5kaXN0KHApO1xuICAgICAgICBwID0gbGluZVtpbmRleF07XG4gICAgfSB3aGlsZSAoYW5jaG9yRGlzdGFuY2UgPiAtbGFiZWxMZW5ndGggLyAyKTtcblxuICAgIHZhciBzZWdtZW50TGVuZ3RoID0gbGluZVtpbmRleF0uZGlzdChsaW5lW2luZGV4ICsgMV0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuQm94ZXM7IGkrKykge1xuICAgICAgICAvLyB0aGUgZGlzdGFuY2UgdGhlIGJveCB3aWxsIGJlIGZyb20gdGhlIGFuY2hvclxuICAgICAgICB2YXIgYm94RGlzdGFuY2VUb0FuY2hvciA9IC1sYWJlbExlbmd0aCAvIDIgKyBpICogc3RlcDtcblxuICAgICAgICAvLyB0aGUgYm94IGlzIG5vdCBvbiB0aGUgY3VycmVudCBzZWdtZW50LiBNb3ZlIHRvIHRoZSBuZXh0IHNlZ21lbnQuXG4gICAgICAgIHdoaWxlIChhbmNob3JEaXN0YW5jZSArIHNlZ21lbnRMZW5ndGggPCBib3hEaXN0YW5jZVRvQW5jaG9yKSB7XG4gICAgICAgICAgICBhbmNob3JEaXN0YW5jZSArPSBzZWdtZW50TGVuZ3RoO1xuICAgICAgICAgICAgaW5kZXgrKztcblxuICAgICAgICAgICAgLy8gVGhlcmUgaXNuJ3QgZW5vdWdoIHJvb20gYmVmb3JlIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgICAgICAgICBpZiAoaW5kZXggKyAxID49IGxpbmUubGVuZ3RoKSByZXR1cm4gYmJveGVzO1xuXG4gICAgICAgICAgICBzZWdtZW50TGVuZ3RoID0gbGluZVtpbmRleF0uZGlzdChsaW5lW2luZGV4ICsgMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIGRpc3RhbmNlIHRoZSBib3ggd2lsbCBiZSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlZ21lbnRcbiAgICAgICAgdmFyIHNlZ21lbnRCb3hEaXN0YW5jZSA9IGJveERpc3RhbmNlVG9BbmNob3IgLSBhbmNob3JEaXN0YW5jZTtcblxuICAgICAgICB2YXIgcDAgPSBsaW5lW2luZGV4XTtcbiAgICAgICAgdmFyIHAxID0gbGluZVtpbmRleCArIDFdO1xuICAgICAgICB2YXIgYm94QW5jaG9yUG9pbnQgPSBwMS5zdWIocDApLl91bml0KCkuX211bHQoc2VnbWVudEJveERpc3RhbmNlKS5fYWRkKHAwKS5fcm91bmQoKTtcblxuICAgICAgICB2YXIgZGlzdGFuY2VUb0lubmVyRWRnZSA9IE1hdGgubWF4KE1hdGguYWJzKGJveERpc3RhbmNlVG9BbmNob3IgLSBmaXJzdEJveE9mZnNldCkgLSBzdGVwIC8gMiwgMCk7XG4gICAgICAgIHZhciBtYXhTY2FsZSA9IGxhYmVsTGVuZ3RoIC8gMiAvIGRpc3RhbmNlVG9Jbm5lckVkZ2U7XG5cbiAgICAgICAgY29sbGlzaW9uQm94QXJyYXkuZW1wbGFjZUJhY2soYm94QW5jaG9yUG9pbnQueCwgYm94QW5jaG9yUG9pbnQueSxcbiAgICAgICAgICAgICAgICAtYm94U2l6ZSAvIDIsIC1ib3hTaXplIC8gMiwgYm94U2l6ZSAvIDIsIGJveFNpemUgLyAyLCBtYXhTY2FsZSxcbiAgICAgICAgICAgICAgICBmZWF0dXJlSW5kZXgsIHNvdXJjZUxheWVySW5kZXgsIGJ1Y2tldEluZGV4LFxuICAgICAgICAgICAgICAgIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cblxuICAgIHJldHVybiBiYm94ZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xudmFyIEVYVEVOVCA9IHJlcXVpcmUoJy4uL2RhdGEvYnVja2V0JykuRVhURU5UO1xudmFyIEdyaWQgPSByZXF1aXJlKCdncmlkLWluZGV4Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGlzaW9uVGlsZTtcblxuLyoqXG4gKiBBIGNvbGxpc2lvbiB0aWxlIHVzZWQgdG8gcHJldmVudCBzeW1ib2xzIGZyb20gb3ZlcmxhcHBpbmcuIEl0IGtlZXAgdHJhY2tzIG9mXG4gKiB3aGVyZSBwcmV2aW91cyBzeW1ib2xzIGhhdmUgYmVlbiBwbGFjZWQgYW5kIGlzIHVzZWQgdG8gY2hlY2sgaWYgYSBuZXdcbiAqIHN5bWJvbCBvdmVybGFwcyB3aXRoIGFueSBwcmV2aW91c2x5IGFkZGVkIHN5bWJvbHMuXG4gKlxuICogQGNsYXNzIENvbGxpc2lvblRpbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICogQHBhcmFtIHtudW1iZXJ9IHBpdGNoXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBDb2xsaXNpb25UaWxlKGFuZ2xlLCBwaXRjaCwgY29sbGlzaW9uQm94QXJyYXkpIHtcbiAgICBpZiAodHlwZW9mIGFuZ2xlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgc2VyaWFsaXplZCA9IGFuZ2xlO1xuICAgICAgICBjb2xsaXNpb25Cb3hBcnJheSA9IHBpdGNoO1xuICAgICAgICBhbmdsZSA9IHNlcmlhbGl6ZWQuYW5nbGU7XG4gICAgICAgIHBpdGNoID0gc2VyaWFsaXplZC5waXRjaDtcbiAgICAgICAgdGhpcy5ncmlkID0gbmV3IEdyaWQoc2VyaWFsaXplZC5ncmlkKTtcbiAgICAgICAgdGhpcy5pZ25vcmVkR3JpZCA9IG5ldyBHcmlkKHNlcmlhbGl6ZWQuaWdub3JlZEdyaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ3JpZCA9IG5ldyBHcmlkKEVYVEVOVCwgMTIsIDYpO1xuICAgICAgICB0aGlzLmlnbm9yZWRHcmlkID0gbmV3IEdyaWQoRVhURU5ULCAxMiwgMCk7XG4gICAgfVxuXG4gICAgdGhpcy5hbmdsZSA9IGFuZ2xlO1xuICAgIHRoaXMucGl0Y2ggPSBwaXRjaDtcblxuICAgIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICB0aGlzLnJvdGF0aW9uTWF0cml4ID0gW2NvcywgLXNpbiwgc2luLCBjb3NdO1xuICAgIHRoaXMucmV2ZXJzZVJvdGF0aW9uTWF0cml4ID0gW2Nvcywgc2luLCAtc2luLCBjb3NdO1xuXG4gICAgLy8gU3RyZXRjaCBib3hlcyBpbiB5IGRpcmVjdGlvbiB0byBhY2NvdW50IGZvciB0aGUgbWFwIHRpbHQuXG4gICAgdGhpcy55U3RyZXRjaCA9IDEgLyBNYXRoLmNvcyhwaXRjaCAvIDE4MCAqIE1hdGguUEkpO1xuXG4gICAgLy8gVGhlIGFtb3VudCB0aGUgbWFwIGlzIHNxdWlzaGVkIGRlcGVuZHMgb24gdGhlIHkgcG9zaXRpb24uXG4gICAgLy8gU29ydCBvZiBhY2NvdW50IGZvciB0aGlzIGJ5IG1ha2luZyBhbGwgYm94ZXMgYSBiaXQgYmlnZ2VyLlxuICAgIHRoaXMueVN0cmV0Y2ggPSBNYXRoLnBvdyh0aGlzLnlTdHJldGNoLCAxLjMpO1xuXG4gICAgdGhpcy5jb2xsaXNpb25Cb3hBcnJheSA9IGNvbGxpc2lvbkJveEFycmF5O1xuICAgIGlmIChjb2xsaXNpb25Cb3hBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gdGhlIGZpcnN0IGNvbGxpc2lvbkJveEFycmF5IGlzIHBhc3NlZCB0byBhIENvbGxpc2lvblRpbGVcblxuICAgICAgICAvLyB0ZW1wQ29sbGlzaW9uQm94XG4gICAgICAgIGNvbGxpc2lvbkJveEFycmF5LmVtcGxhY2VCYWNrKCk7XG5cbiAgICAgICAgdmFyIG1heEludDE2ID0gMzI3Njc7XG4gICAgICAgIC8vbGVmdFxuICAgICAgICBjb2xsaXNpb25Cb3hBcnJheS5lbXBsYWNlQmFjaygwLCAwLCAwLCAtbWF4SW50MTYsIDAsIG1heEludDE2LCBtYXhJbnQxNixcbiAgICAgICAgICAgICAgICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgIDApO1xuICAgICAgICAvLyByaWdodFxuICAgICAgICBjb2xsaXNpb25Cb3hBcnJheS5lbXBsYWNlQmFjayhFWFRFTlQsIDAsIDAsIC1tYXhJbnQxNiwgMCwgbWF4SW50MTYsIG1heEludDE2LFxuICAgICAgICAgICAgICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgICAgICAgICAgICAgMCk7XG4gICAgICAgIC8vIHRvcFxuICAgICAgICBjb2xsaXNpb25Cb3hBcnJheS5lbXBsYWNlQmFjaygwLCAwLCAtbWF4SW50MTYsIDAsIG1heEludDE2LCAwLCBtYXhJbnQxNixcbiAgICAgICAgICAgICAgICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgIDApO1xuICAgICAgICAvLyBib3R0b21cbiAgICAgICAgY29sbGlzaW9uQm94QXJyYXkuZW1wbGFjZUJhY2soMCwgRVhURU5ULCAtbWF4SW50MTYsIDAsIG1heEludDE2LCAwLCBtYXhJbnQxNixcbiAgICAgICAgICAgICAgICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgIDApO1xuICAgIH1cblxuICAgIHRoaXMudGVtcENvbGxpc2lvbkJveCA9IGNvbGxpc2lvbkJveEFycmF5LmdldCgwKTtcbiAgICB0aGlzLmVkZ2VzID0gW1xuICAgICAgICBjb2xsaXNpb25Cb3hBcnJheS5nZXQoMSksXG4gICAgICAgIGNvbGxpc2lvbkJveEFycmF5LmdldCgyKSxcbiAgICAgICAgY29sbGlzaW9uQm94QXJyYXkuZ2V0KDMpLFxuICAgICAgICBjb2xsaXNpb25Cb3hBcnJheS5nZXQoNClcbiAgICBdO1xufVxuXG5Db2xsaXNpb25UaWxlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgYW5nbGU6IHRoaXMuYW5nbGUsXG4gICAgICAgIHBpdGNoOiB0aGlzLnBpdGNoLFxuICAgICAgICBncmlkOiB0aGlzLmdyaWQudG9BcnJheUJ1ZmZlcigpLFxuICAgICAgICBpZ25vcmVkR3JpZDogdGhpcy5pZ25vcmVkR3JpZC50b0FycmF5QnVmZmVyKClcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIHRyYW5zZmVyYWJsZXM6IFtkYXRhLmdyaWQsIGRhdGEuaWdub3JlZEdyaWRdXG4gICAgfTtcbn07XG5cbkNvbGxpc2lvblRpbGUucHJvdG90eXBlLm1pblNjYWxlID0gMC4yNTtcbkNvbGxpc2lvblRpbGUucHJvdG90eXBlLm1heFNjYWxlID0gMjtcblxuXG4vKipcbiAqIEZpbmQgdGhlIHNjYWxlIGF0IHdoaWNoIHRoZSBjb2xsaXNpb25GZWF0dXJlIGNhbiBiZSBzaG93biB3aXRob3V0XG4gKiBvdmVybGFwcGluZyB3aXRoIG90aGVyIGZlYXR1cmVzLlxuICpcbiAqIEBwYXJhbSB7Q29sbGlzaW9uRmVhdHVyZX0gY29sbGlzaW9uRmVhdHVyZVxuICogQHJldHVybnMge251bWJlcn0gcGxhY2VtZW50U2NhbGVcbiAqIEBwcml2YXRlXG4gKi9cbkNvbGxpc2lvblRpbGUucHJvdG90eXBlLnBsYWNlQ29sbGlzaW9uRmVhdHVyZSA9IGZ1bmN0aW9uKGNvbGxpc2lvbkZlYXR1cmUsIGFsbG93T3ZlcmxhcCwgYXZvaWRFZGdlcykge1xuXG4gICAgdmFyIGNvbGxpc2lvbkJveEFycmF5ID0gdGhpcy5jb2xsaXNpb25Cb3hBcnJheTtcbiAgICB2YXIgbWluUGxhY2VtZW50U2NhbGUgPSB0aGlzLm1pblNjYWxlO1xuICAgIHZhciByb3RhdGlvbk1hdHJpeCA9IHRoaXMucm90YXRpb25NYXRyaXg7XG4gICAgdmFyIHlTdHJldGNoID0gdGhpcy55U3RyZXRjaDtcblxuICAgIGZvciAodmFyIGIgPSBjb2xsaXNpb25GZWF0dXJlLmJveFN0YXJ0SW5kZXg7IGIgPCBjb2xsaXNpb25GZWF0dXJlLmJveEVuZEluZGV4OyBiKyspIHtcblxuICAgICAgICB2YXIgYm94ID0gY29sbGlzaW9uQm94QXJyYXkuZ2V0KGIpO1xuXG4gICAgICAgIHZhciBhbmNob3JQb2ludCA9IGJveC5hbmNob3JQb2ludC5fbWF0TXVsdChyb3RhdGlvbk1hdHJpeCk7XG4gICAgICAgIHZhciB4ID0gYW5jaG9yUG9pbnQueDtcbiAgICAgICAgdmFyIHkgPSBhbmNob3JQb2ludC55O1xuXG4gICAgICAgIHZhciB4MSA9IHggKyBib3gueDE7XG4gICAgICAgIHZhciB5MSA9IHkgKyBib3gueTEgKiB5U3RyZXRjaDtcbiAgICAgICAgdmFyIHgyID0geCArIGJveC54MjtcbiAgICAgICAgdmFyIHkyID0geSArIGJveC55MiAqIHlTdHJldGNoO1xuXG4gICAgICAgIGJveC5iYm94MCA9IHgxO1xuICAgICAgICBib3guYmJveDEgPSB5MTtcbiAgICAgICAgYm94LmJib3gyID0geDI7XG4gICAgICAgIGJveC5iYm94MyA9IHkyO1xuXG4gICAgICAgIGlmICghYWxsb3dPdmVybGFwKSB7XG4gICAgICAgICAgICB2YXIgYmxvY2tpbmdCb3hlcyA9IHRoaXMuZ3JpZC5xdWVyeSh4MSwgeTEsIHgyLCB5Mik7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tpbmdCb3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBibG9ja2luZyA9IGNvbGxpc2lvbkJveEFycmF5LmdldChibG9ja2luZ0JveGVzW2ldKTtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tpbmdBbmNob3JQb2ludCA9IGJsb2NraW5nLmFuY2hvclBvaW50Ll9tYXRNdWx0KHJvdGF0aW9uTWF0cml4KTtcblxuICAgICAgICAgICAgICAgIG1pblBsYWNlbWVudFNjYWxlID0gdGhpcy5nZXRQbGFjZW1lbnRTY2FsZShtaW5QbGFjZW1lbnRTY2FsZSwgYW5jaG9yUG9pbnQsIGJveCwgYmxvY2tpbmdBbmNob3JQb2ludCwgYmxvY2tpbmcpO1xuICAgICAgICAgICAgICAgIGlmIChtaW5QbGFjZW1lbnRTY2FsZSA+PSB0aGlzLm1heFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtaW5QbGFjZW1lbnRTY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXZvaWRFZGdlcykge1xuICAgICAgICAgICAgdmFyIHJvdGF0ZWRDb2xsaXNpb25Cb3g7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldmVyc2VSb3RhdGlvbk1hdHJpeCA9IHRoaXMucmV2ZXJzZVJvdGF0aW9uTWF0cml4O1xuICAgICAgICAgICAgICAgIHZhciB0bCA9IG5ldyBQb2ludChib3gueDEsIGJveC55MSkubWF0TXVsdChyZXZlcnNlUm90YXRpb25NYXRyaXgpO1xuICAgICAgICAgICAgICAgIHZhciB0ciA9IG5ldyBQb2ludChib3gueDIsIGJveC55MSkubWF0TXVsdChyZXZlcnNlUm90YXRpb25NYXRyaXgpO1xuICAgICAgICAgICAgICAgIHZhciBibCA9IG5ldyBQb2ludChib3gueDEsIGJveC55MikubWF0TXVsdChyZXZlcnNlUm90YXRpb25NYXRyaXgpO1xuICAgICAgICAgICAgICAgIHZhciBiciA9IG5ldyBQb2ludChib3gueDIsIGJveC55MikubWF0TXVsdChyZXZlcnNlUm90YXRpb25NYXRyaXgpO1xuXG4gICAgICAgICAgICAgICAgcm90YXRlZENvbGxpc2lvbkJveCA9IHRoaXMudGVtcENvbGxpc2lvbkJveDtcbiAgICAgICAgICAgICAgICByb3RhdGVkQ29sbGlzaW9uQm94LmFuY2hvclBvaW50WCA9IGJveC5hbmNob3JQb2ludC54O1xuICAgICAgICAgICAgICAgIHJvdGF0ZWRDb2xsaXNpb25Cb3guYW5jaG9yUG9pbnRZID0gYm94LmFuY2hvclBvaW50Lnk7XG4gICAgICAgICAgICAgICAgcm90YXRlZENvbGxpc2lvbkJveC54MSA9IE1hdGgubWluKHRsLngsIHRyLngsIGJsLngsIGJyLngpO1xuICAgICAgICAgICAgICAgIHJvdGF0ZWRDb2xsaXNpb25Cb3gueTEgPSBNYXRoLm1pbih0bC55LCB0ci54LCBibC54LCBici54KTtcbiAgICAgICAgICAgICAgICByb3RhdGVkQ29sbGlzaW9uQm94LngyID0gTWF0aC5tYXgodGwueCwgdHIueCwgYmwueCwgYnIueCk7XG4gICAgICAgICAgICAgICAgcm90YXRlZENvbGxpc2lvbkJveC55MiA9IE1hdGgubWF4KHRsLnksIHRyLngsIGJsLngsIGJyLngpO1xuICAgICAgICAgICAgICAgIHJvdGF0ZWRDb2xsaXNpb25Cb3gubWF4U2NhbGUgPSBib3gubWF4U2NhbGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdGF0ZWRDb2xsaXNpb25Cb3ggPSBib3g7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5lZGdlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBlZGdlQm94ID0gdGhpcy5lZGdlc1trXTtcbiAgICAgICAgICAgICAgICBtaW5QbGFjZW1lbnRTY2FsZSA9IHRoaXMuZ2V0UGxhY2VtZW50U2NhbGUobWluUGxhY2VtZW50U2NhbGUsIGJveC5hbmNob3JQb2ludCwgcm90YXRlZENvbGxpc2lvbkJveCwgZWRnZUJveC5hbmNob3JQb2ludCwgZWRnZUJveCk7XG4gICAgICAgICAgICAgICAgaWYgKG1pblBsYWNlbWVudFNjYWxlID49IHRoaXMubWF4U2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1pblBsYWNlbWVudFNjYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtaW5QbGFjZW1lbnRTY2FsZTtcbn07XG5cbkNvbGxpc2lvblRpbGUucHJvdG90eXBlLnF1ZXJ5UmVuZGVyZWRTeW1ib2xzID0gZnVuY3Rpb24obWluWCwgbWluWSwgbWF4WCwgbWF4WSwgc2NhbGUpIHtcbiAgICB2YXIgc291cmNlTGF5ZXJGZWF0dXJlcyA9IHt9O1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIHZhciBjb2xsaXNpb25Cb3hBcnJheSA9IHRoaXMuY29sbGlzaW9uQm94QXJyYXk7XG4gICAgdmFyIHJvdGF0aW9uTWF0cml4ID0gdGhpcy5yb3RhdGlvbk1hdHJpeDtcbiAgICB2YXIgYW5jaG9yUG9pbnQgPSBuZXcgUG9pbnQobWluWCwgbWluWSkuX21hdE11bHQocm90YXRpb25NYXRyaXgpO1xuXG4gICAgdmFyIHF1ZXJ5Qm94ID0gdGhpcy50ZW1wQ29sbGlzaW9uQm94O1xuICAgIHF1ZXJ5Qm94LmFuY2hvclggPSBhbmNob3JQb2ludC54O1xuICAgIHF1ZXJ5Qm94LmFuY2hvclkgPSBhbmNob3JQb2ludC55O1xuICAgIHF1ZXJ5Qm94LngxID0gMDtcbiAgICBxdWVyeUJveC55MSA9IDA7XG4gICAgcXVlcnlCb3gueDIgPSBtYXhYIC0gbWluWDtcbiAgICBxdWVyeUJveC55MiA9IG1heFkgLSBtaW5ZO1xuICAgIHF1ZXJ5Qm94Lm1heFNjYWxlID0gc2NhbGU7XG5cbiAgICAvLyBtYXhTY2FsZSBpcyBzdG9yZWQgdXNpbmcgYSBGbG9hdDMyLiBDb252ZXJ0IGBzY2FsZWAgdG8gdGhlIHN0b3JlZCBGbG9hdDMyIHZhbHVlLlxuICAgIHNjYWxlID0gcXVlcnlCb3gubWF4U2NhbGU7XG5cbiAgICB2YXIgc2VhcmNoQm94ID0gW1xuICAgICAgICBhbmNob3JQb2ludC54ICsgcXVlcnlCb3gueDEgLyBzY2FsZSxcbiAgICAgICAgYW5jaG9yUG9pbnQueSArIHF1ZXJ5Qm94LnkxIC8gc2NhbGUgKiB0aGlzLnlTdHJldGNoLFxuICAgICAgICBhbmNob3JQb2ludC54ICsgcXVlcnlCb3gueDIgLyBzY2FsZSxcbiAgICAgICAgYW5jaG9yUG9pbnQueSArIHF1ZXJ5Qm94LnkyIC8gc2NhbGUgKiB0aGlzLnlTdHJldGNoXG4gICAgXTtcblxuICAgIHZhciBibG9ja2luZ0JveEtleXMgPSB0aGlzLmdyaWQucXVlcnkoc2VhcmNoQm94WzBdLCBzZWFyY2hCb3hbMV0sIHNlYXJjaEJveFsyXSwgc2VhcmNoQm94WzNdKTtcbiAgICB2YXIgYmxvY2tpbmdCb3hLZXlzMiA9IHRoaXMuaWdub3JlZEdyaWQucXVlcnkoc2VhcmNoQm94WzBdLCBzZWFyY2hCb3hbMV0sIHNlYXJjaEJveFsyXSwgc2VhcmNoQm94WzNdKTtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGJsb2NraW5nQm94S2V5czIubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgYmxvY2tpbmdCb3hLZXlzLnB1c2goYmxvY2tpbmdCb3hLZXlzMltrXSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja2luZ0JveEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGJsb2NraW5nID0gY29sbGlzaW9uQm94QXJyYXkuZ2V0KGJsb2NraW5nQm94S2V5c1tpXSk7XG5cbiAgICAgICAgdmFyIHNvdXJjZUxheWVyID0gYmxvY2tpbmcuc291cmNlTGF5ZXJJbmRleDtcbiAgICAgICAgdmFyIGZlYXR1cmVJbmRleCA9IGJsb2NraW5nLmZlYXR1cmVJbmRleDtcbiAgICAgICAgaWYgKHNvdXJjZUxheWVyRmVhdHVyZXNbc291cmNlTGF5ZXJdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNvdXJjZUxheWVyRmVhdHVyZXNbc291cmNlTGF5ZXJdID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNvdXJjZUxheWVyRmVhdHVyZXNbc291cmNlTGF5ZXJdW2ZlYXR1cmVJbmRleF0pIHtcbiAgICAgICAgICAgIHZhciBibG9ja2luZ0FuY2hvclBvaW50ID0gYmxvY2tpbmcuYW5jaG9yUG9pbnQubWF0TXVsdChyb3RhdGlvbk1hdHJpeCk7XG4gICAgICAgICAgICB2YXIgbWluUGxhY2VtZW50U2NhbGUgPSB0aGlzLmdldFBsYWNlbWVudFNjYWxlKHRoaXMubWluU2NhbGUsIGFuY2hvclBvaW50LCBxdWVyeUJveCwgYmxvY2tpbmdBbmNob3JQb2ludCwgYmxvY2tpbmcpO1xuICAgICAgICAgICAgaWYgKG1pblBsYWNlbWVudFNjYWxlID49IHNjYWxlKSB7XG4gICAgICAgICAgICAgICAgc291cmNlTGF5ZXJGZWF0dXJlc1tzb3VyY2VMYXllcl1bZmVhdHVyZUluZGV4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmxvY2tpbmdCb3hLZXlzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5Db2xsaXNpb25UaWxlLnByb3RvdHlwZS5nZXRQbGFjZW1lbnRTY2FsZSA9IGZ1bmN0aW9uKG1pblBsYWNlbWVudFNjYWxlLCBhbmNob3JQb2ludCwgYm94LCBibG9ja2luZ0FuY2hvclBvaW50LCBibG9ja2luZykge1xuXG4gICAgLy8gRmluZCB0aGUgbG93ZXN0IHNjYWxlIGF0IHdoaWNoIHRoZSB0d28gYm94ZXMgY2FuIGZpdCBzaWRlIGJ5IHNpZGUgd2l0aG91dCBvdmVybGFwcGluZy5cbiAgICAvLyBPcmlnaW5hbCBhbGdvcml0aG06XG4gICAgdmFyIGFuY2hvckRpZmZYID0gYW5jaG9yUG9pbnQueCAtIGJsb2NraW5nQW5jaG9yUG9pbnQueDtcbiAgICB2YXIgYW5jaG9yRGlmZlkgPSBhbmNob3JQb2ludC55IC0gYmxvY2tpbmdBbmNob3JQb2ludC55O1xuICAgIHZhciBzMSA9IChibG9ja2luZy54MSAtIGJveC54MikgLyBhbmNob3JEaWZmWDsgLy8gc2NhbGUgYXQgd2hpY2ggbmV3IGJveCBpcyB0byB0aGUgbGVmdCBvZiBvbGQgYm94XG4gICAgdmFyIHMyID0gKGJsb2NraW5nLngyIC0gYm94LngxKSAvIGFuY2hvckRpZmZYOyAvLyBzY2FsZSBhdCB3aGljaCBuZXcgYm94IGlzIHRvIHRoZSByaWdodCBvZiBvbGQgYm94XG4gICAgdmFyIHMzID0gKGJsb2NraW5nLnkxIC0gYm94LnkyKSAqIHRoaXMueVN0cmV0Y2ggLyBhbmNob3JEaWZmWTsgLy8gc2NhbGUgYXQgd2hpY2ggbmV3IGJveCBpcyB0byB0aGUgdG9wIG9mIG9sZCBib3hcbiAgICB2YXIgczQgPSAoYmxvY2tpbmcueTIgLSBib3gueTEpICogdGhpcy55U3RyZXRjaCAvIGFuY2hvckRpZmZZOyAvLyBzY2FsZSBhdCB3aGljaCBuZXcgYm94IGlzIHRvIHRoZSBib3R0b20gb2Ygb2xkIGJveFxuXG4gICAgaWYgKGlzTmFOKHMxKSB8fCBpc05hTihzMikpIHMxID0gczIgPSAxO1xuICAgIGlmIChpc05hTihzMykgfHwgaXNOYU4oczQpKSBzMyA9IHM0ID0gMTtcblxuICAgIHZhciBjb2xsaXNpb25GcmVlU2NhbGUgPSBNYXRoLm1pbihNYXRoLm1heChzMSwgczIpLCBNYXRoLm1heChzMywgczQpKTtcbiAgICB2YXIgYmxvY2tpbmdNYXhTY2FsZSA9IGJsb2NraW5nLm1heFNjYWxlO1xuICAgIHZhciBib3hNYXhTY2FsZSA9IGJveC5tYXhTY2FsZTtcblxuICAgIGlmIChjb2xsaXNpb25GcmVlU2NhbGUgPiBibG9ja2luZ01heFNjYWxlKSB7XG4gICAgICAgIC8vIEFmdGVyIGEgYm94J3MgbWF4U2NhbGUgdGhlIGxhYmVsIGhhcyBzaHJ1bmsgZW5vdWdoIHRoYXQgdGhlIGJveCBpcyBubyBsb25nZXIgbmVlZGVkIHRvIGNvdmVyIGl0LFxuICAgICAgICAvLyBzbyB1bmJsb2NrIHRoZSBuZXcgYm94IGF0IHRoZSBzY2FsZSB0aGF0IHRoZSBvbGQgYm94IGRpc2FwcGVhcnMuXG4gICAgICAgIGNvbGxpc2lvbkZyZWVTY2FsZSA9IGJsb2NraW5nTWF4U2NhbGU7XG4gICAgfVxuXG4gICAgaWYgKGNvbGxpc2lvbkZyZWVTY2FsZSA+IGJveE1heFNjYWxlKSB7XG4gICAgICAgIC8vIElmIHRoZSBib3ggY2FuIG9ubHkgYmUgc2hvd24gYWZ0ZXIgaXQgaXMgdmlzaWJsZSwgdGhlbiB0aGUgYm94IGNhbiBuZXZlciBiZSBzaG93bi5cbiAgICAgICAgLy8gQnV0IHRoZSBsYWJlbCBjYW4gYmUgc2hvd24gYWZ0ZXIgdGhpcyBib3ggaXMgbm90IHZpc2libGUuXG4gICAgICAgIGNvbGxpc2lvbkZyZWVTY2FsZSA9IGJveE1heFNjYWxlO1xuICAgIH1cblxuICAgIGlmIChjb2xsaXNpb25GcmVlU2NhbGUgPiBtaW5QbGFjZW1lbnRTY2FsZSAmJlxuICAgICAgICAgICAgY29sbGlzaW9uRnJlZVNjYWxlID49IGJsb2NraW5nLnBsYWNlbWVudFNjYWxlKSB7XG4gICAgICAgIC8vIElmIHRoaXMgY29sbGlzaW9uIG9jY3VycyBhdCBhIGxvd2VyIHNjYWxlIHRoYW4gcHJldmlvdXNseSBmb3VuZCBjb2xsaXNpb25zXG4gICAgICAgIC8vIGFuZCB0aGUgY29sbGlzaW9uIG9jY3VycyB3aGlsZSB0aGUgb3RoZXIgbGFiZWwgaXMgdmlzaWJsZVxuXG4gICAgICAgIC8vIHRoaXMgdGhpcyBpcyB0aGUgbG93ZXN0IHNjYWxlIGF0IHdoaWNoIHRoZSBsYWJlbCB3b24ndCBjb2xsaWRlIHdpdGggYW55dGhpbmdcbiAgICAgICAgbWluUGxhY2VtZW50U2NhbGUgPSBjb2xsaXNpb25GcmVlU2NhbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pblBsYWNlbWVudFNjYWxlO1xufTtcblxuXG4vKipcbiAqIFJlbWVtYmVyIHRoaXMgY29sbGlzaW9uRmVhdHVyZSBhbmQgd2hhdCBzY2FsZSBpdCB3YXMgcGxhY2VkIGF0IHRvIGJsb2NrXG4gKiBsYXRlciBmZWF0dXJlcyBmcm9tIG92ZXJsYXBwaW5nIHdpdGggaXQuXG4gKlxuICogQHBhcmFtIHtDb2xsaXNpb25GZWF0dXJlfSBjb2xsaXNpb25GZWF0dXJlXG4gKiBAcGFyYW0ge251bWJlcn0gbWluUGxhY2VtZW50U2NhbGVcbiAqIEBwcml2YXRlXG4gKi9cbkNvbGxpc2lvblRpbGUucHJvdG90eXBlLmluc2VydENvbGxpc2lvbkZlYXR1cmUgPSBmdW5jdGlvbihjb2xsaXNpb25GZWF0dXJlLCBtaW5QbGFjZW1lbnRTY2FsZSwgaWdub3JlUGxhY2VtZW50KSB7XG5cbiAgICB2YXIgZ3JpZCA9IGlnbm9yZVBsYWNlbWVudCA/IHRoaXMuaWdub3JlZEdyaWQgOiB0aGlzLmdyaWQ7XG4gICAgdmFyIGNvbGxpc2lvbkJveEFycmF5ID0gdGhpcy5jb2xsaXNpb25Cb3hBcnJheTtcblxuICAgIGZvciAodmFyIGsgPSBjb2xsaXNpb25GZWF0dXJlLmJveFN0YXJ0SW5kZXg7IGsgPCBjb2xsaXNpb25GZWF0dXJlLmJveEVuZEluZGV4OyBrKyspIHtcbiAgICAgICAgdmFyIGJveCA9IGNvbGxpc2lvbkJveEFycmF5LmdldChrKTtcbiAgICAgICAgYm94LnBsYWNlbWVudFNjYWxlID0gbWluUGxhY2VtZW50U2NhbGU7XG4gICAgICAgIGlmIChtaW5QbGFjZW1lbnRTY2FsZSA8IHRoaXMubWF4U2NhbGUpIHtcbiAgICAgICAgICAgIGdyaWQuaW5zZXJ0KGssIGJveC5iYm94MCwgYm94LmJib3gxLCBib3guYmJveDIsIGJveC5iYm94Myk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW50ZXJwb2xhdGUgPSByZXF1aXJlKCcuLi91dGlsL2ludGVycG9sYXRlJyk7XG52YXIgQW5jaG9yID0gcmVxdWlyZSgnLi4vc3ltYm9sL2FuY2hvcicpO1xudmFyIGNoZWNrTWF4QW5nbGUgPSByZXF1aXJlKCcuL2NoZWNrX21heF9hbmdsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFuY2hvcnM7XG5cbmZ1bmN0aW9uIGdldEFuY2hvcnMobGluZSwgc3BhY2luZywgbWF4QW5nbGUsIHNoYXBlZFRleHQsIHNoYXBlZEljb24sIGdseXBoU2l6ZSwgYm94U2NhbGUsIG92ZXJzY2FsaW5nLCB0aWxlRXh0ZW50KSB7XG5cbiAgICAvLyBSZXNhbXBsZSBhIGxpbmUgdG8gZ2V0IGFuY2hvciBwb2ludHMgZm9yIGxhYmVscyBhbmQgY2hlY2sgdGhhdCBlYWNoXG4gICAgLy8gcG90ZW50aWFsIGxhYmVsIHBhc3NlcyB0ZXh0LW1heC1hbmdsZSBjaGVjayBhbmQgaGFzIGVub3VnaCBmcm9vbSB0byBmaXRcbiAgICAvLyBvbiB0aGUgbGluZS5cblxuICAgIHZhciBhbmdsZVdpbmRvd1NpemUgPSBzaGFwZWRUZXh0ID9cbiAgICAgICAgMyAvIDUgKiBnbHlwaFNpemUgKiBib3hTY2FsZSA6XG4gICAgICAgIDA7XG5cbiAgICB2YXIgbGFiZWxMZW5ndGggPSBNYXRoLm1heChcbiAgICAgICAgc2hhcGVkVGV4dCA/IHNoYXBlZFRleHQucmlnaHQgLSBzaGFwZWRUZXh0LmxlZnQgOiAwLFxuICAgICAgICBzaGFwZWRJY29uID8gc2hhcGVkSWNvbi5yaWdodCAtIHNoYXBlZEljb24ubGVmdCA6IDApO1xuXG4gICAgLy8gSXMgdGhlIGxpbmUgY29udGludWVkIGZyb20gb3V0c2lkZSB0aGUgdGlsZSBib3VuZGFyeT9cbiAgICB2YXIgaXNMaW5lQ29udGludWVkID0gbGluZVswXS54ID09PSAwIHx8IGxpbmVbMF0ueCA9PT0gdGlsZUV4dGVudCB8fCBsaW5lWzBdLnkgPT09IDAgfHwgbGluZVswXS55ID09PSB0aWxlRXh0ZW50O1xuXG4gICAgLy8gSXMgdGhlIGxhYmVsIGxvbmcsIHJlbGF0aXZlIHRvIHRoZSBzcGFjaW5nP1xuICAgIC8vIElmIHNvLCBhZGp1c3QgdGhlIHNwYWNpbmcgc28gdGhlcmUgaXMgYWx3YXlzIGEgbWluaW11bSBzcGFjZSBvZiBgc3BhY2luZyAvIDRgIGJldHdlZW4gbGFiZWwgZWRnZXMuXG4gICAgaWYgKHNwYWNpbmcgLSBsYWJlbExlbmd0aCAqIGJveFNjYWxlICA8IHNwYWNpbmcgLyA0KSB7XG4gICAgICAgIHNwYWNpbmcgPSBsYWJlbExlbmd0aCAqIGJveFNjYWxlICsgc3BhY2luZyAvIDQ7XG4gICAgfVxuXG4gICAgLy8gT2Zmc2V0IHRoZSBmaXJzdCBhbmNob3IgYnk6XG4gICAgLy8gRWl0aGVyIGhhbGYgdGhlIGxhYmVsIGxlbmd0aCBwbHVzIGEgZml4ZWQgZXh0cmEgb2Zmc2V0IGlmIHRoZSBsaW5lIGlzIG5vdCBjb250aW51ZWRcbiAgICAvLyBPciBoYWxmIHRoZSBzcGFjaW5nIGlmIHRoZSBsaW5lIGlzIGNvbnRpbnVlZC5cblxuICAgIC8vIEZvciBub24tY29udGludWVkIGxpbmVzLCBhZGQgYSBiaXQgb2YgZml4ZWQgZXh0cmEgb2Zmc2V0IHRvIGF2b2lkIGNvbGxpc2lvbnMgYXQgVCBpbnRlcnNlY3Rpb25zLlxuICAgIHZhciBmaXhlZEV4dHJhT2Zmc2V0ID0gZ2x5cGhTaXplICogMjtcblxuICAgIHZhciBvZmZzZXQgPSAhaXNMaW5lQ29udGludWVkID9cbiAgICAgICAgKChsYWJlbExlbmd0aCAvIDIgKyBmaXhlZEV4dHJhT2Zmc2V0KSAqIGJveFNjYWxlICogb3ZlcnNjYWxpbmcpICUgc3BhY2luZyA6XG4gICAgICAgIChzcGFjaW5nIC8gMiAqIG92ZXJzY2FsaW5nKSAlIHNwYWNpbmc7XG5cbiAgICByZXR1cm4gcmVzYW1wbGUobGluZSwgb2Zmc2V0LCBzcGFjaW5nLCBhbmdsZVdpbmRvd1NpemUsIG1heEFuZ2xlLCBsYWJlbExlbmd0aCAqIGJveFNjYWxlLCBpc0xpbmVDb250aW51ZWQsIGZhbHNlLCB0aWxlRXh0ZW50KTtcbn1cblxuXG5mdW5jdGlvbiByZXNhbXBsZShsaW5lLCBvZmZzZXQsIHNwYWNpbmcsIGFuZ2xlV2luZG93U2l6ZSwgbWF4QW5nbGUsIGxhYmVsTGVuZ3RoLCBpc0xpbmVDb250aW51ZWQsIHBsYWNlQXRNaWRkbGUsIHRpbGVFeHRlbnQpIHtcblxuICAgIHZhciBoYWxmTGFiZWxMZW5ndGggPSBsYWJlbExlbmd0aCAvIDI7XG4gICAgdmFyIGxpbmVMZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGluZS5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgICAgbGluZUxlbmd0aCArPSBsaW5lW2tdLmRpc3QobGluZVtrICsgMV0pO1xuICAgIH1cblxuICAgIHZhciBkaXN0YW5jZSA9IDAsXG4gICAgICAgIG1hcmtlZERpc3RhbmNlID0gb2Zmc2V0IC0gc3BhY2luZztcblxuICAgIHZhciBhbmNob3JzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubGVuZ3RoIC0gMTsgaSsrKSB7XG5cbiAgICAgICAgdmFyIGEgPSBsaW5lW2ldLFxuICAgICAgICAgICAgYiA9IGxpbmVbaSArIDFdO1xuXG4gICAgICAgIHZhciBzZWdtZW50RGlzdCA9IGEuZGlzdChiKSxcbiAgICAgICAgICAgIGFuZ2xlID0gYi5hbmdsZVRvKGEpO1xuXG4gICAgICAgIHdoaWxlIChtYXJrZWREaXN0YW5jZSArIHNwYWNpbmcgPCBkaXN0YW5jZSArIHNlZ21lbnREaXN0KSB7XG4gICAgICAgICAgICBtYXJrZWREaXN0YW5jZSArPSBzcGFjaW5nO1xuXG4gICAgICAgICAgICB2YXIgdCA9IChtYXJrZWREaXN0YW5jZSAtIGRpc3RhbmNlKSAvIHNlZ21lbnREaXN0LFxuICAgICAgICAgICAgICAgIHggPSBpbnRlcnBvbGF0ZShhLngsIGIueCwgdCksXG4gICAgICAgICAgICAgICAgeSA9IGludGVycG9sYXRlKGEueSwgYi55LCB0KTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSB0aWxlIGJvdW5kYXJpZXMgYW5kIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZSBsYWJlbCB3b3VsZCBmaXQgYmVmb3JlIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgbGluZVxuICAgICAgICAgICAgLy8gaWYgcGxhY2VkIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgICAgICBpZiAoeCA+PSAwICYmIHggPCB0aWxlRXh0ZW50ICYmIHkgPj0gMCAmJiB5IDwgdGlsZUV4dGVudCAmJlxuICAgICAgICAgICAgICAgICAgICBtYXJrZWREaXN0YW5jZSAtIGhhbGZMYWJlbExlbmd0aCA+PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlZERpc3RhbmNlICsgaGFsZkxhYmVsTGVuZ3RoIDw9IGxpbmVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5jaG9yID0gbmV3IEFuY2hvcih4LCB5LCBhbmdsZSwgaSkuX3JvdW5kKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWFuZ2xlV2luZG93U2l6ZSB8fCBjaGVja01heEFuZ2xlKGxpbmUsIGFuY2hvciwgbGFiZWxMZW5ndGgsIGFuZ2xlV2luZG93U2l6ZSwgbWF4QW5nbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuY2hvcnMucHVzaChhbmNob3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3RhbmNlICs9IHNlZ21lbnREaXN0O1xuICAgIH1cblxuICAgIGlmICghcGxhY2VBdE1pZGRsZSAmJiAhYW5jaG9ycy5sZW5ndGggJiYgIWlzTGluZUNvbnRpbnVlZCkge1xuICAgICAgICAvLyBUaGUgZmlyc3QgYXR0ZW1wdCBhdCBmaW5kaW5nIGFuY2hvcnMgYXQgd2hpY2ggbGFiZWxzIGNhbiBiZSBwbGFjZWQgZmFpbGVkLlxuICAgICAgICAvLyBUcnkgYWdhaW4sIGJ1dCB0aGlzIHRpbWUganVzdCB0cnkgcGxhY2luZyBvbmUgYW5jaG9yIGF0IHRoZSBtaWRkbGUgb2YgdGhlIGxpbmUuXG4gICAgICAgIC8vIFRoaXMgaGFzIHRoZSBtb3N0IGVmZmVjdCBmb3Igc2hvcnQgbGluZXMgaW4gb3ZlcnNjYWxlZCB0aWxlcywgc2luY2UgdGhlXG4gICAgICAgIC8vIGluaXRpYWwgb2Zmc2V0IHVzZWQgaW4gb3ZlcnNjYWxlZCB0aWxlcyBpcyBjYWxjdWxhdGVkIHRvIGFsaWduIGxhYmVscyB3aXRoIHBvc2l0aW9ucyBpblxuICAgICAgICAvLyBwYXJlbnQgdGlsZXMgaW5zdGVhZCBvZiBwbGFjaW5nIHRoZSBsYWJlbCBhcyBjbG9zZSB0byB0aGUgYmVnaW5uaW5nIGFzIHBvc3NpYmxlLlxuICAgICAgICBhbmNob3JzID0gcmVzYW1wbGUobGluZSwgZGlzdGFuY2UgLyAyLCBzcGFjaW5nLCBhbmdsZVdpbmRvd1NpemUsIG1heEFuZ2xlLCBsYWJlbExlbmd0aCwgaXNMaW5lQ29udGludWVkLCB0cnVlLCB0aWxlRXh0ZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jaG9ycztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFNoZWxmUGFjayA9IHJlcXVpcmUoJ3NoZWxmLXBhY2snKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG5cbnZhciBTSVpFX0dST1dUSF9SQVRFID0gNDtcbnZhciBERUZBVUxUX1NJWkUgPSAxMjg7XG4vLyBtdXN0IGJlIFwiREVGQVVMVF9TSVpFICogU0laRV9HUk9XVEhfUkFURSBeIG5cIiBmb3Igc29tZSBpbnRlZ2VyIG5cbnZhciBNQVhfU0laRSA9IDIwNDg7XG5cbm1vZHVsZS5leHBvcnRzID0gR2x5cGhBdGxhcztcbmZ1bmN0aW9uIEdseXBoQXRsYXMoKSB7XG4gICAgdGhpcy53aWR0aCA9IERFRkFVTFRfU0laRTtcbiAgICB0aGlzLmhlaWdodCA9IERFRkFVTFRfU0laRTtcblxuICAgIHRoaXMuYmluID0gbmV3IFNoZWxmUGFjayh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgdGhpcy5pbmRleCA9IHt9O1xuICAgIHRoaXMuaWRzID0ge307XG4gICAgdGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0KTtcbn1cblxuR2x5cGhBdGxhcy5wcm90b3R5cGUuZ2V0R2x5cGhzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdseXBocyA9IHt9LFxuICAgICAgICBzcGxpdCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgaWQ7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5pZHMpIHtcbiAgICAgICAgc3BsaXQgPSBrZXkuc3BsaXQoJyMnKTtcbiAgICAgICAgbmFtZSA9IHNwbGl0WzBdO1xuICAgICAgICBpZCA9IHNwbGl0WzFdO1xuXG4gICAgICAgIGlmICghZ2x5cGhzW25hbWVdKSBnbHlwaHNbbmFtZV0gPSBbXTtcbiAgICAgICAgZ2x5cGhzW25hbWVdLnB1c2goaWQpO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaHM7XG59O1xuXG5HbHlwaEF0bGFzLnByb3RvdHlwZS5nZXRSZWN0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZWN0cyA9IHt9LFxuICAgICAgICBzcGxpdCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgaWQ7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5pZHMpIHtcbiAgICAgICAgc3BsaXQgPSBrZXkuc3BsaXQoJyMnKTtcbiAgICAgICAgbmFtZSA9IHNwbGl0WzBdO1xuICAgICAgICBpZCA9IHNwbGl0WzFdO1xuXG4gICAgICAgIGlmICghcmVjdHNbbmFtZV0pIHJlY3RzW25hbWVdID0ge307XG4gICAgICAgIHJlY3RzW25hbWVdW2lkXSA9IHRoaXMuaW5kZXhba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjdHM7XG59O1xuXG5cbkdseXBoQXRsYXMucHJvdG90eXBlLmFkZEdseXBoID0gZnVuY3Rpb24oaWQsIG5hbWUsIGdseXBoLCBidWZmZXIpIHtcbiAgICBpZiAoIWdseXBoKSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBrZXkgPSBuYW1lICsgXCIjXCIgKyBnbHlwaC5pZDtcblxuICAgIC8vIFRoZSBnbHlwaCBpcyBhbHJlYWR5IGluIHRoaXMgdGV4dHVyZS5cbiAgICBpZiAodGhpcy5pbmRleFtrZXldKSB7XG4gICAgICAgIGlmICh0aGlzLmlkc1trZXldLmluZGV4T2YoaWQpIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5pZHNba2V5XS5wdXNoKGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleFtrZXldO1xuICAgIH1cblxuICAgIC8vIFRoZSBnbHlwaCBiaXRtYXAgaGFzIHplcm8gd2lkdGguXG4gICAgaWYgKCFnbHlwaC5iaXRtYXApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlcmVkV2lkdGggPSBnbHlwaC53aWR0aCArIGJ1ZmZlciAqIDI7XG4gICAgdmFyIGJ1ZmZlcmVkSGVpZ2h0ID0gZ2x5cGguaGVpZ2h0ICsgYnVmZmVyICogMjtcblxuICAgIC8vIEFkZCBhIDFweCBib3JkZXIgYXJvdW5kIGV2ZXJ5IGltYWdlLlxuICAgIHZhciBwYWRkaW5nID0gMTtcbiAgICB2YXIgcGFja1dpZHRoID0gYnVmZmVyZWRXaWR0aCArIDIgKiBwYWRkaW5nO1xuICAgIHZhciBwYWNrSGVpZ2h0ID0gYnVmZmVyZWRIZWlnaHQgKyAyICogcGFkZGluZztcblxuICAgIC8vIEluY3JlYXNlIHRvIG5leHQgbnVtYmVyIGRpdmlzaWJsZSBieSA0LCBidXQgYXQgbGVhc3QgMS5cbiAgICAvLyBUaGlzIGlzIHNvIHdlIGNhbiBzY2FsZSBkb3duIHRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzIGFuZCBwYWNrIHRoZW1cbiAgICAvLyBpbnRvIGZld2VyIGJ5dGVzLlxuICAgIHBhY2tXaWR0aCArPSAoNCAtIHBhY2tXaWR0aCAlIDQpO1xuICAgIHBhY2tIZWlnaHQgKz0gKDQgLSBwYWNrSGVpZ2h0ICUgNCk7XG5cbiAgICB2YXIgcmVjdCA9IHRoaXMuYmluLnBhY2tPbmUocGFja1dpZHRoLCBwYWNrSGVpZ2h0KTtcbiAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgcmVjdCA9IHRoaXMuYmluLnBhY2tPbmUocGFja1dpZHRoLCBwYWNrSGVpZ2h0KTtcbiAgICB9XG4gICAgaWYgKCFyZWN0KSB7XG4gICAgICAgIHV0aWwud2Fybk9uY2UoJ2dseXBoIGJpdG1hcCBvdmVyZmxvdycpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmluZGV4W2tleV0gPSByZWN0O1xuICAgIHRoaXMuaWRzW2tleV0gPSBbaWRdO1xuXG4gICAgdmFyIHRhcmdldCA9IHRoaXMuZGF0YTtcbiAgICB2YXIgc291cmNlID0gZ2x5cGguYml0bWFwO1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgYnVmZmVyZWRIZWlnaHQ7IHkrKykge1xuICAgICAgICB2YXIgeTEgPSB0aGlzLndpZHRoICogKHJlY3QueSArIHkgKyBwYWRkaW5nKSArIHJlY3QueCArIHBhZGRpbmc7XG4gICAgICAgIHZhciB5MiA9IGJ1ZmZlcmVkV2lkdGggKiB5O1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGJ1ZmZlcmVkV2lkdGg7IHgrKykge1xuICAgICAgICAgICAgdGFyZ2V0W3kxICsgeF0gPSBzb3VyY2VbeTIgKyB4XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHJlY3Q7XG59O1xuXG5HbHlwaEF0bGFzLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcHJldldpZHRoID0gdGhpcy53aWR0aDtcbiAgICB2YXIgcHJldkhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgaWYgKHByZXZXaWR0aCA+PSBNQVhfU0laRSB8fCBwcmV2SGVpZ2h0ID49IE1BWF9TSVpFKSByZXR1cm47XG5cbiAgICBpZiAodGhpcy50ZXh0dXJlKSB7XG4gICAgICAgIGlmICh0aGlzLmdsKSB7XG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMud2lkdGggKj0gU0laRV9HUk9XVEhfUkFURTtcbiAgICB0aGlzLmhlaWdodCAqPSBTSVpFX0dST1dUSF9SQVRFO1xuICAgIHRoaXMuYmluLnJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2SGVpZ2h0OyBpKyspIHtcbiAgICAgICAgdmFyIHNyYyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHByZXZIZWlnaHQgKiBpLCBwcmV2V2lkdGgpO1xuICAgICAgICB2YXIgZHN0ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLCBwcmV2SGVpZ2h0ICogaSAqIFNJWkVfR1JPV1RIX1JBVEUsIHByZXZXaWR0aCk7XG4gICAgICAgIGRzdC5zZXQoc3JjKTtcbiAgICB9XG4gICAgdGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbn07XG5cbkdseXBoQXRsYXMucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihnbCkge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICBpZiAoIXRoaXMudGV4dHVyZSkge1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLkFMUEhBLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgZ2wuQUxQSEEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICB9XG59O1xuXG5HbHlwaEF0bGFzLnByb3RvdHlwZS51cGRhdGVUZXh0dXJlID0gZnVuY3Rpb24oZ2wpIHtcbiAgICB0aGlzLmJpbmQoZ2wpO1xuICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIGdsLkFMUEhBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLmRhdGEpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG5vcm1hbGl6ZVVSTCA9IHJlcXVpcmUoJy4uL3V0aWwvbWFwYm94Jykubm9ybWFsaXplR2x5cGhzVVJMO1xudmFyIGdldEFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi4vdXRpbC9hamF4JykuZ2V0QXJyYXlCdWZmZXI7XG52YXIgR2x5cGhzID0gcmVxdWlyZSgnLi4vdXRpbC9nbHlwaHMnKTtcbnZhciBHbHlwaEF0bGFzID0gcmVxdWlyZSgnLi4vc3ltYm9sL2dseXBoX2F0bGFzJyk7XG52YXIgUHJvdG9idWYgPSByZXF1aXJlKCdwYmYnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaFNvdXJjZTtcblxuLyoqXG4gKiBBIGdseXBoIHNvdXJjZSBoYXMgYSBVUkwgZnJvbSB3aGljaCB0byBsb2FkIG5ldyBnbHlwaHMgYW5kIG1hbmFnZXNcbiAqIEdseXBoQXRsYXNlcyBpbiB3aGljaCB0byBzdG9yZSBnbHlwaHMgdXNlZCBieSB0aGUgcmVxdWVzdGVkIGZvbnRzdGFja3NcbiAqIGFuZCByYW5nZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBnbHlwaCB0ZW1wbGF0ZSB1cmxcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEdseXBoU291cmNlKHVybCkge1xuICAgIHRoaXMudXJsID0gdXJsICYmIG5vcm1hbGl6ZVVSTCh1cmwpO1xuICAgIHRoaXMuYXRsYXNlcyA9IHt9O1xuICAgIHRoaXMuc3RhY2tzID0ge307XG4gICAgdGhpcy5sb2FkaW5nID0ge307XG59XG5cbkdseXBoU291cmNlLnByb3RvdHlwZS5nZXRTaW1wbGVHbHlwaHMgPSBmdW5jdGlvbihmb250c3RhY2ssIGdseXBoSURzLCB1aWQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuc3RhY2tzW2ZvbnRzdGFja10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnN0YWNrc1tmb250c3RhY2tdID0ge307XG4gICAgfVxuICAgIGlmICh0aGlzLmF0bGFzZXNbZm9udHN0YWNrXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYXRsYXNlc1tmb250c3RhY2tdID0gbmV3IEdseXBoQXRsYXMoKTtcbiAgICB9XG5cbiAgICB2YXIgZ2x5cGhzID0ge307XG4gICAgdmFyIHN0YWNrID0gdGhpcy5zdGFja3NbZm9udHN0YWNrXTtcbiAgICB2YXIgYXRsYXMgPSB0aGlzLmF0bGFzZXNbZm9udHN0YWNrXTtcblxuICAgIC8vIHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRoZSBzZGYgYml0bWFwcyBhcmUgcGFkZGVkIGJ5XG4gICAgdmFyIGJ1ZmZlciA9IDM7XG5cbiAgICB2YXIgbWlzc2luZyA9IHt9O1xuICAgIHZhciByZW1haW5pbmcgPSAwO1xuICAgIHZhciByYW5nZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdseXBoSUQgPSBnbHlwaElEc1tpXTtcbiAgICAgICAgcmFuZ2UgPSBNYXRoLmZsb29yKGdseXBoSUQgLyAyNTYpO1xuXG4gICAgICAgIGlmIChzdGFja1tyYW5nZV0pIHtcbiAgICAgICAgICAgIHZhciBnbHlwaCA9IHN0YWNrW3JhbmdlXS5nbHlwaHNbZ2x5cGhJRF07XG4gICAgICAgICAgICB2YXIgcmVjdCAgPSBhdGxhcy5hZGRHbHlwaCh1aWQsIGZvbnRzdGFjaywgZ2x5cGgsIGJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAoZ2x5cGgpIGdseXBoc1tnbHlwaElEXSA9IG5ldyBTaW1wbGVHbHlwaChnbHlwaCwgcmVjdCwgYnVmZmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtaXNzaW5nW3JhbmdlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZ1tyYW5nZV0gPSBbXTtcbiAgICAgICAgICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1pc3NpbmdbcmFuZ2VdLnB1c2goZ2x5cGhJRCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXJlbWFpbmluZykgY2FsbGJhY2sodW5kZWZpbmVkLCBnbHlwaHMsIGZvbnRzdGFjayk7XG5cbiAgICB2YXIgb25SYW5nZUxvYWRlZCA9IGZ1bmN0aW9uKGVyciwgcmFuZ2UsIGRhdGEpIHtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMuc3RhY2tzW2ZvbnRzdGFja11bcmFuZ2VdID0gZGF0YS5zdGFja3NbMF07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pc3NpbmdbcmFuZ2VdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdseXBoSUQgPSBtaXNzaW5nW3JhbmdlXVtpXTtcbiAgICAgICAgICAgICAgICB2YXIgZ2x5cGggPSBzdGFjay5nbHlwaHNbZ2x5cGhJRF07XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgID0gYXRsYXMuYWRkR2x5cGgodWlkLCBmb250c3RhY2ssIGdseXBoLCBidWZmZXIpO1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaCkgZ2x5cGhzW2dseXBoSURdID0gbmV3IFNpbXBsZUdseXBoKGdseXBoLCByZWN0LCBidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbWFpbmluZy0tO1xuICAgICAgICBpZiAoIXJlbWFpbmluZykgY2FsbGJhY2sodW5kZWZpbmVkLCBnbHlwaHMsIGZvbnRzdGFjayk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgciBpbiBtaXNzaW5nKSB7XG4gICAgICAgIHRoaXMubG9hZFJhbmdlKGZvbnRzdGFjaywgciwgb25SYW5nZUxvYWRlZCk7XG4gICAgfVxufTtcblxuLy8gQSBzaW1wbGlmaWVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnbHlwaCBjb250YWluaW5nIG9ubHkgdGhlIHByb3BlcnRpZXMgbmVlZGVkIGZvciBzaGFwaW5nLlxuZnVuY3Rpb24gU2ltcGxlR2x5cGgoZ2x5cGgsIHJlY3QsIGJ1ZmZlcikge1xuICAgIHZhciBwYWRkaW5nID0gMTtcbiAgICB0aGlzLmFkdmFuY2UgPSBnbHlwaC5hZHZhbmNlO1xuICAgIHRoaXMubGVmdCA9IGdseXBoLmxlZnQgLSBidWZmZXIgLSBwYWRkaW5nO1xuICAgIHRoaXMudG9wID0gZ2x5cGgudG9wICsgYnVmZmVyICsgcGFkZGluZztcbiAgICB0aGlzLnJlY3QgPSByZWN0O1xufVxuXG5HbHlwaFNvdXJjZS5wcm90b3R5cGUubG9hZFJhbmdlID0gZnVuY3Rpb24oZm9udHN0YWNrLCByYW5nZSwgY2FsbGJhY2spIHtcbiAgICBpZiAocmFuZ2UgKiAyNTYgPiA2NTUzNSkgcmV0dXJuIGNhbGxiYWNrKCdnbHlwaHMgPiA2NTUzNSBub3Qgc3VwcG9ydGVkJyk7XG5cbiAgICBpZiAodGhpcy5sb2FkaW5nW2ZvbnRzdGFja10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxvYWRpbmdbZm9udHN0YWNrXSA9IHt9O1xuICAgIH1cbiAgICB2YXIgbG9hZGluZyA9IHRoaXMubG9hZGluZ1tmb250c3RhY2tdO1xuXG4gICAgaWYgKGxvYWRpbmdbcmFuZ2VdKSB7XG4gICAgICAgIGxvYWRpbmdbcmFuZ2VdLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWRpbmdbcmFuZ2VdID0gW2NhbGxiYWNrXTtcblxuICAgICAgICB2YXIgcmFuZ2VOYW1lID0gKHJhbmdlICogMjU2KSArICctJyArIChyYW5nZSAqIDI1NiArIDI1NSk7XG4gICAgICAgIHZhciB1cmwgPSBnbHlwaFVybChmb250c3RhY2ssIHJhbmdlTmFtZSwgdGhpcy51cmwpO1xuXG4gICAgICAgIGdldEFycmF5QnVmZmVyKHVybCwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGhzID0gIWVyciAmJiBuZXcgR2x5cGhzKG5ldyBQcm90b2J1ZihuZXcgVWludDhBcnJheShkYXRhKSkpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2FkaW5nW3JhbmdlXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxvYWRpbmdbcmFuZ2VdW2ldKGVyciwgcmFuZ2UsIGdseXBocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgbG9hZGluZ1tyYW5nZV07XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbkdseXBoU291cmNlLnByb3RvdHlwZS5nZXRHbHlwaEF0bGFzID0gZnVuY3Rpb24oZm9udHN0YWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuYXRsYXNlc1tmb250c3RhY2tdO1xufTtcblxuLyoqXG4gKiBVc2UgQ05BTUUgc2hhcmRpbmcgdG8gbG9hZCBhIHNwZWNpZmljIGdseXBoIHJhbmdlIG92ZXIgYSByYW5kb21pemVkXG4gKiBidXQgY29uc2lzdGVudCBzdWJkb21haW4uXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udHN0YWNrIGNvbW1hLWpvaW5lZCBmb250c1xuICogQHBhcmFtIHtzdHJpbmd9IHJhbmdlIGNvbW1hLWpvaW5lZCByYW5nZVxuICogQHBhcmFtIHt1cmx9IHVybCB0ZW1wbGF0ZWQgdXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N1YmRvbWFpbnM9YWJjXSBzdWJkb21haW5zIGFzIGEgc3RyaW5nIHdoZXJlIGVhY2ggbGV0dGVyIGlzIG9uZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IGEgdXJsIHRvIGxvYWQgdGhhdCBzZWN0aW9uIG9mIGdseXBoc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2x5cGhVcmwoZm9udHN0YWNrLCByYW5nZSwgdXJsLCBzdWJkb21haW5zKSB7XG4gICAgLy9zdWJkb21haW5zID0gc3ViZG9tYWlucyB8fCAnYWJjJztcblxuICAgIC8vcmV0dXJuIHVybFxuICAgIC8vICAgIC5yZXBsYWNlKCd7c30nLCBzdWJkb21haW5zW2ZvbnRzdGFjay5sZW5ndGggJSBzdWJkb21haW5zLmxlbmd0aF0pXG4gICAgLy8gICAgLnJlcGxhY2UoJ3tmb250c3RhY2t9JywgZm9udHN0YWNrKVxuICAgIC8vICAgIC5yZXBsYWNlKCd7cmFuZ2V9JywgcmFuZ2UpO1xuICAgIHJldHVybiAnL2FwcC9mb250czEvJytyYW5nZSsnLnBiZic7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZlYXR1cmVzLCB0ZXh0RmVhdHVyZXMsIGdlb21ldHJpZXMpIHtcblxuICAgIHZhciBsZWZ0SW5kZXggPSB7fSxcbiAgICAgICAgcmlnaHRJbmRleCA9IHt9LFxuICAgICAgICBtZXJnZWRGZWF0dXJlcyA9IFtdLFxuICAgICAgICBtZXJnZWRHZW9tID0gW10sXG4gICAgICAgIG1lcmdlZFRleHRzID0gW10sXG4gICAgICAgIG1lcmdlZEluZGV4ID0gMCxcbiAgICAgICAgaztcblxuICAgIGZ1bmN0aW9uIGFkZChrKSB7XG4gICAgICAgIG1lcmdlZEZlYXR1cmVzLnB1c2goZmVhdHVyZXNba10pO1xuICAgICAgICBtZXJnZWRHZW9tLnB1c2goZ2VvbWV0cmllc1trXSk7XG4gICAgICAgIG1lcmdlZFRleHRzLnB1c2godGV4dEZlYXR1cmVzW2tdKTtcbiAgICAgICAgbWVyZ2VkSW5kZXgrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZUZyb21SaWdodChsZWZ0S2V5LCByaWdodEtleSwgZ2VvbSkge1xuICAgICAgICB2YXIgaSA9IHJpZ2h0SW5kZXhbbGVmdEtleV07XG4gICAgICAgIGRlbGV0ZSByaWdodEluZGV4W2xlZnRLZXldO1xuICAgICAgICByaWdodEluZGV4W3JpZ2h0S2V5XSA9IGk7XG5cbiAgICAgICAgbWVyZ2VkR2VvbVtpXVswXS5wb3AoKTtcbiAgICAgICAgbWVyZ2VkR2VvbVtpXVswXSA9IG1lcmdlZEdlb21baV1bMF0uY29uY2F0KGdlb21bMF0pO1xuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZUZyb21MZWZ0KGxlZnRLZXksIHJpZ2h0S2V5LCBnZW9tKSB7XG4gICAgICAgIHZhciBpID0gbGVmdEluZGV4W3JpZ2h0S2V5XTtcbiAgICAgICAgZGVsZXRlIGxlZnRJbmRleFtyaWdodEtleV07XG4gICAgICAgIGxlZnRJbmRleFtsZWZ0S2V5XSA9IGk7XG5cbiAgICAgICAgbWVyZ2VkR2VvbVtpXVswXS5zaGlmdCgpO1xuICAgICAgICBtZXJnZWRHZW9tW2ldWzBdID0gZ2VvbVswXS5jb25jYXQobWVyZ2VkR2VvbVtpXVswXSk7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEtleSh0ZXh0LCBnZW9tLCBvblJpZ2h0KSB7XG4gICAgICAgIHZhciBwb2ludCA9IG9uUmlnaHQgPyBnZW9tWzBdW2dlb21bMF0ubGVuZ3RoIC0gMV0gOiBnZW9tWzBdWzBdO1xuICAgICAgICByZXR1cm4gdGV4dCArICc6JyArIHBvaW50LnggKyAnOicgKyBwb2ludC55O1xuICAgIH1cblxuICAgIGZvciAoayA9IDA7IGsgPCBmZWF0dXJlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgZ2VvbSA9IGdlb21ldHJpZXNba10sXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dEZlYXR1cmVzW2tdO1xuXG4gICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgYWRkKGspO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVmdEtleSA9IGdldEtleSh0ZXh0LCBnZW9tKSxcbiAgICAgICAgICAgIHJpZ2h0S2V5ID0gZ2V0S2V5KHRleHQsIGdlb20sIHRydWUpO1xuXG4gICAgICAgIGlmICgobGVmdEtleSBpbiByaWdodEluZGV4KSAmJiAocmlnaHRLZXkgaW4gbGVmdEluZGV4KSAmJiAocmlnaHRJbmRleFtsZWZ0S2V5XSAhPT0gbGVmdEluZGV4W3JpZ2h0S2V5XSkpIHtcbiAgICAgICAgICAgIC8vIGZvdW5kIGxpbmVzIHdpdGggdGhlIHNhbWUgdGV4dCBhZGphY2VudCB0byBib3RoIGVuZHMgb2YgdGhlIGN1cnJlbnQgbGluZSwgbWVyZ2UgYWxsIHRocmVlXG4gICAgICAgICAgICB2YXIgaiA9IG1lcmdlRnJvbUxlZnQobGVmdEtleSwgcmlnaHRLZXksIGdlb20pO1xuICAgICAgICAgICAgdmFyIGkgPSBtZXJnZUZyb21SaWdodChsZWZ0S2V5LCByaWdodEtleSwgbWVyZ2VkR2VvbVtqXSk7XG5cbiAgICAgICAgICAgIGRlbGV0ZSBsZWZ0SW5kZXhbbGVmdEtleV07XG4gICAgICAgICAgICBkZWxldGUgcmlnaHRJbmRleFtyaWdodEtleV07XG5cbiAgICAgICAgICAgIHJpZ2h0SW5kZXhbZ2V0S2V5KHRleHQsIG1lcmdlZEdlb21baV0sIHRydWUpXSA9IGk7XG4gICAgICAgICAgICBtZXJnZWRHZW9tW2pdID0gbnVsbDtcblxuICAgICAgICB9IGVsc2UgaWYgKGxlZnRLZXkgaW4gcmlnaHRJbmRleCkge1xuICAgICAgICAgICAgLy8gZm91bmQgbWVyZ2VhYmxlIGxpbmUgYWRqYWNlbnQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjdXJyZW50IGxpbmUsIG1lcmdlXG4gICAgICAgICAgICBtZXJnZUZyb21SaWdodChsZWZ0S2V5LCByaWdodEtleSwgZ2VvbSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChyaWdodEtleSBpbiBsZWZ0SW5kZXgpIHtcbiAgICAgICAgICAgIC8vIGZvdW5kIG1lcmdlYWJsZSBsaW5lIGFkamFjZW50IHRvIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgbGluZSwgbWVyZ2VcbiAgICAgICAgICAgIG1lcmdlRnJvbUxlZnQobGVmdEtleSwgcmlnaHRLZXksIGdlb20pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBhZGphY2VudCBsaW5lcywgYWRkIGFzIGEgbmV3IGl0ZW1cbiAgICAgICAgICAgIGFkZChrKTtcbiAgICAgICAgICAgIGxlZnRJbmRleFtsZWZ0S2V5XSA9IG1lcmdlZEluZGV4IC0gMTtcbiAgICAgICAgICAgIHJpZ2h0SW5kZXhbcmlnaHRLZXldID0gbWVyZ2VkSW5kZXggLSAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmVhdHVyZXM6IG1lcmdlZEZlYXR1cmVzLFxuICAgICAgICB0ZXh0RmVhdHVyZXM6IG1lcmdlZFRleHRzLFxuICAgICAgICBnZW9tZXRyaWVzOiBtZXJnZWRHZW9tXG4gICAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldEljb25RdWFkczogZ2V0SWNvblF1YWRzLFxuICAgIGdldEdseXBoUXVhZHM6IGdldEdseXBoUXVhZHMsXG4gICAgU3ltYm9sUXVhZDogU3ltYm9sUXVhZFxufTtcblxudmFyIG1pblNjYWxlID0gMC41OyAvLyB1bmRlcnNjYWxlIGJ5IDEgem9vbSBsZXZlbFxuXG4vKipcbiAqIEEgdGV4dHVyZWQgcXVhZCBmb3IgcmVuZGVyaW5nIGEgc2luZ2xlIGljb24gb3IgZ2x5cGguXG4gKlxuICogVGhlIHpvb20gcmFuZ2UgdGhlIGdseXBoIGNhbiBiZSBzaG93biBpcyBkZWZpbmVkIGJ5IG1pblNjYWxlIGFuZCBtYXhTY2FsZS5cbiAqXG4gKiBAcGFyYW0ge1BvaW50fSBhbmNob3JQb2ludCB0aGUgcG9pbnQgdGhlIHN5bWJvbCBpcyBhbmNob3JlZCBhcm91bmRcbiAqIEBwYXJhbSB7UG9pbnR9IHRsIFRoZSBvZmZzZXQgb2YgdGhlIHRvcCBsZWZ0IGNvcm5lciBmcm9tIHRoZSBhbmNob3IuXG4gKiBAcGFyYW0ge1BvaW50fSB0ciBUaGUgb2Zmc2V0IG9mIHRoZSB0b3AgcmlnaHQgY29ybmVyIGZyb20gdGhlIGFuY2hvci5cbiAqIEBwYXJhbSB7UG9pbnR9IGJsIFRoZSBvZmZzZXQgb2YgdGhlIGJvdHRvbSBsZWZ0IGNvcm5lciBmcm9tIHRoZSBhbmNob3IuXG4gKiBAcGFyYW0ge1BvaW50fSBiciBUaGUgb2Zmc2V0IG9mIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIGZyb20gdGhlIGFuY2hvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0ZXggVGhlIHRleHR1cmUgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gYW5jaG9yQW5nbGUgVGhlIGFuZ2xlIG9mIHRoZSBsYWJlbCBhdCBpdCdzIGNlbnRlciwgbm90IHRoZSBhbmdsZSBvZiB0aGlzIHF1YWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZ2x5cGhBbmdsZSBUaGUgYW5nbGUgb2YgdGhlIGdseXBoIHRvIGJlIHBvc2l0aW9uZWQgaW4gdGhlIHF1YWQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluU2NhbGUgVGhlIG1pbmltdW0gc2NhbGUsIHJlbGF0aXZlIHRvIHRoZSB0aWxlJ3MgaW50ZW5kZWQgc2NhbGUsIHRoYXQgdGhlIGdseXBoIGNhbiBiZSBzaG93biBhdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhTY2FsZSBUaGUgbWF4aW11bSBzY2FsZSwgcmVsYXRpdmUgdG8gdGhlIHRpbGUncyBpbnRlbmRlZCBzY2FsZSwgdGhhdCB0aGUgZ2x5cGggY2FuIGJlIHNob3duIGF0LlxuICpcbiAqIEBjbGFzcyBTeW1ib2xRdWFkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBTeW1ib2xRdWFkKGFuY2hvclBvaW50LCB0bCwgdHIsIGJsLCBiciwgdGV4LCBhbmNob3JBbmdsZSwgZ2x5cGhBbmdsZSwgbWluU2NhbGUsIG1heFNjYWxlKSB7XG4gICAgdGhpcy5hbmNob3JQb2ludCA9IGFuY2hvclBvaW50O1xuICAgIHRoaXMudGwgPSB0bDtcbiAgICB0aGlzLnRyID0gdHI7XG4gICAgdGhpcy5ibCA9IGJsO1xuICAgIHRoaXMuYnIgPSBicjtcbiAgICB0aGlzLnRleCA9IHRleDtcbiAgICB0aGlzLmFuY2hvckFuZ2xlID0gYW5jaG9yQW5nbGU7XG4gICAgdGhpcy5nbHlwaEFuZ2xlID0gZ2x5cGhBbmdsZTtcbiAgICB0aGlzLm1pblNjYWxlID0gbWluU2NhbGU7XG4gICAgdGhpcy5tYXhTY2FsZSA9IG1heFNjYWxlO1xufVxuXG4vKipcbiAqIENyZWF0ZSB0aGUgcXVhZHMgdXNlZCBmb3IgcmVuZGVyaW5nIGFuIGljb24uXG4gKlxuICogQHBhcmFtIHtBbmNob3J9IGFuY2hvclxuICogQHBhcmFtIHtQb3NpdGlvbmVkSWNvbn0gc2hhcGVkSWNvblxuICogQHBhcmFtIHtudW1iZXJ9IGJveFNjYWxlIEEgbWFnaWMgbnVtYmVyIGZvciBjb252ZXJ0aW5nIGdseXBoIG1ldHJpYyB1bml0cyB0byBnZW9tZXRyeSB1bml0cy5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8UG9pbnQ+Pn0gbGluZVxuICogQHBhcmFtIHtTdHlsZUxheWVyfSBsYXllclxuICogQHBhcmFtIHtib29sZWFufSBhbG9uZ0xpbmUgV2hldGhlciB0aGUgaWNvbiBzaG91bGQgYmUgcGxhY2VkIGFsb25nIHRoZSBsaW5lLlxuICogQHBhcmFtIHtTaGFwaW5nfSBzaGFwZWRUZXh0IFNoYXBpbmcgZm9yIGNvcnJlc3BvbmRpbmcgdGV4dFxuICogQHJldHVybnMge0FycmF5PFN5bWJvbFF1YWQ+fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0SWNvblF1YWRzKGFuY2hvciwgc2hhcGVkSWNvbiwgYm94U2NhbGUsIGxpbmUsIGxheWVyLCBhbG9uZ0xpbmUsIHNoYXBlZFRleHQsIGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmVQcm9wZXJ0aWVzKSB7XG4gICAgdmFyIHJlY3QgPSBzaGFwZWRJY29uLmltYWdlLnJlY3Q7XG4gICAgdmFyIGxheW91dCA9IGxheWVyLmxheW91dDtcblxuICAgIHZhciBib3JkZXIgPSAxO1xuICAgIHZhciBsZWZ0ID0gc2hhcGVkSWNvbi5sZWZ0IC0gYm9yZGVyO1xuICAgIHZhciByaWdodCA9IGxlZnQgKyByZWN0LncgLyBzaGFwZWRJY29uLmltYWdlLnBpeGVsUmF0aW87XG4gICAgdmFyIHRvcCA9IHNoYXBlZEljb24udG9wIC0gYm9yZGVyO1xuICAgIHZhciBib3R0b20gPSB0b3AgKyByZWN0LmggLyBzaGFwZWRJY29uLmltYWdlLnBpeGVsUmF0aW87XG4gICAgdmFyIHRsLCB0ciwgYnIsIGJsO1xuXG4gICAgLy8gdGV4dC1maXQgbW9kZVxuICAgIGlmIChsYXlvdXRbJ2ljb24tdGV4dC1maXQnXSAhPT0gJ25vbmUnICYmIHNoYXBlZFRleHQpIHtcbiAgICAgICAgdmFyIGljb25XaWR0aCA9IChyaWdodCAtIGxlZnQpLFxuICAgICAgICAgICAgaWNvbkhlaWdodCA9IChib3R0b20gLSB0b3ApLFxuICAgICAgICAgICAgc2l6ZSA9IGxheW91dFsndGV4dC1zaXplJ10gLyAyNCxcbiAgICAgICAgICAgIHRleHRMZWZ0ID0gc2hhcGVkVGV4dC5sZWZ0ICogc2l6ZSxcbiAgICAgICAgICAgIHRleHRSaWdodCA9IHNoYXBlZFRleHQucmlnaHQgKiBzaXplLFxuICAgICAgICAgICAgdGV4dFRvcCA9IHNoYXBlZFRleHQudG9wICogc2l6ZSxcbiAgICAgICAgICAgIHRleHRCb3R0b20gPSBzaGFwZWRUZXh0LmJvdHRvbSAqIHNpemUsXG4gICAgICAgICAgICB0ZXh0V2lkdGggPSB0ZXh0UmlnaHQgLSB0ZXh0TGVmdCxcbiAgICAgICAgICAgIHRleHRIZWlnaHQgPSB0ZXh0Qm90dG9tIC0gdGV4dFRvcCxcbiAgICAgICAgICAgIHBhZFQgPSBsYXlvdXRbJ2ljb24tdGV4dC1maXQtcGFkZGluZyddWzBdLFxuICAgICAgICAgICAgcGFkUiA9IGxheW91dFsnaWNvbi10ZXh0LWZpdC1wYWRkaW5nJ11bMV0sXG4gICAgICAgICAgICBwYWRCID0gbGF5b3V0WydpY29uLXRleHQtZml0LXBhZGRpbmcnXVsyXSxcbiAgICAgICAgICAgIHBhZEwgPSBsYXlvdXRbJ2ljb24tdGV4dC1maXQtcGFkZGluZyddWzNdLFxuICAgICAgICAgICAgb2Zmc2V0WSA9IGxheW91dFsnaWNvbi10ZXh0LWZpdCddID09PSAnd2lkdGgnID8gKHRleHRIZWlnaHQgLSBpY29uSGVpZ2h0KSAqIDAuNSA6IDAsXG4gICAgICAgICAgICBvZmZzZXRYID0gbGF5b3V0WydpY29uLXRleHQtZml0J10gPT09ICdoZWlnaHQnID8gKHRleHRXaWR0aCAtIGljb25XaWR0aCkgKiAwLjUgOiAwLFxuICAgICAgICAgICAgd2lkdGggPSBsYXlvdXRbJ2ljb24tdGV4dC1maXQnXSA9PT0gJ3dpZHRoJyB8fCBsYXlvdXRbJ2ljb24tdGV4dC1maXQnXSA9PT0gJ2JvdGgnID8gdGV4dFdpZHRoIDogaWNvbldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gbGF5b3V0WydpY29uLXRleHQtZml0J10gPT09ICdoZWlnaHQnIHx8IGxheW91dFsnaWNvbi10ZXh0LWZpdCddID09PSAnYm90aCcgPyB0ZXh0SGVpZ2h0IDogaWNvbkhlaWdodDtcbiAgICAgICAgdGwgPSBuZXcgUG9pbnQodGV4dExlZnQgKyBvZmZzZXRYIC0gcGFkTCwgICAgICAgICB0ZXh0VG9wICsgb2Zmc2V0WSAtIHBhZFQpO1xuICAgICAgICB0ciA9IG5ldyBQb2ludCh0ZXh0TGVmdCArIG9mZnNldFggKyBwYWRSICsgd2lkdGgsIHRleHRUb3AgKyBvZmZzZXRZIC0gcGFkVCk7XG4gICAgICAgIGJyID0gbmV3IFBvaW50KHRleHRMZWZ0ICsgb2Zmc2V0WCArIHBhZFIgKyB3aWR0aCwgdGV4dFRvcCArIG9mZnNldFkgKyBwYWRCICsgaGVpZ2h0KTtcbiAgICAgICAgYmwgPSBuZXcgUG9pbnQodGV4dExlZnQgKyBvZmZzZXRYIC0gcGFkTCwgICAgICAgICB0ZXh0VG9wICsgb2Zmc2V0WSArIHBhZEIgKyBoZWlnaHQpO1xuICAgIC8vIE5vcm1hbCBpY29uIHNpemUgbW9kZVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRsID0gbmV3IFBvaW50KGxlZnQsIHRvcCk7XG4gICAgICAgIHRyID0gbmV3IFBvaW50KHJpZ2h0LCB0b3ApO1xuICAgICAgICBiciA9IG5ldyBQb2ludChyaWdodCwgYm90dG9tKTtcbiAgICAgICAgYmwgPSBuZXcgUG9pbnQobGVmdCwgYm90dG9tKTtcbiAgICB9XG5cbiAgICB2YXIgYW5nbGUgPSBsYXllci5nZXRMYXlvdXRWYWx1ZSgnaWNvbi1yb3RhdGUnLCBnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlUHJvcGVydGllcykgKiBNYXRoLlBJIC8gMTgwO1xuICAgIGlmIChhbG9uZ0xpbmUpIHtcbiAgICAgICAgdmFyIHByZXYgPSBsaW5lW2FuY2hvci5zZWdtZW50XTtcbiAgICAgICAgaWYgKGFuY2hvci55ID09PSBwcmV2LnkgJiYgYW5jaG9yLnggPT09IHByZXYueCAmJiBhbmNob3Iuc2VnbWVudCArIDEgPCBsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBsaW5lW2FuY2hvci5zZWdtZW50ICsgMV07XG4gICAgICAgICAgICBhbmdsZSArPSBNYXRoLmF0YW4yKGFuY2hvci55IC0gbmV4dC55LCBhbmNob3IueCAtIG5leHQueCkgKyBNYXRoLlBJO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5nbGUgKz0gTWF0aC5hdGFuMihhbmNob3IueSAtIHByZXYueSwgYW5jaG9yLnggLSBwcmV2LngpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICBtYXRyaXggPSBbY29zLCAtc2luLCBzaW4sIGNvc107XG5cbiAgICAgICAgdGwgPSB0bC5tYXRNdWx0KG1hdHJpeCk7XG4gICAgICAgIHRyID0gdHIubWF0TXVsdChtYXRyaXgpO1xuICAgICAgICBibCA9IGJsLm1hdE11bHQobWF0cml4KTtcbiAgICAgICAgYnIgPSBici5tYXRNdWx0KG1hdHJpeCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtuZXcgU3ltYm9sUXVhZChuZXcgUG9pbnQoYW5jaG9yLngsIGFuY2hvci55KSwgdGwsIHRyLCBibCwgYnIsIHNoYXBlZEljb24uaW1hZ2UucmVjdCwgMCwgMCwgbWluU2NhbGUsIEluZmluaXR5KV07XG59XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBxdWFkcyB1c2VkIGZvciByZW5kZXJpbmcgYSB0ZXh0IGxhYmVsLlxuICpcbiAqIEBwYXJhbSB7QW5jaG9yfSBhbmNob3JcbiAqIEBwYXJhbSB7U2hhcGluZ30gc2hhcGluZ1xuICogQHBhcmFtIHtudW1iZXJ9IGJveFNjYWxlIEEgbWFnaWMgbnVtYmVyIGZvciBjb252ZXJ0aW5nIGZyb20gZ2x5cGggbWV0cmljIHVuaXRzIHRvIGdlb21ldHJ5IHVuaXRzLlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxQb2ludD4+fSBsaW5lXG4gKiBAcGFyYW0ge1N0eWxlTGF5ZXJ9IGxheWVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFsb25nTGluZSBXaGV0aGVyIHRoZSBsYWJlbCBzaG91bGQgYmUgcGxhY2VkIGFsb25nIHRoZSBsaW5lLlxuICogQHJldHVybnMge0FycmF5PFN5bWJvbFF1YWQ+fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0R2x5cGhRdWFkcyhhbmNob3IsIHNoYXBpbmcsIGJveFNjYWxlLCBsaW5lLCBsYXllciwgYWxvbmdMaW5lKSB7XG5cbiAgICB2YXIgdGV4dFJvdGF0ZSA9IGxheWVyLmxheW91dFsndGV4dC1yb3RhdGUnXSAqIE1hdGguUEkgLyAxODA7XG4gICAgdmFyIGtlZXBVcHJpZ2h0ID0gbGF5ZXIubGF5b3V0Wyd0ZXh0LWtlZXAtdXByaWdodCddO1xuXG4gICAgdmFyIHBvc2l0aW9uZWRHbHlwaHMgPSBzaGFwaW5nLnBvc2l0aW9uZWRHbHlwaHM7XG4gICAgdmFyIHF1YWRzID0gW107XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHBvc2l0aW9uZWRHbHlwaHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uZWRHbHlwaCA9IHBvc2l0aW9uZWRHbHlwaHNba107XG4gICAgICAgIHZhciBnbHlwaCA9IHBvc2l0aW9uZWRHbHlwaC5nbHlwaDtcbiAgICAgICAgdmFyIHJlY3QgPSBnbHlwaC5yZWN0O1xuXG4gICAgICAgIGlmICghcmVjdCkgY29udGludWU7XG5cbiAgICAgICAgdmFyIGNlbnRlclggPSAocG9zaXRpb25lZEdseXBoLnggKyBnbHlwaC5hZHZhbmNlIC8gMikgKiBib3hTY2FsZTtcblxuICAgICAgICB2YXIgZ2x5cGhJbnN0YW5jZXM7XG4gICAgICAgIHZhciBsYWJlbE1pblNjYWxlID0gbWluU2NhbGU7XG4gICAgICAgIGlmIChhbG9uZ0xpbmUpIHtcbiAgICAgICAgICAgIGdseXBoSW5zdGFuY2VzID0gW107XG4gICAgICAgICAgICBsYWJlbE1pblNjYWxlID0gZ2V0U2VnbWVudEdseXBocyhnbHlwaEluc3RhbmNlcywgYW5jaG9yLCBjZW50ZXJYLCBsaW5lLCBhbmNob3Iuc2VnbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoa2VlcFVwcmlnaHQpIHtcbiAgICAgICAgICAgICAgICBsYWJlbE1pblNjYWxlID0gTWF0aC5taW4obGFiZWxNaW5TY2FsZSwgZ2V0U2VnbWVudEdseXBocyhnbHlwaEluc3RhbmNlcywgYW5jaG9yLCBjZW50ZXJYLCBsaW5lLCBhbmNob3Iuc2VnbWVudCwgZmFsc2UpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2x5cGhJbnN0YW5jZXMgPSBbe1xuICAgICAgICAgICAgICAgIGFuY2hvclBvaW50OiBuZXcgUG9pbnQoYW5jaG9yLngsIGFuY2hvci55KSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgYW5nbGU6IDAsXG4gICAgICAgICAgICAgICAgbWF4U2NhbGU6IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIG1pblNjYWxlOiBtaW5TY2FsZVxuICAgICAgICAgICAgfV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeDEgPSBwb3NpdGlvbmVkR2x5cGgueCArIGdseXBoLmxlZnQsXG4gICAgICAgICAgICB5MSA9IHBvc2l0aW9uZWRHbHlwaC55IC0gZ2x5cGgudG9wLFxuICAgICAgICAgICAgeDIgPSB4MSArIHJlY3QudyxcbiAgICAgICAgICAgIHkyID0geTEgKyByZWN0LmgsXG5cbiAgICAgICAgICAgIG90bCA9IG5ldyBQb2ludCh4MSwgeTEpLFxuICAgICAgICAgICAgb3RyID0gbmV3IFBvaW50KHgyLCB5MSksXG4gICAgICAgICAgICBvYmwgPSBuZXcgUG9pbnQoeDEsIHkyKSxcbiAgICAgICAgICAgIG9iciA9IG5ldyBQb2ludCh4MiwgeTIpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZ2x5cGhJbnN0YW5jZXNbaV0sXG4gICAgICAgICAgICAgICAgdGwgPSBvdGwsXG4gICAgICAgICAgICAgICAgdHIgPSBvdHIsXG4gICAgICAgICAgICAgICAgYmwgPSBvYmwsXG4gICAgICAgICAgICAgICAgYnIgPSBvYnI7XG5cbiAgICAgICAgICAgIGlmICh0ZXh0Um90YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKHRleHRSb3RhdGUpLFxuICAgICAgICAgICAgICAgICAgICBjb3MgPSBNYXRoLmNvcyh0ZXh0Um90YXRlKSxcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4ID0gW2NvcywgLXNpbiwgc2luLCBjb3NdO1xuXG4gICAgICAgICAgICAgICAgdGwgPSB0bC5tYXRNdWx0KG1hdHJpeCk7XG4gICAgICAgICAgICAgICAgdHIgPSB0ci5tYXRNdWx0KG1hdHJpeCk7XG4gICAgICAgICAgICAgICAgYmwgPSBibC5tYXRNdWx0KG1hdHJpeCk7XG4gICAgICAgICAgICAgICAgYnIgPSBici5tYXRNdWx0KG1hdHJpeCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgbGFiZWwgZnJvbSBleHRlbmRpbmcgcGFzdCB0aGUgZW5kIG9mIHRoZSBsaW5lXG4gICAgICAgICAgICB2YXIgZ2x5cGhNaW5TY2FsZSA9IE1hdGgubWF4KGluc3RhbmNlLm1pblNjYWxlLCBsYWJlbE1pblNjYWxlKTtcblxuICAgICAgICAgICAgdmFyIGFuY2hvckFuZ2xlID0gKGFuY2hvci5hbmdsZSArIGluc3RhbmNlLm9mZnNldCArIDIgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSk7XG4gICAgICAgICAgICB2YXIgZ2x5cGhBbmdsZSA9IChpbnN0YW5jZS5hbmdsZSArIGluc3RhbmNlLm9mZnNldCArIDIgKiBNYXRoLlBJKSAlICgyICogTWF0aC5QSSk7XG4gICAgICAgICAgICBxdWFkcy5wdXNoKG5ldyBTeW1ib2xRdWFkKGluc3RhbmNlLmFuY2hvclBvaW50LCB0bCwgdHIsIGJsLCBiciwgcmVjdCwgYW5jaG9yQW5nbGUsIGdseXBoQW5nbGUsIGdseXBoTWluU2NhbGUsIGluc3RhbmNlLm1heFNjYWxlKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcXVhZHM7XG59XG5cbi8qKlxuICogV2UgY2FuIG9ubHkgcmVuZGVyIGdseXBoIHF1YWRzIHRoYXQgc2xpZGUgYWxvbmcgYSBzdHJhaWdodCBsaW5lLiBUbyBkcmF3XG4gKiBjdXJ2ZWQgbGluZXMgd2UgbmVlZCBhbiBpbnN0YW5jZSBvZiBhIGdseXBoIGZvciBlYWNoIHNlZ21lbnQgaXQgYXBwZWFycyBvbi5cbiAqIFRoaXMgY3JlYXRlcyBhbGwgdGhlIGluc3RhbmNlcyBvZiBhIGdseXBoIHRoYXQgYXJlIG5lY2Vzc2FyeSB0byByZW5kZXIgYSBsYWJlbC5cbiAqXG4gKiBXZSBuZWVkIGFcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gZ2x5cGhJbnN0YW5jZXMgQW4gZW1wdHkgYXJyYXkgdGhhdCBnbHlwaEluc3RhbmNlcyBhcmUgYWRkZWQgdG8uXG4gKiBAcGFyYW0ge0FuY2hvcn0gYW5jaG9yXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBnbHlwaCdzIG9mZnNldCBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGxhYmVsLlxuICogQHBhcmFtIHtBcnJheTxQb2ludD59IGxpbmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50IFRoZSBpbmRleCBvZiB0aGUgc2VnbWVudCBvZiB0aGUgbGluZSBvbiB3aGljaCB0aGUgYW5jaG9yIGV4aXN0cy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yd2FyZCBJZiB0cnVlIGdldCB0aGUgZ2x5cGhzIHRoYXQgY29tZSBsYXRlciBvbiB0aGUgbGluZSwgb3RoZXJ3aXNlIGdldCB0aGUgZ2x5cGhzIHRoYXQgY29tZSBlYXJsaWVyLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheTxPYmplY3Q+fSBnbHlwaEluc3RhbmNlc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0U2VnbWVudEdseXBocyhnbHlwaHMsIGFuY2hvciwgb2Zmc2V0LCBsaW5lLCBzZWdtZW50LCBmb3J3YXJkKSB7XG4gICAgdmFyIHVwc2lkZURvd24gPSAhZm9yd2FyZDtcblxuICAgIGlmIChvZmZzZXQgPCAwKSBmb3J3YXJkID0gIWZvcndhcmQ7XG5cbiAgICBpZiAoZm9yd2FyZCkgc2VnbWVudCsrO1xuXG4gICAgdmFyIG5ld0FuY2hvclBvaW50ID0gbmV3IFBvaW50KGFuY2hvci54LCBhbmNob3IueSk7XG4gICAgdmFyIGVuZCA9IGxpbmVbc2VnbWVudF07XG4gICAgdmFyIHByZXZTY2FsZSA9IEluZmluaXR5O1xuXG4gICAgb2Zmc2V0ID0gTWF0aC5hYnMob2Zmc2V0KTtcblxuICAgIHZhciBwbGFjZW1lbnRTY2FsZSA9IG1pblNjYWxlO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gbmV3QW5jaG9yUG9pbnQuZGlzdChlbmQpO1xuICAgICAgICB2YXIgc2NhbGUgPSBvZmZzZXQgLyBkaXN0YW5jZTtcblxuICAgICAgICAvLyBHZXQgdGhlIGFuZ2xlIG9mIHRoZSBsaW5lIHNlZ21lbnRcbiAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihlbmQueSAtIG5ld0FuY2hvclBvaW50LnksIGVuZC54IC0gbmV3QW5jaG9yUG9pbnQueCk7XG4gICAgICAgIGlmICghZm9yd2FyZCkgYW5nbGUgKz0gTWF0aC5QSTtcblxuICAgICAgICBnbHlwaHMucHVzaCh7XG4gICAgICAgICAgICBhbmNob3JQb2ludDogbmV3QW5jaG9yUG9pbnQsXG4gICAgICAgICAgICBvZmZzZXQ6IHVwc2lkZURvd24gPyBNYXRoLlBJIDogMCxcbiAgICAgICAgICAgIG1pblNjYWxlOiBzY2FsZSxcbiAgICAgICAgICAgIG1heFNjYWxlOiBwcmV2U2NhbGUsXG4gICAgICAgICAgICBhbmdsZTogKGFuZ2xlICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2NhbGUgPD0gcGxhY2VtZW50U2NhbGUpIGJyZWFrO1xuXG4gICAgICAgIG5ld0FuY2hvclBvaW50ID0gZW5kO1xuXG4gICAgICAgIC8vIHNraXAgZHVwbGljYXRlIG5vZGVzXG4gICAgICAgIHdoaWxlIChuZXdBbmNob3JQb2ludC5lcXVhbHMoZW5kKSkge1xuICAgICAgICAgICAgc2VnbWVudCArPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgICAgICAgICAgZW5kID0gbGluZVtzZWdtZW50XTtcbiAgICAgICAgICAgIGlmICghZW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVuaXQgPSBlbmQuc3ViKG5ld0FuY2hvclBvaW50KS5fdW5pdCgpO1xuICAgICAgICBuZXdBbmNob3JQb2ludCA9IG5ld0FuY2hvclBvaW50LnN1Yih1bml0Ll9tdWx0KGRpc3RhbmNlKSk7XG5cbiAgICAgICAgcHJldlNjYWxlID0gc2NhbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBsYWNlbWVudFNjYWxlO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVzb2x2ZVRva2VucyA9IHJlcXVpcmUoJy4uL3V0aWwvdG9rZW4nKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlVGV4dDtcblxuLyoqXG4gKiBGb3IgYW4gYXJyYXkgb2YgZmVhdHVyZXMgZGV0ZXJtaW5lIHdoYXQgZ2x5cGhzIG5lZWQgdG8gYmUgbG9hZGVkXG4gKiBhbmQgYXBwbHkgYW55IHRleHQgcHJlcHJvY2Vzc2luZy4gVGhlIHJlbWFpbmluZyB1c2VycyBvZiB0ZXh0IHNob3VsZFxuICogdXNlIHRoZSBgdGV4dEZlYXR1cmVzYCBrZXkgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiBhY2Nlc3NpbmdcbiAqIGZlYXR1cmUgdGV4dCBkaXJlY3RseS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVUZXh0KGZlYXR1cmVzLCBsYXlvdXRQcm9wZXJ0aWVzLCBjb2RlcG9pbnRzKSB7XG4gICAgdmFyIHRleHRGZWF0dXJlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGZsID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgZmw7IGkrKykge1xuICAgICAgICB2YXIgdGV4dCA9IHJlc29sdmVUb2tlbnMoZmVhdHVyZXNbaV0ucHJvcGVydGllcywgbGF5b3V0UHJvcGVydGllc1sndGV4dC1maWVsZCddKTtcbiAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgICB0ZXh0RmVhdHVyZXNbaV0gPSBudWxsO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IHRleHQudG9TdHJpbmcoKTtcblxuICAgICAgICB2YXIgdHJhbnNmb3JtID0gbGF5b3V0UHJvcGVydGllc1sndGV4dC10cmFuc2Zvcm0nXTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSA9PT0gJ3VwcGVyY2FzZScpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnRvTG9jYWxlVXBwZXJDYXNlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtID09PSAnbG93ZXJjYXNlJykge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29kZXBvaW50c1t0ZXh0LmNoYXJDb2RlQXQoaildID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYWNrIGluZGV4ZXMgb2YgZmVhdHVyZXMgd2l0aCB0ZXh0LlxuICAgICAgICB0ZXh0RmVhdHVyZXNbaV0gPSB0ZXh0O1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0RmVhdHVyZXM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHNoYXBlVGV4dDogc2hhcGVUZXh0LFxuICAgIHNoYXBlSWNvbjogc2hhcGVJY29uXG59O1xuXG5cbi8vIFRoZSBwb3NpdGlvbiBvZiBhIGdseXBoIHJlbGF0aXZlIHRvIHRoZSB0ZXh0J3MgYW5jaG9yIHBvaW50LlxuZnVuY3Rpb24gUG9zaXRpb25lZEdseXBoKGNvZGVQb2ludCwgeCwgeSwgZ2x5cGgpIHtcbiAgICB0aGlzLmNvZGVQb2ludCA9IGNvZGVQb2ludDtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy5nbHlwaCA9IGdseXBoO1xufVxuXG4vLyBBIGNvbGxlY3Rpb24gb2YgcG9zaXRpb25lZCBnbHlwaHMgYW5kIHNvbWUgbWV0YWRhdGFcbmZ1bmN0aW9uIFNoYXBpbmcocG9zaXRpb25lZEdseXBocywgdGV4dCwgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0KSB7XG4gICAgdGhpcy5wb3NpdGlvbmVkR2x5cGhzID0gcG9zaXRpb25lZEdseXBocztcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMudG9wID0gdG9wO1xuICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xufVxuXG5mdW5jdGlvbiBzaGFwZVRleHQodGV4dCwgZ2x5cGhzLCBtYXhXaWR0aCwgbGluZUhlaWdodCwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBqdXN0aWZ5LCBzcGFjaW5nLCB0cmFuc2xhdGUpIHtcblxuICAgIHZhciBwb3NpdGlvbmVkR2x5cGhzID0gW107XG4gICAgdmFyIHNoYXBpbmcgPSBuZXcgU2hhcGluZyhwb3NpdGlvbmVkR2x5cGhzLCB0ZXh0LCB0cmFuc2xhdGVbMV0sIHRyYW5zbGF0ZVsxXSwgdHJhbnNsYXRlWzBdLCB0cmFuc2xhdGVbMF0pO1xuXG4gICAgLy8gdGhlIHkgb2Zmc2V0ICpzaG91bGQqIGJlIHBhcnQgb2YgdGhlIGZvbnQgbWV0YWRhdGFcbiAgICB2YXIgeU9mZnNldCA9IC0xNztcblxuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeSA9IHlPZmZzZXQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGVQb2ludCA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2NvZGVQb2ludF07XG5cbiAgICAgICAgaWYgKCFnbHlwaCkgY29udGludWU7XG5cbiAgICAgICAgcG9zaXRpb25lZEdseXBocy5wdXNoKG5ldyBQb3NpdGlvbmVkR2x5cGgoY29kZVBvaW50LCB4LCB5LCBnbHlwaCkpO1xuICAgICAgICB4ICs9IGdseXBoLmFkdmFuY2UgKyBzcGFjaW5nO1xuICAgIH1cblxuICAgIGlmICghcG9zaXRpb25lZEdseXBocy5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGxpbmV3cmFwKHNoYXBpbmcsIGdseXBocywgbGluZUhlaWdodCwgbWF4V2lkdGgsIGhvcml6b250YWxBbGlnbiwgdmVydGljYWxBbGlnbiwganVzdGlmeSwgdHJhbnNsYXRlKTtcblxuICAgIHJldHVybiBzaGFwaW5nO1xufVxuXG52YXIgaW52aXNpYmxlID0ge1xuICAgIDB4MjA6ICAgdHJ1ZSwgLy8gc3BhY2VcbiAgICAweDIwMGI6IHRydWUgIC8vIHplcm8td2lkdGggc3BhY2Vcbn07XG5cbnZhciBicmVha2FibGUgPSB7XG4gICAgMHgyMDogICB0cnVlLCAvLyBzcGFjZVxuICAgIDB4MjY6ICAgdHJ1ZSwgLy8gYW1wZXJzYW5kXG4gICAgMHgyYjogICB0cnVlLCAvLyBwbHVzIHNpZ25cbiAgICAweDJkOiAgIHRydWUsIC8vIGh5cGhlbi1taW51c1xuICAgIDB4MmY6ICAgdHJ1ZSwgLy8gc29saWR1c1xuICAgIDB4YWQ6ICAgdHJ1ZSwgLy8gc29mdCBoeXBoZW5cbiAgICAweGI3OiAgIHRydWUsIC8vIG1pZGRsZSBkb3RcbiAgICAweDIwMGI6IHRydWUsIC8vIHplcm8td2lkdGggc3BhY2VcbiAgICAweDIwMTA6IHRydWUsIC8vIGh5cGhlblxuICAgIDB4MjAxMzogdHJ1ZSAgLy8gZW4gZGFzaFxufTtcblxuZnVuY3Rpb24gbGluZXdyYXAoc2hhcGluZywgZ2x5cGhzLCBsaW5lSGVpZ2h0LCBtYXhXaWR0aCwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBqdXN0aWZ5LCB0cmFuc2xhdGUpIHtcbiAgICB2YXIgbGFzdFNhZmVCcmVhayA9IG51bGw7XG5cbiAgICB2YXIgbGVuZ3RoQmVmb3JlQ3VycmVudExpbmUgPSAwO1xuICAgIHZhciBsaW5lU3RhcnRJbmRleCA9IDA7XG4gICAgdmFyIGxpbmUgPSAwO1xuXG4gICAgdmFyIG1heExpbmVMZW5ndGggPSAwO1xuXG4gICAgdmFyIHBvc2l0aW9uZWRHbHlwaHMgPSBzaGFwaW5nLnBvc2l0aW9uZWRHbHlwaHM7XG5cbiAgICBpZiAobWF4V2lkdGgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3NpdGlvbmVkR2x5cGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25lZEdseXBoID0gcG9zaXRpb25lZEdseXBoc1tpXTtcblxuICAgICAgICAgICAgcG9zaXRpb25lZEdseXBoLnggLT0gbGVuZ3RoQmVmb3JlQ3VycmVudExpbmU7XG4gICAgICAgICAgICBwb3NpdGlvbmVkR2x5cGgueSArPSBsaW5lSGVpZ2h0ICogbGluZTtcblxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uZWRHbHlwaC54ID4gbWF4V2lkdGggJiYgbGFzdFNhZmVCcmVhayAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBwb3NpdGlvbmVkR2x5cGhzW2xhc3RTYWZlQnJlYWsgKyAxXS54O1xuICAgICAgICAgICAgICAgIG1heExpbmVMZW5ndGggPSBNYXRoLm1heChsaW5lTGVuZ3RoLCBtYXhMaW5lTGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSBsYXN0U2FmZUJyZWFrICsgMTsgayA8PSBpOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25lZEdseXBoc1trXS55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uZWRHbHlwaHNba10ueCAtPSBsaW5lTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChqdXN0aWZ5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbGxhcHNlIGludmlzaWJsZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZUVuZCA9IGxhc3RTYWZlQnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnZpc2libGVbcG9zaXRpb25lZEdseXBoc1tsYXN0U2FmZUJyZWFrXS5jb2RlUG9pbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lRW5kLS07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5TGluZShwb3NpdGlvbmVkR2x5cGhzLCBnbHlwaHMsIGxpbmVTdGFydEluZGV4LCBsaW5lRW5kLCBqdXN0aWZ5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsaW5lU3RhcnRJbmRleCA9IGxhc3RTYWZlQnJlYWsgKyAxO1xuICAgICAgICAgICAgICAgIGxhc3RTYWZlQnJlYWsgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxlbmd0aEJlZm9yZUN1cnJlbnRMaW5lICs9IGxpbmVMZW5ndGg7XG4gICAgICAgICAgICAgICAgbGluZSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYnJlYWthYmxlW3Bvc2l0aW9uZWRHbHlwaC5jb2RlUG9pbnRdKSB7XG4gICAgICAgICAgICAgICAgbGFzdFNhZmVCcmVhayA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFzdFBvc2l0aW9uZWRHbHlwaCA9IHBvc2l0aW9uZWRHbHlwaHNbcG9zaXRpb25lZEdseXBocy5sZW5ndGggLSAxXTtcbiAgICB2YXIgbGFzdExpbmVMZW5ndGggPSBsYXN0UG9zaXRpb25lZEdseXBoLnggKyBnbHlwaHNbbGFzdFBvc2l0aW9uZWRHbHlwaC5jb2RlUG9pbnRdLmFkdmFuY2U7XG4gICAgbWF4TGluZUxlbmd0aCA9IE1hdGgubWF4KG1heExpbmVMZW5ndGgsIGxhc3RMaW5lTGVuZ3RoKTtcblxuICAgIHZhciBoZWlnaHQgPSAobGluZSArIDEpICogbGluZUhlaWdodDtcblxuICAgIGp1c3RpZnlMaW5lKHBvc2l0aW9uZWRHbHlwaHMsIGdseXBocywgbGluZVN0YXJ0SW5kZXgsIHBvc2l0aW9uZWRHbHlwaHMubGVuZ3RoIC0gMSwganVzdGlmeSk7XG4gICAgYWxpZ24ocG9zaXRpb25lZEdseXBocywganVzdGlmeSwgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduLCBtYXhMaW5lTGVuZ3RoLCBsaW5lSGVpZ2h0LCBsaW5lLCB0cmFuc2xhdGUpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBib3VuZGluZyBib3hcbiAgICBzaGFwaW5nLnRvcCArPSAtdmVydGljYWxBbGlnbiAqIGhlaWdodDtcbiAgICBzaGFwaW5nLmJvdHRvbSA9IHNoYXBpbmcudG9wICsgaGVpZ2h0O1xuICAgIHNoYXBpbmcubGVmdCArPSAtaG9yaXpvbnRhbEFsaWduICogbWF4TGluZUxlbmd0aDtcbiAgICBzaGFwaW5nLnJpZ2h0ID0gc2hhcGluZy5sZWZ0ICsgbWF4TGluZUxlbmd0aDtcbn1cblxuZnVuY3Rpb24ganVzdGlmeUxpbmUocG9zaXRpb25lZEdseXBocywgZ2x5cGhzLCBzdGFydCwgZW5kLCBqdXN0aWZ5KSB7XG4gICAgdmFyIGxhc3RBZHZhbmNlID0gZ2x5cGhzW3Bvc2l0aW9uZWRHbHlwaHNbZW5kXS5jb2RlUG9pbnRdLmFkdmFuY2U7XG4gICAgdmFyIGxpbmVJbmRlbnQgPSAocG9zaXRpb25lZEdseXBoc1tlbmRdLnggKyBsYXN0QWR2YW5jZSkgKiBqdXN0aWZ5O1xuXG4gICAgZm9yICh2YXIgaiA9IHN0YXJ0OyBqIDw9IGVuZDsgaisrKSB7XG4gICAgICAgIHBvc2l0aW9uZWRHbHlwaHNbal0ueCAtPSBsaW5lSW5kZW50O1xuICAgIH1cblxufVxuXG5mdW5jdGlvbiBhbGlnbihwb3NpdGlvbmVkR2x5cGhzLCBqdXN0aWZ5LCBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ24sIG1heExpbmVMZW5ndGgsIGxpbmVIZWlnaHQsIGxpbmUsIHRyYW5zbGF0ZSkge1xuICAgIHZhciBzaGlmdFggPSAoanVzdGlmeSAtIGhvcml6b250YWxBbGlnbikgKiBtYXhMaW5lTGVuZ3RoICsgdHJhbnNsYXRlWzBdO1xuICAgIHZhciBzaGlmdFkgPSAoLXZlcnRpY2FsQWxpZ24gKiAobGluZSArIDEpICsgMC41KSAqIGxpbmVIZWlnaHQgKyB0cmFuc2xhdGVbMV07XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvc2l0aW9uZWRHbHlwaHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcG9zaXRpb25lZEdseXBoc1tqXS54ICs9IHNoaWZ0WDtcbiAgICAgICAgcG9zaXRpb25lZEdseXBoc1tqXS55ICs9IHNoaWZ0WTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gc2hhcGVJY29uKGltYWdlLCBsYXlvdXQpIHtcbiAgICBpZiAoIWltYWdlIHx8ICFpbWFnZS5yZWN0KSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBkeCA9IGxheW91dFsnaWNvbi1vZmZzZXQnXVswXTtcbiAgICB2YXIgZHkgPSBsYXlvdXRbJ2ljb24tb2Zmc2V0J11bMV07XG4gICAgdmFyIHgxID0gZHggLSBpbWFnZS53aWR0aCAvIDI7XG4gICAgdmFyIHgyID0geDEgKyBpbWFnZS53aWR0aDtcbiAgICB2YXIgeTEgPSBkeSAtIGltYWdlLmhlaWdodCAvIDI7XG4gICAgdmFyIHkyID0geTEgKyBpbWFnZS5oZWlnaHQ7XG5cbiAgICByZXR1cm4gbmV3IFBvc2l0aW9uZWRJY29uKGltYWdlLCB5MSwgeTIsIHgxLCB4Mik7XG59XG5cbmZ1bmN0aW9uIFBvc2l0aW9uZWRJY29uKGltYWdlLCB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQpIHtcbiAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgdGhpcy50b3AgPSB0b3A7XG4gICAgdGhpcy5ib3R0b20gPSBib3R0b207XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBTaGVsZlBhY2sgPSByZXF1aXJlKCdzaGVsZi1wYWNrJyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcHJpdGVBdGxhcztcbmZ1bmN0aW9uIFNwcml0ZUF0bGFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICB0aGlzLmJpbiA9IG5ldyBTaGVsZlBhY2sod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5pbWFnZXMgPSB7fTtcbiAgICB0aGlzLmRhdGEgPSBmYWxzZTtcbiAgICB0aGlzLnRleHR1cmUgPSAwOyAvLyBXZWJHTCBJRFxuICAgIHRoaXMuZmlsdGVyID0gMDsgLy8gV2ViR0wgSURcbiAgICB0aGlzLnBpeGVsUmF0aW8gPSAxO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb3B5Qml0bWFwKHNyYywgc3JjU3RyaWRlLCBzcmNYLCBzcmNZLCBkc3QsIGRzdFN0cmlkZSwgZHN0WCwgZHN0WSwgd2lkdGgsIGhlaWdodCwgd3JhcCkge1xuICAgIHZhciBzcmNJID0gc3JjWSAqIHNyY1N0cmlkZSArIHNyY1g7XG4gICAgdmFyIGRzdEkgPSBkc3RZICogZHN0U3RyaWRlICsgZHN0WDtcbiAgICB2YXIgeCwgeTtcblxuICAgIGlmICh3cmFwKSB7XG4gICAgICAgIC8vIGFkZCAxIHBpeGVsIHdyYXBwZWQgcGFkZGluZyBvbiBlYWNoIHNpZGUgb2YgdGhlIGltYWdlXG4gICAgICAgIGRzdEkgLT0gZHN0U3RyaWRlO1xuICAgICAgICBmb3IgKHkgPSAtMTsgeSA8PSBoZWlnaHQ7IHkrKywgc3JjSSA9ICgoeSArIGhlaWdodCkgJSBoZWlnaHQgKyBzcmNZKSAqIHNyY1N0cmlkZSArIHNyY1gsIGRzdEkgKz0gZHN0U3RyaWRlKSB7XG4gICAgICAgICAgICBmb3IgKHggPSAtMTsgeCA8PSB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgZHN0W2RzdEkgKyB4XSA9IHNyY1tzcmNJICsgKCh4ICsgd2lkdGgpICUgd2lkdGgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh5ID0gMDsgeSA8IGhlaWdodDsgeSsrLCBzcmNJICs9IHNyY1N0cmlkZSwgZHN0SSArPSBkc3RTdHJpZGUpIHtcbiAgICAgICAgICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgZHN0W2RzdEkgKyB4XSA9IHNyY1tzcmNJICsgeF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cblNwcml0ZUF0bGFzLnByb3RvdHlwZS5hbGxvY2F0ZUltYWdlID0gZnVuY3Rpb24ocGl4ZWxXaWR0aCwgcGl4ZWxIZWlnaHQpIHtcblxuICAgIHBpeGVsV2lkdGggPSBwaXhlbFdpZHRoIC8gdGhpcy5waXhlbFJhdGlvO1xuICAgIHBpeGVsSGVpZ2h0ID0gcGl4ZWxIZWlnaHQgLyB0aGlzLnBpeGVsUmF0aW87XG5cbiAgICAvLyBJbmNyZWFzZSB0byBuZXh0IG51bWJlciBkaXZpc2libGUgYnkgNCwgYnV0IGF0IGxlYXN0IDEuXG4gICAgLy8gVGhpcyBpcyBzbyB3ZSBjYW4gc2NhbGUgZG93biB0aGUgdGV4dHVyZSBjb29yZGluYXRlcyBhbmQgcGFjayB0aGVtXG4gICAgLy8gaW50byAyIGJ5dGVzIHJhdGhlciB0aGFuIDQgYnl0ZXMuXG4gICAgLy8gUGFkIGljb25zIHRvIHByZXZlbnQgdGhlbSBmcm9tIHBvbGx1dGluZyBuZWlnaGJvdXJzIGR1cmluZyBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgIHZhciBwYWRkaW5nID0gMjtcbiAgICB2YXIgcGFja1dpZHRoID0gcGl4ZWxXaWR0aCArIHBhZGRpbmcgKyAoNCAtIChwaXhlbFdpZHRoICsgcGFkZGluZykgJSA0KTtcbiAgICB2YXIgcGFja0hlaWdodCA9IHBpeGVsSGVpZ2h0ICsgcGFkZGluZyArICg0IC0gKHBpeGVsSGVpZ2h0ICsgcGFkZGluZykgJSA0KTsvLyArIDQ7XG5cbiAgICB2YXIgcmVjdCA9IHRoaXMuYmluLnBhY2tPbmUocGFja1dpZHRoLCBwYWNrSGVpZ2h0KTtcbiAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgdXRpbC53YXJuT25jZSgnU3ByaXRlQXRsYXMgb3V0IG9mIHNwYWNlLicpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjdDtcbn07XG5cblNwcml0ZUF0bGFzLnByb3RvdHlwZS5nZXRJbWFnZSA9IGZ1bmN0aW9uKG5hbWUsIHdyYXApIHtcbiAgICBpZiAodGhpcy5pbWFnZXNbbmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VzW25hbWVdO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zcHJpdGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHBvcyA9IHRoaXMuc3ByaXRlLmdldFNwcml0ZVBvc2l0aW9uKG5hbWUpO1xuICAgIGlmICghcG9zLndpZHRoIHx8ICFwb3MuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciByZWN0ID0gdGhpcy5hbGxvY2F0ZUltYWdlKHBvcy53aWR0aCwgcG9zLmhlaWdodCk7XG4gICAgaWYgKCFyZWN0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBpbWFnZSA9IG5ldyBBdGxhc0ltYWdlKHJlY3QsIHBvcy53aWR0aCAvIHBvcy5waXhlbFJhdGlvLCBwb3MuaGVpZ2h0IC8gcG9zLnBpeGVsUmF0aW8sIHBvcy5zZGYsIHBvcy5waXhlbFJhdGlvIC8gdGhpcy5waXhlbFJhdGlvKTtcbiAgICB0aGlzLmltYWdlc1tuYW1lXSA9IGltYWdlO1xuXG4gICAgdGhpcy5jb3B5KHJlY3QsIHBvcywgd3JhcCk7XG5cbiAgICByZXR1cm4gaW1hZ2U7XG59O1xuXG5cbi8vIFJldHVybiBwb3NpdGlvbiBvZiBhIHJlcGVhdGluZyBmaWxsIHBhdHRlcm4uXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbihuYW1lLCByZXBlYXRpbmcpIHtcbiAgICB2YXIgaW1hZ2UgPSB0aGlzLmdldEltYWdlKG5hbWUsIHJlcGVhdGluZyk7XG4gICAgdmFyIHJlY3QgPSBpbWFnZSAmJiBpbWFnZS5yZWN0O1xuXG4gICAgaWYgKCFyZWN0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IGltYWdlLndpZHRoICogaW1hZ2UucGl4ZWxSYXRpbztcbiAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0ICogaW1hZ2UucGl4ZWxSYXRpbztcbiAgICB2YXIgcGFkZGluZyA9IDE7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzaXplOiBbaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodF0sXG4gICAgICAgIHRsOiBbKHJlY3QueCArIHBhZGRpbmcpICAgICAgICAgLyB0aGlzLndpZHRoLCAocmVjdC55ICsgcGFkZGluZykgICAgICAgICAgLyB0aGlzLmhlaWdodF0sXG4gICAgICAgIGJyOiBbKHJlY3QueCArIHBhZGRpbmcgKyB3aWR0aCkgLyB0aGlzLndpZHRoLCAocmVjdC55ICsgcGFkZGluZyArIGhlaWdodCkgLyB0aGlzLmhlaWdodF1cbiAgICB9O1xufTtcblxuXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUuYWxsb2NhdGUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YSkge1xuICAgICAgICB2YXIgdyA9IE1hdGguZmxvb3IodGhpcy53aWR0aCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIHZhciBoID0gTWF0aC5mbG9vcih0aGlzLmhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBVaW50MzJBcnJheSh3ICogaCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSAwO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGRzdCwgc3JjLCB3cmFwKSB7XG4gICAgaWYgKCF0aGlzLnNwcml0ZS5pbWcuZGF0YSkgcmV0dXJuO1xuICAgIHZhciBzcmNJbWcgPSBuZXcgVWludDMyQXJyYXkodGhpcy5zcHJpdGUuaW1nLmRhdGEuYnVmZmVyKTtcblxuICAgIHRoaXMuYWxsb2NhdGUoKTtcbiAgICB2YXIgZHN0SW1nID0gdGhpcy5kYXRhO1xuXG4gICAgdmFyIHBhZGRpbmcgPSAxO1xuXG4gICAgY29weUJpdG1hcChcbiAgICAgICAgLyogc291cmNlIGJ1ZmZlciAqLyAgc3JjSW1nLFxuICAgICAgICAvKiBzb3VyY2Ugc3RyaWRlICovICB0aGlzLnNwcml0ZS5pbWcud2lkdGgsXG4gICAgICAgIC8qIHNvdXJjZSB4ICovICAgICAgIHNyYy54LFxuICAgICAgICAvKiBzb3VyY2UgeSAqLyAgICAgICBzcmMueSxcbiAgICAgICAgLyogZGVzdCBidWZmZXIgKi8gICAgZHN0SW1nLFxuICAgICAgICAvKiBkZXN0IHN0cmlkZSAqLyAgICB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvLFxuICAgICAgICAvKiBkZXN0IHggKi8gICAgICAgICAoZHN0LnggKyBwYWRkaW5nKSAqIHRoaXMucGl4ZWxSYXRpbyxcbiAgICAgICAgLyogZGVzdCB5ICovICAgICAgICAgKGRzdC55ICsgcGFkZGluZykgKiB0aGlzLnBpeGVsUmF0aW8sXG4gICAgICAgIC8qIGljb24gZGltZW5zaW9uICovIHNyYy53aWR0aCxcbiAgICAgICAgLyogaWNvbiBkaW1lbnNpb24gKi8gc3JjLmhlaWdodCxcbiAgICAgICAgLyogd3JhcCAqLyB3cmFwXG4gICAgKTtcblxuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xufTtcblxuU3ByaXRlQXRsYXMucHJvdG90eXBlLnNldFNwcml0ZSA9IGZ1bmN0aW9uKHNwcml0ZSkge1xuICAgIGlmIChzcHJpdGUpIHtcbiAgICAgICAgdGhpcy5waXhlbFJhdGlvID0gYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvID4gMSA/IDIgOiAxO1xuXG4gICAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zcHJpdGUgPSBzcHJpdGU7XG59O1xuXG5TcHJpdGVBdGxhcy5wcm90b3R5cGUuYWRkSWNvbnMgPSBmdW5jdGlvbihpY29ucywgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGljb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZ2V0SW1hZ2UoaWNvbnNbaV0pO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIHRoaXMuaW1hZ2VzKTtcbn07XG5cblNwcml0ZUF0bGFzLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oZ2wsIGxpbmVhcikge1xuICAgIHZhciBmaXJzdCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBmaXJzdCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlKTtcbiAgICB9XG5cbiAgICB2YXIgZmlsdGVyVmFsID0gbGluZWFyID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVDtcbiAgICBpZiAoZmlsdGVyVmFsICE9PSB0aGlzLmZpbHRlcikge1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVyVmFsKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlclZhbCk7XG4gICAgICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyVmFsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgIHRoaXMuYWxsb2NhdGUoKTtcblxuICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoXG4gICAgICAgICAgICAgICAgZ2wuVEVYVFVSRV8yRCwgLy8gZW51bSB0YXJnZXRcbiAgICAgICAgICAgICAgICAwLCAvLyBpbmQgbGV2ZWxcbiAgICAgICAgICAgICAgICBnbC5SR0JBLCAvLyBpbmQgaW50ZXJuYWxmb3JtYXRcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvLCAvLyBHTHNpemVpIHdpZHRoXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8sIC8vIEdMc2l6ZWkgaGVpZ2h0XG4gICAgICAgICAgICAgICAgMCwgLy8gaW5kIGJvcmRlclxuICAgICAgICAgICAgICAgIGdsLlJHQkEsIC8vIGVudW0gZm9ybWF0XG4gICAgICAgICAgICAgICAgZ2wuVU5TSUdORURfQllURSwgLy8gZW51bSB0eXBlXG4gICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlcikgLy8gT2JqZWN0IGRhdGFcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKFxuICAgICAgICAgICAgICAgIGdsLlRFWFRVUkVfMkQsIC8vIGVudW0gdGFyZ2V0XG4gICAgICAgICAgICAgICAgMCwgLy8gaW50IGxldmVsXG4gICAgICAgICAgICAgICAgMCwgLy8gaW50IHhvZmZzZXRcbiAgICAgICAgICAgICAgICAwLCAvLyBpbnQgeW9mZnNldFxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggKiB0aGlzLnBpeGVsUmF0aW8sIC8vIGxvbmcgd2lkdGhcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbywgLy8gbG9uZyBoZWlnaHRcbiAgICAgICAgICAgICAgICBnbC5SR0JBLCAvLyBlbnVtIGZvcm1hdFxuICAgICAgICAgICAgICAgIGdsLlVOU0lHTkVEX0JZVEUsIC8vIGVudW0gdHlwZVxuICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIpIC8vIE9iamVjdCBwaXhlbHNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gQXRsYXNJbWFnZShyZWN0LCB3aWR0aCwgaGVpZ2h0LCBzZGYsIHBpeGVsUmF0aW8pIHtcbiAgICB0aGlzLnJlY3QgPSByZWN0O1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnNkZiA9IHNkZjtcbiAgICB0aGlzLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3RydWN0QXJyYXlUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9zdHJ1Y3RfYXJyYXknKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG4vKlxuICpcbiAqIEEgU3RydWN0QXJyYXkgaW1wbGVtZW50YXRpb24gb2Ygc3ltYm9sSW5zdGFuY2VzIGZyb20gZGF0YS9idWNrZXQvc3ltYm9sX2J1Y2tldC5qc1xuICogdGhpcyB3aWxsIGFsbG93IHN5bWJvbEluc3RhbmNlcyB0byBiZSB0cmFuc2ZlcnJlZCBiZXR3ZWVuIHRoZSB3b3JrZXIgYW5kIG1haW4gdGhyZWFkc1xuICpcbiAqIEBjbGFzcyBTeW1ib2xJbnN0YW5jZUFycmF5XG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBTeW1ib2xJbnN0YW5jZXNBcnJheSA9IG1vZHVsZS5leHBvcnRzID0gbmV3IFN0cnVjdEFycmF5VHlwZSh7XG4gICAgbWVtYmVyczogW1xuXG4gICAgICAgIHsgdHlwZTogJ1VpbnQxNicsIG5hbWU6ICd0ZXh0Qm94U3RhcnRJbmRleCcgfSxcbiAgICAgICAgeyB0eXBlOiAnVWludDE2JywgbmFtZTogJ3RleHRCb3hFbmRJbmRleCcgfSxcbiAgICAgICAgeyB0eXBlOiAnVWludDE2JywgbmFtZTogJ2ljb25Cb3hTdGFydEluZGV4JyB9LFxuICAgICAgICB7IHR5cGU6ICdVaW50MTYnLCBuYW1lOiAnaWNvbkJveEVuZEluZGV4JyB9LFxuICAgICAgICB7IHR5cGU6ICdVaW50MTYnLCBuYW1lOiAnZ2x5cGhRdWFkU3RhcnRJbmRleCcgfSxcbiAgICAgICAgeyB0eXBlOiAnVWludDE2JywgbmFtZTogJ2dseXBoUXVhZEVuZEluZGV4JyB9LFxuICAgICAgICB7IHR5cGU6ICdVaW50MTYnLCBuYW1lOiAnaWNvblF1YWRTdGFydEluZGV4JyB9LFxuICAgICAgICB7IHR5cGU6ICdVaW50MTYnLCBuYW1lOiAnaWNvblF1YWRFbmRJbmRleCcgfSxcblxuICAgICAgICAvLyBlYWNoIHN5bWJvbEluc3RhbmNlIGlzIGNlbnRlcmVkIGFyb3VuZCB0aGUgYW5jaG9yIHBvaW50XG4gICAgICAgIHsgdHlwZTogJ0ludDE2JywgbmFtZTogJ2FuY2hvclBvaW50WCcgfSxcbiAgICAgICAgeyB0eXBlOiAnSW50MTYnLCBuYW1lOiAnYW5jaG9yUG9pbnRZJyB9LFxuXG4gICAgICAgIC8vIGluZGV4IC0tIG5vdCBzdXJlIGlmIHdlIG5lZWQgdGhpcyAtQG1vbGx5bWVycFxuICAgICAgICB7IHR5cGU6ICdJbnQ4JywgbmFtZTogJ2luZGV4JyB9XG4gICAgXVxufSk7XG5cbnV0aWwuZXh0ZW5kQWxsKFN5bWJvbEluc3RhbmNlc0FycmF5LnByb3RvdHlwZS5TdHJ1Y3RUeXBlLnByb3RvdHlwZSwge1xuICAgIGdldCBhbmNob3JQb2ludCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmFuY2hvclBvaW50WCwgdGhpcy5hbmNob3JQb2ludFkpO1xuICAgIH1cbn0pO1xuXG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFN0cnVjdEFycmF5VHlwZSA9IHJlcXVpcmUoJy4uL3V0aWwvc3RydWN0X2FycmF5Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbCcpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcbnZhciBTeW1ib2xRdWFkID0gcmVxdWlyZSgnLi9xdWFkcycpLlN5bWJvbFF1YWQ7XG5cbi8vIG5vdGVzIGZyb20gYW5zaXMgb24gc2xhY2s6XG4vLyBpdCB3b3VsZCBiZSBiZXN0IGlmIHRoZXkgYXJlIGFkZGVkIHRvIGEgYnVmZmVyIGluIGFkdmFuY2Ugc28gdGhhdCB0aGV5IGFyZSBvbmx5IGNyZWF0ZWQgb25jZS4gVGhlcmUgd291bGQgYmUgYSBzZXBhcmF0ZSBidWZmZXIgd2l0aCBhbGwgdGhlIGluZGl2aWR1YWwgY29sbGlzaW9uIGJveGVzIGFuZCB0aGVuIFN5bWJvbEluc3RhbmNlIHdvdWxkIHN0b3JlIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBpbmRleGVzIG9mIGEgZmVhdHVyZSdzIGNvbGxpc2lvbmJveGVzLiBDb2xsaXNpb25GZWF0dXJlIHdvdWxkbid0IHJlYWxseSBleGlzdCBhcyBhIHN0YW5kYWxvbmUgdGhpbmcsIGl0IHdvdWxkIGp1c3QgYmUgYSByYW5nZSBvZiBib3hlcyBpbiB0aGUgYmlnIGNvbGxpc2lvbiBib3ggYnVmZmVyXG5cbi8qXG4gKlxuICogQSBTdHJ1Y3RBcnJheSBpbXBsZW1lbnRhdGlvbiBvZiBnbHlwaFF1YWQgZnJvbSBzeW1ib2wvcXVhZHNcbiAqIHRoaXMgd2lsbCBhbGxvdyBnbHlwaCBxdWFkcyB0byBiZSB0cmFuc2ZlcnJlZCBiZXR3ZWVuIHRoZSB3b3JrZXIgYW5kIG1haW4gdGhyZWFkcyBhbG9uZyB3aXRoIHRoZSByZXN0IG9mXG4gKiB0aGUgc3ltYm9sSW5zdGFuY2VzXG4gKlxuICogQGNsYXNzIFN5bWJvbFF1YWRzQXJyYXlcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIFN5bWJvbFF1YWRzQXJyYXkgPSBtb2R1bGUuZXhwb3J0cyA9IG5ldyBTdHJ1Y3RBcnJheVR5cGUoe1xuICAgIG1lbWJlcnM6IFtcbiAgICAgICAgLy8gdGhlIHF1YWQgaXMgY2VudGVyZWQgYXJvdW5kIHRoZSBhbmNob3IgcG9pbnRcbiAgICAgICAgeyB0eXBlOiAnSW50MTYnLCBuYW1lOiAnYW5jaG9yUG9pbnRYJyB9LFxuICAgICAgICB7IHR5cGU6ICdJbnQxNicsIG5hbWU6ICdhbmNob3JQb2ludFknIH0sXG5cbiAgICAgICAgLy8gdGhlIG9mZnNldHMgb2YgdGhlIHRsICh0b3AtbGVmdCksIHRyLCBibCwgYnIgY29ybmVycyBmcm9tIHRoZSBhbmNob3IgcG9pbnRcbiAgICAgICAgLy8gZG8gdGhlc2UgbmVlZCB0byBiZSBmbG9hdHM/XG4gICAgICAgIHsgdHlwZTogJ0Zsb2F0MzInLCBuYW1lOiAndGxYJyB9LFxuICAgICAgICB7IHR5cGU6ICdGbG9hdDMyJywgbmFtZTogJ3RsWScgfSxcbiAgICAgICAgeyB0eXBlOiAnRmxvYXQzMicsIG5hbWU6ICd0clgnIH0sXG4gICAgICAgIHsgdHlwZTogJ0Zsb2F0MzInLCBuYW1lOiAndHJZJyB9LFxuICAgICAgICB7IHR5cGU6ICdGbG9hdDMyJywgbmFtZTogJ2JsWCcgfSxcbiAgICAgICAgeyB0eXBlOiAnRmxvYXQzMicsIG5hbWU6ICdibFknIH0sXG4gICAgICAgIHsgdHlwZTogJ0Zsb2F0MzInLCBuYW1lOiAnYnJYJyB9LFxuICAgICAgICB7IHR5cGU6ICdGbG9hdDMyJywgbmFtZTogJ2JyWScgfSxcblxuICAgICAgICAvLyB0ZXh0dXJlIGNvb3JkaW5hdGVzIChoZWlnaHQsIHdpZHRoLCB4LCBhbmQgeSlcbiAgICAgICAgeyB0eXBlOiAnSW50MTYnLCBuYW1lOiAndGV4SCcgfSxcbiAgICAgICAgeyB0eXBlOiAnSW50MTYnLCBuYW1lOiAndGV4VycgfSxcbiAgICAgICAgeyB0eXBlOiAnSW50MTYnLCBuYW1lOiAndGV4WCcgfSxcbiAgICAgICAgeyB0eXBlOiAnSW50MTYnLCBuYW1lOiAndGV4WScgfSxcblxuICAgICAgICAvLyB0aGUgYW5nbGUgb2YgdGhlIGxhYmVsIGF0IGl0J3MgY2VudGVyLCBub3QgdGhlIGFuZ2xlIG9mIHRoaXMgcXVhZC5cbiAgICAgICAgeyB0eXBlOiAnRmxvYXQzMicsIG5hbWU6ICdhbmNob3JBbmdsZScgfSxcbiAgICAgICAgLy8gdGhlIGFuZ2xlIG9mIHRoaXMgcXVhZC5cbiAgICAgICAgeyB0eXBlOiAnRmxvYXQzMicsIG5hbWU6ICdnbHlwaEFuZ2xlJyB9LFxuXG4gICAgICAgIC8vIHF1YWQgaXMgb25seSB2YWxpZCBmb3Igc2NhbGVzIDwgbWF4U2NhbGUgJiYgc2NhbGUgPiBtaW5TY2FsZS5cbiAgICAgICAgeyB0eXBlOiAnRmxvYXQzMicsIG5hbWU6ICdtYXhTY2FsZScgfSxcbiAgICAgICAgeyB0eXBlOiAnRmxvYXQzMicsIG5hbWU6ICdtaW5TY2FsZScgfVxuICAgIF1cbn0pO1xuXG51dGlsLmV4dGVuZEFsbChTeW1ib2xRdWFkc0FycmF5LnByb3RvdHlwZS5TdHJ1Y3RUeXBlLnByb3RvdHlwZSwge1xuICAgIGdldCBhbmNob3JQb2ludCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmFuY2hvclBvaW50WCwgdGhpcy5hbmNob3JQb2ludFkpO1xuICAgIH0sXG4gICAgZ2V0IFN5bWJvbFF1YWQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3ltYm9sUXVhZCh0aGlzLmFuY2hvclBvaW50LFxuICAgICAgICAgICAgbmV3IFBvaW50KHRoaXMudGxYLCB0aGlzLnRsWSksXG4gICAgICAgICAgICBuZXcgUG9pbnQodGhpcy50clgsIHRoaXMudHJZKSxcbiAgICAgICAgICAgIG5ldyBQb2ludCh0aGlzLmJsWCwgdGhpcy5ibFkpLFxuICAgICAgICAgICAgbmV3IFBvaW50KHRoaXMuYnJYLCB0aGlzLmJyWSksXG4gICAgICAgICAgICB7IHg6IHRoaXMudGV4WCwgeTogdGhpcy50ZXhZLCBoOiB0aGlzLnRleEgsIHc6IHRoaXMudGV4VywgaGVpZ2h0OiB0aGlzLnRleEgsIHdpZHRoOiB0aGlzLnRleFcgfSxcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yQW5nbGUsXG4gICAgICAgICAgICB0aGlzLmdseXBoQW5nbGUsXG4gICAgICAgICAgICB0aGlzLm1pblNjYWxlLFxuICAgICAgICAgICAgdGhpcy5tYXhTY2FsZSk7XG4gICAgfVxufSk7XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERPTSA9IHJlcXVpcmUoJy4uL3V0aWwvZG9tJyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG52YXIgaGFuZGxlcnMgPSB7XG4gICAgc2Nyb2xsWm9vbTogcmVxdWlyZSgnLi9oYW5kbGVyL3Njcm9sbF96b29tJyksXG4gICAgYm94Wm9vbTogcmVxdWlyZSgnLi9oYW5kbGVyL2JveF96b29tJyksXG4gICAgZHJhZ1JvdGF0ZTogcmVxdWlyZSgnLi9oYW5kbGVyL2RyYWdfcm90YXRlJyksXG4gICAgZHJhZ1BhbjogcmVxdWlyZSgnLi9oYW5kbGVyL2RyYWdfcGFuJyksXG4gICAga2V5Ym9hcmQ6IHJlcXVpcmUoJy4vaGFuZGxlci9rZXlib2FyZCcpLFxuICAgIGRvdWJsZUNsaWNrWm9vbTogcmVxdWlyZSgnLi9oYW5kbGVyL2RibGNsaWNrX3pvb20nKSxcbiAgICB0b3VjaFpvb21Sb3RhdGU6IHJlcXVpcmUoJy4vaGFuZGxlci90b3VjaF96b29tX3JvdGF0ZScpXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmRIYW5kbGVycyhtYXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZWwgPSBtYXAuZ2V0Q2FudmFzQ29udGFpbmVyKCk7XG4gICAgdmFyIGNvbnRleHRNZW51RXZlbnQgPSBudWxsO1xuICAgIHZhciBzdGFydFBvcyA9IG51bGw7XG4gICAgdmFyIHRhcHBlZCA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIGhhbmRsZXJzKSB7XG4gICAgICAgIG1hcFtuYW1lXSA9IG5ldyBoYW5kbGVyc1tuYW1lXShtYXAsIG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5pbnRlcmFjdGl2ZSAmJiBvcHRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICBtYXBbbmFtZV0uZW5hYmxlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIG9uTW91c2VPdXQsIGZhbHNlKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbk1vdXNlRG93biwgZmFsc2UpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXAsIGZhbHNlKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIGZhbHNlKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hFbmQsIGZhbHNlKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgZmFsc2UpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgb25Ub3VjaENhbmNlbCwgZmFsc2UpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGljaywgZmFsc2UpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgb25EYmxDbGljaywgZmFsc2UpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51Jywgb25Db250ZXh0TWVudSwgZmFsc2UpO1xuXG4gICAgZnVuY3Rpb24gb25Nb3VzZU91dChlKSB7XG4gICAgICAgIGZpcmVNb3VzZUV2ZW50KCdtb3VzZW91dCcsIGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICAgICAgbWFwLnN0b3AoKTtcbiAgICAgICAgc3RhcnRQb3MgPSBET00ubW91c2VQb3MoZWwsIGUpO1xuICAgICAgICBmaXJlTW91c2VFdmVudCgnbW91c2Vkb3duJywgZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZVVwKGUpIHtcbiAgICAgICAgdmFyIHJvdGF0aW5nID0gbWFwLmRyYWdSb3RhdGUgJiYgbWFwLmRyYWdSb3RhdGUuaXNBY3RpdmUoKTtcblxuICAgICAgICBpZiAoY29udGV4dE1lbnVFdmVudCAmJiAhcm90YXRpbmcpIHtcbiAgICAgICAgICAgIGZpcmVNb3VzZUV2ZW50KCdjb250ZXh0bWVudScsIGNvbnRleHRNZW51RXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dE1lbnVFdmVudCA9IG51bGw7XG4gICAgICAgIGZpcmVNb3VzZUV2ZW50KCdtb3VzZXVwJywgZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZU1vdmUoZSkge1xuICAgICAgICBpZiAobWFwLmRyYWdQYW4gJiYgbWFwLmRyYWdQYW4uaXNBY3RpdmUoKSkgcmV0dXJuO1xuICAgICAgICBpZiAobWFwLmRyYWdSb3RhdGUgJiYgbWFwLmRyYWdSb3RhdGUuaXNBY3RpdmUoKSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRvRWxlbWVudCB8fCBlLnRhcmdldDtcbiAgICAgICAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQgIT09IGVsKSB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gZWwpIHJldHVybjtcblxuICAgICAgICBmaXJlTW91c2VFdmVudCgnbW91c2Vtb3ZlJywgZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcbiAgICAgICAgbWFwLnN0b3AoKTtcbiAgICAgICAgZmlyZVRvdWNoRXZlbnQoJ3RvdWNoc3RhcnQnLCBlKTtcblxuICAgICAgICBpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoID4gMSkgcmV0dXJuO1xuXG4gICAgICAgIGlmICghdGFwcGVkKSB7XG4gICAgICAgICAgICB0YXBwZWQgPSBzZXRUaW1lb3V0KG9uVG91Y2hUaW1lb3V0LCAzMDApO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGFwcGVkKTtcbiAgICAgICAgICAgIHRhcHBlZCA9IG51bGw7XG4gICAgICAgICAgICBmaXJlTW91c2VFdmVudCgnZGJsY2xpY2snLCBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uVG91Y2hNb3ZlKGUpIHtcbiAgICAgICAgZmlyZVRvdWNoRXZlbnQoJ3RvdWNobW92ZScsIGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uVG91Y2hFbmQoZSkge1xuICAgICAgICBmaXJlVG91Y2hFdmVudCgndG91Y2hlbmQnLCBlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblRvdWNoQ2FuY2VsKGUpIHtcbiAgICAgICAgZmlyZVRvdWNoRXZlbnQoJ3RvdWNoY2FuY2VsJywgZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Ub3VjaFRpbWVvdXQoKSB7XG4gICAgICAgIHRhcHBlZCA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgIHZhciBwb3MgPSBET00ubW91c2VQb3MoZWwsIGUpO1xuXG4gICAgICAgIGlmIChwb3MuZXF1YWxzKHN0YXJ0UG9zKSkge1xuICAgICAgICAgICAgZmlyZU1vdXNlRXZlbnQoJ2NsaWNrJywgZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRibENsaWNrKGUpIHtcbiAgICAgICAgZmlyZU1vdXNlRXZlbnQoJ2RibGNsaWNrJywgZSk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkNvbnRleHRNZW51KGUpIHtcbiAgICAgICAgY29udGV4dE1lbnVFdmVudCA9IGU7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXJlTW91c2VFdmVudCh0eXBlLCBlKSB7XG4gICAgICAgIHZhciBwb3MgPSBET00ubW91c2VQb3MoZWwsIGUpO1xuXG4gICAgICAgIHJldHVybiBtYXAuZmlyZSh0eXBlLCB7XG4gICAgICAgICAgICBsbmdMYXQ6IG1hcC51bnByb2plY3QocG9zKSxcbiAgICAgICAgICAgIHBvaW50OiBwb3MsXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpcmVUb3VjaEV2ZW50KHR5cGUsIGUpIHtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBET00udG91Y2hQb3MoZWwsIGUpO1xuICAgICAgICB2YXIgc2luZ3VsYXIgPSB0b3VjaGVzLnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXJyLCBpLCBhcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2LmFkZChjdXJyLmRpdihhcnIubGVuZ3RoKSk7XG4gICAgICAgIH0sIG5ldyBQb2ludCgwLCAwKSk7XG5cbiAgICAgICAgcmV0dXJuIG1hcC5maXJlKHR5cGUsIHtcbiAgICAgICAgICAgIGxuZ0xhdDogbWFwLnVucHJvamVjdChzaW5ndWxhciksXG4gICAgICAgICAgICBwb2ludDogc2luZ3VsYXIsXG4gICAgICAgICAgICBsbmdMYXRzOiB0b3VjaGVzLm1hcChmdW5jdGlvbih0KSB7IHJldHVybiBtYXAudW5wcm9qZWN0KHQpOyB9LCB0aGlzKSxcbiAgICAgICAgICAgIHBvaW50czogdG91Y2hlcyxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGVcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNYXBNb3VzZUV2ZW50XG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAqIEBwcm9wZXJ0eSB7TWFwfSB0YXJnZXQgVGhlIGBNYXBgIG9iamVjdCB0aGF0IGZpcmVkIHRoZSBldmVudC5cbiAqIEBwcm9wZXJ0eSB7TW91c2VFdmVudH0gb3JpZ2luYWxFdmVudFxuICogQHByb3BlcnR5IHtQb2ludH0gcG9pbnQgVGhlIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZSBldmVudCB0YXJnZXQsIHJlbGF0aXZlIHRvIHRoZSBtYXBcbiAqICAgYW5kIG1lYXN1cmVkIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lci5cbiAqIEBwcm9wZXJ0eSB7TG5nTGF0fSBsbmdMYXQgVGhlIGdlb2dyYXBoaWMgbG9jYXRpb24gb24gdGhlIG1hcCBvZiB0aGUgbW91c2UgZXZlbnQgdGFyZ2V0LlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWFwVG91Y2hFdmVudFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gKiBAcHJvcGVydHkge01hcH0gdGFyZ2V0IFRoZSBgTWFwYCBvYmplY3QgdGhhdCBmaXJlZCB0aGUgZXZlbnQuXG4gKiBAcHJvcGVydHkge1RvdWNoRXZlbnR9IG9yaWdpbmFsRXZlbnRcbiAqIEBwcm9wZXJ0eSB7UG9pbnR9IHBvaW50IFRoZSBwaXhlbCBjb29yZGluYXRlcyBvZiB0aGUgY2VudGVyIG9mIHRoZSB0b3VjaCBldmVudCBwb2ludHMsIHJlbGF0aXZlIHRvIHRoZSBtYXBcbiAqICAgYW5kIG1lYXN1cmVkIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lci5cbiAqIEBwcm9wZXJ0eSB7TG5nTGF0fSBsbmdMYXQgVGhlIGdlb2dyYXBoaWMgbG9jYXRpb24gb24gdGhlIG1hcCBvZiB0aGUgY2VudGVyIG9mIHRoZSB0b3VjaCBldmVudCBwb2ludHMuXG4gKiBAcHJvcGVydHkge0FycmF5PFBvaW50Pn0gcG9pbnRzIFRoZSBhcnJheSBvZiBwaXhlbCBjb29yZGluYXRlcyBjb3JyZXNwb25kaW5nIHRvXG4gKiAgIGEgW3RvdWNoIGV2ZW50J3MgYHRvdWNoZXNgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVG91Y2hFdmVudC90b3VjaGVzKVxuICogICBwcm9wZXJ0eS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8TG5nTGF0Pn0gbG5nTGF0cyBUaGUgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9ucyBvbiB0aGUgbWFwIGNvcnJlc3BvbmRpbmcgdG9cbiAqICAgYSBbdG91Y2ggZXZlbnQncyBgdG91Y2hlc2BdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ub3VjaEV2ZW50L3RvdWNoZXMpXG4gKiAgIHByb3BlcnR5LlxuICovXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgaW50ZXJwb2xhdGUgPSByZXF1aXJlKCcuLi91dGlsL2ludGVycG9sYXRlJyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWwvYnJvd3NlcicpO1xudmFyIExuZ0xhdCA9IHJlcXVpcmUoJy4uL2dlby9sbmdfbGF0Jyk7XG52YXIgTG5nTGF0Qm91bmRzID0gcmVxdWlyZSgnLi4vZ2VvL2xuZ19sYXRfYm91bmRzJyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG4vKipcbiAqIE9wdGlvbnMgY29tbW9uIHRvIHtAbGluayBNYXAjanVtcFRvfSwge0BsaW5rIE1hcCNlYXNlVG99LCBhbmQge0BsaW5rIE1hcCNmbHlUb30sXG4gKiBjb250cm9sbGluZyB0aGUgZGVzdGluYXRpb24ncyBsb2NhdGlvbiwgem9vbSBsZXZlbCwgYmVhcmluZywgYW5kIHBpdGNoLlxuICogQWxsIHByb3BlcnRpZXMgYXJlIG9wdGlvbmFsLiBVbnNwZWNpZmllZFxuICogb3B0aW9ucyB3aWxsIGRlZmF1bHQgdG8gdGhlIG1hcCdzIGN1cnJlbnQgdmFsdWUgZm9yIHRoYXQgcHJvcGVydHkuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2FtZXJhT3B0aW9uc1xuICogQHByb3BlcnR5IHtMbmdMYXRMaWtlfSBjZW50ZXIgVGhlIGRlc3RpbmF0aW9uJ3MgY2VudGVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHpvb20gVGhlIGRlc3RpbmF0aW9uJ3Mgem9vbSBsZXZlbC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBiZWFyaW5nIFRoZSBkZXN0aW5hdGlvbidzIGJlYXJpbmcgKHJvdGF0aW9uKSwgbWVhc3VyZWQgaW4gZGVncmVlcyBjb3VudGVyLWNsb2Nrd2lzZSBmcm9tIG5vcnRoLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBpdGNoIFRoZSBkZXN0aW5hdGlvbidzIHBpdGNoICh0aWx0KSwgbWVhc3VyZWQgaW4gZGVncmVlcy5cbiAqIEBwcm9wZXJ0eSB7TG5nTGF0TGlrZX0gYXJvdW5kIElmIGEgYHpvb21gIGlzIHNwZWNpZmllZCwgYGFyb3VuZGAgZGV0ZXJtaW5lcyB0aGUgem9vbSBjZW50ZXIgKGRlZmF1bHRzIHRvIHRoZSBjZW50ZXIgb2YgdGhlIG1hcCkuXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIGNvbW1vbiB0byBtYXAgbW92ZW1lbnQgbWV0aG9kcyB0aGF0IGludm9sdmUgYW5pbWF0aW9uLCBzdWNoIGFzIHtAbGluayBNYXAjcGFuQnl9IGFuZFxuICoge0BsaW5rIE1hcCNlYXNlVG99LCBjb250cm9sbGluZyB0aGUgZHVyYXRpb24gYW5kIGVhc2luZyBmdW5jdGlvbiBvZiB0aGUgYW5pbWF0aW9uLiBBbGwgcHJvcGVydGllc1xuICogYXJlIG9wdGlvbmFsLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFuaW1hdGlvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkdXJhdGlvbiBUaGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIG1lYXN1cmVkIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVhc2luZyBUaGUgYW5pbWF0aW9uJ3MgZWFzaW5nIGZ1bmN0aW9uLlxuICogQHByb3BlcnR5IHtQb2ludExpa2V9IG9mZnNldCBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyByZXByZXNlbnRpbmcgdGhlIGFuaW1hdGlvbidzIG9yaWdpbiBvZiBtb3ZlbWVudCByZWxhdGl2ZSB0byB0aGUgbWFwJ3MgY2VudGVyLlxuICogQHByb3BlcnR5IHtib29sZWFufSBhbmltYXRlIElmIGBmYWxzZWAsIG5vIGFuaW1hdGlvbiB3aWxsIG9jY3VyLlxuICovXG5cbnZhciBDYW1lcmEgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge307XG5cbnV0aWwuZXh0ZW5kKENhbWVyYS5wcm90b3R5cGUsIC8qKiBAbGVuZHMgTWFwLnByb3RvdHlwZSAqL3tcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXAncyBnZW9ncmFwaGljYWwgY2VudGVycG9pbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TG5nTGF0fSBUaGUgbWFwJ3MgZ2VvZ3JhcGhpY2FsIGNlbnRlcnBvaW50LlxuICAgICAqL1xuICAgIGdldENlbnRlcjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybS5jZW50ZXI7IH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXAncyBnZW9ncmFwaGljYWwgY2VudGVycG9pbnQuIEVxdWl2YWxlbnQgdG8gYGp1bXBUbyh7Y2VudGVyOiBjZW50ZXJ9KWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xuZ0xhdExpa2V9IGNlbnRlciBUaGUgY2VudGVycG9pbnQgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnREYXRhXSBEYXRhIHRvIHByb3BhZ2F0ZSB0byBhbnkgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqIEBleGFtcGxlXG4gICAgICogbWFwLnNldENlbnRlcihbLTc0LCAzOF0pO1xuICAgICAqL1xuICAgIHNldENlbnRlcjogZnVuY3Rpb24oY2VudGVyLCBldmVudERhdGEpIHtcbiAgICAgICAgdGhpcy5qdW1wVG8oe2NlbnRlcjogY2VudGVyfSwgZXZlbnREYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhbnMgdGhlIG1hcCBieSB0aGUgc3BlY2lmaWVkIG9mZmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gb2Zmc2V0IGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIGJ5IHdoaWNoIHRvIHBhbiB0aGUgbWFwLlxuICAgICAqIEBwYXJhbSB7QW5pbWF0aW9uT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtldmVudERhdGFdIERhdGEgdG8gcHJvcGFnYXRlIHRvIGFueSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgcGFuQnk6IGZ1bmN0aW9uKG9mZnNldCwgb3B0aW9ucywgZXZlbnREYXRhKSB7XG4gICAgICAgIHRoaXMucGFuVG8odGhpcy50cmFuc2Zvcm0uY2VudGVyLFxuICAgICAgICAgICAgdXRpbC5leHRlbmQoe29mZnNldDogUG9pbnQuY29udmVydChvZmZzZXQpLm11bHQoLTEpfSwgb3B0aW9ucyksIGV2ZW50RGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYW5zIHRoZSBtYXAgdG8gdGhlIHNwZWNpZmllZCBsb2NhdGlvbiwgd2l0aCBhbiBhbmltYXRlZCB0cmFuc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMbmdMYXRMaWtlfSBsbmdsYXQgVGhlIGxvY2F0aW9uIHRvIHBhbiB0aGUgbWFwIHRvLlxuICAgICAqIEBwYXJhbSB7QW5pbWF0aW9uT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtldmVudERhdGFdIERhdGEgdG8gcHJvcGFnYXRlIHRvIGFueSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgcGFuVG86IGZ1bmN0aW9uKGxuZ2xhdCwgb3B0aW9ucywgZXZlbnREYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhc2VUbyh1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBjZW50ZXI6IGxuZ2xhdFxuICAgICAgICB9LCBvcHRpb25zKSwgZXZlbnREYXRhKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXAncyBjdXJyZW50IHpvb20gbGV2ZWwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbWFwJ3MgY3VycmVudCB6b29tIGxldmVsLlxuICAgICAqL1xuICAgIGdldFpvb206IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm0uem9vbTsgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1hcCdzIHpvb20gbGV2ZWwuIEVxdWl2YWxlbnQgdG8gYGp1bXBUbyh7em9vbTogem9vbX0pYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFRoZSB6b29tIGxldmVsIHRvIHNldCAoMC0yMCkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtldmVudERhdGFdIERhdGEgdG8gcHJvcGFnYXRlIHRvIGFueSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyB6b29tc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZVxuICAgICAqIEBmaXJlcyB6b29tXG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAZmlyZXMgem9vbWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gem9vbSB0aGUgbWFwIHRvIDVcbiAgICAgKiBtYXAuc2V0Wm9vbSg1KTtcbiAgICAgKi9cbiAgICBzZXRab29tOiBmdW5jdGlvbih6b29tLCBldmVudERhdGEpIHtcbiAgICAgICAgdGhpcy5qdW1wVG8oe3pvb206IHpvb219LCBldmVudERhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWm9vbXMgdGhlIG1hcCB0byB0aGUgc3BlY2lmaWVkIHpvb20gbGV2ZWwsIHdpdGggYW4gYW5pbWF0ZWQgdHJhbnNpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFRoZSB6b29tIGxldmVsIHRvIHRyYW5zaXRpb24gdG8uXG4gICAgICogQHBhcmFtIHtBbmltYXRpb25PcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2V2ZW50RGF0YV0gRGF0YSB0byBwcm9wYWdhdGUgdG8gYW55IGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIHpvb21zdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlXG4gICAgICogQGZpcmVzIHpvb21cbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEBmaXJlcyB6b29tZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgem9vbVRvOiBmdW5jdGlvbih6b29tLCBvcHRpb25zLCBldmVudERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFzZVRvKHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIHpvb206IHpvb21cbiAgICAgICAgfSwgb3B0aW9ucyksIGV2ZW50RGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluY3JlYXNlcyB0aGUgbWFwJ3Mgem9vbSBsZXZlbCBieSAxLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBbmltYXRpb25PcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2V2ZW50RGF0YV0gRGF0YSB0byBwcm9wYWdhdGUgdG8gYW55IGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIHpvb21zdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlXG4gICAgICogQGZpcmVzIHpvb21cbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEBmaXJlcyB6b29tZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgem9vbUluOiBmdW5jdGlvbihvcHRpb25zLCBldmVudERhdGEpIHtcbiAgICAgICAgdGhpcy56b29tVG8odGhpcy5nZXRab29tKCkgKyAxLCBvcHRpb25zLCBldmVudERhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjcmVhc2VzIHRoZSBtYXAncyB6b29tIGxldmVsIGJ5IDEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FuaW1hdGlvbk9wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnREYXRhXSBEYXRhIHRvIHByb3BhZ2F0ZSB0byBhbnkgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgem9vbXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVcbiAgICAgKiBAZmlyZXMgem9vbVxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQGZpcmVzIHpvb21lbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICB6b29tT3V0OiBmdW5jdGlvbihvcHRpb25zLCBldmVudERhdGEpIHtcbiAgICAgICAgdGhpcy56b29tVG8odGhpcy5nZXRab29tKCkgLSAxLCBvcHRpb25zLCBldmVudERhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXAncyBjdXJyZW50IGJlYXJpbmcgKHJvdGF0aW9uKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBtYXAncyBjdXJyZW50IGJlYXJpbmcsIG1lYXN1cmVkIGluIGRlZ3JlZXMgY291bnRlci1jbG9ja3dpc2UgZnJvbSBub3J0aC5cbiAgICAgKi9cbiAgICBnZXRCZWFyaW5nOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtLmJlYXJpbmc7IH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXBzJyBiZWFyaW5nIChyb3RhdGlvbikuIEVxdWl2YWxlbnQgdG8gYGp1bXBUbyh7YmVhcmluZzogYmVhcmluZ30pYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiZWFyaW5nIFRoZSBiZWFyaW5nIHRvIHNldCwgbWVhc3VyZWQgaW4gZGVncmVlcyBjb3VudGVyLWNsb2Nrd2lzZSBmcm9tIG5vcnRoLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnREYXRhXSBEYXRhIHRvIHByb3BhZ2F0ZSB0byBhbnkgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gcm90YXRlIHRoZSBtYXAgdG8gOTAgZGVncmVlc1xuICAgICAqIG1hcC5zZXRCZWFyaW5nKDkwKTtcbiAgICAgKi9cbiAgICBzZXRCZWFyaW5nOiBmdW5jdGlvbihiZWFyaW5nLCBldmVudERhdGEpIHtcbiAgICAgICAgdGhpcy5qdW1wVG8oe2JlYXJpbmc6IGJlYXJpbmd9LCBldmVudERhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyB0aGUgbWFwIHRvIHRoZSBzcGVjaWZpZWQgYmVhcmluZywgd2l0aCBhbiBhbmltYXRlZCB0cmFuc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJlYXJpbmcgVGhlIGJlYXJpbmcgdG8gcm90YXRlIHRoZSBtYXAgdG8sIG1lYXN1cmVkIGluIGRlZ3JlZXMgY291bnRlci1jbG9ja3dpc2UgZnJvbSBub3J0aC5cbiAgICAgKiBAcGFyYW0ge0FuaW1hdGlvbk9wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnREYXRhXSBEYXRhIHRvIHByb3BhZ2F0ZSB0byBhbnkgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHJvdGF0ZVRvOiBmdW5jdGlvbihiZWFyaW5nLCBvcHRpb25zLCBldmVudERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFzZVRvKHV0aWwuZXh0ZW5kKHtcbiAgICAgICAgICAgIGJlYXJpbmc6IGJlYXJpbmdcbiAgICAgICAgfSwgb3B0aW9ucyksIGV2ZW50RGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhlIG1hcCB0byBhIGJlYXJpbmcgb2YgMCAoZHVlIG5vcnRoKSwgd2l0aCBhbiBhbmltYXRlZCB0cmFuc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBbmltYXRpb25PcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2V2ZW50RGF0YV0gRGF0YSB0byBwcm9wYWdhdGUgdG8gYW55IGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZXNldE5vcnRoOiBmdW5jdGlvbihvcHRpb25zLCBldmVudERhdGEpIHtcbiAgICAgICAgdGhpcy5yb3RhdGVUbygwLCB1dGlsLmV4dGVuZCh7ZHVyYXRpb246IDEwMDB9LCBvcHRpb25zKSwgZXZlbnREYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNuYXBzIHRoZSBtYXAncyBiZWFyaW5nIHRvIDAgKGR1ZSBub3J0aCksIGlmIHRoZSBjdXJyZW50IGJlYXJpbmcgaXMgY2xvc2UgZW5vdWdoIHRvIGl0IChpLmUuIHdpdGhpbiB0aGUgYGJlYXJpbmdTbmFwYCB0aHJlc2hvbGQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBbmltYXRpb25PcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2V2ZW50RGF0YV0gRGF0YSB0byBwcm9wYWdhdGUgdG8gYW55IGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzbmFwVG9Ob3J0aDogZnVuY3Rpb24ob3B0aW9ucywgZXZlbnREYXRhKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyh0aGlzLmdldEJlYXJpbmcoKSkgPCB0aGlzLl9iZWFyaW5nU25hcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzZXROb3J0aChvcHRpb25zLCBldmVudERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXAncyBjdXJyZW50IHBpdGNoICh0aWx0KS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBtYXAncyBjdXJyZW50IHBpdGNoLCBtZWFzdXJlZCBpbiBkZWdyZWVzIGF3YXkgZnJvbSB0aGUgcGxhbmUgb2YgdGhlIHNjcmVlbi5cbiAgICAgKi9cbiAgICBnZXRQaXRjaDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybS5waXRjaDsgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1hcCdzIHBpdGNoICh0aWx0KS4gRXF1aXZhbGVudCB0byBganVtcFRvKHtwaXRjaDogcGl0Y2h9KWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGl0Y2ggVGhlIHBpdGNoIHRvIHNldCwgbWVhc3VyZWQgaW4gZGVncmVlcyBhd2F5IGZyb20gdGhlIHBsYW5lIG9mIHRoZSBzY3JlZW4gKDAtNjApLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnREYXRhXSBEYXRhIHRvIHByb3BhZ2F0ZSB0byBhbnkgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqIEBmaXJlcyBtb3Zlc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldFBpdGNoOiBmdW5jdGlvbihwaXRjaCwgZXZlbnREYXRhKSB7XG4gICAgICAgIHRoaXMuanVtcFRvKHtwaXRjaDogcGl0Y2h9LCBldmVudERhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBQYW5zIGFuZCB6b29tcyB0aGUgbWFwIHRvIGNvbnRhaW4gaXRzIHZpc2libGUgYXJlYSB3aXRoaW4gdGhlIHNwZWNpZmllZCBnZW9ncmFwaGljYWwgYm91bmRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMbmdMYXRCb3VuZHNMaWtlfSBib3VuZHMgVGhlIGJvdW5kcyB0byBmaXQgdGhlIHZpc2libGUgYXJlYSBpbnRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxpbmVhcj1mYWxzZV0gSWYgYHRydWVgLCB0aGUgbWFwIHRyYW5zaXRpb25zIHVzaW5nXG4gICAgICogICAgIHtAbGluayBNYXAjZWFzZVRvfS4gSWYgYGZhbHNlYCwgdGhlIG1hcCB0cmFuc2l0aW9ucyB1c2luZyB7QGxpbmsgTWFwI2ZseVRvfS4gU2VlXG4gICAgICogICAgIHtAbGluayBNYXAjZmx5VG99IGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3B0aW9ucyBzcGVjaWZpYyB0byB0aGF0IGFuaW1hdGVkIHRyYW5zaXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZWFzaW5nXSBBbiBlYXNpbmcgZnVuY3Rpb24gZm9yIHRoZSBhbmltYXRlZCB0cmFuc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5wYWRkaW5nPTBdIFRoZSBhbW91bnQgb2YgcGFkZGluZywgaW4gcGl4ZWxzLCB0byBhbGxvdyBhcm91bmQgdGhlIHNwZWNpZmllZCBib3VuZHMuXG4gICAgICogQHBhcmFtIHtQb2ludExpa2V9IFtvcHRpb25zLm9mZnNldD1bMCwgMF1dIFRoZSBjZW50ZXIgb2YgdGhlIGdpdmVuIGJvdW5kcyByZWxhdGl2ZSB0byB0aGUgbWFwJ3MgY2VudGVyLCBtZWFzdXJlZCBpbiBwaXhlbHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFpvb21dIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdG8gYWxsb3cgd2hlbiB0aGUgbWFwIHZpZXcgdHJhbnNpdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBib3VuZHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtldmVudERhdGFdIERhdGEgdG8gcHJvcGFnYXRlIHRvIGFueSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlZW5kXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgZml0Qm91bmRzOiBmdW5jdGlvbihib3VuZHMsIG9wdGlvbnMsIGV2ZW50RGF0YSkge1xuXG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgb2Zmc2V0OiBbMCwgMF0sXG4gICAgICAgICAgICBtYXhab29tOiBJbmZpbml0eVxuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICBib3VuZHMgPSBMbmdMYXRCb3VuZHMuY29udmVydChib3VuZHMpO1xuXG4gICAgICAgIHZhciBvZmZzZXQgPSBQb2ludC5jb252ZXJ0KG9wdGlvbnMub2Zmc2V0KSxcbiAgICAgICAgICAgIHRyID0gdGhpcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICBudyA9IHRyLnByb2plY3QoYm91bmRzLmdldE5vcnRoV2VzdCgpKSxcbiAgICAgICAgICAgIHNlID0gdHIucHJvamVjdChib3VuZHMuZ2V0U291dGhFYXN0KCkpLFxuICAgICAgICAgICAgc2l6ZSA9IHNlLnN1YihudyksXG4gICAgICAgICAgICBzY2FsZVggPSAodHIud2lkdGggLSBvcHRpb25zLnBhZGRpbmcgKiAyIC0gTWF0aC5hYnMob2Zmc2V0LngpICogMikgLyBzaXplLngsXG4gICAgICAgICAgICBzY2FsZVkgPSAodHIuaGVpZ2h0IC0gb3B0aW9ucy5wYWRkaW5nICogMiAtIE1hdGguYWJzKG9mZnNldC55KSAqIDIpIC8gc2l6ZS55O1xuXG4gICAgICAgIG9wdGlvbnMuY2VudGVyID0gdHIudW5wcm9qZWN0KG53LmFkZChzZSkuZGl2KDIpKTtcbiAgICAgICAgb3B0aW9ucy56b29tID0gTWF0aC5taW4odHIuc2NhbGVab29tKHRyLnNjYWxlICogTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpKSwgb3B0aW9ucy5tYXhab29tKTtcbiAgICAgICAgb3B0aW9ucy5iZWFyaW5nID0gMDtcblxuICAgICAgICByZXR1cm4gb3B0aW9ucy5saW5lYXIgP1xuICAgICAgICAgICAgdGhpcy5lYXNlVG8ob3B0aW9ucywgZXZlbnREYXRhKSA6XG4gICAgICAgICAgICB0aGlzLmZseVRvKG9wdGlvbnMsIGV2ZW50RGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgYW55IGNvbWJpbmF0aW9uIG9mIGNlbnRlciwgem9vbSwgYmVhcmluZywgYW5kIHBpdGNoLCB3aXRob3V0XG4gICAgICogYW4gYW5pbWF0ZWQgdHJhbnNpdGlvbi4gVGhlIG1hcCB3aWxsIHJldGFpbiBpdHMgY3VycmVudCB2YWx1ZXMgZm9yIGFueVxuICAgICAqIGRldGFpbHMgbm90IHNwZWNpZmllZCBpbiBgb3B0aW9uc2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbWVyYU9wdGlvbnN9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2V2ZW50RGF0YV0gRGF0YSB0byBwcm9wYWdhdGUgdG8gYW55IGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKiBAZmlyZXMgbW92ZXN0YXJ0XG4gICAgICogQGZpcmVzIHpvb21zdGFydFxuICAgICAqIEBmaXJlcyBtb3ZlXG4gICAgICogQGZpcmVzIHpvb21cbiAgICAgKiBAZmlyZXMgcm90YXRlXG4gICAgICogQGZpcmVzIHBpdGNoXG4gICAgICogQGZpcmVzIHpvb21lbmRcbiAgICAgKiBAZmlyZXMgbW92ZWVuZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIGp1bXBUbzogZnVuY3Rpb24ob3B0aW9ucywgZXZlbnREYXRhKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgIHZhciB0ciA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgem9vbUNoYW5nZWQgPSBmYWxzZSxcbiAgICAgICAgICAgIGJlYXJpbmdDaGFuZ2VkID0gZmFsc2UsXG4gICAgICAgICAgICBwaXRjaENoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoJ3pvb20nIGluIG9wdGlvbnMgJiYgdHIuem9vbSAhPT0gK29wdGlvbnMuem9vbSkge1xuICAgICAgICAgICAgem9vbUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdHIuem9vbSA9ICtvcHRpb25zLnpvb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ2NlbnRlcicgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdHIuY2VudGVyID0gTG5nTGF0LmNvbnZlcnQob3B0aW9ucy5jZW50ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdiZWFyaW5nJyBpbiBvcHRpb25zICYmIHRyLmJlYXJpbmcgIT09ICtvcHRpb25zLmJlYXJpbmcpIHtcbiAgICAgICAgICAgIGJlYXJpbmdDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyLmJlYXJpbmcgPSArb3B0aW9ucy5iZWFyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdwaXRjaCcgaW4gb3B0aW9ucyAmJiB0ci5waXRjaCAhPT0gK29wdGlvbnMucGl0Y2gpIHtcbiAgICAgICAgICAgIHBpdGNoQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB0ci5waXRjaCA9ICtvcHRpb25zLnBpdGNoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maXJlKCdtb3Zlc3RhcnQnLCBldmVudERhdGEpXG4gICAgICAgICAgICAuZmlyZSgnbW92ZScsIGV2ZW50RGF0YSk7XG5cbiAgICAgICAgaWYgKHpvb21DaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ3pvb21zdGFydCcsIGV2ZW50RGF0YSlcbiAgICAgICAgICAgICAgICAuZmlyZSgnem9vbScsIGV2ZW50RGF0YSlcbiAgICAgICAgICAgICAgICAuZmlyZSgnem9vbWVuZCcsIGV2ZW50RGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmVhcmluZ0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgncm90YXRlJywgZXZlbnREYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwaXRjaENoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgncGl0Y2gnLCBldmVudERhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmlyZSgnbW92ZWVuZCcsIGV2ZW50RGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgYW55IGNvbWJpbmF0aW9uIG9mIGNlbnRlciwgem9vbSwgYmVhcmluZywgYW5kIHBpdGNoLCB3aXRoIGFuIGFuaW1hdGVkIHRyYW5zaXRpb25cbiAgICAgKiBiZXR3ZWVuIG9sZCBhbmQgbmV3IHZhbHVlcy4gVGhlIG1hcCB3aWxsIHJldGFpbiBpdHMgY3VycmVudCB2YWx1ZXMgZm9yIGFueVxuICAgICAqIGRldGFpbHMgbm90IHNwZWNpZmllZCBpbiBgb3B0aW9uc2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbWVyYU9wdGlvbnN8QW5pbWF0aW9uT3B0aW9uc30gb3B0aW9ucyBPcHRpb25zIGRlc2NyaWJpbmcgdGhlIGRlc3RpbmF0aW9uIGFuZCBhbmltYXRpb24gb2YgdGhlIHRyYW5zaXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtldmVudERhdGFdIERhdGEgdG8gcHJvcGFnYXRlIHRvIGFueSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyB6b29tc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZVxuICAgICAqIEBmaXJlcyB6b29tXG4gICAgICogQGZpcmVzIHJvdGF0ZVxuICAgICAqIEBmaXJlcyBwaXRjaFxuICAgICAqIEBmaXJlcyB6b29tZW5kXG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBlYXNlVG86IGZ1bmN0aW9uKG9wdGlvbnMsIGV2ZW50RGF0YSkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcblxuICAgICAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgICAgICAgb2Zmc2V0OiBbMCwgMF0sXG4gICAgICAgICAgICBkdXJhdGlvbjogNTAwLFxuICAgICAgICAgICAgZWFzaW5nOiB1dGlsLmVhc2VcbiAgICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHRyID0gdGhpcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICBvZmZzZXQgPSBQb2ludC5jb252ZXJ0KG9wdGlvbnMub2Zmc2V0KSxcbiAgICAgICAgICAgIHN0YXJ0Wm9vbSA9IHRoaXMuZ2V0Wm9vbSgpLFxuICAgICAgICAgICAgc3RhcnRCZWFyaW5nID0gdGhpcy5nZXRCZWFyaW5nKCksXG4gICAgICAgICAgICBzdGFydFBpdGNoID0gdGhpcy5nZXRQaXRjaCgpLFxuXG4gICAgICAgICAgICB6b29tID0gJ3pvb20nIGluIG9wdGlvbnMgPyArb3B0aW9ucy56b29tIDogc3RhcnRab29tLFxuICAgICAgICAgICAgYmVhcmluZyA9ICdiZWFyaW5nJyBpbiBvcHRpb25zID8gdGhpcy5fbm9ybWFsaXplQmVhcmluZyhvcHRpb25zLmJlYXJpbmcsIHN0YXJ0QmVhcmluZykgOiBzdGFydEJlYXJpbmcsXG4gICAgICAgICAgICBwaXRjaCA9ICdwaXRjaCcgaW4gb3B0aW9ucyA/ICtvcHRpb25zLnBpdGNoIDogc3RhcnRQaXRjaCxcblxuICAgICAgICAgICAgdG9MbmdMYXQsXG4gICAgICAgICAgICB0b1BvaW50O1xuXG4gICAgICAgIGlmICgnY2VudGVyJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB0b0xuZ0xhdCA9IExuZ0xhdC5jb252ZXJ0KG9wdGlvbnMuY2VudGVyKTtcbiAgICAgICAgICAgIHRvUG9pbnQgPSB0ci5jZW50ZXJQb2ludC5hZGQob2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIGlmICgnYXJvdW5kJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB0b0xuZ0xhdCA9IExuZ0xhdC5jb252ZXJ0KG9wdGlvbnMuYXJvdW5kKTtcbiAgICAgICAgICAgIHRvUG9pbnQgPSB0ci5sb2NhdGlvblBvaW50KHRvTG5nTGF0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvUG9pbnQgPSB0ci5jZW50ZXJQb2ludC5hZGQob2Zmc2V0KTtcbiAgICAgICAgICAgIHRvTG5nTGF0ID0gdHIucG9pbnRMb2NhdGlvbih0b1BvaW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmcm9tUG9pbnQgPSB0ci5sb2NhdGlvblBvaW50KHRvTG5nTGF0KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSkgb3B0aW9ucy5kdXJhdGlvbiA9IDA7XG5cbiAgICAgICAgdGhpcy56b29taW5nID0gKHpvb20gIT09IHN0YXJ0Wm9vbSk7XG4gICAgICAgIHRoaXMucm90YXRpbmcgPSAoc3RhcnRCZWFyaW5nICE9PSBiZWFyaW5nKTtcbiAgICAgICAgdGhpcy5waXRjaGluZyA9IChwaXRjaCAhPT0gc3RhcnRQaXRjaCk7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLm5vTW92ZVN0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ21vdmVzdGFydCcsIGV2ZW50RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuem9vbWluZykge1xuICAgICAgICAgICAgdGhpcy5maXJlKCd6b29tc3RhcnQnLCBldmVudERhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX29uRWFzZUVuZCk7XG5cbiAgICAgICAgdGhpcy5fZWFzZShmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKHRoaXMuem9vbWluZykge1xuICAgICAgICAgICAgICAgIHRyLnpvb20gPSBpbnRlcnBvbGF0ZShzdGFydFpvb20sIHpvb20sIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5yb3RhdGluZykge1xuICAgICAgICAgICAgICAgIHRyLmJlYXJpbmcgPSBpbnRlcnBvbGF0ZShzdGFydEJlYXJpbmcsIGJlYXJpbmcsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5waXRjaGluZykge1xuICAgICAgICAgICAgICAgIHRyLnBpdGNoID0gaW50ZXJwb2xhdGUoc3RhcnRQaXRjaCwgcGl0Y2gsIGspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ci5zZXRMb2NhdGlvbkF0UG9pbnQodG9MbmdMYXQsIGZyb21Qb2ludC5hZGQodG9Qb2ludC5zdWIoZnJvbVBvaW50KS5fbXVsdChrKSkpO1xuXG4gICAgICAgICAgICB0aGlzLmZpcmUoJ21vdmUnLCBldmVudERhdGEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuem9vbWluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgnem9vbScsIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5yb3RhdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgncm90YXRlJywgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBpdGNoaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdwaXRjaCcsIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVsYXlFbmRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkVhc2VFbmQgPSBzZXRUaW1lb3V0KHRoaXMuX2Vhc2VUb0VuZC5iaW5kKHRoaXMsIGV2ZW50RGF0YSksIG9wdGlvbnMuZGVsYXlFbmRFdmVudHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lYXNlVG9FbmQoZXZlbnREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpLCBvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2Vhc2VUb0VuZDogZnVuY3Rpb24oZXZlbnREYXRhKSB7XG4gICAgICAgIHZhciB3YXNab29taW5nID0gdGhpcy56b29taW5nO1xuICAgICAgICB0aGlzLnpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yb3RhdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBpdGNoaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHdhc1pvb21pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnem9vbWVuZCcsIGV2ZW50RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maXJlKCdtb3ZlZW5kJywgZXZlbnREYXRhKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIGFueSBjb21iaW5hdGlvbiBvZiBjZW50ZXIsIHpvb20sIGJlYXJpbmcsIGFuZCBwaXRjaCwgYW5pbWF0aW5nIHRoZSB0cmFuc2l0aW9uIGFsb25nIGEgY3VydmUgdGhhdFxuICAgICAqIGV2b2tlcyBmbGlnaHQuIFRoZSBhbmltYXRpb24gc2VhbWxlc3NseSBpbmNvcnBvcmF0ZXMgem9vbWluZyBhbmQgcGFubmluZyB0byBoZWxwXG4gICAgICogdGhlIHVzZXIgbWFpbnRhaW4gaGVyIGJlYXJpbmdzIGV2ZW4gYWZ0ZXIgdHJhdmVyc2luZyBhIGdyZWF0IGRpc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBkZXNjcmliaW5nIHRoZSBkZXN0aW5hdGlvbiBhbmQgYW5pbWF0aW9uIG9mIHRoZSB0cmFuc2l0aW9uLlxuICAgICAqICAgICBBY2NlcHRzIFtDYW1lcmFPcHRpb25zXSgjQ2FtZXJhT3B0aW9ucyksIFtBbmltYXRpb25PcHRpb25zXSgjQW5pbWF0aW9uT3B0aW9ucyksXG4gICAgICogICAgIGFuZCB0aGUgZm9sbG93aW5nIGFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY3VydmU9MS40Ml0gVGhlIHpvb21pbmcgXCJjdXJ2ZVwiIHRoYXQgd2lsbCBvY2N1ciBhbG9uZyB0aGVcbiAgICAgKiAgICAgZmxpZ2h0IHBhdGguIEEgaGlnaCB2YWx1ZSBtYXhpbWl6ZXMgem9vbWluZyBmb3IgYW4gZXhhZ2dlcmF0ZWQgYW5pbWF0aW9uLCB3aGlsZSBhIGxvd1xuICAgICAqICAgICB2YWx1ZSBtaW5pbWl6ZXMgem9vbWluZyBmb3IgYW4gZWZmZWN0IGNsb3NlciB0byB7QGxpbmsgTWFwI2Vhc2VUb30uIDEuNDIgaXMgdGhlIGF2ZXJhZ2VcbiAgICAgKiAgICAgdmFsdWUgc2VsZWN0ZWQgYnkgcGFydGljaXBhbnRzIGluIHRoZSB1c2VyIHN0dWR5IGRpc2N1c3NlZCBpblxuICAgICAqICAgICBbdmFuIFdpamsgKDIwMDMpXShodHRwczovL3d3dy53aW4udHVlLm5sL352YW53aWprL3pvb21wYW4ucGRmKS4gQSB2YWx1ZSBvZlxuICAgICAqICAgICBgTWF0aC5wb3coNiwgMC4yNSlgIHdvdWxkIGJlIGVxdWl2YWxlbnQgdG8gdGhlIHJvb3QgbWVhbiBzcXVhcmVkIGF2ZXJhZ2UgdmVsb2NpdHkuIEFcbiAgICAgKiAgICAgdmFsdWUgb2YgMSB3b3VsZCBwcm9kdWNlIGEgY2lyY3VsYXIgbW90aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5taW5ab29tXSBUaGUgemVyby1iYXNlZCB6b29tIGxldmVsIGF0IHRoZSBwZWFrIG9mIHRoZSBmbGlnaHQgcGF0aC4gSWZcbiAgICAgKiAgICAgYG9wdGlvbnMuY3VydmVgIGlzIHNwZWNpZmllZCwgdGhpcyBvcHRpb24gaXMgaWdub3JlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3BlZWQ9MS4yXSBUaGUgYXZlcmFnZSBzcGVlZCBvZiB0aGUgYW5pbWF0aW9uIGRlZmluZWQgaW4gcmVsYXRpb24gdG9cbiAgICAgKiAgICAgYG9wdGlvbnMuY3VydmVgLiBBIHNwZWVkIG9mIDEuMiBtZWFucyB0aGF0IHRoZSBtYXAgYXBwZWFycyB0byBtb3ZlIGFsb25nIHRoZSBmbGlnaHQgcGF0aFxuICAgICAqICAgICBieSAxLjIgdGltZXMgYG9wdGlvbnMuY3VydmVgIHNjcmVlbmZ1bHMgZXZlcnkgc2Vjb25kLiBBIF9zY3JlZW5mdWxfIGlzIHRoZSBtYXAncyB2aXNpYmxlIHNwYW4uXG4gICAgICogICAgIEl0IGRvZXMgbm90IGNvcnJlc3BvbmQgdG8gYSBmaXhlZCBwaHlzaWNhbCBkaXN0YW5jZSwgYnV0IHZhcmllcyBieSB6b29tIGxldmVsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zY3JlZW5TcGVlZF0gVGhlIGF2ZXJhZ2Ugc3BlZWQgb2YgdGhlIGFuaW1hdGlvbiBtZWFzdXJlZCBpbiBzY3JlZW5mdWxzXG4gICAgICogICAgIHBlciBzZWNvbmQsIGFzc3VtaW5nIGEgbGluZWFyIHRpbWluZyBjdXJ2ZS4gSWYgYG9wdGlvbnMuc3BlZWRgIGlzIHNwZWNpZmllZCwgdGhpcyBvcHRpb24gaXMgaWdub3JlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5lYXNpbmddIEFuIGVhc2luZyBmdW5jdGlvbiBmb3IgdGhlIGFuaW1hdGVkIHRyYW5zaXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtldmVudERhdGFdIERhdGEgdG8gcHJvcGFnYXRlIHRvIGFueSBldmVudCBsaXN0ZW5lcnMuXG4gICAgICogQGZpcmVzIG1vdmVzdGFydFxuICAgICAqIEBmaXJlcyB6b29tc3RhcnRcbiAgICAgKiBAZmlyZXMgbW92ZVxuICAgICAqIEBmaXJlcyB6b29tXG4gICAgICogQGZpcmVzIHJvdGF0ZVxuICAgICAqIEBmaXJlcyBwaXRjaFxuICAgICAqIEBmaXJlcyB6b29tZW5kXG4gICAgICogQGZpcmVzIG1vdmVlbmRcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGZseSB3aXRoIGRlZmF1bHQgb3B0aW9ucyB0byBudWxsIGlzbGFuZFxuICAgICAqIG1hcC5mbHlUbyh7Y2VudGVyOiBbMCwgMF0sIHpvb206IDl9KTtcbiAgICAgKiAvLyB1c2luZyBmbHlUbyBvcHRpb25zXG4gICAgICogbWFwLmZseVRvKHtcbiAgICAgKiAgIGNlbnRlcjogWzAsIDBdLFxuICAgICAqICAgem9vbTogOSxcbiAgICAgKiAgIHNwZWVkOiAwLjIsXG4gICAgICogICBjdXJ2ZTogMSxcbiAgICAgKiAgIGVhc2luZzogZnVuY3Rpb24odCkge1xuICAgICAqICAgICByZXR1cm4gdDtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBmbHlUbzogZnVuY3Rpb24ob3B0aW9ucywgZXZlbnREYXRhKSB7XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgYW4g4oCcb3B0aW1hbCBwYXRo4oCdIGFuaW1hdGlvbiwgYXMgZGV0YWlsZWQgaW46XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFZhbiBXaWprLCBKYXJrZSBKLjsgTnVpaiwgV2ltIEEuIEEuIOKAnFNtb290aCBhbmQgZWZmaWNpZW50IHpvb21pbmcgYW5kIHBhbm5pbmcu4oCdIElORk9WSVNcbiAgICAgICAgLy8gICDigJkwMy4gcHAuIDE14oCTMjIuIDxodHRwczovL3d3dy53aW4udHVlLm5sL352YW53aWprL3pvb21wYW4ucGRmI3BhZ2U9NT4uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdoZXJlIGFwcGxpY2FibGUsIGxvY2FsIHZhcmlhYmxlIGRvY3VtZW50YXRpb24gYmVnaW5zIHdpdGggdGhlIGFzc29jaWF0ZWQgdmFyaWFibGUgb3JcbiAgICAgICAgLy8gZnVuY3Rpb24gaW4gdmFuIFdpamsgKDIwMDMpLlxuXG4gICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7XG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICAgICAgICAgIHNwZWVkOiAxLjIsXG4gICAgICAgICAgICBjdXJ2ZTogMS40MixcbiAgICAgICAgICAgIGVhc2luZzogdXRpbC5lYXNlXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciB0ciA9IHRoaXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgb2Zmc2V0ID0gUG9pbnQuY29udmVydChvcHRpb25zLm9mZnNldCksXG4gICAgICAgICAgICBzdGFydFpvb20gPSB0aGlzLmdldFpvb20oKSxcbiAgICAgICAgICAgIHN0YXJ0QmVhcmluZyA9IHRoaXMuZ2V0QmVhcmluZygpLFxuICAgICAgICAgICAgc3RhcnRQaXRjaCA9IHRoaXMuZ2V0UGl0Y2goKTtcblxuICAgICAgICB2YXIgY2VudGVyID0gJ2NlbnRlcicgaW4gb3B0aW9ucyA/IExuZ0xhdC5jb252ZXJ0KG9wdGlvbnMuY2VudGVyKSA6IHRoaXMuZ2V0Q2VudGVyKCk7XG4gICAgICAgIHZhciB6b29tID0gJ3pvb20nIGluIG9wdGlvbnMgPyAgK29wdGlvbnMuem9vbSA6IHN0YXJ0Wm9vbTtcbiAgICAgICAgdmFyIGJlYXJpbmcgPSAnYmVhcmluZycgaW4gb3B0aW9ucyA/IHRoaXMuX25vcm1hbGl6ZUJlYXJpbmcob3B0aW9ucy5iZWFyaW5nLCBzdGFydEJlYXJpbmcpIDogc3RhcnRCZWFyaW5nO1xuICAgICAgICB2YXIgcGl0Y2ggPSAncGl0Y2gnIGluIG9wdGlvbnMgPyArb3B0aW9ucy5waXRjaCA6IHN0YXJ0UGl0Y2g7XG5cbiAgICAgICAgLy8gSWYgYSBwYXRoIGNyb3NzaW5nIHRoZSBhbnRpbWVyaWRpYW4gd291bGQgYmUgc2hvcnRlciwgZXh0ZW5kIHRoZSBmaW5hbCBjb29yZGluYXRlIHNvIHRoYXRcbiAgICAgICAgLy8gaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHRoZSB0d28gZW5kcG9pbnRzIHdpbGwgY3Jvc3MgaXQuXG4gICAgICAgIGlmIChNYXRoLmFicyh0ci5jZW50ZXIubG5nKSArIE1hdGguYWJzKGNlbnRlci5sbmcpID4gMTgwKSB7XG4gICAgICAgICAgICBpZiAodHIuY2VudGVyLmxuZyA+IDAgJiYgY2VudGVyLmxuZyA8IDApIHtcbiAgICAgICAgICAgICAgICBjZW50ZXIubG5nICs9IDM2MDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHIuY2VudGVyLmxuZyA8IDAgJiYgY2VudGVyLmxuZyA+IDApIHtcbiAgICAgICAgICAgICAgICBjZW50ZXIubG5nIC09IDM2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzY2FsZSA9IHRyLnpvb21TY2FsZSh6b29tIC0gc3RhcnRab29tKSxcbiAgICAgICAgICAgIGZyb20gPSB0ci5wb2ludCxcbiAgICAgICAgICAgIHRvID0gJ2NlbnRlcicgaW4gb3B0aW9ucyA/IHRyLnByb2plY3QoY2VudGVyKS5zdWIob2Zmc2V0LmRpdihzY2FsZSkpIDogZnJvbTtcblxuICAgICAgICB2YXIgc3RhcnRXb3JsZFNpemUgPSB0ci53b3JsZFNpemUsXG4gICAgICAgICAgICByaG8gPSBvcHRpb25zLmN1cnZlLFxuXG4gICAgICAgICAgICAvLyB34oKAOiBJbml0aWFsIHZpc2libGUgc3BhbiwgbWVhc3VyZWQgaW4gcGl4ZWxzIGF0IHRoZSBpbml0aWFsIHNjYWxlLlxuICAgICAgICAgICAgdzAgPSBNYXRoLm1heCh0ci53aWR0aCwgdHIuaGVpZ2h0KSxcbiAgICAgICAgICAgIC8vIHfigoE6IEZpbmFsIHZpc2libGUgc3BhbiwgbWVhc3VyZWQgaW4gcGl4ZWxzIHdpdGggcmVzcGVjdCB0byB0aGUgaW5pdGlhbCBzY2FsZS5cbiAgICAgICAgICAgIHcxID0gdzAgLyBzY2FsZSxcbiAgICAgICAgICAgIC8vIExlbmd0aCBvZiB0aGUgZmxpZ2h0IHBhdGggYXMgcHJvamVjdGVkIG9udG8gdGhlIGdyb3VuZCBwbGFuZSwgbWVhc3VyZWQgaW4gcGl4ZWxzIGZyb21cbiAgICAgICAgICAgIC8vIHRoZSB3b3JsZCBpbWFnZSBvcmlnaW4gYXQgdGhlIGluaXRpYWwgc2NhbGUuXG4gICAgICAgICAgICB1MSA9IHRvLnN1Yihmcm9tKS5tYWcoKTtcblxuICAgICAgICBpZiAoJ21pblpvb20nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBtaW5ab29tID0gdXRpbC5jbGFtcChNYXRoLm1pbihvcHRpb25zLm1pblpvb20sIHN0YXJ0Wm9vbSwgem9vbSksIHRyLm1pblpvb20sIHRyLm1heFpvb20pO1xuICAgICAgICAgICAgLy8gdzxzdWI+bTwvc3ViPjogTWF4aW11bSB2aXNpYmxlIHNwYW4sIG1lYXN1cmVkIGluIHBpeGVscyB3aXRoIHJlc3BlY3QgdG8gdGhlIGluaXRpYWxcbiAgICAgICAgICAgIC8vIHNjYWxlLlxuICAgICAgICAgICAgdmFyIHdNYXggPSB3MCAvIHRyLnpvb21TY2FsZShtaW5ab29tIC0gc3RhcnRab29tKTtcbiAgICAgICAgICAgIHJobyA9IE1hdGguc3FydCh3TWF4IC8gdTEgKiAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIM+BwrJcbiAgICAgICAgdmFyIHJobzIgPSByaG8gKiByaG87XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHLhtaI6IFJldHVybnMgdGhlIHpvb20tb3V0IGZhY3RvciBhdCBvbmUgZW5kIG9mIHRoZSBhbmltYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpIDAgZm9yIHRoZSBhc2NlbnQgb3IgMSBmb3IgdGhlIGRlc2NlbnQuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiByKGkpIHtcbiAgICAgICAgICAgIHZhciBiID0gKHcxICogdzEgLSB3MCAqIHcwICsgKGkgPyAtMSA6IDEpICogcmhvMiAqIHJobzIgKiB1MSAqIHUxKSAvICgyICogKGkgPyB3MSA6IHcwKSAqIHJobzIgKiB1MSk7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5sb2coTWF0aC5zcXJ0KGIgKiBiICsgMSkgLSBiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHNpbmgobikgeyByZXR1cm4gKE1hdGguZXhwKG4pIC0gTWF0aC5leHAoLW4pKSAvIDI7IH1cbiAgICAgICAgZnVuY3Rpb24gY29zaChuKSB7IHJldHVybiAoTWF0aC5leHAobikgKyBNYXRoLmV4cCgtbikpIC8gMjsgfVxuICAgICAgICBmdW5jdGlvbiB0YW5oKG4pIHsgcmV0dXJuIHNpbmgobikgLyBjb3NoKG4pOyB9XG5cbiAgICAgICAgLy8gcuKCgDogWm9vbS1vdXQgZmFjdG9yIGR1cmluZyBhc2NlbnQuXG4gICAgICAgIHZhciByMCA9IHIoMCksXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHcocyk6IFJldHVybnMgdGhlIHZpc2libGUgc3BhbiBvbiB0aGUgZ3JvdW5kLCBtZWFzdXJlZCBpbiBwaXhlbHMgd2l0aCByZXNwZWN0IHRvIHRoZVxuICAgICAgICAgICAgICogaW5pdGlhbCBzY2FsZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBBc3N1bWVzIGFuIGFuZ3VsYXIgZmllbGQgb2YgdmlldyBvZiAyIGFyY3RhbiDCvSDiiYggNTPCsC5cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHcgPSBmdW5jdGlvbiAocykgeyByZXR1cm4gKGNvc2gocjApIC8gY29zaChyMCArIHJobyAqIHMpKTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogdShzKTogUmV0dXJucyB0aGUgZGlzdGFuY2UgYWxvbmcgdGhlIGZsaWdodCBwYXRoIGFzIHByb2plY3RlZCBvbnRvIHRoZSBncm91bmQgcGxhbmUsXG4gICAgICAgICAgICAgKiBtZWFzdXJlZCBpbiBwaXhlbHMgZnJvbSB0aGUgd29ybGQgaW1hZ2Ugb3JpZ2luIGF0IHRoZSBpbml0aWFsIHNjYWxlLlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdSA9IGZ1bmN0aW9uIChzKSB7IHJldHVybiB3MCAqICgoY29zaChyMCkgKiB0YW5oKHIwICsgcmhvICogcykgLSBzaW5oKHIwKSkgLyByaG8yKSAvIHUxOyB9LFxuICAgICAgICAgICAgLy8gUzogVG90YWwgbGVuZ3RoIG9mIHRoZSBmbGlnaHQgcGF0aCwgbWVhc3VyZWQgaW4gz4Etc2NyZWVuZnVscy5cbiAgICAgICAgICAgIFMgPSAocigxKSAtIHIwKSAvIHJobztcblxuICAgICAgICAvLyBXaGVuIHXigoAgPSB14oKBLCB0aGUgb3B0aW1hbCBwYXRoIGRvZXNu4oCZdCByZXF1aXJlIGJvdGggYXNjZW50IGFuZCBkZXNjZW50LlxuICAgICAgICBpZiAoTWF0aC5hYnModTEpIDwgMC4wMDAwMDEpIHtcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gYSBtb3JlIG9yIGxlc3MgaW5zdGFudGFuZW91cyB0cmFuc2l0aW9uIGlmIHRoZSBwYXRoIGlzIHRvbyBzaG9ydC5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh3MCAtIHcxKSA8IDAuMDAwMDAxKSByZXR1cm4gdGhpcy5lYXNlVG8ob3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHZhciBrID0gdzEgPCB3MCA/IC0xIDogMTtcbiAgICAgICAgICAgIFMgPSBNYXRoLmFicyhNYXRoLmxvZyh3MSAvIHcwKSkgLyByaG87XG5cbiAgICAgICAgICAgIHUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4gICAgICAgICAgICB3ID0gZnVuY3Rpb24ocykgeyByZXR1cm4gTWF0aC5leHAoayAqIHJobyAqIHMpOyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdkdXJhdGlvbicgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9ICtvcHRpb25zLmR1cmF0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIFYgPSAnc2NyZWVuU3BlZWQnIGluIG9wdGlvbnMgPyArb3B0aW9ucy5zY3JlZW5TcGVlZCAvIHJobyA6ICtvcHRpb25zLnNwZWVkO1xuICAgICAgICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9IDEwMDAgKiBTIC8gVjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuem9vbWluZyA9IHRydWU7XG4gICAgICAgIGlmIChzdGFydEJlYXJpbmcgIT09IGJlYXJpbmcpIHRoaXMucm90YXRpbmcgPSB0cnVlO1xuICAgICAgICBpZiAoc3RhcnRQaXRjaCAhPT0gcGl0Y2gpIHRoaXMucGl0Y2hpbmcgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuZmlyZSgnbW92ZXN0YXJ0JywgZXZlbnREYXRhKTtcbiAgICAgICAgdGhpcy5maXJlKCd6b29tc3RhcnQnLCBldmVudERhdGEpO1xuXG4gICAgICAgIHRoaXMuX2Vhc2UoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIC8vIHM6IFRoZSBkaXN0YW5jZSB0cmF2ZWxlZCBhbG9uZyB0aGUgZmxpZ2h0IHBhdGgsIG1lYXN1cmVkIGluIM+BLXNjcmVlbmZ1bHMuXG4gICAgICAgICAgICB2YXIgcyA9IGsgKiBTLFxuICAgICAgICAgICAgICAgIHVzID0gdShzKTtcblxuICAgICAgICAgICAgdHIuem9vbSA9IHN0YXJ0Wm9vbSArIHRyLnNjYWxlWm9vbSgxIC8gdyhzKSk7XG4gICAgICAgICAgICB0ci5jZW50ZXIgPSB0ci51bnByb2plY3QoZnJvbS5hZGQodG8uc3ViKGZyb20pLm11bHQodXMpKSwgc3RhcnRXb3JsZFNpemUpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5yb3RhdGluZykge1xuICAgICAgICAgICAgICAgIHRyLmJlYXJpbmcgPSBpbnRlcnBvbGF0ZShzdGFydEJlYXJpbmcsIGJlYXJpbmcsIGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucGl0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICB0ci5waXRjaCA9IGludGVycG9sYXRlKHN0YXJ0UGl0Y2gsIHBpdGNoLCBrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5maXJlKCdtb3ZlJywgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnem9vbScsIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICBpZiAodGhpcy5yb3RhdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSgncm90YXRlJywgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBpdGNoaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdwaXRjaCcsIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy56b29taW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJvdGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBpdGNoaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHRoaXMuZmlyZSgnem9vbWVuZCcsIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ21vdmVlbmQnLCBldmVudERhdGEpO1xuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaXNFYXNpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9hYm9ydEZuO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdG9wcyBhbnkgYW5pbWF0ZWQgdHJhbnNpdGlvbiB1bmRlcndheS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYWJvcnRGbikge1xuICAgICAgICAgICAgdGhpcy5fYWJvcnRGbigpO1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoRWFzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfZWFzZTogZnVuY3Rpb24oZnJhbWUsIGZpbmlzaCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9maW5pc2hGbiA9IGZpbmlzaDtcbiAgICAgICAgdGhpcy5fYWJvcnRGbiA9IGJyb3dzZXIudGltZWQoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGZyYW1lLmNhbGwodGhpcywgb3B0aW9ucy5lYXNpbmcodCkpO1xuICAgICAgICAgICAgaWYgKHQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maW5pc2hFYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgPyAwIDogb3B0aW9ucy5kdXJhdGlvbiwgdGhpcyk7XG4gICAgfSxcblxuICAgIF9maW5pc2hFYXNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2Fib3J0Rm47XG4gICAgICAgIC8vIFRoZSBmaW5pc2ggZnVuY3Rpb24gbWlnaHQgZW1pdCBldmVudHMgd2hpY2ggdHJpZ2dlciBuZXcgZWFzZXMsIHdoaWNoXG4gICAgICAgIC8vIHNldCBhIG5ldyBfZmluaXNoRm4uIEVuc3VyZSB3ZSBkb24ndCBkZWxldGUgaXQgdW5pbnRlbnRpb25hbGx5LlxuICAgICAgICB2YXIgZmluaXNoID0gdGhpcy5fZmluaXNoRm47XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9maW5pc2hGbjtcbiAgICAgICAgZmluaXNoLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIC8vIGNvbnZlcnQgYmVhcmluZyBzbyB0aGF0IGl0J3MgbnVtZXJpY2FsbHkgY2xvc2UgdG8gdGhlIGN1cnJlbnQgb25lIHNvIHRoYXQgaXQgaW50ZXJwb2xhdGVzIHByb3Blcmx5XG4gICAgX25vcm1hbGl6ZUJlYXJpbmc6IGZ1bmN0aW9uKGJlYXJpbmcsIGN1cnJlbnRCZWFyaW5nKSB7XG4gICAgICAgIGJlYXJpbmcgPSB1dGlsLndyYXAoYmVhcmluZywgLTE4MCwgMTgwKTtcbiAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhiZWFyaW5nIC0gY3VycmVudEJlYXJpbmcpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoYmVhcmluZyAtIDM2MCAtIGN1cnJlbnRCZWFyaW5nKSA8IGRpZmYpIGJlYXJpbmcgLT0gMzYwO1xuICAgICAgICBpZiAoTWF0aC5hYnMoYmVhcmluZyArIDM2MCAtIGN1cnJlbnRCZWFyaW5nKSA8IGRpZmYpIGJlYXJpbmcgKz0gMzYwO1xuICAgICAgICByZXR1cm4gYmVhcmluZztcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUVhc2luZzogZnVuY3Rpb24oZHVyYXRpb24sIHpvb20sIGJlemllcikge1xuICAgICAgICB2YXIgZWFzaW5nO1xuXG4gICAgICAgIGlmICh0aGlzLmVhc2UpIHtcbiAgICAgICAgICAgIHZhciBlYXNlID0gdGhpcy5lYXNlLFxuICAgICAgICAgICAgICAgIHQgPSAoRGF0ZS5ub3coKSAtIGVhc2Uuc3RhcnQpIC8gZWFzZS5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICBzcGVlZCA9IGVhc2UuZWFzaW5nKHQgKyAwLjAxKSAtIGVhc2UuZWFzaW5nKHQpLFxuXG4gICAgICAgICAgICAgICAgLy8gUXVpY2sgaGFjayB0byBtYWtlIG5ldyBiZXppZXIgdGhhdCBpcyBjb250aW51b3VzIHdpdGggbGFzdFxuICAgICAgICAgICAgICAgIHggPSAwLjI3IC8gTWF0aC5zcXJ0KHNwZWVkICogc3BlZWQgKyAwLjAwMDEpICogMC4wMSxcbiAgICAgICAgICAgICAgICB5ID0gTWF0aC5zcXJ0KDAuMjcgKiAwLjI3IC0geCAqIHgpO1xuXG4gICAgICAgICAgICBlYXNpbmcgPSB1dGlsLmJlemllcih4LCB5LCAwLjI1LCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVhc2luZyA9IGJlemllciA/IHV0aWwuYmV6aWVyLmFwcGx5KHV0aWwsIGJlemllcikgOiB1dGlsLmVhc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdG9yZSBpbmZvcm1hdGlvbiBvbiBjdXJyZW50IGVhc2luZ1xuICAgICAgICB0aGlzLmVhc2UgPSB7XG4gICAgICAgICAgICBzdGFydDogKG5ldyBEYXRlKCkpLmdldFRpbWUoKSxcbiAgICAgICAgICAgIHRvOiBNYXRoLnBvdygyLCB6b29tKSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZzogZWFzaW5nXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGVhc2luZztcbiAgICB9XG59KTtcblxuLyoqXG4gKiBGaXJlZCB3aGVuZXZlciB0aGUgbWFwJ3MgcGl0Y2ggKHRpbHQpIGNoYW5nZXMuXG4gKlxuICogQGV2ZW50IHBpdGNoXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7TWFwRXZlbnREYXRhfSBkYXRhXG4gKi9cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENvbnRyb2wgPSByZXF1aXJlKCcuL2NvbnRyb2wnKTtcbnZhciBET00gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvbScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdHRyaWJ1dGlvbjtcblxuLyoqXG4gKiBBbiBgQXR0cmlidXRpb25gIGNvbnRyb2wgcHJlc2VudHMgdGhlIG1hcCdzIFthdHRyaWJ1dGlvbiBpbmZvcm1hdGlvbl0oaHR0cHM6Ly93d3cubWFwYm94LmNvbS9oZWxwL2F0dHJpYnV0aW9uLykuXG4gKiBFeHRlbmRzIFtgQ29udHJvbGBdKCNDb250cm9sKS5cbiAqXG4gKiBAY2xhc3MgQXR0cmlidXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbj0nYm90dG9tLXJpZ2h0J10gQSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgY29udHJvbCdzIHBvc2l0aW9uIG9uIHRoZSBtYXAuIE9wdGlvbnMgYXJlIGAndG9wLXJpZ2h0J2AsIGAndG9wLWxlZnQnYCwgYCdib3R0b20tcmlnaHQnYCwgYW5kIGAnYm90dG9tLWxlZnQnYC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgbWFwID0gbmV3IG1hcGJveGdsLk1hcCh7YXR0cmlidXRpb25Db250cm9sOiBmYWxzZX0pXG4gKiAgICAgLmFkZENvbnRyb2wobmV3IG1hcGJveGdsLkF0dHJpYnV0aW9uKHtwb3NpdGlvbjogJ3RvcC1sZWZ0J30pKTtcbiAqL1xuZnVuY3Rpb24gQXR0cmlidXRpb24ob3B0aW9ucykge1xuICAgIHV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbn1cblxuQXR0cmlidXRpb24uY3JlYXRlQXR0cmlidXRpb25TdHJpbmcgPSBmdW5jdGlvbihzb3VyY2VzKSB7XG4gICAgdmFyIGF0dHJpYnV0aW9ucyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaWQgaW4gc291cmNlcykge1xuICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpZF07XG4gICAgICAgIGlmIChzb3VyY2UuYXR0cmlidXRpb24gJiYgYXR0cmlidXRpb25zLmluZGV4T2Yoc291cmNlLmF0dHJpYnV0aW9uKSA8IDApIHtcbiAgICAgICAgICAgIGF0dHJpYnV0aW9ucy5wdXNoKHNvdXJjZS5hdHRyaWJ1dGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYW55IGVudHJpZXMgdGhhdCBhcmUgc3Vic3RyaW5ncyBvZiBhbm90aGVyIGVudHJ5LlxuICAgIC8vIGZpcnN0IHNvcnQgYnkgbGVuZ3RoIHNvIHRoYXQgc3Vic3RyaW5ncyBjb21lIGZpcnN0XG4gICAgYXR0cmlidXRpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7IH0pO1xuICAgIGF0dHJpYnV0aW9ucyA9IGF0dHJpYnV0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGF0dHJpYiwgaSkge1xuICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBhdHRyaWJ1dGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGlvbnNbal0uaW5kZXhPZihhdHRyaWIpID49IDApIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXR0cmlidXRpb25zLmpvaW4oJyB8ICcpO1xufTtcblxuQXR0cmlidXRpb24ucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KENvbnRyb2wsIHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHBvc2l0aW9uOiAnYm90dG9tLXJpZ2h0J1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAnbWFwYm94Z2wtY3RybC1hdHRyaWInLFxuICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRE9NLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBtYXAuZ2V0Q29udGFpbmVyKCkpO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICBtYXAub24oJ3NvdXJjZS5sb2FkJywgdGhpcy5fdXBkYXRlLmJpbmQodGhpcykpO1xuICAgICAgICBtYXAub24oJ3NvdXJjZS5jaGFuZ2UnLCB0aGlzLl91cGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIG1hcC5vbignc291cmNlLnJlbW92ZScsIHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgbWFwLm9uKCdtb3ZlZW5kJywgdGhpcy5fdXBkYXRlRWRpdExpbmsuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXAuc3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBBdHRyaWJ1dGlvbi5jcmVhdGVBdHRyaWJ1dGlvblN0cmluZyh0aGlzLl9tYXAuc3R5bGUuc291cmNlcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lZGl0TGluayA9IHRoaXMuX2NvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdtYXBib3gtaW1wcm92ZS1tYXAnKVswXTtcbiAgICAgICAgdGhpcy5fdXBkYXRlRWRpdExpbmsoKTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUVkaXRMaW5rOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VkaXRMaW5rKSB7XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5fbWFwLmdldENlbnRlcigpO1xuICAgICAgICAgICAgdGhpcy5fZWRpdExpbmsuaHJlZiA9ICdodHRwczovL3d3dy5tYXBib3guY29tL21hcC1mZWVkYmFjay8jLycgK1xuICAgICAgICAgICAgICAgICAgICBjZW50ZXIubG5nICsgJy8nICsgY2VudGVyLmxhdCArICcvJyArIE1hdGgucm91bmQodGhpcy5fbWFwLmdldFpvb20oKSArIDEpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgRXZlbnRlZCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZXZlbnRlZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBDb250cm9sO1xuXG4vKipcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBtYXAtcmVsYXRlZCBpbnRlcmZhY2UgZWxlbWVudHMuXG4gKlxuICogVGhlIGBDb250cm9sYCBjbGFzcyBtaXhlcyBpbiBbYEV2ZW50ZWRgXSgjRXZlbnRlZCkgbWV0aG9kcy5cbiAqXG4gKiBAY2xhc3MgQ29udHJvbFxuICovXG5mdW5jdGlvbiBDb250cm9sKCkge31cblxuQ29udHJvbC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgY29udHJvbCB0byBhIG1hcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TWFwfSBtYXAgVGhlIE1hcGJveCBHTCBKUyBtYXAgdG8gYWRkIHRoZSBjb250cm9sIHRvLlxuICAgICAqIEByZXR1cm5zIHtDb250cm9sfSBgdGhpc2BcbiAgICAgKi9cbiAgICBhZGRUbzogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IHRoaXMub25BZGQobWFwKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMucG9zaXRpb24pIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG4gICAgICAgICAgICB2YXIgY29ybmVyID0gbWFwLl9jb250cm9sQ29ybmVyc1twb3NdO1xuICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSArPSAnIG1hcGJveGdsLWN0cmwnO1xuICAgICAgICAgICAgaWYgKHBvcy5pbmRleE9mKCdib3R0b20nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb3JuZXIuaW5zZXJ0QmVmb3JlKGNvbnRhaW5lciwgY29ybmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3JuZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBjb250cm9sIGZyb20gdGhlIG1hcCBpdCBoYXMgYmVlbiBhZGRlZCB0by5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb250cm9sfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9jb250YWluZXIpO1xuICAgICAgICBpZiAodGhpcy5vblJlbW92ZSkgdGhpcy5vblJlbW92ZSh0aGlzLl9tYXApO1xuICAgICAgICB0aGlzLl9tYXAgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG51dGlsLmV4dGVuZChDb250cm9sLnByb3RvdHlwZSwgRXZlbnRlZCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb250cm9sID0gcmVxdWlyZSgnLi9jb250cm9sJyk7XG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvYnJvd3NlcicpO1xudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlb2xvY2F0ZTtcblxudmFyIGdlb09wdGlvbnMgPSB7IGVuYWJsZUhpZ2hBY2N1cmFjeTogZmFsc2UsIHRpbWVvdXQ6IDYwMDAgLyogNnNlYyAqLyB9O1xuXG5cbi8qKlxuICogQSBgR2VvbG9jYXRlYCBjb250cm9sIHByb3ZpZGVzIGEgYnV0dG9uIHRoYXQgdXNlcyB0aGUgYnJvd3NlcidzIGdlb2xvY2F0aW9uXG4gKiBBUEkgdG8gbG9jYXRlIHRoZSB1c2VyIG9uIHRoZSBtYXAuIEV4dGVuZHMgW2BDb250cm9sYF0oI0NvbnRyb2wpLlxuICpcbiAqIEBjbGFzcyBHZW9sb2NhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbj0ndG9wLXJpZ2h0J10gQSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgY29udHJvbCdzIHBvc2l0aW9uIG9uIHRoZSBtYXAuIE9wdGlvbnMgYXJlIGAndG9wLXJpZ2h0J2AsIGAndG9wLWxlZnQnYCwgYCdib3R0b20tcmlnaHQnYCwgYW5kIGAnYm90dG9tLWxlZnQnYC5cbiAqIEBleGFtcGxlXG4gKiBtYXAuYWRkQ29udHJvbChuZXcgbWFwYm94Z2wuR2VvbG9jYXRlKHtwb3NpdGlvbjogJ3RvcC1sZWZ0J30pKTsgLy8gcG9zaXRpb24gaXMgb3B0aW9uYWxcbiAqL1xuZnVuY3Rpb24gR2VvbG9jYXRlKG9wdGlvbnMpIHtcbiAgICB1dGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG59XG5cbkdlb2xvY2F0ZS5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoQ29udHJvbCwge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcG9zaXRpb246ICd0b3AtcmlnaHQnXG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICdtYXBib3hnbC1jdHJsJztcblxuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gRE9NLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1ncm91cCcsIG1hcC5nZXRDb250YWluZXIoKSk7XG4gICAgICAgIGlmICghYnJvd3Nlci5zdXBwb3J0c0dlb2xvY2F0aW9uKSByZXR1cm4gY29udGFpbmVyO1xuXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMuX29uQ29udGV4dE1lbnUuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uID0gRE9NLmNyZWF0ZSgnYnV0dG9uJywgKGNsYXNzTmFtZSArICctaWNvbiAnICsgY2xhc3NOYW1lICsgJy1nZW9sb2NhdGUnKSwgdGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLnR5cGUgPSAnYnV0dG9uJztcbiAgICAgICAgdGhpcy5fZ2VvbG9jYXRlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGlja0dlb2xvY2F0ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgX29uQ29udGV4dE1lbnU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBfb25DbGlja0dlb2xvY2F0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24odGhpcy5fc3VjY2Vzcy5iaW5kKHRoaXMpLCB0aGlzLl9lcnJvci5iaW5kKHRoaXMpLCBnZW9PcHRpb25zKTtcblxuICAgICAgICAvLyBUaGlzIHRpbWVvdXQgZW5zdXJlcyB0aGF0IHdlIHN0aWxsIGNhbGwgZmluaXNoKCkgZXZlbiBpZlxuICAgICAgICAvLyB0aGUgdXNlciBkZWNsaW5lcyB0byBzaGFyZSB0aGVpciBsb2NhdGlvbiBpbiBGaXJlZm94XG4gICAgICAgIHRoaXMuX3RpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fZmluaXNoLmJpbmQodGhpcyksIDEwMDAwIC8qIDEwc2VjICovKTtcbiAgICB9LFxuXG4gICAgX3N1Y2Nlc3M6IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuX21hcC5qdW1wVG8oe1xuICAgICAgICAgICAgY2VudGVyOiBbcG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZSwgcG9zaXRpb24uY29vcmRzLmxhdGl0dWRlXSxcbiAgICAgICAgICAgIHpvb206IDE3LFxuICAgICAgICAgICAgYmVhcmluZzogMCxcbiAgICAgICAgICAgIHBpdGNoOiAwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZmlyZSgnZ2VvbG9jYXRlJywgcG9zaXRpb24pO1xuICAgICAgICB0aGlzLl9maW5pc2goKTtcbiAgICB9LFxuXG4gICAgX2Vycm9yOiBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICB0aGlzLmZpcmUoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB0aGlzLl9maW5pc2goKTtcbiAgICB9LFxuXG4gICAgX2ZpbmlzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl90aW1lb3V0SWQpIHsgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRJZCk7IH1cbiAgICAgICAgdGhpcy5fdGltZW91dElkID0gdW5kZWZpbmVkO1xuICAgIH1cblxufSk7XG5cbi8qKlxuICogZ2VvbG9jYXRlIGV2ZW50LlxuICpcbiAqIEBldmVudCBnZW9sb2NhdGVcbiAqIEBtZW1iZXJvZiBHZW9sb2NhdGVcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtQb3NpdGlvbn0gZGF0YSBUaGUgcmV0dXJuZWQgW1Bvc2l0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUG9zaXRpb24pIG9iamVjdCBmcm9tIHRoZSBjYWxsYmFjayBpbiBbR2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9HZW9sb2NhdGlvbi9nZXRDdXJyZW50UG9zaXRpb24pLlxuICpcbiAqL1xuXG4vKipcbiAqIGVycm9yIGV2ZW50LlxuICpcbiAqIEBldmVudCBlcnJvclxuICogQG1lbWJlcm9mIEdlb2xvY2F0ZVxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge1Bvc2l0aW9uRXJyb3J9IGRhdGEgVGhlIHJldHVybmVkIFtQb3NpdGlvbkVycm9yXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUG9zaXRpb25FcnJvcikgb2JqZWN0IGZyb20gdGhlIGNhbGxiYWNrIGluIFtHZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0dlb2xvY2F0aW9uL2dldEN1cnJlbnRQb3NpdGlvbikuXG4gKlxuICovXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDb250cm9sID0gcmVxdWlyZSgnLi9jb250cm9sJyk7XG52YXIgRE9NID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9kb20nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTmF2aWdhdGlvbjtcblxuLyoqXG4gKiBBIGBOYXZpZ2F0aW9uYCBjb250cm9sIGNvbnRhaW5zIHpvb20gYnV0dG9ucyBhbmQgYSBjb21wYXNzLlxuICogRXh0ZW5kcyBbYENvbnRyb2xgXSgjQ29udHJvbCkuXG4gKlxuICogQGNsYXNzIE5hdmlnYXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbj0ndG9wLXJpZ2h0J10gQSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgY29udHJvbCdzIHBvc2l0aW9uIG9uIHRoZSBtYXAuIE9wdGlvbnMgYXJlIGAndG9wLXJpZ2h0J2AsIGAndG9wLWxlZnQnYCwgYCdib3R0b20tcmlnaHQnYCwgYW5kIGAnYm90dG9tLWxlZnQnYC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgbmF2ID0gbmV3IG1hcGJveGdsLk5hdmlnYXRpb24oe3Bvc2l0aW9uOiAndG9wLWxlZnQnfSk7IC8vIHBvc2l0aW9uIGlzIG9wdGlvbmFsXG4gKiBtYXAuYWRkQ29udHJvbChuYXYpO1xuICovXG5mdW5jdGlvbiBOYXZpZ2F0aW9uKG9wdGlvbnMpIHtcbiAgICB1dGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG59XG5cbk5hdmlnYXRpb24ucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KENvbnRyb2wsIHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHBvc2l0aW9uOiAndG9wLXJpZ2h0J1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSAnbWFwYm94Z2wtY3RybCc7XG5cbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERPTS5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctZ3JvdXAnLCBtYXAuZ2V0Q29udGFpbmVyKCkpO1xuICAgICAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLl9vbkNvbnRleHRNZW51LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMuX3pvb21JbkJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihjbGFzc05hbWUgKyAnLWljb24gJyArIGNsYXNzTmFtZSArICctem9vbS1pbicsIG1hcC56b29tSW4uYmluZChtYXApKTtcbiAgICAgICAgdGhpcy5fem9vbU91dEJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihjbGFzc05hbWUgKyAnLWljb24gJyArIGNsYXNzTmFtZSArICctem9vbS1vdXQnLCBtYXAuem9vbU91dC5iaW5kKG1hcCkpO1xuICAgICAgICB0aGlzLl9jb21wYXNzID0gdGhpcy5fY3JlYXRlQnV0dG9uKGNsYXNzTmFtZSArICctaWNvbiAnICsgY2xhc3NOYW1lICsgJy1jb21wYXNzJywgbWFwLnJlc2V0Tm9ydGguYmluZChtYXApKTtcblxuICAgICAgICB0aGlzLl9jb21wYXNzQXJyb3cgPSBET00uY3JlYXRlKCdkaXYnLCAnYXJyb3cnLCB0aGlzLl9jb21wYXNzKTtcblxuICAgICAgICB0aGlzLl9jb21wYXNzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uQ29tcGFzc0Rvd24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX29uQ29tcGFzc01vdmUgPSB0aGlzLl9vbkNvbXBhc3NNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX29uQ29tcGFzc1VwID0gdGhpcy5fb25Db21wYXNzVXAuYmluZCh0aGlzKTtcblxuICAgICAgICBtYXAub24oJ3JvdGF0ZScsIHRoaXMuX3JvdGF0ZUNvbXBhc3NBcnJvdy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fcm90YXRlQ29tcGFzc0Fycm93KCk7XG5cbiAgICAgICAgdGhpcy5fZWwgPSBtYXAuZ2V0Q2FudmFzQ29udGFpbmVyKCk7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgX29uQ29udGV4dE1lbnU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBfb25Db21wYXNzRG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5idXR0b24gIT09IDApIHJldHVybjtcblxuICAgICAgICBET00uZGlzYWJsZURyYWcoKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Db21wYXNzTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbkNvbXBhc3NVcCk7XG5cbiAgICAgICAgdGhpcy5fZWwuZGlzcGF0Y2hFdmVudChjb3B5TW91c2VFdmVudChlKSk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcblxuICAgIF9vbkNvbXBhc3NNb3ZlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLmJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuX2VsLmRpc3BhdGNoRXZlbnQoY29weU1vdXNlRXZlbnQoZSkpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG5cbiAgICBfb25Db21wYXNzVXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUuYnV0dG9uICE9PSAwKSByZXR1cm47XG5cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Db21wYXNzTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbkNvbXBhc3NVcCk7XG4gICAgICAgIERPTS5lbmFibGVEcmFnKCk7XG5cbiAgICAgICAgdGhpcy5fZWwuZGlzcGF0Y2hFdmVudChjb3B5TW91c2VFdmVudChlKSk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcblxuICAgIF9jcmVhdGVCdXR0b246IGZ1bmN0aW9uKGNsYXNzTmFtZSwgZm4pIHtcbiAgICAgICAgdmFyIGEgPSBET00uY3JlYXRlKCdidXR0b24nLCBjbGFzc05hbWUsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIGEudHlwZSA9ICdidXR0b24nO1xuICAgICAgICBhLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7IGZuKCk7IH0pO1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9LFxuXG4gICAgX3JvdGF0ZUNvbXBhc3NBcnJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByb3RhdGUgPSAncm90YXRlKCcgKyAodGhpcy5fbWFwLnRyYW5zZm9ybS5hbmdsZSAqICgxODAgLyBNYXRoLlBJKSkgKyAnZGVnKSc7XG4gICAgICAgIHRoaXMuX2NvbXBhc3NBcnJvdy5zdHlsZS50cmFuc2Zvcm0gPSByb3RhdGU7XG4gICAgfVxufSk7XG5cblxuZnVuY3Rpb24gY29weU1vdXNlRXZlbnQoZSkge1xuICAgIHJldHVybiBuZXcgTW91c2VFdmVudChlLnR5cGUsIHtcbiAgICAgICAgYnV0dG9uOiAyLCAgICAvLyByaWdodCBjbGlja1xuICAgICAgICBidXR0b25zOiAyLCAgIC8vIHJpZ2h0IGNsaWNrXG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgIGRldGFpbDogZS5kZXRhaWwsXG4gICAgICAgIHZpZXc6IGUudmlldyxcbiAgICAgICAgc2NyZWVuWDogZS5zY3JlZW5YLFxuICAgICAgICBzY3JlZW5ZOiBlLnNjcmVlblksXG4gICAgICAgIGNsaWVudFg6IGUuY2xpZW50WCxcbiAgICAgICAgY2xpZW50WTogZS5jbGllbnRZLFxuICAgICAgICBtb3ZlbWVudFg6IGUubW92ZW1lbnRYLFxuICAgICAgICBtb3ZlbWVudFk6IGUubW92ZW1lbnRZLFxuICAgICAgICBjdHJsS2V5OiBlLmN0cmxLZXksXG4gICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5LFxuICAgICAgICBhbHRLZXk6IGUuYWx0S2V5LFxuICAgICAgICBtZXRhS2V5OiBlLm1ldGFLZXlcbiAgICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG52YXIgQ29udHJvbCA9IHJlcXVpcmUoJy4vY29udHJvbCcpO1xudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2NhbGU7XG5cbi8qKlxuICogQSBgU2NhbGVgIGNvbnRyb2wgZGlzcGxheXMgdGhlIHJhdGlvIG9mIGEgZGlzdGFuY2Ugb24gdGhlIG1hcCB0byB0aGUgY29ycmVzcG9uZGluZyBkaXN0YW5jZSBvbiB0aGUgZ3JvdW5kLlxuICogRXh0ZW5kcyBbYENvbnRyb2xgXSgjQ29udHJvbCkuXG4gKlxuICogQGNsYXNzIFNjYWxlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucG9zaXRpb249J2JvdHRvbS1sZWZ0J10gQSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgY29udHJvbCdzIHBvc2l0aW9uIG9uIHRoZSBtYXAuIE9wdGlvbnMgYXJlIGAndG9wLXJpZ2h0J2AsIGAndG9wLWxlZnQnYCwgYCdib3R0b20tcmlnaHQnYCwgYW5kIGAnYm90dG9tLWxlZnQnYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXaWR0aD0nMTUwJ10gVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBzY2FsZSBjb250cm9sIGluIHBpeGVscy5cbiAqIEBleGFtcGxlXG4gKiBtYXAuYWRkQ29udHJvbChuZXcgbWFwYm94Z2wuU2NhbGUoe3Bvc2l0aW9uOiAndG9wLWxlZnQnfSkpOyAvLyBwb3NpdGlvbiBpcyBvcHRpb25hbFxuICogbWFwLmFkZENvbnRyb2wobmV3IG1hcGJveGdsLlNjYWxlKHttYXhXaWR0aDogODB9KSk7IC8vbWF4V2lkdGggaXMgb3B0aW9uYWxcbiAqL1xuZnVuY3Rpb24gU2NhbGUob3B0aW9ucykge1xuICAgIHV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbn1cblxuU2NhbGUucHJvdG90eXBlID0gdXRpbC5pbmhlcml0KENvbnRyb2wsIHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHBvc2l0aW9uOiAnYm90dG9tLWxlZnQnXG4gICAgfSxcblxuICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICdtYXBib3hnbC1jdHJsLXNjYWxlJyxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IERPTS5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSwgbWFwLmdldENvbnRhaW5lcigpKSxcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgdXBkYXRlU2NhbGUobWFwLCBjb250YWluZXIsIG9wdGlvbnMpO1xuICAgICAgICBtYXAub24oJ21vdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHVwZGF0ZVNjYWxlKG1hcCwgY29udGFpbmVyLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU2NhbGUobWFwLCBzY2FsZSwgb3B0aW9ucykge1xuICAgIC8vIEEgaG9yaXpvbnRhbCBzY2FsZSBpcyBpbWFnaW5lZCB0byBiZSBwcmVzZW50IGF0IGNlbnRlciBvZiB0aGUgbWFwXG4gICAgLy8gY29udGFpbmVyIHdpdGggbWF4aW11bSBsZW5ndGggKERlZmF1bHQpIGFzIDEwMHB4LlxuICAgIC8vIFVzaW5nIHNwaGVyaWNhbCBsYXcgb2YgY29zaW5lcyBhcHByb3hpbWF0aW9uLCB0aGUgcmVhbCBkaXN0YW5jZSBpc1xuICAgIC8vIGZvdW5kIGJldHdlZW4gdGhlIHR3byBjb29yZGluYXRlcy5cbiAgICB2YXIgbWF4V2lkdGggPSBvcHRpb25zICYmIG9wdGlvbnMubWF4V2lkdGggfHwgMTAwO1xuXG4gICAgdmFyIHkgPSBtYXAuX2NvbnRhaW5lci5jbGllbnRIZWlnaHQgLyAyO1xuICAgIHZhciBtYXhNZXRlcnMgPSBnZXREaXN0YW5jZShtYXAudW5wcm9qZWN0KFswLCB5XSksIG1hcC51bnByb2plY3QoW21heFdpZHRoLCB5XSkpO1xuXG4gICAgLy8gVGhlIHJlYWwgZGlzdGFuY2UgY29ycmVzcG9uZGluZyB0byAxMDBweCBzY2FsZSBsZW5ndGggaXMgcm91bmRlZCBvZmYgdG9cbiAgICAvLyBuZWFyIHByZXR0eSBudW1iZXIgYW5kIHRoZSBzY2FsZSBsZW5ndGggZm9yIHRoZSBzYW1lIGlzIGZvdW5kIG91dC5cbiAgICB2YXIgbWV0ZXJzID0gZ2V0Um91bmROdW0obWF4TWV0ZXJzKTtcbiAgICB2YXIgcmF0aW8gPSBtZXRlcnMgLyBtYXhNZXRlcnM7XG4gICAgc2NhbGUuc3R5bGUud2lkdGggPSBtYXhXaWR0aCAqIHJhdGlvICsgJ3B4JztcbiAgICBzY2FsZS5pbm5lckhUTUwgPSBtZXRlcnMgPCAxMDAwID8gbWV0ZXJzICsgJyBtJyA6IChtZXRlcnMgLyAxMDAwKSArICcga20nO1xuXG59XG5cbmZ1bmN0aW9uIGdldERpc3RhbmNlKGxhdGxuZzEsIGxhdGxuZzIpIHtcbiAgICAvLyBVc2VzIHNwaGVyaWNhbCBsYXcgb2YgY29zaW5lcyBhcHByb3hpbWF0aW9uLlxuICAgIHZhciBSID0gNjM3MTAwMDtcblxuICAgIHZhciByYWQgPSBNYXRoLlBJIC8gMTgwLFxuICAgICAgICBsYXQxID0gbGF0bG5nMS5sYXQgKiByYWQsXG4gICAgICAgIGxhdDIgPSBsYXRsbmcyLmxhdCAqIHJhZCxcbiAgICAgICAgYSA9IE1hdGguc2luKGxhdDEpICogTWF0aC5zaW4obGF0MikgK1xuICAgICAgICAgIE1hdGguY29zKGxhdDEpICogTWF0aC5jb3MobGF0MikgKiBNYXRoLmNvcygobGF0bG5nMi5sbmcgLSBsYXRsbmcxLmxuZykgKiByYWQpO1xuXG4gICAgdmFyIG1heE1ldGVycyA9IFIgKiBNYXRoLmFjb3MoTWF0aC5taW4oYSwgMSkpO1xuICAgIHJldHVybiBtYXhNZXRlcnM7XG5cbn1cblxuZnVuY3Rpb24gZ2V0Um91bmROdW0obnVtKSB7XG4gICAgdmFyIHBvdzEwID0gTWF0aC5wb3coMTAsIChNYXRoLmZsb29yKG51bSkgKyAnJykubGVuZ3RoIC0gMSksXG4gICAgICAgIGQgPSBudW0gLyBwb3cxMDtcblxuICAgIGQgPSBkID49IDEwID8gMTAgOlxuICAgICAgICBkID49IDUgPyA1IDpcbiAgICAgICAgZCA+PSAzID8gMyA6XG4gICAgICAgIGQgPj0gMiA/IDIgOiAxO1xuXG4gICAgcmV0dXJuIHBvdzEwICogZDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyksXG4gICAgTG5nTGF0Qm91bmRzID0gcmVxdWlyZSgnLi4vLi4vZ2VvL2xuZ19sYXRfYm91bmRzJyksXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJveFpvb21IYW5kbGVyO1xuXG4vKipcbiAqIFRoZSBgQm94Wm9vbUhhbmRsZXJgIGFsbG93cyB0aGUgdXNlciB0byB6b29tIHRoZSBtYXAgdG8gZml0IHdpdGhpbiBhIGJvdW5kaW5nIGJveC5cbiAqIFRoZSBib3VuZGluZyBib3ggaXMgZGVmaW5lZCBieSBjbGlja2luZyBhbmQgaG9sZGluZyBgc2hpZnRgIHdoaWxlIGRyYWdnaW5nIHRoZSBjdXJzb3IuXG4gKlxuICogQGNsYXNzIEJveFpvb21IYW5kbGVyXG4gKiBAcGFyYW0ge01hcH0gbWFwIFRoZSBNYXBib3ggR0wgSlMgbWFwIHRvIGFkZCB0aGUgaGFuZGxlciB0by5cbiAqL1xuZnVuY3Rpb24gQm94Wm9vbUhhbmRsZXIobWFwKSB7XG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHRoaXMuX2VsID0gbWFwLmdldENhbnZhc0NvbnRhaW5lcigpO1xuICAgIHRoaXMuX2NvbnRhaW5lciA9IG1hcC5nZXRDb250YWluZXIoKTtcblxuICAgIHV0aWwuYmluZEhhbmRsZXJzKHRoaXMpO1xufVxuXG5Cb3hab29tSGFuZGxlci5wcm90b3R5cGUgPSB7XG5cbiAgICBfZW5hYmxlZDogZmFsc2UsXG4gICAgX2FjdGl2ZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIFwiYm94IHpvb21cIiBpbnRlcmFjdGlvbiBpcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgXCJib3ggem9vbVwiIGludGVyYWN0aW9uIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIFwiYm94IHpvb21cIiBpbnRlcmFjdGlvbiBpcyBhY3RpdmUsIGkuZS4gY3VycmVudGx5IGJlaW5nIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBcImJveCB6b29tXCIgaW50ZXJhY3Rpb24gaXMgYWN0aXZlLlxuICAgICAqL1xuICAgIGlzQWN0aXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIFwiYm94IHpvb21cIiBpbnRlcmFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICBtYXAuYm94Wm9vbS5lbmFibGUoKTtcbiAgICAgKi9cbiAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5fZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIHRoZSBcImJveCB6b29tXCIgaW50ZXJhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgbWFwLmJveFpvb20uZGlzYWJsZSgpO1xuICAgICAqL1xuICAgIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRW5hYmxlZCgpKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duKTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghKGUuc2hpZnRLZXkgJiYgZS5idXR0b24gPT09IDApKSByZXR1cm47XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwLCBmYWxzZSk7XG5cbiAgICAgICAgRE9NLmRpc2FibGVEcmFnKCk7XG4gICAgICAgIHRoaXMuX3N0YXJ0UG9zID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlKTtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgX29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgcDAgPSB0aGlzLl9zdGFydFBvcyxcbiAgICAgICAgICAgIHAxID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlKTtcblxuICAgICAgICBpZiAoIXRoaXMuX2JveCkge1xuICAgICAgICAgICAgdGhpcy5fYm94ID0gRE9NLmNyZWF0ZSgnZGl2JywgJ21hcGJveGdsLWJveHpvb20nLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ21hcGJveGdsLWNyb3NzaGFpcicpO1xuICAgICAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCdib3h6b29tc3RhcnQnLCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5YID0gTWF0aC5taW4ocDAueCwgcDEueCksXG4gICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgocDAueCwgcDEueCksXG4gICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4ocDAueSwgcDEueSksXG4gICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgocDAueSwgcDEueSk7XG5cbiAgICAgICAgRE9NLnNldFRyYW5zZm9ybSh0aGlzLl9ib3gsICd0cmFuc2xhdGUoJyArIG1pblggKyAncHgsJyArIG1pblkgKyAncHgpJyk7XG5cbiAgICAgICAgdGhpcy5fYm94LnN0eWxlLndpZHRoID0gKG1heFggLSBtaW5YKSArICdweCc7XG4gICAgICAgIHRoaXMuX2JveC5zdHlsZS5oZWlnaHQgPSAobWF4WSAtIG1pblkpICsgJ3B4JztcbiAgICB9LFxuXG4gICAgX29uTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuYnV0dG9uICE9PSAwKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHAwID0gdGhpcy5fc3RhcnRQb3MsXG4gICAgICAgICAgICBwMSA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZSksXG4gICAgICAgICAgICBib3VuZHMgPSBuZXcgTG5nTGF0Qm91bmRzKHRoaXMuX21hcC51bnByb2plY3QocDApLCB0aGlzLl9tYXAudW5wcm9qZWN0KHAxKSk7XG5cbiAgICAgICAgdGhpcy5fZmluaXNoKCk7XG5cbiAgICAgICAgaWYgKHAwLnggPT09IHAxLnggJiYgcDAueSA9PT0gcDEueSkge1xuICAgICAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCdib3h6b29tY2FuY2VsJywgZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9tYXBcbiAgICAgICAgICAgICAgICAuZml0Qm91bmRzKGJvdW5kcywge2xpbmVhcjogdHJ1ZX0pXG4gICAgICAgICAgICAgICAgLmZpcmUoJ2JveHpvb21lbmQnLCB7IG9yaWdpbmFsRXZlbnQ6IGUsIGJveFpvb21Cb3VuZHM6IGJvdW5kcyB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAyNykge1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoKCk7XG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ2JveHpvb21jYW5jZWwnLCBlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZmluaXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIGZhbHNlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCwgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdtYXBib3hnbC1jcm9zc2hhaXInKTtcblxuICAgICAgICBpZiAodGhpcy5fYm94KSB7XG4gICAgICAgICAgICB0aGlzLl9ib3gucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9ib3gpO1xuICAgICAgICAgICAgdGhpcy5fYm94ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIERPTS5lbmFibGVEcmFnKCk7XG4gICAgfSxcblxuICAgIF9maXJlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuZmlyZSh0eXBlLCB7IG9yaWdpbmFsRXZlbnQ6IGUgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNYXBCb3hab29tRXZlbnRcbiAqIEBwcm9wZXJ0eSB7TW91c2VFdmVudH0gb3JpZ2luYWxFdmVudFxuICogQHByb3BlcnR5IHtMbmdMYXRCb3VuZHN9IGJveFpvb21Cb3VuZHMgVGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgXCJib3ggem9vbVwiIGludGVyYWN0aW9uLlxuICogICBUaGlzIHByb3BlcnR5IGlzIG9ubHkgcHJvdmlkZWQgZm9yIGBib3h6b29tZW5kYCBldmVudHMuXG4gKi9cblxuLyoqXG4gKiBGaXJlZCB3aGVuIGEgXCJib3ggem9vbVwiIGludGVyYWN0aW9uIHN0YXJ0cy4gU2VlIFtgQm94Wm9vbUhhbmRsZXJgXSgjQm94Wm9vbUhhbmRsZXIpLlxuICpcbiAqIEBldmVudCBib3h6b29tc3RhcnRcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtNYXBCb3hab29tRXZlbnR9IGRhdGFcbiAqL1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gYSBcImJveCB6b29tXCIgaW50ZXJhY3Rpb24gZW5kcy4gIFNlZSBbYEJveFpvb21IYW5kbGVyYF0oI0JveFpvb21IYW5kbGVyKS5cbiAqXG4gKiBAZXZlbnQgYm94em9vbWVuZFxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtNYXBCb3hab29tRXZlbnR9IGRhdGFcbiAqL1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gdGhlIHVzZXIgY2FuY2VscyBhIFwiYm94IHpvb21cIiBpbnRlcmFjdGlvbiwgb3Igd2hlbiB0aGUgYm91bmRpbmcgYm94IGRvZXMgbm90IG1lZXQgdGhlIG1pbmltdW0gc2l6ZSB0aHJlc2hvbGQuXG4gKiBTZWUgW2BCb3hab29tSGFuZGxlcmBdKCNCb3hab29tSGFuZGxlcikuXG4gKlxuICogQGV2ZW50IGJveHpvb21jYW5jZWxcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtNYXBCb3hab29tRXZlbnR9IGRhdGFcbiAqL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERvdWJsZUNsaWNrWm9vbUhhbmRsZXI7XG5cbi8qKlxuICogVGhlIGBEb3VibGVDbGlja1pvb21IYW5kbGVyYCBhbGxvd3MgdGhlIHVzZXIgdG8gem9vbSB0aGUgbWFwIGF0IGEgcG9pbnQgYnlcbiAqIGRvdWJsZSBjbGlja2luZy5cbiAqXG4gKiBAY2xhc3MgRG91YmxlQ2xpY2tab29tSGFuZGxlclxuICogQHBhcmFtIHtNYXB9IG1hcCBUaGUgTWFwYm94IEdMIEpTIG1hcCB0byBhZGQgdGhlIGhhbmRsZXIgdG8uXG4gKi9cbmZ1bmN0aW9uIERvdWJsZUNsaWNrWm9vbUhhbmRsZXIobWFwKSB7XG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHRoaXMuX29uRGJsQ2xpY2sgPSB0aGlzLl9vbkRibENsaWNrLmJpbmQodGhpcyk7XG59XG5cbkRvdWJsZUNsaWNrWm9vbUhhbmRsZXIucHJvdG90eXBlID0ge1xuXG4gICAgX2VuYWJsZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBcImRvdWJsZSBjbGljayB0byB6b29tXCIgaW50ZXJhY3Rpb24gaXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIFwiZG91YmxlIGNsaWNrIHRvIHpvb21cIiBpbnRlcmFjdGlvbiBpcyBlbmFibGVkLlxuICAgICAqL1xuICAgIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGUgXCJkb3VibGUgY2xpY2sgdG8gem9vbVwiIGludGVyYWN0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBtYXAuZG91YmxlQ2xpY2tab29tLmVuYWJsZSgpO1xuICAgICAqL1xuICAgIGVuYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQoKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9tYXAub24oJ2RibGNsaWNrJywgdGhpcy5fb25EYmxDbGljayk7XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyB0aGUgXCJkb3VibGUgY2xpY2sgdG8gem9vbVwiIGludGVyYWN0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBtYXAuZG91YmxlQ2xpY2tab29tLmRpc2FibGUoKTtcbiAgICAgKi9cbiAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0VuYWJsZWQoKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9tYXAub2ZmKCdkYmxjbGljaycsIHRoaXMuX29uRGJsQ2xpY2spO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIF9vbkRibENsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLl9tYXAuem9vbVRvKFxuICAgICAgICAgICAgdGhpcy5fbWFwLmdldFpvb20oKSArIChlLm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgPyAtMSA6IDEpLFxuICAgICAgICAgICAge2Fyb3VuZDogZS5sbmdMYXR9LFxuICAgICAgICAgICAgZVxuICAgICAgICApO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBET00gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvbScpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcmFnUGFuSGFuZGxlcjtcblxudmFyIGluZXJ0aWFMaW5lYXJpdHkgPSAwLjMsXG4gICAgaW5lcnRpYUVhc2luZyA9IHV0aWwuYmV6aWVyKDAsIDAsIGluZXJ0aWFMaW5lYXJpdHksIDEpLFxuICAgIGluZXJ0aWFNYXhTcGVlZCA9IDE0MDAsIC8vIHB4L3NcbiAgICBpbmVydGlhRGVjZWxlcmF0aW9uID0gMjUwMDsgLy8gcHgvc14yXG5cblxuLyoqXG4gKiBUaGUgYERyYWdQYW5IYW5kbGVyYCBhbGxvd3MgdGhlIHVzZXIgdG8gcGFuIHRoZSBtYXAgYnkgY2xpY2tpbmcgYW5kIGRyYWdnaW5nXG4gKiB0aGUgY3Vyc29yLlxuICpcbiAqIEBjbGFzcyBEcmFnUGFuSGFuZGxlclxuICogQHBhcmFtIHtNYXB9IG1hcCBUaGUgTWFwYm94IEdMIEpTIG1hcCB0byBhZGQgdGhlIGhhbmRsZXIgdG8uXG4gKi9cbmZ1bmN0aW9uIERyYWdQYW5IYW5kbGVyKG1hcCkge1xuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB0aGlzLl9lbCA9IG1hcC5nZXRDYW52YXNDb250YWluZXIoKTtcblxuICAgIHV0aWwuYmluZEhhbmRsZXJzKHRoaXMpO1xufVxuXG5EcmFnUGFuSGFuZGxlci5wcm90b3R5cGUgPSB7XG5cbiAgICBfZW5hYmxlZDogZmFsc2UsXG4gICAgX2FjdGl2ZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIFwiZHJhZyB0byBwYW5cIiBpbnRlcmFjdGlvbiBpcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgXCJkcmFnIHRvIHBhblwiIGludGVyYWN0aW9uIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIFwiZHJhZyB0byBwYW5cIiBpbnRlcmFjdGlvbiBpcyBhY3RpdmUsIGkuZS4gY3VycmVudGx5IGJlaW5nIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBcImRyYWcgdG8gcGFuXCIgaW50ZXJhY3Rpb24gaXMgYWN0aXZlLlxuICAgICAqL1xuICAgIGlzQWN0aXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIFwiZHJhZyB0byBwYW5cIiBpbnRlcmFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbWFwLmRyYWdQYW4uZW5hYmxlKCk7XG4gICAgICovXG4gICAgZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCgpKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2VsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uRG93bik7XG4gICAgICAgIHRoaXMuX2VsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24pO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgdGhlIFwiZHJhZyB0byBwYW5cIiBpbnRlcmFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbWFwLmRyYWdQYW4uZGlzYWJsZSgpO1xuICAgICAqL1xuICAgIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRW5hYmxlZCgpKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uRG93bik7XG4gICAgICAgIHRoaXMuX2VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkRvd24pO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIF9vbkRvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pZ25vcmVFdmVudChlKSkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSByZXR1cm47XG5cbiAgICAgICAgaWYgKGUudG91Y2hlcykge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdmUpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhcnRQb3MgPSB0aGlzLl9wb3MgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUpO1xuICAgICAgICB0aGlzLl9pbmVydGlhID0gW1tEYXRlLm5vdygpLCB0aGlzLl9wb3NdXTtcbiAgICB9LFxuXG4gICAgX29uTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lnbm9yZUV2ZW50KGUpKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ2RyYWdzdGFydCcsIGUpO1xuICAgICAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCdtb3Zlc3RhcnQnLCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3MgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUpLFxuICAgICAgICAgICAgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgIG1hcC5zdG9wKCk7XG4gICAgICAgIHRoaXMuX2RyYWluSW5lcnRpYUJ1ZmZlcigpO1xuICAgICAgICB0aGlzLl9pbmVydGlhLnB1c2goW0RhdGUubm93KCksIHBvc10pO1xuXG4gICAgICAgIG1hcC50cmFuc2Zvcm0uc2V0TG9jYXRpb25BdFBvaW50KG1hcC50cmFuc2Zvcm0ucG9pbnRMb2NhdGlvbih0aGlzLl9wb3MpLCBwb3MpO1xuXG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnZHJhZycsIGUpO1xuICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ21vdmUnLCBlKTtcblxuICAgICAgICB0aGlzLl9wb3MgPSBwb3M7XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBfb25VcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlKCkpIHJldHVybjtcblxuICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCdkcmFnZW5kJywgZSk7XG4gICAgICAgIHRoaXMuX2RyYWluSW5lcnRpYUJ1ZmZlcigpO1xuXG4gICAgICAgIHZhciBmaW5pc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnbW92ZWVuZCcsIGUpO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgdmFyIGluZXJ0aWEgPSB0aGlzLl9pbmVydGlhO1xuICAgICAgICBpZiAoaW5lcnRpYS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0ID0gaW5lcnRpYVtpbmVydGlhLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgZmlyc3QgPSBpbmVydGlhWzBdLFxuICAgICAgICAgICAgZmxpbmdPZmZzZXQgPSBsYXN0WzFdLnN1YihmaXJzdFsxXSksXG4gICAgICAgICAgICBmbGluZ0R1cmF0aW9uID0gKGxhc3RbMF0gLSBmaXJzdFswXSkgLyAxMDAwO1xuXG4gICAgICAgIGlmIChmbGluZ0R1cmF0aW9uID09PSAwIHx8IGxhc3RbMV0uZXF1YWxzKGZpcnN0WzFdKSkge1xuICAgICAgICAgICAgZmluaXNoKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxjdWxhdGUgcHgvcyB2ZWxvY2l0eSAmIGFkanVzdCBmb3IgaW5jcmVhc2VkIGluaXRpYWwgYW5pbWF0aW9uIHNwZWVkIHdoZW4gZWFzaW5nIG91dFxuICAgICAgICB2YXIgdmVsb2NpdHkgPSBmbGluZ09mZnNldC5tdWx0KGluZXJ0aWFMaW5lYXJpdHkgLyBmbGluZ0R1cmF0aW9uKSxcbiAgICAgICAgICAgIHNwZWVkID0gdmVsb2NpdHkubWFnKCk7IC8vIHB4L3NcblxuICAgICAgICBpZiAoc3BlZWQgPiBpbmVydGlhTWF4U3BlZWQpIHtcbiAgICAgICAgICAgIHNwZWVkID0gaW5lcnRpYU1heFNwZWVkO1xuICAgICAgICAgICAgdmVsb2NpdHkuX3VuaXQoKS5fbXVsdChzcGVlZCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHVyYXRpb24gPSBzcGVlZCAvIChpbmVydGlhRGVjZWxlcmF0aW9uICogaW5lcnRpYUxpbmVhcml0eSksXG4gICAgICAgICAgICBvZmZzZXQgPSB2ZWxvY2l0eS5tdWx0KC1kdXJhdGlvbiAvIDIpO1xuXG4gICAgICAgIHRoaXMuX21hcC5wYW5CeShvZmZzZXQsIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiAqIDEwMDAsXG4gICAgICAgICAgICBlYXNpbmc6IGluZXJ0aWFFYXNpbmcsXG4gICAgICAgICAgICBub01vdmVTdGFydDogdHJ1ZVxuICAgICAgICB9LCB7IG9yaWdpbmFsRXZlbnQ6IGUgfSk7XG4gICAgfSxcblxuICAgIF9vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pZ25vcmVFdmVudChlKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9vblVwKGUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICB9LFxuXG4gICAgX29uVG91Y2hFbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pZ25vcmVFdmVudChlKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9vblVwKGUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQpO1xuICAgIH0sXG5cbiAgICBfZmlyZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmZpcmUodHlwZSwgeyBvcmlnaW5hbEV2ZW50OiBlIH0pO1xuICAgIH0sXG5cbiAgICBfaWdub3JlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgaWYgKG1hcC5ib3hab29tICYmIG1hcC5ib3hab29tLmlzQWN0aXZlKCkpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAobWFwLmRyYWdSb3RhdGUgJiYgbWFwLmRyYWdSb3RhdGUuaXNBY3RpdmUoKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChlLnRvdWNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGUuY3RybEtleSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB2YXIgYnV0dG9ucyA9IDEsICAvLyBsZWZ0IGJ1dHRvblxuICAgICAgICAgICAgICAgIGJ1dHRvbiA9IDA7ICAgLy8gbGVmdCBidXR0b25cbiAgICAgICAgICAgIHJldHVybiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJyA/IGUuYnV0dG9ucyAmIGJ1dHRvbnMgPT09IDAgOiBlLmJ1dHRvbiAhPT0gYnV0dG9uKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZHJhaW5JbmVydGlhQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmVydGlhID0gdGhpcy5faW5lcnRpYSxcbiAgICAgICAgICAgIG5vdyA9IERhdGUubm93KCksXG4gICAgICAgICAgICBjdXRvZmYgPSAxNjA7ICAgLy8gbXNlY1xuXG4gICAgICAgIHdoaWxlIChpbmVydGlhLmxlbmd0aCA+IDAgJiYgbm93IC0gaW5lcnRpYVswXVswXSA+IGN1dG9mZikgaW5lcnRpYS5zaGlmdCgpO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBGaXJlZCB3aGVuIGEgXCJkcmFnIHRvIHBhblwiIGludGVyYWN0aW9uIHN0YXJ0cy4gU2VlIFtgRHJhZ1BhbkhhbmRsZXJgXSgjRHJhZ1BhbkhhbmRsZXIpLlxuICpcbiAqIEBldmVudCBkcmFnc3RhcnRcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtNYXBNb3VzZUV2ZW50IHwgTWFwVG91Y2hFdmVudH0gZGF0YVxuICovXG5cbi8qKlxuICogRmlyZWQgcmVwZWF0ZWRseSBkdXJpbmcgYSBcImRyYWcgdG8gcGFuXCIgaW50ZXJhY3Rpb24uIFNlZSBbYERyYWdQYW5IYW5kbGVyYF0oI0RyYWdQYW5IYW5kbGVyKS5cbiAqXG4gKiBAZXZlbnQgZHJhZ1xuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge01hcE1vdXNlRXZlbnQgfCBNYXBUb3VjaEV2ZW50fSBkYXRhXG4gKi9cblxuLyoqXG4gKiBGaXJlZCB3aGVuIGEgXCJkcmFnIHRvIHBhblwiIGludGVyYWN0aW9uIGVuZHMuIFNlZSBbYERyYWdQYW5IYW5kbGVyYF0oI0RyYWdQYW5IYW5kbGVyKS5cbiAqXG4gKiBAZXZlbnQgZHJhZ2VuZFxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge01hcE1vdXNlRXZlbnQgfCBNYXBUb3VjaEV2ZW50fSBkYXRhXG4gKi9cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyksXG4gICAgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEcmFnUm90YXRlSGFuZGxlcjtcblxudmFyIGluZXJ0aWFMaW5lYXJpdHkgPSAwLjI1LFxuICAgIGluZXJ0aWFFYXNpbmcgPSB1dGlsLmJlemllcigwLCAwLCBpbmVydGlhTGluZWFyaXR5LCAxKSxcbiAgICBpbmVydGlhTWF4U3BlZWQgPSAxODAsIC8vIGRlZy9zXG4gICAgaW5lcnRpYURlY2VsZXJhdGlvbiA9IDcyMDsgLy8gZGVnL3NeMlxuXG5cbi8qKlxuICogVGhlIGBEcmFnUm90YXRlSGFuZGxlcmAgYWxsb3dzIHRoZSB1c2VyIHRvIHJvdGF0ZSB0aGUgbWFwIGJ5IGNsaWNraW5nIGFuZFxuICogZHJhZ2dpbmcgdGhlIGN1cnNvciB3aGlsZSBob2xkaW5nIHRoZSByaWdodCBtb3VzZSBidXR0b24gb3IgYGN0cmxgIGtleS5cbiAqXG4gKiBAY2xhc3MgRHJhZ1JvdGF0ZUhhbmRsZXJcbiAqIEBwYXJhbSB7TWFwfSBtYXAgVGhlIE1hcGJveCBHTCBKUyBtYXAgdG8gYWRkIHRoZSBoYW5kbGVyIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmJlYXJpbmdTbmFwXSBUaGUgdGhyZXNob2xkLCBtZWFzdXJlZCBpbiBkZWdyZWVzLCB0aGF0IGRldGVybWluZXMgd2hlbiB0aGUgbWFwJ3NcbiAqICAgYmVhcmluZyAocm90YXRpb24pIHdpbGwgc25hcCB0byBub3J0aC5cbiAqL1xuZnVuY3Rpb24gRHJhZ1JvdGF0ZUhhbmRsZXIobWFwLCBvcHRpb25zKSB7XG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHRoaXMuX2VsID0gbWFwLmdldENhbnZhc0NvbnRhaW5lcigpO1xuICAgIHRoaXMuX2JlYXJpbmdTbmFwID0gb3B0aW9ucy5iZWFyaW5nU25hcDtcblxuICAgIHV0aWwuYmluZEhhbmRsZXJzKHRoaXMpO1xufVxuXG5EcmFnUm90YXRlSGFuZGxlci5wcm90b3R5cGUgPSB7XG5cbiAgICBfZW5hYmxlZDogZmFsc2UsXG4gICAgX2FjdGl2ZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIFwiZHJhZyB0byByb3RhdGVcIiBpbnRlcmFjdGlvbiBpcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgXCJkcmFnIHRvIHJvdGF0ZVwiIGludGVyYWN0aW9uIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIFwiZHJhZyB0byByb3RhdGVcIiBpbnRlcmFjdGlvbiBpcyBhY3RpdmUsIGkuZS4gY3VycmVudGx5IGJlaW5nIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBcImRyYWcgdG8gcm90YXRlXCIgaW50ZXJhY3Rpb24gaXMgYWN0aXZlLlxuICAgICAqL1xuICAgIGlzQWN0aXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIFwiZHJhZyB0byByb3RhdGVcIiBpbnRlcmFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbWFwLmRyYWdSb3RhdGUuZW5hYmxlKCk7XG4gICAgICovXG4gICAgZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCgpKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2VsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uRG93bik7XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyB0aGUgXCJkcmFnIHRvIHJvdGF0ZVwiIGludGVyYWN0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBtYXAuZHJhZ1JvdGF0ZS5kaXNhYmxlKCk7XG4gICAgICovXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNFbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5fZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Eb3duKTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBfb25Eb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAodGhpcy5faWdub3JlRXZlbnQoZSkpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkgcmV0dXJuO1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vblVwKTtcblxuICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5lcnRpYSA9IFtbRGF0ZS5ub3coKSwgdGhpcy5fbWFwLmdldEJlYXJpbmcoKV1dO1xuICAgICAgICB0aGlzLl9zdGFydFBvcyA9IHRoaXMuX3BvcyA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZSk7XG4gICAgICAgIHRoaXMuX2NlbnRlciA9IHRoaXMuX21hcC50cmFuc2Zvcm0uY2VudGVyUG9pbnQ7ICAvLyBDZW50ZXIgb2Ygcm90YXRpb25cblxuICAgICAgICAvLyBJZiB0aGUgZmlyc3QgY2xpY2sgd2FzIHRvbyBjbG9zZSB0byB0aGUgY2VudGVyLCBtb3ZlIHRoZSBjZW50ZXIgb2Ygcm90YXRpb24gYnkgMjAwIHBpeGVsc1xuICAgICAgICAvLyBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBjbGljay5cbiAgICAgICAgdmFyIHN0YXJ0VG9DZW50ZXIgPSB0aGlzLl9zdGFydFBvcy5zdWIodGhpcy5fY2VudGVyKSxcbiAgICAgICAgICAgIHN0YXJ0VG9DZW50ZXJEaXN0ID0gc3RhcnRUb0NlbnRlci5tYWcoKTtcblxuICAgICAgICBpZiAoc3RhcnRUb0NlbnRlckRpc3QgPCAyMDApIHtcbiAgICAgICAgICAgIHRoaXMuX2NlbnRlciA9IHRoaXMuX3N0YXJ0UG9zLmFkZChuZXcgUG9pbnQoLTIwMCwgMCkuX3JvdGF0ZShzdGFydFRvQ2VudGVyLmFuZ2xlKCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgX29uTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lnbm9yZUV2ZW50KGUpKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ3JvdGF0ZXN0YXJ0JywgZSk7XG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ21vdmVzdGFydCcsIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgbWFwLnN0b3AoKTtcblxuICAgICAgICB2YXIgcDEgPSB0aGlzLl9wb3MsXG4gICAgICAgICAgICBwMiA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZSksXG4gICAgICAgICAgICBjZW50ZXIgPSB0aGlzLl9jZW50ZXIsXG4gICAgICAgICAgICBiZWFyaW5nRGlmZiA9IHAxLnN1YihjZW50ZXIpLmFuZ2xlV2l0aChwMi5zdWIoY2VudGVyKSkgLyBNYXRoLlBJICogMTgwLFxuICAgICAgICAgICAgYmVhcmluZyA9IG1hcC5nZXRCZWFyaW5nKCkgLSBiZWFyaW5nRGlmZixcbiAgICAgICAgICAgIGluZXJ0aWEgPSB0aGlzLl9pbmVydGlhLFxuICAgICAgICAgICAgbGFzdCA9IGluZXJ0aWFbaW5lcnRpYS5sZW5ndGggLSAxXTtcblxuICAgICAgICB0aGlzLl9kcmFpbkluZXJ0aWFCdWZmZXIoKTtcbiAgICAgICAgaW5lcnRpYS5wdXNoKFtEYXRlLm5vdygpLCBtYXAuX25vcm1hbGl6ZUJlYXJpbmcoYmVhcmluZywgbGFzdFsxXSldKTtcblxuICAgICAgICBtYXAudHJhbnNmb3JtLmJlYXJpbmcgPSBiZWFyaW5nO1xuXG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudCgncm90YXRlJywgZSk7XG4gICAgICAgIHRoaXMuX2ZpcmVFdmVudCgnbW92ZScsIGUpO1xuXG4gICAgICAgIHRoaXMuX3BvcyA9IHAyO1xuICAgIH0sXG5cbiAgICBfb25VcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lnbm9yZUV2ZW50KGUpKSByZXR1cm47XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vblVwKTtcblxuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUoKSkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9maXJlRXZlbnQoJ3JvdGF0ZWVuZCcsIGUpO1xuICAgICAgICB0aGlzLl9kcmFpbkluZXJ0aWFCdWZmZXIoKTtcblxuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwLFxuICAgICAgICAgICAgbWFwQmVhcmluZyA9IG1hcC5nZXRCZWFyaW5nKCksXG4gICAgICAgICAgICBpbmVydGlhID0gdGhpcy5faW5lcnRpYTtcblxuICAgICAgICB2YXIgZmluaXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobWFwQmVhcmluZykgPCB0aGlzLl9iZWFyaW5nU25hcCkge1xuICAgICAgICAgICAgICAgIG1hcC5yZXNldE5vcnRoKHtub01vdmVTdGFydDogdHJ1ZX0sIHsgb3JpZ2luYWxFdmVudDogZSB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCdtb3ZlZW5kJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICBpZiAoaW5lcnRpYS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaXJzdCA9IGluZXJ0aWFbMF0sXG4gICAgICAgICAgICBsYXN0ID0gaW5lcnRpYVtpbmVydGlhLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcHJldmlvdXMgPSBpbmVydGlhW2luZXJ0aWEubGVuZ3RoIC0gMl0sXG4gICAgICAgICAgICBiZWFyaW5nID0gbWFwLl9ub3JtYWxpemVCZWFyaW5nKG1hcEJlYXJpbmcsIHByZXZpb3VzWzFdKSxcbiAgICAgICAgICAgIGZsaW5nRGlmZiA9IGxhc3RbMV0gLSBmaXJzdFsxXSxcbiAgICAgICAgICAgIHNpZ24gPSBmbGluZ0RpZmYgPCAwID8gLTEgOiAxLFxuICAgICAgICAgICAgZmxpbmdEdXJhdGlvbiA9IChsYXN0WzBdIC0gZmlyc3RbMF0pIC8gMTAwMDtcblxuICAgICAgICBpZiAoZmxpbmdEaWZmID09PSAwIHx8IGZsaW5nRHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgICAgIGZpbmlzaCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNwZWVkID0gTWF0aC5hYnMoZmxpbmdEaWZmICogKGluZXJ0aWFMaW5lYXJpdHkgLyBmbGluZ0R1cmF0aW9uKSk7ICAvLyBkZWcvc1xuICAgICAgICBpZiAoc3BlZWQgPiBpbmVydGlhTWF4U3BlZWQpIHtcbiAgICAgICAgICAgIHNwZWVkID0gaW5lcnRpYU1heFNwZWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGR1cmF0aW9uID0gc3BlZWQgLyAoaW5lcnRpYURlY2VsZXJhdGlvbiAqIGluZXJ0aWFMaW5lYXJpdHkpLFxuICAgICAgICAgICAgb2Zmc2V0ID0gc2lnbiAqIHNwZWVkICogKGR1cmF0aW9uIC8gMik7XG5cbiAgICAgICAgYmVhcmluZyArPSBvZmZzZXQ7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKG1hcC5fbm9ybWFsaXplQmVhcmluZyhiZWFyaW5nLCAwKSkgPCB0aGlzLl9iZWFyaW5nU25hcCkge1xuICAgICAgICAgICAgYmVhcmluZyA9IG1hcC5fbm9ybWFsaXplQmVhcmluZygwLCBiZWFyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcC5yb3RhdGVUbyhiZWFyaW5nLCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24gKiAxMDAwLFxuICAgICAgICAgICAgZWFzaW5nOiBpbmVydGlhRWFzaW5nLFxuICAgICAgICAgICAgbm9Nb3ZlU3RhcnQ6IHRydWVcbiAgICAgICAgfSwgeyBvcmlnaW5hbEV2ZW50OiBlIH0pO1xuICAgIH0sXG5cbiAgICBfZmlyZUV2ZW50OiBmdW5jdGlvbiAodHlwZSwgZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmZpcmUodHlwZSwgeyBvcmlnaW5hbEV2ZW50OiBlIH0pO1xuICAgIH0sXG5cbiAgICBfaWdub3JlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgaWYgKG1hcC5ib3hab29tICYmIG1hcC5ib3hab29tLmlzQWN0aXZlKCkpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAobWFwLmRyYWdQYW4gJiYgbWFwLmRyYWdQYW4uaXNBY3RpdmUoKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChlLnRvdWNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGJ1dHRvbnMgPSAoZS5jdHJsS2V5ID8gMSA6IDIpLCAgLy8gPyBjdHJsK2xlZnQgYnV0dG9uIDogcmlnaHQgYnV0dG9uXG4gICAgICAgICAgICAgICAgYnV0dG9uID0gKGUuY3RybEtleSA/IDAgOiAyKTsgICAvLyA/IGN0cmwrbGVmdCBidXR0b24gOiByaWdodCBidXR0b25cbiAgICAgICAgICAgIHJldHVybiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJyA/IGUuYnV0dG9ucyAmIGJ1dHRvbnMgPT09IDAgOiBlLmJ1dHRvbiAhPT0gYnV0dG9uKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZHJhaW5JbmVydGlhQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmVydGlhID0gdGhpcy5faW5lcnRpYSxcbiAgICAgICAgICAgIG5vdyA9IERhdGUubm93KCksXG4gICAgICAgICAgICBjdXRvZmYgPSAxNjA7ICAgLy9tc2VjXG5cbiAgICAgICAgd2hpbGUgKGluZXJ0aWEubGVuZ3RoID4gMCAmJiBub3cgLSBpbmVydGlhWzBdWzBdID4gY3V0b2ZmKVxuICAgICAgICAgICAgaW5lcnRpYS5zaGlmdCgpO1xuICAgIH1cblxufTtcblxuXG4vKipcbiAqIEZpcmVkIHdoZW4gYSBcImRyYWcgdG8gcm90YXRlXCIgaW50ZXJhY3Rpb24gc3RhcnRzLiBTZWUgW2BEcmFnUm90YXRlSGFuZGxlcmBdKCNEcmFnUm90YXRlSGFuZGxlcikuXG4gKlxuICogQGV2ZW50IHJvdGF0ZXN0YXJ0XG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7TWFwTW91c2VFdmVudCB8IE1hcFRvdWNoRXZlbnR9IGRhdGFcbiAqL1xuXG4vKipcbiAqIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGEgXCJkcmFnIHRvIHJvdGF0ZVwiIGludGVyYWN0aW9uLiBTZWUgW2BEcmFnUm90YXRlSGFuZGxlcmBdKCNEcmFnUm90YXRlSGFuZGxlcikuXG4gKlxuICogQGV2ZW50IHJvdGF0ZVxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge01hcE1vdXNlRXZlbnQgfCBNYXBUb3VjaEV2ZW50fSBkYXRhXG4gKi9cblxuLyoqXG4gKiBGaXJlZCB3aGVuIGEgXCJkcmFnIHRvIHJvdGF0ZVwiIGludGVyYWN0aW9uIGVuZHMuIFNlZSBbYERyYWdSb3RhdGVIYW5kbGVyYF0oI0RyYWdSb3RhdGVIYW5kbGVyKS5cbiAqXG4gKiBAZXZlbnQgcm90YXRlZW5kXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7TWFwTW91c2VFdmVudCB8IE1hcFRvdWNoRXZlbnR9IGRhdGFcbiAqL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleWJvYXJkSGFuZGxlcjtcblxuXG52YXIgcGFuRGVsdGEgPSA4MCxcbiAgICByb3RhdGVEZWx0YSA9IDIsXG4gICAgcGl0Y2hEZWx0YSA9IDU7XG5cbi8qKlxuICogVGhlIGBLZXlib2FyZEhhbmRsZXJgIGFsbG93cyB0aGUgdXNlciB0byB6b29tLCByb3RhdGUsIGFuZCBwYW4gdGhlIG1hcCB1c2luZ1xuICogdGhlIGZvbGxvd2luZyBrZXlib2FyZCBzaG9ydGN1dHM6XG4gKlxuICogLSBgPWAgLyBgK2A6IEluY3JlYXNlIHRoZSB6b29tIGxldmVsIGJ5IDEuXG4gKiAtIGBTaGlmdC09YCAvIGBTaGlmdC0rYDogSW5jcmVhc2UgdGhlIHpvb20gbGV2ZWwgYnkgMi5cbiAqIC0gYC1gOiBEZWNyZWFzZSB0aGUgem9vbSBsZXZlbCBieSAxLlxuICogLSBgU2hpZnQtLWA6IERlY3JlYXNlIHRoZSB6b29tIGxldmVsIGJ5IDIuXG4gKiAtIEFycm93IGtleXM6IFBhbiBieSA4MCBwaXhlbHMuXG4gKiAtIGBTaGlmdCvih6JgOiBJbmNyZWFzZSB0aGUgcm90YXRpb24gYnkgMiBkZWdyZWVzLlxuICogLSBgU2hpZnQr4oegYDogRGVjcmVhc2UgdGhlIHJvdGF0aW9uIGJ5IDIgZGVncmVlcy5cbiAqIC0gYFNoaWZ0K+KHoWA6IEluY3JlYXNlIHRoZSBwaXRjaCBieSA1IGRlZ3JlZXMuXG4gKiAtIGBTaGlmdCvih6NgOiBEZWNyZWFzZSB0aGUgcGl0Y2ggYnkgNSBkZWdyZWVzLlxuICpcbiAqIEBjbGFzcyBLZXlib2FyZEhhbmRsZXJcbiAqIEBwYXJhbSB7TWFwfSBtYXAgVGhlIE1hcGJveCBHTCBKUyBtYXAgdG8gYWRkIHRoZSBoYW5kbGVyIHRvLlxuICovXG5mdW5jdGlvbiBLZXlib2FyZEhhbmRsZXIobWFwKSB7XG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHRoaXMuX2VsID0gbWFwLmdldENhbnZhc0NvbnRhaW5lcigpO1xuXG4gICAgdGhpcy5fb25LZXlEb3duID0gdGhpcy5fb25LZXlEb3duLmJpbmQodGhpcyk7XG59XG5cbktleWJvYXJkSGFuZGxlci5wcm90b3R5cGUgPSB7XG5cbiAgICBfZW5hYmxlZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIga2V5Ym9hcmQgaW50ZXJhY3Rpb24gaXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYga2V5Ym9hcmQgaW50ZXJhY3Rpb24gaXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMga2V5Ym9hcmQgaW50ZXJhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG1hcC5rZXlib2FyZC5lbmFibGUoKTtcbiAgICAgKi9cbiAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5fZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMga2V5Ym9hcmQgaW50ZXJhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG1hcC5rZXlib2FyZC5kaXNhYmxlKCk7XG4gICAgICovXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNFbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5fZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93bik7XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgX29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkpIHJldHVybjtcblxuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwLFxuICAgICAgICAgICAgZXZlbnREYXRhID0geyBvcmlnaW5hbEV2ZW50OiBlIH07XG5cbiAgICAgICAgaWYgKG1hcC5pc0Vhc2luZygpKSByZXR1cm47XG5cbiAgICAgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSA2MTpcbiAgICAgICAgY2FzZSAxMDc6XG4gICAgICAgIGNhc2UgMTcxOlxuICAgICAgICBjYXNlIDE4NzpcbiAgICAgICAgICAgIG1hcC56b29tVG8oTWF0aC5yb3VuZChtYXAuZ2V0Wm9vbSgpKSArIChlLnNoaWZ0S2V5ID8gMiA6IDEpLCBldmVudERhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxODk6XG4gICAgICAgIGNhc2UgMTA5OlxuICAgICAgICBjYXNlIDE3MzpcbiAgICAgICAgICAgIG1hcC56b29tVG8oTWF0aC5yb3VuZChtYXAuZ2V0Wm9vbSgpKSAtIChlLnNoaWZ0S2V5ID8gMiA6IDEpLCBldmVudERhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgbWFwLmVhc2VUbyh7IGJlYXJpbmc6IG1hcC5nZXRCZWFyaW5nKCkgLSByb3RhdGVEZWx0YSB9LCBldmVudERhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgbWFwLnBhbkJ5KFstcGFuRGVsdGEsIDBdLCBldmVudERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgbWFwLmVhc2VUbyh7IGJlYXJpbmc6IG1hcC5nZXRCZWFyaW5nKCkgKyByb3RhdGVEZWx0YSB9LCBldmVudERhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgbWFwLnBhbkJ5KFtwYW5EZWx0YSwgMF0sIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICBtYXAuZWFzZVRvKHsgcGl0Y2g6IG1hcC5nZXRQaXRjaCgpICsgcGl0Y2hEZWx0YSB9LCBldmVudERhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgbWFwLnBhbkJ5KFswLCAtcGFuRGVsdGFdLCBldmVudERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgbWFwLmVhc2VUbyh7IHBpdGNoOiBNYXRoLm1heChtYXAuZ2V0UGl0Y2goKSAtIHBpdGNoRGVsdGEsIDApIH0sIGV2ZW50RGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBtYXAucGFuQnkoWzAsIHBhbkRlbHRhXSwgZXZlbnREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERPTSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZG9tJyksXG4gICAgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvYnJvd3NlcicpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY3JvbGxab29tSGFuZGxlcjtcblxuXG52YXIgdWEgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSA6ICcnLFxuICAgIGZpcmVmb3ggPSB1YS5pbmRleE9mKCdmaXJlZm94JykgIT09IC0xLFxuICAgIHNhZmFyaSA9IHVhLmluZGV4T2YoJ3NhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdjaHJvbScpID09PSAtMTtcblxuXG4vKipcbiAqIFRoZSBgU2Nyb2xsWm9vbUhhbmRsZXJgIGFsbG93cyB0aGUgdXNlciB0byB6b29tIHRoZSBtYXAgYnkgc2Nyb2xsaW5nLlxuICpcbiAqIEBjbGFzcyBTY3JvbGxab29tSGFuZGxlclxuICogQHBhcmFtIHtNYXB9IG1hcCBUaGUgTWFwYm94IEdMIEpTIG1hcCB0byBhZGQgdGhlIGhhbmRsZXIgdG8uXG4gKi9cbmZ1bmN0aW9uIFNjcm9sbFpvb21IYW5kbGVyKG1hcCkge1xuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB0aGlzLl9lbCA9IG1hcC5nZXRDYW52YXNDb250YWluZXIoKTtcblxuICAgIHV0aWwuYmluZEhhbmRsZXJzKHRoaXMpO1xufVxuXG5TY3JvbGxab29tSGFuZGxlci5wcm90b3R5cGUgPSB7XG5cbiAgICBfZW5hYmxlZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIFwic2Nyb2xsIHRvIHpvb21cIiBpbnRlcmFjdGlvbiBpcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgXCJzY3JvbGwgdG8gem9vbVwiIGludGVyYWN0aW9uIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSBcInNjcm9sbCB0byB6b29tXCIgaW50ZXJhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgbWFwLnNjcm9sbFpvb20uZW5hYmxlKCk7XG4gICAgICovXG4gICAgZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCgpKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2VsLmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5fb25XaGVlbCwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9lbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5fb25XaGVlbCwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgdGhlIFwic2Nyb2xsIHRvIHpvb21cIiBpbnRlcmFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICBtYXAuc2Nyb2xsWm9vbS5kaXNhYmxlKCk7XG4gICAgICovXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNFbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5fZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLl9vbldoZWVsKTtcbiAgICAgICAgdGhpcy5fZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWwpO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIF9vbldoZWVsOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgaWYgKGUudHlwZSA9PT0gJ3doZWVsJykge1xuICAgICAgICAgICAgdmFsdWUgPSBlLmRlbHRhWTtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggZG91YmxlcyB0aGUgdmFsdWVzIG9uIHJldGluYSBzY3JlZW5zLi4uXG4gICAgICAgICAgICBpZiAoZmlyZWZveCAmJiBlLmRlbHRhTW9kZSA9PT0gd2luZG93LldoZWVsRXZlbnQuRE9NX0RFTFRBX1BJWEVMKSB2YWx1ZSAvPSBicm93c2VyLmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgICAgICBpZiAoZS5kZWx0YU1vZGUgPT09IHdpbmRvdy5XaGVlbEV2ZW50LkRPTV9ERUxUQV9MSU5FKSB2YWx1ZSAqPSA0MDtcblxuICAgICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IC1lLndoZWVsRGVsdGFZO1xuICAgICAgICAgICAgaWYgKHNhZmFyaSkgdmFsdWUgPSB2YWx1ZSAvIDM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm93ID0gYnJvd3Nlci5ub3coKSxcbiAgICAgICAgICAgIHRpbWVEZWx0YSA9IG5vdyAtICh0aGlzLl90aW1lIHx8IDApO1xuXG4gICAgICAgIHRoaXMuX3BvcyA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZSk7XG4gICAgICAgIHRoaXMuX3RpbWUgPSBub3c7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSAwICYmICh2YWx1ZSAlIDQuMDAwMjQ0MTQwNjI1KSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gVGhpcyBvbmUgaXMgZGVmaW5pdGVseSBhIG1vdXNlIHdoZWVsIGV2ZW50LlxuICAgICAgICAgICAgdGhpcy5fdHlwZSA9ICd3aGVlbCc7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdGhpcyB2YWx1ZSB0byBtYXRjaCB0cmFja3BhZC5cbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAvIDQpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IDAgJiYgTWF0aC5hYnModmFsdWUpIDwgNCkge1xuICAgICAgICAgICAgLy8gVGhpcyBvbmUgaXMgZGVmaW5pdGVseSBhIHRyYWNrcGFkIGV2ZW50IGJlY2F1c2UgaXQgaXMgc28gc21hbGwuXG4gICAgICAgICAgICB0aGlzLl90eXBlID0gJ3RyYWNrcGFkJztcblxuICAgICAgICB9IGVsc2UgaWYgKHRpbWVEZWx0YSA+IDQwMCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBsaWtlbHkgYSBuZXcgc2Nyb2xsIGFjdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbGFzdFZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IGEgdGltZW91dCBpbiBjYXNlIHRoaXMgd2FzIGEgc2luZ3VsYXIgZXZlbnQsIGFuZCBkZWx5IGl0IGJ5IHVwIHRvIDQwbXMuXG4gICAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl9vblRpbWVvdXQsIDQwKTtcblxuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl90eXBlKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgcmVwZWF0aW5nIGV2ZW50LCBidXQgd2UgZG9uJ3Qga25vdyB0aGUgdHlwZSBvZiBldmVudCBqdXN0IHlldC5cbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWx0YSBwZXIgdGltZSBpcyBzbWFsbCwgd2UgYXNzdW1lIGl0J3MgYSBmYXN0IHRyYWNrcGFkOyBvdGhlcndpc2Ugd2Ugc3dpdGNoIGludG8gd2hlZWwgbW9kZS5cbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPSAoTWF0aC5hYnModGltZURlbHRhICogdmFsdWUpIDwgMjAwKSA/ICd0cmFja3BhZCcgOiAnd2hlZWwnO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgb3VyIGRlbGF5ZWQgZXZlbnQgaXNuJ3QgZmlyZWQgYWdhaW4sIGJlY2F1c2Ugd2UgYWNjdW11bGF0ZVxuICAgICAgICAgICAgLy8gdGhlIHByZXZpb3VzIGV2ZW50ICh3aGljaCB3YXMgbGVzcyB0aGFuIDQwbXMgYWdvKSBpbnRvIHRoaXMgZXZlbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5fdGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSB0aGlzLl9sYXN0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTbG93IGRvd24gem9vbSBpZiBzaGlmdCBrZXkgaXMgaGVsZCBmb3IgbW9yZSBwcmVjaXNlIHpvb21pbmdcbiAgICAgICAgaWYgKGUuc2hpZnRLZXkgJiYgdmFsdWUpIHZhbHVlID0gdmFsdWUgLyA0O1xuXG4gICAgICAgIC8vIE9ubHkgZmlyZSB0aGUgY2FsbGJhY2sgaWYgd2UgYWN0dWFsbHkga25vdyB3aGF0IHR5cGUgb2Ygc2Nyb2xsaW5nIGRldmljZSB0aGUgdXNlciB1c2VzLlxuICAgICAgICBpZiAodGhpcy5fdHlwZSkgdGhpcy5fem9vbSgtdmFsdWUsIGUpO1xuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgX29uVGltZW91dDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90eXBlID0gJ3doZWVsJztcbiAgICAgICAgdGhpcy5fem9vbSgtdGhpcy5fbGFzdFZhbHVlKTtcbiAgICB9LFxuXG4gICAgX3pvb206IGZ1bmN0aW9uIChkZWx0YSwgZSkge1xuICAgICAgICBpZiAoZGVsdGEgPT09IDApIHJldHVybjtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblxuICAgICAgICAvLyBTY2FsZSBieSBzaWdtb2lkIG9mIHNjcm9sbCB3aGVlbCBkZWx0YS5cbiAgICAgICAgdmFyIHNjYWxlID0gMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGRlbHRhIC8gMTAwKSkpO1xuICAgICAgICBpZiAoZGVsdGEgPCAwICYmIHNjYWxlICE9PSAwKSBzY2FsZSA9IDEgLyBzY2FsZTtcblxuICAgICAgICB2YXIgZnJvbVNjYWxlID0gbWFwLmVhc2UgPyBtYXAuZWFzZS50byA6IG1hcC50cmFuc2Zvcm0uc2NhbGUsXG4gICAgICAgICAgICB0YXJnZXRab29tID0gbWFwLnRyYW5zZm9ybS5zY2FsZVpvb20oZnJvbVNjYWxlICogc2NhbGUpO1xuXG4gICAgICAgIG1hcC56b29tVG8odGFyZ2V0Wm9vbSwge1xuICAgICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgICBhcm91bmQ6IG1hcC51bnByb2plY3QodGhpcy5fcG9zKSxcbiAgICAgICAgICAgIGRlbGF5RW5kRXZlbnRzOiAyMDBcbiAgICAgICAgfSwgeyBvcmlnaW5hbEV2ZW50OiBlIH0pO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBGaXJlZCBqdXN0IGJlZm9yZSB0aGUgbWFwIGJlZ2lucyBhIHRyYW5zaXRpb24gZnJvbSBvbmUgem9vbSBsZXZlbCB0byBhbm90aGVyLFxuICogYXMgdGhlIHJlc3VsdCBvZiBlaXRoZXIgdXNlciBpbnRlcmFjdGlvbiBvciBtZXRob2RzIHN1Y2ggYXMgW01hcCNmbHlUb10oI01hcCNmbHlUbykuXG4gKlxuICogQGV2ZW50IHpvb21zdGFydFxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge01hcE1vdXNlRXZlbnQgfCBNYXBUb3VjaEV2ZW50fSBkYXRhXG4gKi9cblxuLyoqXG4gKiBGaXJlZCByZXBlYXRlZGx5IGR1cmluZyBhbiBhbmltYXRlZCB0cmFuc2l0aW9uIGZyb20gb25lIHpvb20gbGV2ZWwgdG8gYW5vdGhlcixcbiAqIGFzIHRoZSByZXN1bHQgb2YgZWl0aGVyIHVzZXIgaW50ZXJhY3Rpb24gb3IgbWV0aG9kcyBzdWNoIGFzIFtNYXAjZmx5VG9dKCNNYXAjZmx5VG8pLlxuICpcbiAqIEBldmVudCB6b29tXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7TWFwTW91c2VFdmVudCB8IE1hcFRvdWNoRXZlbnR9IGRhdGFcbiAqL1xuXG4vKipcbiAqIEZpcmVkIGp1c3QgYWZ0ZXIgdGhlIG1hcCBjb21wbGV0ZXMgYSB0cmFuc2l0aW9uIGZyb20gb25lIHpvb20gbGV2ZWwgdG8gYW5vdGhlcixcbiAqIGFzIHRoZSByZXN1bHQgb2YgZWl0aGVyIHVzZXIgaW50ZXJhY3Rpb24gb3IgbWV0aG9kcyBzdWNoIGFzIFtNYXAjZmx5VG9dKCNNYXAjZmx5VG8pLlxuICpcbiAqIEBldmVudCB6b29tZW5kXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7TWFwTW91c2VFdmVudCB8IE1hcFRvdWNoRXZlbnR9IGRhdGFcbiAqL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9kb20nKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbC91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVG91Y2hab29tUm90YXRlSGFuZGxlcjtcblxudmFyIGluZXJ0aWFMaW5lYXJpdHkgPSAwLjE1LFxuICAgIGluZXJ0aWFFYXNpbmcgPSB1dGlsLmJlemllcigwLCAwLCBpbmVydGlhTGluZWFyaXR5LCAxKSxcbiAgICBpbmVydGlhRGVjZWxlcmF0aW9uID0gMTIsIC8vIHNjYWxlIC8gc14yXG4gICAgaW5lcnRpYU1heFNwZWVkID0gMi41LCAvLyBzY2FsZSAvIHNcbiAgICBzaWduaWZpY2FudFNjYWxlVGhyZXNob2xkID0gMC4xNSxcbiAgICBzaWduaWZpY2FudFJvdGF0ZVRocmVzaG9sZCA9IDQ7XG5cblxuLyoqXG4gKiBUaGUgYFRvdWNoWm9vbVJvdGF0ZUhhbmRsZXJgIGFsbG93cyB0aGUgdXNlciB0byB6b29tIGFuZCByb3RhdGUgdGhlIG1hcCBieVxuICogcGluY2hpbmcgb24gYSB0b3VjaHNjcmVlbi5cbiAqXG4gKiBAY2xhc3MgVG91Y2hab29tUm90YXRlSGFuZGxlclxuICogQHBhcmFtIHtNYXB9IG1hcCBUaGUgTWFwYm94IEdMIEpTIG1hcCB0byBhZGQgdGhlIGhhbmRsZXIgdG8uXG4gKi9cbmZ1bmN0aW9uIFRvdWNoWm9vbVJvdGF0ZUhhbmRsZXIobWFwKSB7XG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHRoaXMuX2VsID0gbWFwLmdldENhbnZhc0NvbnRhaW5lcigpO1xuXG4gICAgdXRpbC5iaW5kSGFuZGxlcnModGhpcyk7XG59XG5cblRvdWNoWm9vbVJvdGF0ZUhhbmRsZXIucHJvdG90eXBlID0ge1xuXG4gICAgX2VuYWJsZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBcInBpbmNoIHRvIHJvdGF0ZSBhbmQgem9vbVwiIGludGVyYWN0aW9uIGlzIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBcInBpbmNoIHRvIHJvdGF0ZSBhbmQgem9vbVwiIGludGVyYWN0aW9uIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgaXNFbmFibGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSBcInBpbmNoIHRvIHJvdGF0ZSBhbmQgem9vbVwiIGludGVyYWN0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgIG1hcC50b3VjaFpvb21Sb3RhdGUuZW5hYmxlKCk7XG4gICAgICovXG4gICAgZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCgpKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2VsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblN0YXJ0LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyB0aGUgXCJwaW5jaCB0byByb3RhdGUgYW5kIHpvb21cIiBpbnRlcmFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICBtYXAudG91Y2hab29tUm90YXRlLmRpc2FibGUoKTtcbiAgICAgKi9cbiAgICBkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0VuYWJsZWQoKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9lbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25TdGFydCk7XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgdGhlIFwicGluY2ggdG8gcm90YXRlXCIgaW50ZXJhY3Rpb24sIGxlYXZpbmcgdGhlIFwicGluY2ggdG8gem9vbVwiXG4gICAgICogaW50ZXJhY3Rpb24gZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICBtYXAudG91Y2hab29tUm90YXRlLmRpc2FibGVSb3RhdGlvbigpO1xuICAgICAqL1xuICAgIGRpc2FibGVSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3JvdGF0aW9uRGlzYWJsZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSBcInBpbmNoIHRvIHJvdGF0ZVwiIGludGVyYWN0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgIG1hcC50b3VjaFpvb21Sb3RhdGUuZW5hYmxlKCk7XG4gICAgICogICBtYXAudG91Y2hab29tUm90YXRlLmVuYWJsZVJvdGF0aW9uKCk7XG4gICAgICovXG4gICAgZW5hYmxlUm90YXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9yb3RhdGlvbkRpc2FibGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIF9vblN0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCAhPT0gMikgcmV0dXJuO1xuXG4gICAgICAgIHZhciBwMCA9IERPTS5tb3VzZVBvcyh0aGlzLl9lbCwgZS50b3VjaGVzWzBdKSxcbiAgICAgICAgICAgIHAxID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlLnRvdWNoZXNbMV0pO1xuXG4gICAgICAgIHRoaXMuX3N0YXJ0VmVjID0gcDAuc3ViKHAxKTtcbiAgICAgICAgdGhpcy5fc3RhcnRTY2FsZSA9IHRoaXMuX21hcC50cmFuc2Zvcm0uc2NhbGU7XG4gICAgICAgIHRoaXMuX3N0YXJ0QmVhcmluZyA9IHRoaXMuX21hcC50cmFuc2Zvcm0uYmVhcmluZztcbiAgICAgICAgdGhpcy5fZ2VzdHVyZUludGVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faW5lcnRpYSA9IFtdO1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgZmFsc2UpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uRW5kLCBmYWxzZSk7XG4gICAgfSxcblxuICAgIF9vbk1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoICE9PSAyKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHAwID0gRE9NLm1vdXNlUG9zKHRoaXMuX2VsLCBlLnRvdWNoZXNbMF0pLFxuICAgICAgICAgICAgcDEgPSBET00ubW91c2VQb3ModGhpcy5fZWwsIGUudG91Y2hlc1sxXSksXG4gICAgICAgICAgICBwID0gcDAuYWRkKHAxKS5kaXYoMiksXG4gICAgICAgICAgICB2ZWMgPSBwMC5zdWIocDEpLFxuICAgICAgICAgICAgc2NhbGUgPSB2ZWMubWFnKCkgLyB0aGlzLl9zdGFydFZlYy5tYWcoKSxcbiAgICAgICAgICAgIGJlYXJpbmcgPSB0aGlzLl9yb3RhdGlvbkRpc2FibGVkID8gMCA6IHZlYy5hbmdsZVdpdGgodGhpcy5fc3RhcnRWZWMpICogMTgwIC8gTWF0aC5QSSxcbiAgICAgICAgICAgIG1hcCA9IHRoaXMuX21hcDtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgJ2ludGVudCcgYnkgd2hpY2hldmVyIHRocmVzaG9sZCBpcyBzdXJwYXNzZWQgZmlyc3QsXG4gICAgICAgIC8vIHRoZW4ga2VlcCB0aGF0IHN0YXRlIGZvciB0aGUgZHVyYXRpb24gb2YgdGhpcyBnZXN0dXJlLlxuICAgICAgICBpZiAoIXRoaXMuX2dlc3R1cmVJbnRlbnQpIHtcbiAgICAgICAgICAgIHZhciBzY2FsaW5nU2lnbmlmaWNhbnRseSA9IChNYXRoLmFicygxIC0gc2NhbGUpID4gc2lnbmlmaWNhbnRTY2FsZVRocmVzaG9sZCksXG4gICAgICAgICAgICAgICAgcm90YXRpbmdTaWduaWZpY2FudGx5ID0gKE1hdGguYWJzKGJlYXJpbmcpID4gc2lnbmlmaWNhbnRSb3RhdGVUaHJlc2hvbGQpO1xuXG4gICAgICAgICAgICBpZiAocm90YXRpbmdTaWduaWZpY2FudGx5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2VzdHVyZUludGVudCA9ICdyb3RhdGUnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzY2FsaW5nU2lnbmlmaWNhbnRseSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dlc3R1cmVJbnRlbnQgPSAnem9vbSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXN0dXJlSW50ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRWZWMgPSB2ZWM7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRTY2FsZSA9IG1hcC50cmFuc2Zvcm0uc2NhbGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRCZWFyaW5nID0gbWFwLnRyYW5zZm9ybS5iZWFyaW5nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSB7IGR1cmF0aW9uOiAwLCBhcm91bmQ6IG1hcC51bnByb2plY3QocCkgfTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2dlc3R1cmVJbnRlbnQgPT09ICdyb3RhdGUnKSB7XG4gICAgICAgICAgICAgICAgcGFyYW0uYmVhcmluZyA9IHRoaXMuX3N0YXJ0QmVhcmluZyArIGJlYXJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fZ2VzdHVyZUludGVudCA9PT0gJ3pvb20nIHx8IHRoaXMuX2dlc3R1cmVJbnRlbnQgPT09ICdyb3RhdGUnKSB7XG4gICAgICAgICAgICAgICAgcGFyYW0uem9vbSA9IG1hcC50cmFuc2Zvcm0uc2NhbGVab29tKHRoaXMuX3N0YXJ0U2NhbGUgKiBzY2FsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hcC5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9kcmFpbkluZXJ0aWFCdWZmZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2luZXJ0aWEucHVzaChbRGF0ZS5ub3coKSwgc2NhbGUsIHBdKTtcblxuICAgICAgICAgICAgbWFwLmVhc2VUbyhwYXJhbSwgeyBvcmlnaW5hbEV2ZW50OiBlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBfb25FbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25FbmQpO1xuICAgICAgICB0aGlzLl9kcmFpbkluZXJ0aWFCdWZmZXIoKTtcblxuICAgICAgICB2YXIgaW5lcnRpYSA9IHRoaXMuX2luZXJ0aWEsXG4gICAgICAgICAgICBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgaWYgKGluZXJ0aWEubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgbWFwLnNuYXBUb05vcnRoKHt9LCB7IG9yaWdpbmFsRXZlbnQ6IGUgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdCA9IGluZXJ0aWFbaW5lcnRpYS5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIGZpcnN0ID0gaW5lcnRpYVswXSxcbiAgICAgICAgICAgIGxhc3RTY2FsZSA9IG1hcC50cmFuc2Zvcm0uc2NhbGVab29tKHRoaXMuX3N0YXJ0U2NhbGUgKiBsYXN0WzFdKSxcbiAgICAgICAgICAgIGZpcnN0U2NhbGUgPSBtYXAudHJhbnNmb3JtLnNjYWxlWm9vbSh0aGlzLl9zdGFydFNjYWxlICogZmlyc3RbMV0pLFxuICAgICAgICAgICAgc2NhbGVPZmZzZXQgPSBsYXN0U2NhbGUgLSBmaXJzdFNjYWxlLFxuICAgICAgICAgICAgc2NhbGVEdXJhdGlvbiA9IChsYXN0WzBdIC0gZmlyc3RbMF0pIC8gMTAwMCxcbiAgICAgICAgICAgIHAgPSBsYXN0WzJdO1xuXG4gICAgICAgIGlmIChzY2FsZUR1cmF0aW9uID09PSAwIHx8IGxhc3RTY2FsZSA9PT0gZmlyc3RTY2FsZSkge1xuICAgICAgICAgICAgbWFwLnNuYXBUb05vcnRoKHt9LCB7IG9yaWdpbmFsRXZlbnQ6IGUgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxjdWxhdGUgc2NhbGUvcyBzcGVlZCBhbmQgYWRqdXN0IGZvciBpbmNyZWFzZWQgaW5pdGlhbCBhbmltYXRpb24gc3BlZWQgd2hlbiBlYXNpbmdcbiAgICAgICAgdmFyIHNwZWVkID0gc2NhbGVPZmZzZXQgKiBpbmVydGlhTGluZWFyaXR5IC8gc2NhbGVEdXJhdGlvbjsgLy8gc2NhbGUvc1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhzcGVlZCkgPiBpbmVydGlhTWF4U3BlZWQpIHtcbiAgICAgICAgICAgIGlmIChzcGVlZCA+IDApIHtcbiAgICAgICAgICAgICAgICBzcGVlZCA9IGluZXJ0aWFNYXhTcGVlZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3BlZWQgPSAtaW5lcnRpYU1heFNwZWVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGR1cmF0aW9uID0gTWF0aC5hYnMoc3BlZWQgLyAoaW5lcnRpYURlY2VsZXJhdGlvbiAqIGluZXJ0aWFMaW5lYXJpdHkpKSAqIDEwMDAsXG4gICAgICAgICAgICB0YXJnZXRTY2FsZSA9IGxhc3RTY2FsZSArIHNwZWVkICogZHVyYXRpb24gLyAyMDAwO1xuXG4gICAgICAgIGlmICh0YXJnZXRTY2FsZSA8IDApIHtcbiAgICAgICAgICAgIHRhcmdldFNjYWxlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcC5lYXNlVG8oe1xuICAgICAgICAgICAgem9vbTogdGFyZ2V0U2NhbGUsXG4gICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgICBlYXNpbmc6IGluZXJ0aWFFYXNpbmcsXG4gICAgICAgICAgICBhcm91bmQ6IG1hcC51bnByb2plY3QocClcbiAgICAgICAgfSwgeyBvcmlnaW5hbEV2ZW50OiBlIH0pO1xuICAgIH0sXG5cbiAgICBfZHJhaW5JbmVydGlhQnVmZmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGluZXJ0aWEgPSB0aGlzLl9pbmVydGlhLFxuICAgICAgICAgICAgbm93ID0gRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGN1dG9mZiA9IDE2MDsgLy8gbXNlY1xuXG4gICAgICAgIHdoaWxlIChpbmVydGlhLmxlbmd0aCA+IDIgJiYgbm93IC0gaW5lcnRpYVswXVswXSA+IGN1dG9mZikgaW5lcnRpYS5zaGlmdCgpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qXG4gKiBBZGRzIHRoZSBtYXAncyBwb3NpdGlvbiB0byBpdHMgcGFnZSdzIGxvY2F0aW9uIGhhc2guXG4gKiBQYXNzZWQgYXMgYW4gb3B0aW9uIHRvIHRoZSBtYXAgb2JqZWN0LlxuICpcbiAqIEBjbGFzcyBtYXBib3hnbC5IYXNoXG4gKiBAcmV0dXJucyB7SGFzaH0gYHRoaXNgXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcblxuZnVuY3Rpb24gSGFzaCgpIHtcbiAgICB1dGlsLmJpbmRBbGwoW1xuICAgICAgICAnX29uSGFzaENoYW5nZScsXG4gICAgICAgICdfdXBkYXRlSGFzaCdcbiAgICBdLCB0aGlzKTtcbn1cblxuSGFzaC5wcm90b3R5cGUgPSB7XG4gICAgLypcbiAgICAgKiBNYXAgZWxlbWVudCB0byBsaXN0ZW4gZm9yIGNvb3JkaW5hdGUgY2hhbmdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcFxuICAgICAqIEByZXR1cm5zIHtIYXNofSBgdGhpc2BcbiAgICAgKi9cbiAgICBhZGRUbzogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLl9vbkhhc2hDaGFuZ2UsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fbWFwLm9uKCdtb3ZlZW5kJywgdGhpcy5fdXBkYXRlSGFzaCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIFJlbW92ZXMgaGFzaFxuICAgICAqXG4gICAgICogQHJldHVybnMge1BvcHVwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIHRoaXMuX29uSGFzaENoYW5nZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9tYXAub2ZmKCdtb3ZlZW5kJywgdGhpcy5fdXBkYXRlSGFzaCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tYXA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfb25IYXNoQ2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxvYyA9IGxvY2F0aW9uLmhhc2gucmVwbGFjZSgnIycsICcnKS5zcGxpdCgnLycpO1xuICAgICAgICBpZiAobG9jLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuanVtcFRvKHtcbiAgICAgICAgICAgICAgICBjZW50ZXI6IFsrbG9jWzJdLCArbG9jWzFdXSxcbiAgICAgICAgICAgICAgICB6b29tOiArbG9jWzBdLFxuICAgICAgICAgICAgICAgIGJlYXJpbmc6ICsobG9jWzNdIHx8IDApXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZUhhc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5fbWFwLmdldENlbnRlcigpLFxuICAgICAgICAgICAgem9vbSA9IHRoaXMuX21hcC5nZXRab29tKCksXG4gICAgICAgICAgICBiZWFyaW5nID0gdGhpcy5fbWFwLmdldEJlYXJpbmcoKSxcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbChNYXRoLmxvZyh6b29tKSAvIE1hdGguTE4yKSksXG5cbiAgICAgICAgICAgIGhhc2ggPSAnIycgKyAoTWF0aC5yb3VuZCh6b29tICogMTAwKSAvIDEwMCkgK1xuICAgICAgICAgICAgICAgICcvJyArIGNlbnRlci5sYXQudG9GaXhlZChwcmVjaXNpb24pICtcbiAgICAgICAgICAgICAgICAnLycgKyBjZW50ZXIubG5nLnRvRml4ZWQocHJlY2lzaW9uKSArXG4gICAgICAgICAgICAgICAgKGJlYXJpbmcgPyAnLycgKyAoTWF0aC5yb3VuZChiZWFyaW5nICogMTApIC8gMTApIDogJycpO1xuXG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSgnJywgJycsIGhhc2gpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW52YXMgPSByZXF1aXJlKCcuLi91dGlsL2NhbnZhcycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsL3V0aWwnKTtcbnZhciBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJyk7XG52YXIgd2luZG93ID0gcmVxdWlyZSgnLi4vdXRpbC9icm93c2VyJykud2luZG93O1xudmFyIEV2ZW50ZWQgPSByZXF1aXJlKCcuLi91dGlsL2V2ZW50ZWQnKTtcbnZhciBET00gPSByZXF1aXJlKCcuLi91dGlsL2RvbScpO1xuXG52YXIgU3R5bGUgPSByZXF1aXJlKCcuLi9zdHlsZS9zdHlsZScpO1xudmFyIEFuaW1hdGlvbkxvb3AgPSByZXF1aXJlKCcuLi9zdHlsZS9hbmltYXRpb25fbG9vcCcpO1xudmFyIFBhaW50ZXIgPSByZXF1aXJlKCcuLi9yZW5kZXIvcGFpbnRlcicpO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vZ2VvL3RyYW5zZm9ybScpO1xudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKTtcblxudmFyIGJpbmRIYW5kbGVycyA9IHJlcXVpcmUoJy4vYmluZF9oYW5kbGVycycpO1xuXG52YXIgQ2FtZXJhID0gcmVxdWlyZSgnLi9jYW1lcmEnKTtcbnZhciBMbmdMYXQgPSByZXF1aXJlKCcuLi9nZW8vbG5nX2xhdCcpO1xudmFyIExuZ0xhdEJvdW5kcyA9IHJlcXVpcmUoJy4uL2dlby9sbmdfbGF0X2JvdW5kcycpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgncG9pbnQtZ2VvbWV0cnknKTtcbnZhciBBdHRyaWJ1dGlvbiA9IHJlcXVpcmUoJy4vY29udHJvbC9hdHRyaWJ1dGlvbicpO1xudmFyIHBhcnNlQ29sb3IgPSByZXF1aXJlKCcuLi9zdHlsZS9wYXJzZV9jb2xvcicpO1xuXG5cbnZhciBkZWZhdWx0TWluWm9vbSA9IDA7XG52YXIgZGVmYXVsdE1heFpvb20gPSAyMDtcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBjZW50ZXI6IFswLCAwXSxcbiAgICB6b29tOiAwLFxuICAgIGJlYXJpbmc6IDAsXG4gICAgcGl0Y2g6IDAsXG5cbiAgICBsaWdodDoge1xuICAgICAgICBsaWdodEFuY2hvcjogJ3ZpZXdwb3J0JyxcbiAgICAgICAgbGlnaHREaXJlY3Rpb246IFstMC41LCAtMC4zLCAxLjBdLFxuICAgICAgICBsaWdodENvbG9yOiAncmdiYSgxLDEsMSwwLjc1KSdcbiAgICB9LFxuXG4gICAgbWluWm9vbTogZGVmYXVsdE1pblpvb20sXG4gICAgbWF4Wm9vbTogZGVmYXVsdE1heFpvb20sXG5cbiAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcblxuICAgIHNjcm9sbFpvb206IHRydWUsXG4gICAgYm94Wm9vbTogdHJ1ZSxcbiAgICBkcmFnUm90YXRlOiB0cnVlLFxuICAgIGRyYWdQYW46IHRydWUsXG4gICAga2V5Ym9hcmQ6IHRydWUsXG4gICAgZG91YmxlQ2xpY2tab29tOiB0cnVlLFxuICAgIHRvdWNoWm9vbVJvdGF0ZTogdHJ1ZSxcblxuICAgIGJlYXJpbmdTbmFwOiA3LFxuXG4gICAgaGFzaDogZmFsc2UsXG5cbiAgICBhdHRyaWJ1dGlvbkNvbnRyb2w6IHRydWUsXG5cbiAgICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiBmYWxzZSxcbiAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxuXG4gICAgdHJhY2tSZXNpemU6IHRydWUsXG4gICAgd29ya2VyQ291bnQ6IE1hdGgubWF4KGJyb3dzZXIuaGFyZHdhcmVDb25jdXJyZW5jeSAtIDEsIDEpXG59O1xuXG4vKipcbiAqIFRoZSBgTWFwYCBvYmplY3QgcmVwcmVzZW50cyB0aGUgbWFwIG9uIHlvdXIgcGFnZS4gSXQgZXhwb3NlcyBtZXRob2RzXG4gKiBhbmQgcHJvcGVydGllcyB0aGF0IGVuYWJsZSB5b3UgdG8gcHJvZ3JhbW1hdGljYWxseSBjaGFuZ2UgdGhlIG1hcCxcbiAqIGFuZCBmaXJlcyBldmVudHMgYXMgdXNlcnMgaW50ZXJhY3Qgd2l0aCBpdC5cbiAqXG4gKiBZb3UgY3JlYXRlIGEgYE1hcGAgYnkgc3BlY2lmeWluZyBhIGBjb250YWluZXJgIGFuZCBvdGhlciBvcHRpb25zLlxuICogVGhlbiBNYXBib3ggR0wgSlMgaW5pdGlhbGl6ZXMgdGhlIG1hcCBvbiB0aGUgcGFnZSBhbmQgcmV0dXJucyB5b3VyIGBNYXBgXG4gKiBvYmplY3QuXG4gKlxuICogVGhlIGBNYXBgIGNsYXNzIG1peGVzIGluIFtgRXZlbnRlZGBdKCNFdmVudGVkKSBtZXRob2RzLlxuICpcbiAqIEBjbGFzcyBNYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fHN0cmluZ30gb3B0aW9ucy5jb250YWluZXIgVGhlIEhUTUwgZWxlbWVudCBpbiB3aGljaCBNYXBib3ggR0wgSlMgd2lsbCByZW5kZXIgdGhlIG1hcCwgb3IgdGhlIGVsZW1lbnQncyBzdHJpbmcgYGlkYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5taW5ab29tPTBdIFRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCAoMS0yMCkuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4Wm9vbT0yMF0gVGhlIG1heGltdW0gem9vbSBsZXZlbCBvZiB0aGUgbWFwICgxLTIwKS5cbiAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW29wdGlvbnMuc3R5bGVdIFRoZSBtYXAncyBNYXBib3ggc3R5bGUuIFRoaXMgbXVzdCBiZSBhbiBhIEpTT04gb2JqZWN0IGNvbmZvcm1pbmcgdG9cbiAqIHRoZSBzY2hlbWEgZGVzY3JpYmVkIGluIHRoZSBbTWFwYm94IFN0eWxlIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vbWFwYm94LmNvbS9tYXBib3gtZ2wtc3R5bGUtc3BlYy8pLCBvciBhIFVSTCB0b1xuICogc3VjaCBKU09OLlxuICpcbiAqIFRvIGxvYWQgYSBzdHlsZSBmcm9tIHRoZSBNYXBib3ggQVBJLCB5b3UgY2FuIHVzZSBhIFVSTCBvZiB0aGUgZm9ybSBgbWFwYm94Oi8vc3R5bGVzLzpvd25lci86c3R5bGVgLFxuICogd2hlcmUgYDpvd25lcmAgaXMgeW91ciBNYXBib3ggYWNjb3VudCBuYW1lIGFuZCBgOnN0eWxlYCBpcyB0aGUgc3R5bGUgSUQuIE9yIHlvdSBjYW4gdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nXG4gKiBbdGhlIHByZWRlZmluZWQgTWFwYm94IHN0eWxlc10oaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBzLyk6XG4gKlxuICogICogYG1hcGJveDovL3N0eWxlcy9tYXBib3gvc3RyZWV0cy12OWBcbiAqICAqIGBtYXBib3g6Ly9zdHlsZXMvbWFwYm94L291dGRvb3JzLXY5YFxuICogICogYG1hcGJveDovL3N0eWxlcy9tYXBib3gvbGlnaHQtdjlgXG4gKiAgKiBgbWFwYm94Oi8vc3R5bGVzL21hcGJveC9kYXJrLXY5YFxuICogICogYG1hcGJveDovL3N0eWxlcy9tYXBib3gvc2F0ZWxsaXRlLXY5YFxuICogICogYG1hcGJveDovL3N0eWxlcy9tYXBib3gvc2F0ZWxsaXRlLXN0cmVldHMtdjlgXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5oYXNoPWZhbHNlXSBJZiBgdHJ1ZWAsIHRoZSBtYXAncyBwb3NpdGlvbiAoem9vbSwgY2VudGVyIGxhdGl0dWRlLCBjZW50ZXIgbG9uZ2l0dWRlLCBhbmQgYmVhcmluZykgd2lsbCBiZSBzeW5jZWQgd2l0aCB0aGUgaGFzaCBmcmFnbWVudCBvZiB0aGUgcGFnZSdzIFVSTC5cbiAqICAgRm9yIGV4YW1wbGUsIGBodHRwOi8vcGF0aC90by9teS9wYWdlLmh0bWwjMi41OS8zOS4yNi81My4wNy8tMjQuMWAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmludGVyYWN0aXZlPXRydWVdIElmIGBmYWxzZWAsIG5vIG1vdXNlLCB0b3VjaCwgb3Iga2V5Ym9hcmQgbGlzdGVuZXJzIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlIG1hcCwgc28gaXQgd2lsbCBub3QgcmVzcG9uZCB0byBpbnRlcmFjdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5iZWFyaW5nU25hcD03XSBUaGUgdGhyZXNob2xkLCBtZWFzdXJlZCBpbiBkZWdyZWVzLCB0aGF0IGRldGVybWluZXMgd2hlbiB0aGUgbWFwJ3NcbiAqICAgYmVhcmluZyAocm90YXRpb24pIHdpbGwgc25hcCB0byBub3J0aC4gRm9yIGV4YW1wbGUsIHdpdGggYSBgYmVhcmluZ1NuYXBgIG9mIDcsIGlmIHRoZSB1c2VyIHJvdGF0ZXNcbiAqICAgdGhlIG1hcCB3aXRoaW4gNyBkZWdyZWVzIG9mIG5vcnRoLCB0aGUgbWFwIHdpbGwgYXV0b21hdGljYWxseSBzbmFwIHRvIGV4YWN0IG5vcnRoLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbb3B0aW9ucy5jbGFzc2VzXSBNYXBib3ggc3R5bGUgY2xhc3MgbmFtZXMgd2l0aCB3aGljaCB0byBpbml0aWFsaXplIHRoZSBtYXAuXG4gKiAgIEtlZXAgaW4gbWluZCB0aGF0IHRoZXNlIGNsYXNzZXMgYXJlIHVzZWQgZm9yIGNvbnRyb2xsaW5nIGEgc3R5bGUgbGF5ZXIncyBwYWludCBwcm9wZXJ0aWVzLCBzbyBhcmUgKm5vdCogcmVmbGVjdGVkXG4gKiAgIGluIGFuIEhUTUwgZWxlbWVudCdzIGBjbGFzc2AgYXR0cmlidXRlLiBUbyBsZWFybiBtb3JlIGFib3V0IE1hcGJveCBzdHlsZSBjbGFzc2VzLCByZWFkIGFib3V0XG4gKiAgIFtMYXllcnNdKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvI2xheWVycykgaW4gdGhlIHN0eWxlIHNwZWNpZmljYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbD10cnVlXSBJZiBgdHJ1ZWAsIGFuIFtBdHRyaWJ1dGlvbl0oI0F0dHJpYnV0aW9uKSBjb250cm9sIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hcC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdD1mYWxzZV0gSWYgYHRydWVgLCBtYXAgY3JlYXRpb24gd2lsbCBmYWlsIGlmIHRoZSBwZXJmb3JtYW5jZSBvZiBNYXBib3hcbiAqICAgR0wgSlMgd291bGQgYmUgZHJhbWF0aWNhbGx5IHdvcnNlIHRoYW4gZXhwZWN0ZWQgKGkuZS4gYSBzb2Z0d2FyZSByZW5kZXJlciB3b3VsZCBiZSB1c2VkKS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucHJlc2VydmVEcmF3aW5nQnVmZmVyPWZhbHNlXSBJZiBgdHJ1ZWAsIHRoZSBtYXAncyBjYW52YXMgY2FuIGJlIGV4cG9ydGVkIHRvIGEgUE5HIHVzaW5nIGBtYXAuZ2V0Q2FudmFzKCkudG9EYXRhVVJMKClgLiBUaGlzIGlzIGBmYWxzZWAgYnkgZGVmYXVsdCBhcyBhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cbiAqIEBwYXJhbSB7TG5nTGF0Qm91bmRzTGlrZX0gW29wdGlvbnMubWF4Qm91bmRzXSBJZiBzZXQsIHRoZSBtYXAgd2lsbCBiZSBjb25zdHJhaW5lZCB0byB0aGUgZ2l2ZW4gYm91bmRzLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zY3JvbGxab29tPXRydWVdIElmIGB0cnVlYCwgdGhlIFwic2Nyb2xsIHRvIHpvb21cIiBpbnRlcmFjdGlvbiBpcyBlbmFibGVkIChzZWUgW2BTY3JvbGxab29tSGFuZGxlcmBdKCNTY3JvbGxab29tSGFuZGxlcikpLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5ib3hab29tPXRydWVdIElmIGB0cnVlYCwgdGhlIFwiYm94IHpvb21cIiBpbnRlcmFjdGlvbiBpcyBlbmFibGVkIChzZWUgW2BCb3hab29tSGFuZGxlcmBdKCNCb3hab29tSGFuZGxlcikpLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kcmFnUm90YXRlPXRydWVdIElmIGB0cnVlYCwgdGhlIFwiZHJhZyB0byByb3RhdGVcIiBpbnRlcmFjdGlvbiBpcyBlbmFibGVkIChzZWUgW2BEcmFnUm90YXRlSGFuZGxlcmBdKCNEcmFnUm90YXRlSGFuZGxlcikpLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kcmFnUGFuPXRydWVdIElmIGB0cnVlYCwgdGhlIFwiZHJhZyB0byBwYW5cIiBpbnRlcmFjdGlvbiBpcyBlbmFibGVkIChzZWUgW2BEcmFnUGFuSGFuZGxlcmBdKCNEcmFnUGFuSGFuZGxlcikpLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5rZXlib2FyZD10cnVlXSBJZiBgdHJ1ZWAsIGtleWJvYXJkIHNob3J0Y3V0cyBhcmUgZW5hYmxlZCAoc2VlIFtgS2V5Ym9hcmRIYW5kbGVyYF0oI0tleWJvYXJkSGFuZGxlcikpLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kb3VibGVDbGlja1pvb209dHJ1ZV0gSWYgYHRydWVgLCB0aGUgXCJkb3VibGUgY2xpY2sgdG8gem9vbVwiIGludGVyYWN0aW9uIGlzIGVuYWJsZWQgKHNlZSBbYERvdWJsZUNsaWNrWm9vbUhhbmRsZXJgXSgjRG91YmxlQ2xpY2tab29tSGFuZGxlcikpLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50b3VjaFpvb21Sb3RhdGU9dHJ1ZV0gSWYgYHRydWVgLCB0aGUgXCJwaW5jaCB0byByb3RhdGUgYW5kIHpvb21cIiBpbnRlcmFjdGlvbiBpcyBlbmFibGVkIChzZWUgW2BUb3VjaFpvb21Sb3RhdGVIYW5kbGVyYF0oI1RvdWNoWm9vbVJvdGF0ZUhhbmRsZXIpKS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhY2tSZXNpemU9dHJ1ZV0gIElmIGB0cnVlYCwgdGhlIG1hcCB3aWxsIGF1dG9tYXRpY2FsbHkgcmVzaXplIHdoZW4gdGhlIGJyb3dzZXIgd2luZG93IHJlc2l6ZXMuXG4gKiBAcGFyYW0ge0xuZ0xhdExpa2V9IFtvcHRpb25zLmNlbnRlcj1bMCwgMF1dIFRoZSBpbml0YWwgZ2VvZ3JhcGhpY2FsIGNlbnRlcnBvaW50IG9mIHRoZSBtYXAuIElmIGBjZW50ZXJgIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGNvbnN0cnVjdG9yIG9wdGlvbnMsIE1hcGJveCBHTCBKUyB3aWxsIGxvb2sgZm9yIGl0IGluIHRoZSBtYXAncyBzdHlsZSBvYmplY3QuIElmIGl0IGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIHN0eWxlLCBlaXRoZXIsIGl0IHdpbGwgZGVmYXVsdCB0byBgWzAsIDBdYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy56b29tPTBdIFRoZSBpbml0aWFsIHpvb20gbGV2ZWwgb2YgdGhlIG1hcC4gSWYgYHpvb21gIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGNvbnN0cnVjdG9yIG9wdGlvbnMsIE1hcGJveCBHTCBKUyB3aWxsIGxvb2sgZm9yIGl0IGluIHRoZSBtYXAncyBzdHlsZSBvYmplY3QuIElmIGl0IGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIHN0eWxlLCBlaXRoZXIsIGl0IHdpbGwgZGVmYXVsdCB0byBgMGAuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYmVhcmluZz0wXSBUaGUgaW5pdGlhbCBiZWFyaW5nIChyb3RhdGlvbikgb2YgdGhlIG1hcCwgbWVhc3VyZWQgaW4gZGVncmVlcyBjb3VudGVyLWNsb2Nrd2lzZSBmcm9tIG5vcnRoLiBJZiBgYmVhcmluZ2AgaXMgbm90IHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3Igb3B0aW9ucywgTWFwYm94IEdMIEpTIHdpbGwgbG9vayBmb3IgaXQgaW4gdGhlIG1hcCdzIHN0eWxlIG9iamVjdC4gSWYgaXQgaXMgbm90IHNwZWNpZmllZCBpbiB0aGUgc3R5bGUsIGVpdGhlciwgaXQgd2lsbCBkZWZhdWx0IHRvIGAwYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5waXRjaD0wXSBUaGUgaW5pdGlhbCBwaXRjaCAodGlsdCkgb2YgdGhlIG1hcCwgbWVhc3VyZWQgaW4gZGVncmVlcyBhd2F5IGZyb20gdGhlIHBsYW5lIG9mIHRoZSBzY3JlZW4gKDAtNjApLiBJZiBgcGl0Y2hgIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGNvbnN0cnVjdG9yIG9wdGlvbnMsIE1hcGJveCBHTCBKUyB3aWxsIGxvb2sgZm9yIGl0IGluIHRoZSBtYXAncyBzdHlsZSBvYmplY3QuIElmIGl0IGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIHN0eWxlLCBlaXRoZXIsIGl0IHdpbGwgZGVmYXVsdCB0byBgMGAuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud29ya2VyQ291bnQ9bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kgLSAxXSBUaGUgbnVtYmVyIG9mIFdlYldvcmtlcnMgdGhhdCBNYXBib3ggR0wgSlMgc2hvdWxkIHVzZSB0byBwcm9jZXNzIHZlY3RvciB0aWxlIGRhdGEuXG4gKiBAZXhhbXBsZVxuICogdmFyIG1hcCA9IG5ldyBtYXBib3hnbC5NYXAoe1xuICogICBjb250YWluZXI6ICdtYXAnLFxuICogICBjZW50ZXI6IFstMTIyLjQyMDY3OSwgMzcuNzcyNTM3XSxcbiAqICAgem9vbTogMTMsXG4gKiAgIHN0eWxlOiBzdHlsZV9vYmplY3QsXG4gKiAgIGhhc2g6IHRydWVcbiAqIH0pO1xuICovXG52YXIgTWFwID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zLndvcmtlckNvdW50IDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dvcmtlckNvdW50IG11c3QgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMS4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbnRlcmFjdGl2ZSA9IG9wdGlvbnMuaW50ZXJhY3RpdmU7XG4gICAgdGhpcy5fZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCA9IG9wdGlvbnMuZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDtcbiAgICB0aGlzLl9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBvcHRpb25zLnByZXNlcnZlRHJhd2luZ0J1ZmZlcjtcbiAgICB0aGlzLl90cmFja1Jlc2l6ZSA9IG9wdGlvbnMudHJhY2tSZXNpemU7XG4gICAgdGhpcy5fd29ya2VyQ291bnQgPSBvcHRpb25zLndvcmtlckNvdW50O1xuICAgIHRoaXMuX2JlYXJpbmdTbmFwID0gb3B0aW9ucy5iZWFyaW5nU25hcDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb250YWluZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMuY29udGFpbmVyKTtcbiAgICB9IGVsc2Uge3NcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG4gICAgfVxuXG4gICAgdGhpcy5hbmltYXRpb25Mb29wID0gbmV3IEFuaW1hdGlvbkxvb3AoKTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0ob3B0aW9ucy5taW5ab29tLCBvcHRpb25zLm1heFpvb20pO1xuXG4gICAgaWYgKG9wdGlvbnMubWF4Qm91bmRzKSB7XG4gICAgICAgIHRoaXMuc2V0TWF4Qm91bmRzKG9wdGlvbnMubWF4Qm91bmRzKTtcbiAgICB9XG5cbiAgICB1dGlsLmJpbmRBbGwoW1xuICAgICAgICAnX2ZvcndhcmRTdHlsZUV2ZW50JyxcbiAgICAgICAgJ19mb3J3YXJkU291cmNlRXZlbnQnLFxuICAgICAgICAnX2ZvcndhcmRMYXllckV2ZW50JyxcbiAgICAgICAgJ19mb3J3YXJkVGlsZUV2ZW50JyxcbiAgICAgICAgJ19vblN0eWxlTG9hZCcsXG4gICAgICAgICdfb25TdHlsZUNoYW5nZScsXG4gICAgICAgICdfb25Tb3VyY2VBZGQnLFxuICAgICAgICAnX29uU291cmNlUmVtb3ZlJyxcbiAgICAgICAgJ19vblNvdXJjZVVwZGF0ZScsXG4gICAgICAgICdfb25XaW5kb3dPbmxpbmUnLFxuICAgICAgICAnX29uV2luZG93UmVzaXplJyxcbiAgICAgICAgJ191cGRhdGUnLFxuICAgICAgICAnX3JlbmRlcidcbiAgICBdLCB0aGlzKTtcblxuICAgIHRoaXMuX3NldHVwQ29udGFpbmVyKCk7XG4gICAgdGhpcy5fc2V0dXBQYWludGVyKCk7XG5cbiAgICB0aGlzLm9uKCdtb3ZlJywgdGhpcy5fdXBkYXRlLmJpbmQodGhpcywgZmFsc2UpKTtcbiAgICB0aGlzLm9uKCd6b29tJywgdGhpcy5fdXBkYXRlLmJpbmQodGhpcywgdHJ1ZSkpO1xuICAgIHRoaXMub24oJ21vdmVlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25Mb29wLnNldCgzMDApOyAvLyB0ZXh0IGZhZGluZ1xuICAgICAgICB0aGlzLl9yZXJlbmRlcigpO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIHRoaXMuX29uV2luZG93T25saW5lLCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGJpbmRIYW5kbGVycyh0aGlzLCBvcHRpb25zKTtcblxuICAgIHRoaXMuX2hhc2ggPSBvcHRpb25zLmhhc2ggJiYgKG5ldyBIYXNoKCkpLmFkZFRvKHRoaXMpO1xuICAgIC8vIGRvbid0IHNldCBwb3NpdGlvbiBmcm9tIG9wdGlvbnMgaWYgc2V0IHRocm91Z2ggaGFzaFxuICAgIGlmICghdGhpcy5faGFzaCB8fCAhdGhpcy5faGFzaC5fb25IYXNoQ2hhbmdlKCkpIHtcbiAgICAgICAgdGhpcy5qdW1wVG8oe1xuICAgICAgICAgICAgY2VudGVyOiBvcHRpb25zLmNlbnRlcixcbiAgICAgICAgICAgIHpvb206IG9wdGlvbnMuem9vbSxcbiAgICAgICAgICAgIGJlYXJpbmc6IG9wdGlvbnMuYmVhcmluZyxcbiAgICAgICAgICAgIHBpdGNoOiBvcHRpb25zLnBpdGNoXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuc3RhY2tzID0ge307XG4gICAgdGhpcy5fY2xhc3NlcyA9IFtdO1xuXG4gICAgdGhpcy5yZXNpemUoKTtcblxuICAgIGlmIChvcHRpb25zLmNsYXNzZXMpIHRoaXMuc2V0Q2xhc3NlcyhvcHRpb25zLmNsYXNzZXMpO1xuICAgIGlmIChvcHRpb25zLnN0eWxlKSB0aGlzLnNldFN0eWxlKG9wdGlvbnMuc3R5bGUpO1xuXG4gICAgdmFyIF9tYXAgPSB0aGlzO1xuICAgIHRoaXMuc3R5bGUub24oJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgX21hcC5fc2V0TGlnaHRPcHRpb25zKHV0aWwuZXh0ZW5kKG9wdGlvbnMubGlnaHQsIF9tYXAuc3R5bGUuX2xpZ2h0KSk7XG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpIHRoaXMuYWRkQ29udHJvbChuZXcgQXR0cmlidXRpb24ob3B0aW9ucy5hdHRyaWJ1dGlvbkNvbnRyb2wpKTtcblxuICAgIHZhciBmaXJlRXJyb3IgPSB0aGlzLmZpcmUuYmluZCh0aGlzLCAnZXJyb3InKTtcbiAgICB0aGlzLm9uKCdzdHlsZS5lcnJvcicsIGZpcmVFcnJvcik7XG4gICAgdGhpcy5vbignc291cmNlLmVycm9yJywgZmlyZUVycm9yKTtcbiAgICB0aGlzLm9uKCd0aWxlLmVycm9yJywgZmlyZUVycm9yKTtcbiAgICB0aGlzLm9uKCdsYXllci5lcnJvcicsIGZpcmVFcnJvcik7XG59O1xuXG51dGlsLmV4dGVuZChNYXAucHJvdG90eXBlLCBFdmVudGVkKTtcbnV0aWwuZXh0ZW5kKE1hcC5wcm90b3R5cGUsIENhbWVyYS5wcm90b3R5cGUpO1xudXRpbC5leHRlbmQoTWFwLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBNYXAucHJvdG90eXBlICove1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIFtgQ29udHJvbGBdKCNDb250cm9sKSB0byB0aGUgbWFwLCBjYWxsaW5nIGBjb250cm9sLmFkZFRvKHRoaXMpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q29udHJvbH0gY29udHJvbCBUaGUgW2BDb250cm9sYF0oI0NvbnRyb2wpIHRvIGFkZC5cbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBhZGRDb250cm9sOiBmdW5jdGlvbihjb250cm9sKSB7XG4gICAgICAgIGNvbnRyb2wuYWRkVG8odGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgTWFwYm94IHN0eWxlIGNsYXNzIHRvIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBLZWVwIGluIG1pbmQgdGhhdCB0aGVzZSBjbGFzc2VzIGFyZSB1c2VkIGZvciBjb250cm9sbGluZyBhIHN0eWxlIGxheWVyJ3MgcGFpbnQgcHJvcGVydGllcywgc28gYXJlICpub3QqIHJlZmxlY3RlZFxuICAgICAqIGluIGFuIEhUTUwgZWxlbWVudCdzIGBjbGFzc2AgYXR0cmlidXRlLiBUbyBsZWFybiBtb3JlIGFib3V0IE1hcGJveCBzdHlsZSBjbGFzc2VzLCByZWFkIGFib3V0XG4gICAgICogW0xheWVyc10oaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtc3R5bGUtc3BlYy8jbGF5ZXJzKSBpbiB0aGUgc3R5bGUgc3BlY2lmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrbGFzcyBUaGUgc3R5bGUgY2xhc3MgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7U3R5bGVPcHRpb25zfSBbb3B0aW9uc11cbiAgICAgKiBAZmlyZXMgY2hhbmdlXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKGtsYXNzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbGFzc2VzLmluZGV4T2Yoa2xhc3MpID49IDAgfHwga2xhc3MgPT09ICcnKSByZXR1cm4gdGhpcztcbiAgICAgICAgdGhpcy5fY2xhc3Nlcy5wdXNoKGtsYXNzKTtcbiAgICAgICAgdGhpcy5fY2xhc3NPcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgICBpZiAodGhpcy5zdHlsZSkgdGhpcy5zdHlsZS51cGRhdGVDbGFzc2VzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGUodHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBNYXBib3ggc3R5bGUgY2xhc3MgZnJvbSB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtsYXNzIFRoZSBzdHlsZSBjbGFzcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtTdHlsZU9wdGlvbnN9IFtvcHRpb25zXVxuICAgICAqIEBmaXJlcyBjaGFuZ2VcbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oa2xhc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLl9jbGFzc2VzLmluZGV4T2Yoa2xhc3MpO1xuICAgICAgICBpZiAoaSA8IDAgfHwga2xhc3MgPT09ICcnKSByZXR1cm4gdGhpcztcbiAgICAgICAgdGhpcy5fY2xhc3Nlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHRoaXMuX2NsYXNzT3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAgICAgaWYgKHRoaXMuc3R5bGUpIHRoaXMuc3R5bGUudXBkYXRlQ2xhc3NlcygpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlKHRydWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyB0aGUgbWFwJ3MgZXhpc3RpbmcgTWFwYm94IHN0eWxlIGNsYXNzZXMgd2l0aCBhIG5ldyBhcnJheSBvZiBjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBrbGFzc2VzIFRoZSBzdHlsZSBjbGFzc2VzIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge1N0eWxlT3B0aW9uc30gW29wdGlvbnNdXG4gICAgICogQGZpcmVzIGNoYW5nZVxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldENsYXNzZXM6IGZ1bmN0aW9uKGtsYXNzZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHVuaXF1ZUNsYXNzZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoa2xhc3Nlc1tpXSAhPT0gJycpIHVuaXF1ZUNsYXNzZXNba2xhc3Nlc1tpXV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NsYXNzZXMgPSBPYmplY3Qua2V5cyh1bmlxdWVDbGFzc2VzKTtcbiAgICAgICAgdGhpcy5fY2xhc3NPcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgICBpZiAodGhpcy5zdHlsZSkgdGhpcy5zdHlsZS51cGRhdGVDbGFzc2VzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGUodHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgbWFwIGhhcyB0aGVcbiAgICAgKiBzcGVjaWZpZWQgTWFwYm94IHN0eWxlIGNsYXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtsYXNzIFRoZSBzdHlsZSBjbGFzcyB0byB0ZXN0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIG1hcCBoYXMgdGhlIHNwZWNpZmllZCBzdHlsZSBjbGFzcy5cbiAgICAgKi9cbiAgICBoYXNDbGFzczogZnVuY3Rpb24oa2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzZXMuaW5kZXhPZihrbGFzcykgPj0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWFwJ3MgTWFwYm94IHN0eWxlIGNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gVGhlIG1hcCdzIHN0eWxlIGNsYXNzZXMuXG4gICAgICovXG4gICAgZ2V0Q2xhc3NlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGFzc2VzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemVzIHRoZSBtYXAgYWNjb3JkaW5nIHRvIHRoZSBkaW1lbnNpb25zIG9mIGl0c1xuICAgICAqIGBjb250YWluZXJgIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCBhZnRlciB0aGUgbWFwJ3MgYGNvbnRhaW5lcmAgaXMgcmVzaXplZCBieSBhbm90aGVyIHNjcmlwdCxcbiAgICAgKiBvciB3aGVuIHRoZSBtYXAgaXMgc2hvd24gYWZ0ZXIgYmVpbmcgaW5pdGlhbGx5IGhpZGRlbiB3aXRoIENTUy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IDAsIGhlaWdodCA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5lcikge1xuICAgICAgICAgICAgd2lkdGggPSB0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGggfHwgNDAwO1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5fY29udGFpbmVyLm9mZnNldEhlaWdodCB8fCAzMDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jYW52YXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMucGFpbnRlci5yZXNpemUod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxuICAgICAgICAgICAgLmZpcmUoJ21vdmUnKVxuICAgICAgICAgICAgLmZpcmUoJ3Jlc2l6ZScpXG4gICAgICAgICAgICAuZmlyZSgnbW92ZWVuZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXAncyBnZW9ncmFwaGljYWwgYm91bmRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0xuZ0xhdEJvdW5kc30gVGhlIG1hcCdzIGdlb2dyYXBoaWNhbCBib3VuZHMuXG4gICAgICovXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJvdW5kcyA9IG5ldyBMbmdMYXRCb3VuZHMoXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5wb2ludExvY2F0aW9uKG5ldyBQb2ludCgwLCAwKSksXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5wb2ludExvY2F0aW9uKHRoaXMudHJhbnNmb3JtLnNpemUpKTtcblxuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm0uYW5nbGUgfHwgdGhpcy50cmFuc2Zvcm0ucGl0Y2gpIHtcbiAgICAgICAgICAgIGJvdW5kcy5leHRlbmQodGhpcy50cmFuc2Zvcm0ucG9pbnRMb2NhdGlvbihuZXcgUG9pbnQodGhpcy50cmFuc2Zvcm0uc2l6ZS54LCAwKSkpO1xuICAgICAgICAgICAgYm91bmRzLmV4dGVuZCh0aGlzLnRyYW5zZm9ybS5wb2ludExvY2F0aW9uKG5ldyBQb2ludCgwLCB0aGlzLnRyYW5zZm9ybS5zaXplLnkpKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9yIGNsZWFycyB0aGUgbWFwJ3MgZ2VvZ3JhcGhpY2FsIGJvdW5kcy5cbiAgICAgKlxuICAgICAqIFBhbiBhbmQgem9vbSBvcGVyYXRpb25zIGFyZSBjb25zdHJhaW5lZCB3aXRoaW4gdGhlc2UgYm91bmRzLlxuICAgICAqIElmIGEgcGFuIG9yIHpvb20gaXMgcGVyZm9ybWVkIHRoYXQgd291bGRcbiAgICAgKiBkaXNwbGF5IHJlZ2lvbnMgb3V0c2lkZSB0aGVzZSBib3VuZHMsIHRoZSBtYXAgd2lsbFxuICAgICAqIGluc3RlYWQgZGlzcGxheSBhIHBvc2l0aW9uIGFuZCB6b29tIGxldmVsXG4gICAgICogYXMgY2xvc2UgYXMgcG9zc2libGUgdG8gdGhlIG9wZXJhdGlvbidzIHJlcXVlc3Qgd2hpbGUgc3RpbGxcbiAgICAgKiByZW1haW5pbmcgd2l0aGluIHRoZSBib3VuZHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xuZ0xhdEJvdW5kc0xpa2UgfCBudWxsIHwgdW5kZWZpbmVkfSBsbmdsYXRib3VuZHMgVGhlIG1heGltdW0gYm91bmRzIHRvIHNldC4gSWYgYG51bGxgIG9yIGB1bmRlZmluZWRgIGlzIHByb3ZpZGVkLCB0aGUgZnVuY3Rpb24gcmVtb3ZlcyB0aGUgbWFwJ3MgbWF4aW11bSBib3VuZHMuXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgc2V0TWF4Qm91bmRzOiBmdW5jdGlvbiAobG5nbGF0Ym91bmRzKSB7XG4gICAgICAgIGlmIChsbmdsYXRib3VuZHMpIHtcbiAgICAgICAgICAgIHZhciBiID0gTG5nTGF0Qm91bmRzLmNvbnZlcnQobG5nbGF0Ym91bmRzKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmxuZ1JhbmdlID0gW2IuZ2V0V2VzdCgpLCBiLmdldEVhc3QoKV07XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5sYXRSYW5nZSA9IFtiLmdldFNvdXRoKCksIGIuZ2V0Tm9ydGgoKV07XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5fY29uc3RyYWluKCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChsbmdsYXRib3VuZHMgPT09IG51bGwgfHwgbG5nbGF0Ym91bmRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLmxuZ1JhbmdlID0gW107XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5sYXRSYW5nZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNldHMgb3IgY2xlYXJzIHRoZSBtYXAncyBtaW5pbXVtIHpvb20gbGV2ZWwuXG4gICAgICogSWYgdGhlIG1hcCdzIGN1cnJlbnQgem9vbSBsZXZlbCBpcyBsb3dlciB0aGFuIHRoZSBuZXcgbWluaW11bSxcbiAgICAgKiB0aGUgbWFwIHdpbGwgem9vbSB0byB0aGUgbmV3IG1pbmltdW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IG1pblpvb20gVGhlIG1pbmltdW0gem9vbSBsZXZlbCB0byBzZXQgKDAtMjApLlxuICAgICAqICAgSWYgYG51bGxgIG9yIGB1bmRlZmluZWRgIGlzIHByb3ZpZGVkLCB0aGUgZnVuY3Rpb24gcmVtb3ZlcyB0aGUgY3VycmVudCBtaW5pbXVtIHpvb20gKGkuZS4gc2V0cyBpdCB0byAwKS5cbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzZXRNaW5ab29tOiBmdW5jdGlvbihtaW5ab29tKSB7XG5cbiAgICAgICAgbWluWm9vbSA9IG1pblpvb20gPT09IG51bGwgfHwgbWluWm9vbSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdE1pblpvb20gOiBtaW5ab29tO1xuXG4gICAgICAgIGlmIChtaW5ab29tID49IGRlZmF1bHRNaW5ab29tICYmIG1pblpvb20gPD0gdGhpcy50cmFuc2Zvcm0ubWF4Wm9vbSkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0ubWluWm9vbSA9IG1pblpvb207XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Wm9vbSgpIDwgbWluWm9vbSkgdGhpcy5zZXRab29tKG1pblpvb20pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKCdtaW5ab29tIG11c3QgYmUgYmV0d2VlbiAnICsgZGVmYXVsdE1pblpvb20gKyAnIGFuZCB0aGUgY3VycmVudCBtYXhab29tLCBpbmNsdXNpdmUnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBvciBjbGVhcnMgdGhlIG1hcCdzIG1heGltdW0gem9vbSBsZXZlbC5cbiAgICAgKiBJZiB0aGUgbWFwJ3MgY3VycmVudCB6b29tIGxldmVsIGlzIGhpZ2hlciB0aGFuIHRoZSBuZXcgbWF4aW11bSxcbiAgICAgKiB0aGUgbWFwIHdpbGwgem9vbSB0byB0aGUgbmV3IG1heGltdW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9udW1iZXJ9IG1heFpvb20gVGhlIG1heGltdW0gem9vbSBsZXZlbCB0byBzZXQgKDAtMjApLlxuICAgICAqICAgSWYgYG51bGxgIG9yIGB1bmRlZmluZWRgIGlzIHByb3ZpZGVkLCB0aGUgZnVuY3Rpb24gcmVtb3ZlcyB0aGUgY3VycmVudCBtYXhpbXVtIHpvb20gKHNldHMgaXQgdG8gMjApLlxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldE1heFpvb206IGZ1bmN0aW9uKG1heFpvb20pIHtcblxuICAgICAgICBtYXhab29tID0gbWF4Wm9vbSA9PT0gbnVsbCB8fCBtYXhab29tID09PSB1bmRlZmluZWQgPyBkZWZhdWx0TWF4Wm9vbSA6IG1heFpvb207XG5cbiAgICAgICAgaWYgKG1heFpvb20gPj0gdGhpcy50cmFuc2Zvcm0ubWluWm9vbSAmJiBtYXhab29tIDw9IGRlZmF1bHRNYXhab29tKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5tYXhab29tID0gbWF4Wm9vbTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRab29tKCkgPiBtYXhab29tKSB0aGlzLnNldFpvb20obWF4Wm9vbSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ21heFpvb20gbXVzdCBiZSBiZXR3ZWVuIHRoZSBjdXJyZW50IG1pblpvb20gYW5kICcgKyBkZWZhdWx0TWF4Wm9vbSArICcsIGluY2x1c2l2ZScpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2V0IGxpZ2h0IGNvbG9yIChmb3IgdXNlIGluIGV4dHJ1c2lvbnMpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDb2xvcn0gbGlnaHRDb2xvciBDb2xvciB3aXRoIHdoaWNoIHRvIGxpZ2h0IGV4dHJ1c2lvbnMuXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgc2V0TGlnaHRDb2xvcjogZnVuY3Rpb24obGlnaHRDb2xvcikge1xuICAgICAgICB0aGlzLnBhaW50ZXIuc2V0TGlnaHRpbmcoe1xuICAgICAgICAgICAgbGlnaHRDb2xvcjogcGFyc2VDb2xvcihsaWdodENvbG9yKVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNldCBsaWdodCBjb2xvciAoZm9yIHVzZSBpbiBleHRydXNpb25zKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gbGlnaHREaXJlY3Rpb24gQXJyYXkgb2YgdGhyZWUgdmFsdWVzIHJlcHJlc2VudGluZyBsaWdodCBkaXJlY3Rpb24geCx5LHouXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgc2V0TGlnaHREaXJlY3Rpb246IGZ1bmN0aW9uKGxpZ2h0RGlyZWN0aW9uKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxpZ2h0RGlyZWN0aW9uKSAmJiBsaWdodERpcmVjdGlvbi5sZW5ndGggPT09IDMgJiZcbiAgICAgICAgICAgIGxpZ2h0RGlyZWN0aW9uLmV2ZXJ5KGZ1bmN0aW9uKGkpIHsgcmV0dXJuIHR5cGVvZiBpID09PSAnbnVtYmVyJzsgfSkpIHtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5zZXRMaWdodGluZyh7XG4gICAgICAgICAgICAgICAgbGlnaHREaXJlY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgeDogbGlnaHREaXJlY3Rpb25bMF0sXG4gICAgICAgICAgICAgICAgICAgIHk6IGxpZ2h0RGlyZWN0aW9uWzFdLFxuICAgICAgICAgICAgICAgICAgICB6OiBsaWdodERpcmVjdGlvblsyXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKCdsaWdodC5saWdodERpcmVjdGlvbiBtdXN0IGJlIGFuIGFycmF5IG9mIHRocmVlIG51bWJlcnMnKTtcbiAgICAgICAgLy8gVE9ETyBzaG91bGQgd2UgZG8gbW9yZSBzcGVjaWZpYyBib3VuZHMgY2hlY2tpbmcgb24gdGhlc2UgbnVtYmVycz8gcHJvYmFibHlcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNldCBsaWdodCBjb2xvciAoZm9yIHVzZSBpbiBleHRydXNpb25zKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaWdodEFuY2hvciBBbmNob3IgZm9yIGV4dHJ1c2lvbiBsaWdodGluZy4gT25lIG9mIGBtYXBgLCBgdmlld3BvcnRgLlxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldExpZ2h0QW5jaG9yOiBmdW5jdGlvbihsaWdodEFuY2hvcikge1xuICAgICAgICBpZiAobGlnaHRBbmNob3IgPT09ICdtYXAnIHx8IGxpZ2h0QW5jaG9yID09PSAndmlld3BvcnQnKSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIuc2V0TGlnaHRpbmcoe1xuICAgICAgICAgICAgICAgIGxpZ2h0QW5jaG9yOiBsaWdodEFuY2hvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ2xpZ2h0LmxpZ2h0QW5jaG9yIG11c3QgYmUgb25lIG9mOiBgbWFwYCwgYHZpZXdwb3J0YCcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2V0IGFsbCBsaWdodCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxpZ2h0T3B0aW9ucyBPYmplY3QgY29udGFpbmluZyBhbnkgbGlnaHQgc3VicHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBfc2V0TGlnaHRPcHRpb25zOiBmdW5jdGlvbihvcHRzKSB7XG4gICAgICAgIHRoaXMuc2V0TGlnaHRBbmNob3Iob3B0cy5saWdodEFuY2hvcik7XG4gICAgICAgIHRoaXMuc2V0TGlnaHRDb2xvcihvcHRzLmxpZ2h0Q29sb3IpO1xuICAgICAgICB0aGlzLnNldExpZ2h0RGlyZWN0aW9uKG9wdHMubGlnaHREaXJlY3Rpb24pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFtgUG9pbnRgXSgjUG9pbnQpIHJlcHJlc2VudGluZyBwaXhlbCBjb29yZGluYXRlcywgcmVsYXRpdmUgdG8gdGhlIG1hcCdzIGBjb250YWluZXJgLFxuICAgICAqIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgc3BlY2lmaWVkIGdlb2dyYXBoaWNhbCBsb2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG5nTGF0TGlrZX0gbG5nbGF0IFRoZSBnZW9ncmFwaGljYWwgbG9jYXRpb24gdG8gcHJvamVjdC5cbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IFRoZSBbYFBvaW50YF0oI1BvaW50KSBjb3JyZXNwb25kaW5nIHRvIGBsbmdsYXRgLCByZWxhdGl2ZSB0byB0aGUgbWFwJ3MgYGNvbnRhaW5lcmAuXG4gICAgICovXG4gICAgcHJvamVjdDogZnVuY3Rpb24obG5nbGF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5sb2NhdGlvblBvaW50KExuZ0xhdC5jb252ZXJ0KGxuZ2xhdCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgW2BMbmdMYXRgXSgjTG5nTGF0KSByZXByZXNlbnRpbmcgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzIHRoYXQgY29ycmVzcG9uZFxuICAgICAqIHRvIHRoZSBzcGVjaWZpZWQgcGl4ZWwgY29vcmRpbmF0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BvaW50TGlrZX0gcG9pbnQgVGhlIHBpeGVsIGNvb3JkaW5hdGVzIHRvIHVucHJvamVjdC5cbiAgICAgKiBAcmV0dXJucyB7TG5nTGF0fSBUaGUgW2BMbmdMYXRgXSgjTG5nTGF0KSBjb3JyZXNwb25kaW5nIHRvIGBwb2ludGAuXG4gICAgICovXG4gICAgdW5wcm9qZWN0OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucG9pbnRMb2NhdGlvbihQb2ludC5jb252ZXJ0KHBvaW50KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgW0dlb0pTT05dKGh0dHA6Ly9nZW9qc29uLm9yZy8pXG4gICAgICogW0ZlYXR1cmUgb2JqZWN0c10oaHR0cDovL2dlb2pzb24ub3JnL2dlb2pzb24tc3BlYy5odG1sI2ZlYXR1cmUtb2JqZWN0cylcbiAgICAgKiByZXByZXNlbnRpbmcgdmlzaWJsZSBmZWF0dXJlcyB0aGF0IHNhdGlzZnkgdGhlIHF1ZXJ5IHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BvaW50TGlrZXxBcnJheTxQb2ludExpa2U+fSBbZ2VvbWV0cnldIC0gVGhlIGdlb21ldHJ5IG9mIHRoZSBxdWVyeSByZWdpb246XG4gICAgICogZWl0aGVyIGEgc2luZ2xlIHBvaW50IG9yIHNvdXRod2VzdCBhbmQgbm9ydGhlYXN0IHBvaW50cyBkZXNjcmliaW5nIGEgYm91bmRpbmcgYm94LlxuICAgICAqIE9taXR0aW5nIHRoaXMgcGFyYW1ldGVyIChpLmUuIGNhbGxpbmcgW2BNYXAjcXVlcnlSZW5kZXJlZEZlYXR1cmVzYF0oI01hcCNxdWVyeVJlbmRlcmVkRmVhdHVyZXMpIHdpdGggemVybyBhcmd1bWVudHMsXG4gICAgICogb3Igd2l0aCBvbmx5IGEgYHBhcmFtZXRlcnNgIGFyZ3VtZW50KSBpcyBlcXVpdmFsZW50IHRvIHBhc3NpbmcgYSBib3VuZGluZyBib3ggZW5jb21wYXNzaW5nIHRoZSBlbnRpcmVcbiAgICAgKiBtYXAgdmlld3BvcnQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbWV0ZXJzXVxuICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3BhcmFtZXRlcnMubGF5ZXJzXSBBbiBhcnJheSBvZiBzdHlsZSBsYXllciBJRHMgZm9yIHRoZSBxdWVyeSB0byBpbnNwZWN0LlxuICAgICAqICAgT25seSBmZWF0dXJlcyB3aXRoaW4gdGhlc2UgbGF5ZXJzIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoaXMgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZCwgYWxsIGxheWVycyB3aWxsIGJlIGNoZWNrZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcmFtZXRlcnMuZmlsdGVyXSBBIFtmaWx0ZXJdKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvI3R5cGVzLWZpbHRlcilcbiAgICAgKiAgIHRvIGxpbWl0IHF1ZXJ5IHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8T2JqZWN0Pn0gQW4gYXJyYXkgb2YgW0dlb0pTT05dKGh0dHA6Ly9nZW9qc29uLm9yZy8pXG4gICAgICogW2ZlYXR1cmUgb2JqZWN0c10oaHR0cDovL2dlb2pzb24ub3JnL2dlb2pzb24tc3BlYy5odG1sI2ZlYXR1cmUtb2JqZWN0cykuXG4gICAgICpcbiAgICAgKiBUaGUgYHByb3BlcnRpZXNgIHZhbHVlIG9mIGVhY2ggcmV0dXJuZWQgZmVhdHVyZSBvYmplY3QgY29udGFpbnMgdGhlIHByb3BlcnRpZXMgb2YgaXRzIHNvdXJjZSBmZWF0dXJlLiBGb3IgR2VvSlNPTiBzb3VyY2VzLCBvbmx5XG4gICAgICogc3RyaW5nIGFuZCBudW1lcmljIHByb3BlcnR5IHZhbHVlcyBhcmUgc3VwcG9ydGVkIChpLmUuIGBudWxsYCwgYEFycmF5YCwgYW5kIGBPYmplY3RgIHZhbHVlcyBhcmUgbm90IHN1cHBvcnRlZCkuXG4gICAgICpcbiAgICAgKiBFYWNoIGZlYXR1cmUgaW5jbHVkZXMgYSB0b3AtbGV2ZWwgYGxheWVyYCBwcm9wZXJ0eSB3aG9zZSB2YWx1ZSBpcyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzdHlsZSBsYXllciB0b1xuICAgICAqIHdoaWNoIHRoZSBmZWF0dXJlIGJlbG9uZ3MuIExheW91dCBhbmQgcGFpbnQgcHJvcGVydGllcyBpbiB0aGlzIG9iamVjdCBjb250YWluIHZhbHVlcyB3aGljaCBhcmUgZnVsbHkgZXZhbHVhdGVkXG4gICAgICogZm9yIHRoZSBnaXZlbiB6b29tIGxldmVsIGFuZCBmZWF0dXJlLlxuICAgICAqXG4gICAgICogT25seSB2aXNpYmxlIGZlYXR1cmVzIGFyZSByZXR1cm5lZC4gVGhlIHRvcG1vc3QgcmVuZGVyZWQgZmVhdHVyZSBhcHBlYXJzIGZpcnN0IGluIHRoZSByZXR1cm5lZCBhcnJheSwgYW5kXG4gICAgICogc3Vic2VxdWVudCBmZWF0dXJlcyBhcmUgc29ydGVkIGJ5IGRlc2NlbmRpbmcgei1vcmRlci4gRmVhdHVyZXMgdGhhdCBhcmUgcmVuZGVyZWQgbXVsdGlwbGUgdGltZXMgKGR1ZSB0byB3cmFwcGluZ1xuICAgICAqIGFjcm9zcyB0aGUgYW50aW1lcmlkaWFuIGF0IGxvdyB6b29tIGxldmVscykgYXJlIHJldHVybmVkIG9ubHkgb25jZSAodGhvdWdoIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjYXZlYXQpLlxuICAgICAqXG4gICAgICogQmVjYXVzZSBmZWF0dXJlcyBjb21lIGZyb20gdGlsZWQgdmVjdG9yIGRhdGEgb3IgR2VvSlNPTiBkYXRhIHRoYXQgaXMgY29udmVydGVkIHRvIHRpbGVzIGludGVybmFsbHksIGZlYXR1cmVcbiAgICAgKiBnZW9tZXRyaWVzIGFyZSBjbGlwcGVkIGF0IHRpbGUgYm91bmRhcmllcyBhbmQsIGFzIGEgcmVzdWx0LCBmZWF0dXJlcyBtYXkgYXBwZWFyIG11bHRpcGxlIHRpbWVzIGluIHF1ZXJ5XG4gICAgICogcmVzdWx0cyB3aGVuIHRoZXkgc3BhbiBtdWx0aXBsZSB0aWxlcy4gRm9yIGV4YW1wbGUsIHN1cHBvc2VcbiAgICAgKiB0aGVyZSBpcyBhIGhpZ2h3YXkgcnVubmluZyB0aHJvdWdoIHRoZSBib3VuZGluZyByZWN0YW5nbGUgb2YgYSBxdWVyeS4gVGhlIHJlc3VsdHMgb2YgdGhlIHF1ZXJ5IHdpbGwgYmUgdGhvc2VcbiAgICAgKiBwYXJ0cyBvZiB0aGUgaGlnaHdheSB0aGF0IGxpZSB3aXRoaW4gdGhlIG1hcCB0aWxlcyBjb3ZlcmluZyB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlLCBldmVuIGlmIHRoZSBoaWdod2F5IGV4dGVuZHNcbiAgICAgKiBpbnRvIG90aGVyIHRpbGVzLCBhbmQgdGhlIHBvcnRpb24gb2YgdGhlIGhpZ2h3YXkgd2l0aGluIGVhY2ggbWFwIHRpbGUgd2lsbCBiZSByZXR1cm5lZCBhcyBhIHNlcGFyYXRlIGZlYXR1cmUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIEZpbmQgYWxsIGZlYXR1cmVzIGF0IGEgcG9pbnRcbiAgICAgKiB2YXIgZmVhdHVyZXMgPSBtYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKFxuICAgICAqICAgWzIwLCAzNV0sXG4gICAgICogICB7IGxheWVyczogWydteS1sYXllci1uYW1lJ10gfVxuICAgICAqICk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIEZpbmQgYWxsIGZlYXR1cmVzIHdpdGhpbiBhIHN0YXRpYyBib3VuZGluZyBib3hcbiAgICAgKiB2YXIgZmVhdHVyZXMgPSBtYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKFxuICAgICAqICAgW1sxMCwgMjBdLCBbMzAsIDUwXV0sXG4gICAgICogICB7IGxheWVyczogWydteS1sYXllci1uYW1lJ10gfVxuICAgICAqICk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIEZpbmQgYWxsIGZlYXR1cmVzIHdpdGhpbiBhIGJvdW5kaW5nIGJveCBhcm91bmQgYSBwb2ludFxuICAgICAqIHZhciB3aWR0aCA9IDEwO1xuICAgICAqIHZhciBoZWlnaHQgPSAyMDtcbiAgICAgKiB2YXIgZmVhdHVyZXMgPSBtYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKFtcbiAgICAgKiAgIFtwb2ludC54IC0gd2lkdGggLyAyLCBwb2ludC55IC0gaGVpZ2h0IC8gMl0sXG4gICAgICogICBbcG9pbnQueCArIHdpZHRoIC8gMiwgcG9pbnQueSArIGhlaWdodCAvIDJdXG4gICAgICogXSwgeyBsYXllcnM6IFsnbXktbGF5ZXItbmFtZSddIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBRdWVyeSBhbGwgcmVuZGVyZWQgZmVhdHVyZXMgZnJvbSBhIHNpbmdsZSBsYXllclxuICAgICAqIHZhciBmZWF0dXJlcyA9IG1hcC5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoeyBsYXllcnM6IFsnbXktbGF5ZXItbmFtZSddIH0pO1xuICAgICAqL1xuICAgIHF1ZXJ5UmVuZGVyZWRGZWF0dXJlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgICAgdmFyIGdlb21ldHJ5O1xuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBnZW9tZXRyeSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHBhcmFtcyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGlzUG9pbnRMaWtlKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhcbiAgICAgICAgICAgIHRoaXMuX21ha2VRdWVyeUdlb21ldHJ5KGdlb21ldHJ5KSxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnpvb20sXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS5hbmdsZVxuICAgICAgICApO1xuXG4gICAgICAgIGZ1bmN0aW9uIGlzUG9pbnRMaWtlKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBQb2ludCB8fCBBcnJheS5pc0FycmF5KGlucHV0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfbWFrZVF1ZXJ5R2VvbWV0cnk6IGZ1bmN0aW9uKHBvaW50T3JCb3gpIHtcbiAgICAgICAgaWYgKHBvaW50T3JCb3ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gYm91bmRzIHdhcyBvbWl0dGVkOiB1c2UgZnVsbCB2aWV3cG9ydFxuICAgICAgICAgICAgcG9pbnRPckJveCA9IFtcbiAgICAgICAgICAgICAgICBQb2ludC5jb252ZXJ0KFswLCAwXSksXG4gICAgICAgICAgICAgICAgUG9pbnQuY29udmVydChbdGhpcy50cmFuc2Zvcm0ud2lkdGgsIHRoaXMudHJhbnNmb3JtLmhlaWdodF0pXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHF1ZXJ5R2VvbWV0cnk7XG4gICAgICAgIHZhciBpc1BvaW50ID0gcG9pbnRPckJveCBpbnN0YW5jZW9mIFBvaW50IHx8IHR5cGVvZiBwb2ludE9yQm94WzBdID09PSAnbnVtYmVyJztcblxuICAgICAgICBpZiAoaXNQb2ludCkge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gUG9pbnQuY29udmVydChwb2ludE9yQm94KTtcbiAgICAgICAgICAgIHF1ZXJ5R2VvbWV0cnkgPSBbcG9pbnRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGJveCA9IFtQb2ludC5jb252ZXJ0KHBvaW50T3JCb3hbMF0pLCBQb2ludC5jb252ZXJ0KHBvaW50T3JCb3hbMV0pXTtcbiAgICAgICAgICAgIHF1ZXJ5R2VvbWV0cnkgPSBbXG4gICAgICAgICAgICAgICAgYm94WzBdLFxuICAgICAgICAgICAgICAgIG5ldyBQb2ludChib3hbMV0ueCwgYm94WzBdLnkpLFxuICAgICAgICAgICAgICAgIGJveFsxXSxcbiAgICAgICAgICAgICAgICBuZXcgUG9pbnQoYm94WzBdLngsIGJveFsxXS55KSxcbiAgICAgICAgICAgICAgICBib3hbMF1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBxdWVyeUdlb21ldHJ5ID0gcXVlcnlHZW9tZXRyeS5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnBvaW50Q29vcmRpbmF0ZShwKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICByZXR1cm4gcXVlcnlHZW9tZXRyeTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBbR2VvSlNPTl0oaHR0cDovL2dlb2pzb24ub3JnLylcbiAgICAgKiBbRmVhdHVyZSBvYmplY3RzXShodHRwOi8vZ2VvanNvbi5vcmcvZ2VvanNvbi1zcGVjLmh0bWwjZmVhdHVyZS1vYmplY3RzKVxuICAgICAqIHJlcHJlc2VudGluZyBmZWF0dXJlcyB3aXRoaW4gdGhlIHNwZWNpZmllZCB2ZWN0b3IgdGlsZSBvciBHZW9KU09OIHNvdXJjZSB0aGF0IHNhdGlzZnkgdGhlIHF1ZXJ5IHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlSUQgVGhlIElEIG9mIHRoZSB2ZWN0b3IgdGlsZSBvciBHZW9KU09OIHNvdXJjZSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1ldGVycy5zb3VyY2VMYXllcl0gVGhlIG5hbWUgb2YgdGhlIHZlY3RvciB0aWxlIGxheWVyIHRvIHF1ZXJ5LiAqRm9yIHZlY3RvciB0aWxlXG4gICAgICogICBzb3VyY2VzLCB0aGlzIHBhcmFtZXRlciBpcyByZXF1aXJlZC4qIEZvciBHZW9KU09OIHNvdXJjZXMsIGl0IGlzIGlnbm9yZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcmFtZXRlcnMuZmlsdGVyXSBBIFtmaWx0ZXJdKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvI3R5cGVzLWZpbHRlcilcbiAgICAgKiAgIHRvIGxpbWl0IHF1ZXJ5IHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8T2JqZWN0Pn0gQW4gYXJyYXkgb2YgW0dlb0pTT05dKGh0dHA6Ly9nZW9qc29uLm9yZy8pXG4gICAgICogW0ZlYXR1cmUgb2JqZWN0c10oaHR0cDovL2dlb2pzb24ub3JnL2dlb2pzb24tc3BlYy5odG1sI2ZlYXR1cmUtb2JqZWN0cykuXG4gICAgICpcbiAgICAgKiBJbiBjb250cmFzdCB0byBbYE1hcCNxdWVyeVJlbmRlcmVkRmVhdHVyZXNgXSgjTWFwI3F1ZXJ5UmVuZGVyZWRGZWF0dXJlcyksIHRoaXMgZnVuY3Rpb25cbiAgICAgKiByZXR1cm5zIGFsbCBmZWF0dXJlcyBtYXRjaGluZyB0aGUgcXVlcnkgcGFyYW1ldGVycyxcbiAgICAgKiB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSByZW5kZXJlZCBieSB0aGUgY3VycmVudCBzdHlsZSAoaS5lLiB2aXNpYmxlKS4gVGhlIGRvbWFpbiBvZiB0aGUgcXVlcnkgaW5jbHVkZXMgYWxsIGN1cnJlbnRseS1sb2FkZWRcbiAgICAgKiB2ZWN0b3IgdGlsZXMgYW5kIEdlb0pTT04gc291cmNlIHRpbGVzOiB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNoZWNrIHRpbGVzIG91dHNpZGUgdGhlIGN1cnJlbnRseVxuICAgICAqIHZpc2libGUgdmlld3BvcnQuXG4gICAgICpcbiAgICAgKiBCZWNhdXNlIGZlYXR1cmVzIGNvbWUgZnJvbSB0aWxlZCB2ZWN0b3IgZGF0YSBvciBHZW9KU09OIGRhdGEgdGhhdCBpcyBjb252ZXJ0ZWQgdG8gdGlsZXMgaW50ZXJuYWxseSwgZmVhdHVyZVxuICAgICAqIGdlb21ldHJpZXMgYXJlIGNsaXBwZWQgYXQgdGlsZSBib3VuZGFyaWVzIGFuZCwgYXMgYSByZXN1bHQsIGZlYXR1cmVzIG1heSBhcHBlYXIgbXVsdGlwbGUgdGltZXMgaW4gcXVlcnlcbiAgICAgKiByZXN1bHRzIHdoZW4gdGhleSBzcGFuIG11bHRpcGxlIHRpbGVzLiBGb3IgZXhhbXBsZSwgc3VwcG9zZVxuICAgICAqIHRoZXJlIGlzIGEgaGlnaHdheSBydW5uaW5nIHRocm91Z2ggdGhlIGJvdW5kaW5nIHJlY3RhbmdsZSBvZiBhIHF1ZXJ5LiBUaGUgcmVzdWx0cyBvZiB0aGUgcXVlcnkgd2lsbCBiZSB0aG9zZVxuICAgICAqIHBhcnRzIG9mIHRoZSBoaWdod2F5IHRoYXQgbGllIHdpdGhpbiB0aGUgbWFwIHRpbGVzIGNvdmVyaW5nIHRoZSBib3VuZGluZyByZWN0YW5nbGUsIGV2ZW4gaWYgdGhlIGhpZ2h3YXkgZXh0ZW5kc1xuICAgICAqIGludG8gb3RoZXIgdGlsZXMsIGFuZCB0aGUgcG9ydGlvbiBvZiB0aGUgaGlnaHdheSB3aXRoaW4gZWFjaCBtYXAgdGlsZSB3aWxsIGJlIHJldHVybmVkIGFzIGEgc2VwYXJhdGUgZmVhdHVyZS5cbiAgICAgKi9cbiAgICBxdWVyeVNvdXJjZUZlYXR1cmVzOiBmdW5jdGlvbihzb3VyY2VJRCwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnF1ZXJ5U291cmNlRmVhdHVyZXMoc291cmNlSUQsIHBhcmFtcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIHRoZSBtYXAncyBNYXBib3ggc3R5bGUgb2JqZWN0IHdpdGggYSBuZXcgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IHN0eWxlIEEgSlNPTiBvYmplY3QgY29uZm9ybWluZyB0byB0aGUgc2NoZW1hIGRlc2NyaWJlZCBpbiB0aGVcbiAgICAgKiAgIFtNYXBib3ggU3R5bGUgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9tYXBib3guY29tL21hcGJveC1nbC1zdHlsZS1zcGVjLyksIG9yIGEgVVJMIHRvIHN1Y2ggSlNPTi5cbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKi9cbiAgICBzZXRTdHlsZTogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVcbiAgICAgICAgICAgICAgICAub2ZmKCdsb2FkJywgdGhpcy5fb25TdHlsZUxvYWQpXG4gICAgICAgICAgICAgICAgLm9mZignZXJyb3InLCB0aGlzLl9mb3J3YXJkU3R5bGVFdmVudClcbiAgICAgICAgICAgICAgICAub2ZmKCdjaGFuZ2UnLCB0aGlzLl9vblN0eWxlQ2hhbmdlKVxuICAgICAgICAgICAgICAgIC5vZmYoJ3NvdXJjZS5hZGQnLCB0aGlzLl9vblNvdXJjZUFkZClcbiAgICAgICAgICAgICAgICAub2ZmKCdzb3VyY2UucmVtb3ZlJywgdGhpcy5fb25Tb3VyY2VSZW1vdmUpXG4gICAgICAgICAgICAgICAgLm9mZignc291cmNlLmxvYWQnLCB0aGlzLl9vblNvdXJjZVVwZGF0ZSlcbiAgICAgICAgICAgICAgICAub2ZmKCdzb3VyY2UuZXJyb3InLCB0aGlzLl9mb3J3YXJkU291cmNlRXZlbnQpXG4gICAgICAgICAgICAgICAgLm9mZignc291cmNlLmNoYW5nZScsIHRoaXMuX29uU291cmNlVXBkYXRlKVxuICAgICAgICAgICAgICAgIC5vZmYoJ2xheWVyLmFkZCcsIHRoaXMuX2ZvcndhcmRMYXllckV2ZW50KVxuICAgICAgICAgICAgICAgIC5vZmYoJ2xheWVyLnJlbW92ZScsIHRoaXMuX2ZvcndhcmRMYXllckV2ZW50KVxuICAgICAgICAgICAgICAgIC5vZmYoJ2xheWVyLmVycm9yJywgdGhpcy5fZm9yd2FyZExheWVyRXZlbnQpXG4gICAgICAgICAgICAgICAgLm9mZigndGlsZS5hZGQnLCB0aGlzLl9mb3J3YXJkVGlsZUV2ZW50KVxuICAgICAgICAgICAgICAgIC5vZmYoJ3RpbGUucmVtb3ZlJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgICAgICAub2ZmKCd0aWxlLmxvYWQnLCB0aGlzLl91cGRhdGUpXG4gICAgICAgICAgICAgICAgLm9mZigndGlsZS5lcnJvcicsIHRoaXMuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAgICAgLm9mZigndGlsZS5zdGF0cycsIHRoaXMuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAgICAgLl9yZW1vdmUoKTtcblxuICAgICAgICAgICAgdGhpcy5vZmYoJ3JvdGF0ZScsIHRoaXMuc3R5bGUuX3JlZG9QbGFjZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ3BpdGNoJywgdGhpcy5zdHlsZS5fcmVkb1BsYWNlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2UgaWYgKHN0eWxlIGluc3RhbmNlb2YgU3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUgPSBuZXcgU3R5bGUoc3R5bGUsIHRoaXMuYW5pbWF0aW9uTG9vcCwgdGhpcy5fd29ya2VyQ291bnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdHlsZVxuICAgICAgICAgICAgLm9uKCdsb2FkJywgdGhpcy5fb25TdHlsZUxvYWQpXG4gICAgICAgICAgICAub24oJ2Vycm9yJywgdGhpcy5fZm9yd2FyZFN0eWxlRXZlbnQpXG4gICAgICAgICAgICAub24oJ2NoYW5nZScsIHRoaXMuX29uU3R5bGVDaGFuZ2UpXG4gICAgICAgICAgICAub24oJ3NvdXJjZS5hZGQnLCB0aGlzLl9vblNvdXJjZUFkZClcbiAgICAgICAgICAgIC5vbignc291cmNlLnJlbW92ZScsIHRoaXMuX29uU291cmNlUmVtb3ZlKVxuICAgICAgICAgICAgLm9uKCdzb3VyY2UubG9hZCcsIHRoaXMuX29uU291cmNlVXBkYXRlKVxuICAgICAgICAgICAgLm9uKCdzb3VyY2UuZXJyb3InLCB0aGlzLl9mb3J3YXJkU291cmNlRXZlbnQpXG4gICAgICAgICAgICAub24oJ3NvdXJjZS5jaGFuZ2UnLCB0aGlzLl9vblNvdXJjZVVwZGF0ZSlcbiAgICAgICAgICAgIC5vbignbGF5ZXIuYWRkJywgdGhpcy5fZm9yd2FyZExheWVyRXZlbnQpXG4gICAgICAgICAgICAub24oJ2xheWVyLnJlbW92ZScsIHRoaXMuX2ZvcndhcmRMYXllckV2ZW50KVxuICAgICAgICAgICAgLm9uKCdsYXllci5lcnJvcicsIHRoaXMuX2ZvcndhcmRMYXllckV2ZW50KVxuICAgICAgICAgICAgLm9uKCd0aWxlLmFkZCcsIHRoaXMuX2ZvcndhcmRUaWxlRXZlbnQpXG4gICAgICAgICAgICAub24oJ3RpbGUucmVtb3ZlJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgIC5vbigndGlsZS5sb2FkJywgdGhpcy5fdXBkYXRlKVxuICAgICAgICAgICAgLm9uKCd0aWxlLmVycm9yJywgdGhpcy5fZm9yd2FyZFRpbGVFdmVudClcbiAgICAgICAgICAgIC5vbigndGlsZS5zdGF0cycsIHRoaXMuX2ZvcndhcmRUaWxlRXZlbnQpO1xuXG4gICAgICAgIHRoaXMub24oJ3JvdGF0ZScsIHRoaXMuc3R5bGUuX3JlZG9QbGFjZW1lbnQpO1xuICAgICAgICB0aGlzLm9uKCdwaXRjaCcsIHRoaXMuc3R5bGUuX3JlZG9QbGFjZW1lbnQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXAncyBNYXBib3ggc3R5bGUgb2JqZWN0LCB3aGljaCBjYW4gYmUgdXNlZCB0byByZWNyZWF0ZSB0aGUgbWFwJ3Mgc3R5bGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgbWFwJ3Mgc3R5bGUgb2JqZWN0LlxuICAgICAqL1xuICAgIGdldFN0eWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0eWxlLnNlcmlhbGl6ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzb3VyY2UgdG8gdGhlIG1hcCdzIHN0eWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiB0aGUgc291cmNlIHRvIGFkZC4gTXVzdCBub3QgY29uZmxpY3Qgd2l0aCBleGlzdGluZyBzb3VyY2VzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QsIGNvbmZvcm1pbmcgdG8gdGhlXG4gICAgICogTWFwYm94IFN0eWxlIFNwZWNpZmljYXRpb24ncyBbc291cmNlIGRlZmluaXRpb25dKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvI3NvdXJjZXMpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UudHlwZSBUaGUgc291cmNlIHR5cGUsIHdoaWNoIG11c3QgYmUgZWl0aGVyIG9uZSBvZiB0aGUgY29yZSBNYXBib3ggR0wgc291cmNlIHR5cGVzIGRlZmluZWQgaW4gdGhlIHN0eWxlIHNwZWNpZmljYXRpb24gb3IgYSBjdXN0b20gdHlwZSB0aGF0IGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBtYXAgd2l0aCB7QGxpbmsgTWFwI2FkZFNvdXJjZVR5cGV9LlxuICAgICAqIEBmaXJlcyBzb3VyY2UuYWRkXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgYWRkU291cmNlOiBmdW5jdGlvbihpZCwgc291cmNlKSB7XG4gICAgICAgIHRoaXMuc3R5bGUuYWRkU291cmNlKGlkLCBzb3VyY2UpO1xuICAgICAgICB0aGlzLl91cGRhdGUodHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgW2N1c3RvbSBzb3VyY2UgdHlwZV0oI0N1c3RvbSBTb3VyY2VzKSwgbWFraW5nIGl0IGF2YWlsYWJsZSBmb3IgdXNlIHdpdGhcbiAgICAgKiB7QGxpbmsgTWFwI2FkZFNvdXJjZX0uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc291cmNlIHR5cGU7IHNvdXJjZSBkZWZpbml0aW9uIG9iamVjdHMgdXNlIHRoaXMgbmFtZSBpbiB0aGUgYHt0eXBlOiAuLi59YCBmaWVsZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBTb3VyY2VUeXBlIEEge0BsaW5rIFNvdXJjZX0gY29uc3RydWN0b3IuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIHdoZW4gdGhlIHNvdXJjZSB0eXBlIGlzIHJlYWR5IG9yIHdpdGggYW4gZXJyb3IgYXJndW1lbnQgaWYgdGhlcmUgaXMgYW4gZXJyb3IuXG4gICAgICovXG4gICAgYWRkU291cmNlVHlwZTogZnVuY3Rpb24gKG5hbWUsIFNvdXJjZVR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLmFkZFNvdXJjZVR5cGUobmFtZSwgU291cmNlVHlwZSwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgc291cmNlIGZyb20gdGhlIG1hcCdzIHN0eWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiB0aGUgc291cmNlIHRvIHJlbW92ZS5cbiAgICAgKiBAZmlyZXMgc291cmNlLnJlbW92ZVxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHJlbW92ZVNvdXJjZTogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgdGhpcy5zdHlsZS5yZW1vdmVTb3VyY2UoaWQpO1xuICAgICAgICB0aGlzLl91cGRhdGUodHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzb3VyY2Ugd2l0aCB0aGUgc3BlY2lmaWVkIElEIGluIHRoZSBtYXAncyBzdHlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIHNvdXJjZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgez9PYmplY3R9IFRoZSBzdHlsZSBzb3VyY2Ugd2l0aCB0aGUgc3BlY2lmaWVkIElELCBvciBgdW5kZWZpbmVkYFxuICAgICAqICAgaWYgdGhlIElEIGNvcnJlc3BvbmRzIHRvIG5vIGV4aXN0aW5nIHNvdXJjZXMuXG4gICAgICovXG4gICAgZ2V0U291cmNlOiBmdW5jdGlvbihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5nZXRTb3VyY2UoaWQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgW01hcGJveCBzdHlsZSBsYXllcl0oaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtc3R5bGUtc3BlYy8jbGF5ZXJzKVxuICAgICAqIHRvIHRoZSBtYXAncyBzdHlsZS5cbiAgICAgKlxuICAgICAqIEEgbGF5ZXIgZGVmaW5lcyBzdHlsaW5nIGZvciBkYXRhIGZyb20gYSBzcGVjaWZpZWQgc291cmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxheWVyIFRoZSBzdHlsZSBsYXllciB0byBhZGQsIGNvbmZvcm1pbmcgdG8gdGhlIE1hcGJveCBTdHlsZSBTcGVjaWZpY2F0aW9uJ3NcbiAgICAgKiAgIFtsYXllciBkZWZpbml0aW9uXShodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1zdHlsZS1zcGVjLyNsYXllcnMpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYmVmb3JlXSBUaGUgSUQgb2YgYW4gZXhpc3RpbmcgbGF5ZXIgdG8gaW5zZXJ0IHRoZSBuZXcgbGF5ZXIgYmVmb3JlLlxuICAgICAqICAgSWYgdGhpcyBhcmd1bWVudCBpcyBvbWl0dGVkLCB0aGUgbGF5ZXIgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBsYXllcnMgYXJyYXkuXG4gICAgICogQGZpcmVzIGxheWVyLmFkZFxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqL1xuICAgIGFkZExheWVyOiBmdW5jdGlvbihsYXllciwgYmVmb3JlKSB7XG4gICAgICAgIHRoaXMuc3R5bGUuYWRkTGF5ZXIobGF5ZXIsIGJlZm9yZSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBsYXllciBmcm9tIHRoZSBtYXAncyBzdHlsZS5cbiAgICAgKlxuICAgICAqIEFsc28gcmVtb3ZlcyBhbnkgbGF5ZXJzIHdoaWNoIHJlZmVyIHRvIHRoZSBzcGVjaWZpZWQgbGF5ZXIgdmlhIGFcbiAgICAgKiBbYHJlZmAgcHJvcGVydHldKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvI2xheWVyLXJlZikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIG9mIHRoZSBsYXllciB0byByZW1vdmUuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIG5vIGxheWVyIHdpdGggdGhlIHNwZWNpZmllZCBgaWRgIGV4aXN0cy5cbiAgICAgKiBAZmlyZXMgbGF5ZXIucmVtb3ZlXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICovXG4gICAgcmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHRoaXMuc3R5bGUucmVtb3ZlTGF5ZXIoaWQpO1xuICAgICAgICB0aGlzLl91cGRhdGUodHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsYXllciB3aXRoIHRoZSBzcGVjaWZpZWQgSUQgaW4gdGhlIG1hcCdzIHN0eWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiB0aGUgbGF5ZXIgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHs/T2JqZWN0fSBUaGUgbGF5ZXIgd2l0aCB0aGUgc3BlY2lmaWVkIElELCBvciBgdW5kZWZpbmVkYFxuICAgICAqICAgaWYgdGhlIElEIGNvcnJlc3BvbmRzIHRvIG5vIGV4aXN0aW5nIGxheWVycy5cbiAgICAgKi9cbiAgICBnZXRMYXllcjogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuZ2V0TGF5ZXIoaWQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBmaWx0ZXIgZm9yIHRoZSBzcGVjaWZpZWQgc3R5bGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgVGhlIElEIG9mIHRoZSBsYXllciB0byB3aGljaCB0aGUgZmlsdGVyIHdpbGwgYmUgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXIgVGhlIGZpbHRlciwgY29uZm9ybWluZyB0byB0aGUgTWFwYm94IFN0eWxlIFNwZWNpZmljYXRpb24nc1xuICAgICAqICAgW2ZpbHRlciBkZWZpbml0aW9uXShodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1zdHlsZS1zcGVjLyN0eXBlcy1maWx0ZXIpLlxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqIEBleGFtcGxlXG4gICAgICogbWFwLnNldEZpbHRlcignbXktbGF5ZXInLCBbJz09JywgJ25hbWUnLCAnVVNBJ10pO1xuICAgICAqL1xuICAgIHNldEZpbHRlcjogZnVuY3Rpb24obGF5ZXIsIGZpbHRlcikge1xuICAgICAgICB0aGlzLnN0eWxlLnNldEZpbHRlcihsYXllciwgZmlsdGVyKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlKHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgem9vbSBleHRlbnQgZm9yIHRoZSBzcGVjaWZpZWQgc3R5bGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJJZCBUaGUgSUQgb2YgdGhlIGxheWVyIHRvIHdoaWNoIHRoZSB6b29tIGV4dGVudCB3aWxsIGJlIGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbnpvb20gVGhlIG1pbmltdW0gem9vbSB0byBzZXQgKDAtMjApLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXh6b29tIFRoZSBtYXhpbXVtIHpvb20gdG8gc2V0ICgwLTIwKS5cbiAgICAgKiBAcmV0dXJucyB7TWFwfSBgdGhpc2BcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG1hcC5zZXRMYXllclpvb21SYW5nZSgnbXktbGF5ZXInLCAyLCA1KTtcbiAgICAgKi9cbiAgICBzZXRMYXllclpvb21SYW5nZTogZnVuY3Rpb24obGF5ZXJJZCwgbWluem9vbSwgbWF4em9vbSkge1xuICAgICAgICB0aGlzLnN0eWxlLnNldExheWVyWm9vbVJhbmdlKGxheWVySWQsIG1pbnpvb20sIG1heHpvb20pO1xuICAgICAgICB0aGlzLl91cGRhdGUodHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaWx0ZXIgYXBwbGllZCB0byB0aGUgc3BlY2lmaWVkIHN0eWxlIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyIFRoZSBJRCBvZiB0aGUgc3R5bGUgbGF5ZXIgd2hvc2UgZmlsdGVyIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBsYXllcidzIGZpbHRlci5cbiAgICAgKi9cbiAgICBnZXRGaWx0ZXI6IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlLmdldEZpbHRlcihsYXllcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIGEgcGFpbnQgcHJvcGVydHkgaW4gdGhlIHNwZWNpZmllZCBzdHlsZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllciBUaGUgSUQgb2YgdGhlIGxheWVyIHRvIHNldCB0aGUgcGFpbnQgcHJvcGVydHkgaW4uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHBhaW50IHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgcGFpbnQgcHJvcGVyeSB0byBzZXQuXG4gICAgICogICBNdXN0IGJlIG9mIGEgdHlwZSBhcHByb3ByaWF0ZSBmb3IgdGhlIHByb3BlcnR5LCBhcyBkZWZpbmVkIGluIHRoZSBbTWFwYm94IFN0eWxlIFNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLXN0eWxlLXNwZWMvKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGtsYXNzIEEgc3R5bGUgY2xhc3Mgc3BlY2lmaWVyIGZvciB0aGUgcGFpbnQgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge01hcH0gYHRoaXNgXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBtYXAuc2V0UGFpbnRQcm9wZXJ0eSgnbXktbGF5ZXInLCAnZmlsbC1jb2xvcicsICcjZmFhZmVlJyk7XG4gICAgICovXG4gICAgc2V0UGFpbnRQcm9wZXJ0eTogZnVuY3Rpb24obGF5ZXIsIG5hbWUsIHZhbHVlLCBrbGFzcykge1xuICAgICAgICB0aGlzLnN0eWxlLnNldFBhaW50UHJvcGVydHkobGF5ZXIsIG5hbWUsIHZhbHVlLCBrbGFzcyk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgcGFpbnQgcHJvcGVydHkgaW4gdGhlIHNwZWNpZmllZCBzdHlsZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllciBUaGUgSUQgb2YgdGhlIGxheWVyIHRvIGdldCB0aGUgcGFpbnQgcHJvcGVydHkgZnJvbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiBhIHBhaW50IHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGtsYXNzIEEgY2xhc3Mgc3BlY2lmaWVyIGZvciB0aGUgcGFpbnQgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIHBhaW50IHByb3BlcnR5LlxuICAgICAqL1xuICAgIGdldFBhaW50UHJvcGVydHk6IGZ1bmN0aW9uKGxheWVyLCBuYW1lLCBrbGFzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZS5nZXRQYWludFByb3BlcnR5KGxheWVyLCBuYW1lLCBrbGFzcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIGEgbGF5b3V0IHByb3BlcnR5IGluIHRoZSBzcGVjaWZpZWQgc3R5bGUgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgVGhlIElEIG9mIHRoZSBsYXllciB0byBzZXQgdGhlIGxheW91dCBwcm9wZXJ0eSBpbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbGF5b3V0IHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgbGF5b3V0IHByb3BlcnkuIE11c3QgYmUgb2YgYSB0eXBlIGFwcHJvcHJpYXRlIGZvciB0aGUgcHJvcGVydHksIGFzIGRlZmluZWQgaW4gdGhlIFtNYXBib3ggU3R5bGUgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtc3R5bGUtc3BlYy8pLlxuICAgICAqIEByZXR1cm5zIHtNYXB9IGB0aGlzYFxuICAgICAqIEBleGFtcGxlXG4gICAgICogbWFwLnNldExheW91dFByb3BlcnR5KCdteS1sYXllcicsICd2aXNpYmlsaXR5JywgJ25vbmUnKTtcbiAgICAgKi9cbiAgICBzZXRMYXlvdXRQcm9wZXJ0eTogZnVuY3Rpb24obGF5ZXIsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3R5bGUuc2V0TGF5b3V0UHJvcGVydHkobGF5ZXIsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlKHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBsYXlvdXQgcHJvcGVydHkgaW4gdGhlIHNwZWNpZmllZCBzdHlsZSBsYXllci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllciBUaGUgSUQgb2YgdGhlIGxheWVyIHRvIGdldCB0aGUgbGF5b3V0IHByb3BlcnR5IGZyb20uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGxheW91dCBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIGxheW91dCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBnZXRMYXlvdXRQcm9wZXJ0eTogZnVuY3Rpb24obGF5ZXIsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGUuZ2V0TGF5b3V0UHJvcGVydHkobGF5ZXIsIG5hbWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXAncyBjb250YWluaW5nIEhUTUwgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gVGhlIG1hcCdzIGNvbnRhaW5lci5cbiAgICAgKi9cbiAgICBnZXRDb250YWluZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBIVE1MIGVsZW1lbnQgY29udGFpbmluZyB0aGUgbWFwJ3MgYDxjYW52YXM+YCBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgeW91IHdhbnQgdG8gYWRkIG5vbi1HTCBvdmVybGF5cyB0byB0aGUgbWFwLCB5b3Ugc2hvdWxkIGFwcGVuZCB0aGVtIHRvIHRoaXMgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdGhlIGVsZW1lbnQgdG8gd2hpY2ggZXZlbnQgYmluZGluZ3MgZm9yIG1hcCBpbnRlcmFjdGl2aXR5IChzdWNoIGFzIHBhbm5pbmcgYW5kIHpvb21pbmcpIGFyZVxuICAgICAqIGF0dGFjaGVkLiBJdCB3aWxsIHJlY2VpdmUgYnViYmxlZCBldmVudHMgZnJvbSBjaGlsZCBlbGVtZW50cyBzdWNoIGFzIHRoZSBgPGNhbnZhcz5gLCBidXQgbm90IGZyb21cbiAgICAgKiBtYXAgY29udHJvbHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IFRoZSBjb250YWluZXIgb2YgdGhlIG1hcCdzIGA8Y2FudmFzPmAuXG4gICAgICovXG4gICAgZ2V0Q2FudmFzQ29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhc0NvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWFwJ3MgYDxjYW52YXM+YCBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMge0hUTUxDYW52YXNFbGVtZW50fSBUaGUgbWFwJ3MgYDxjYW52YXM+YCBlbGVtZW50LlxuICAgICAqL1xuICAgIGdldENhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXMuZ2V0RWxlbWVudCgpO1xuICAgIH0sXG5cbiAgICBfc2V0dXBDb250YWluZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnbWFwYm94Z2wtbWFwJyk7XG5cbiAgICAgICAgdmFyIGNhbnZhc0NvbnRhaW5lciA9IHRoaXMuX2NhbnZhc0NvbnRhaW5lciA9IERPTS5jcmVhdGUoJ2RpdicsICdtYXBib3hnbC1jYW52YXMtY29udGFpbmVyJywgY29udGFpbmVyKTtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVyYWN0aXZlKSB7XG4gICAgICAgICAgICBjYW52YXNDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnbWFwYm94Z2wtaW50ZXJhY3RpdmUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYW52YXMgPSBuZXcgQ2FudmFzKHRoaXMsIGNhbnZhc0NvbnRhaW5lcik7XG5cbiAgICAgICAgdmFyIGNvbnRyb2xDb250YWluZXIgPSB0aGlzLl9jb250cm9sQ29udGFpbmVyID0gRE9NLmNyZWF0ZSgnZGl2JywgJ21hcGJveGdsLWNvbnRyb2wtY29udGFpbmVyJywgY29udGFpbmVyKTtcbiAgICAgICAgdmFyIGNvcm5lcnMgPSB0aGlzLl9jb250cm9sQ29ybmVycyA9IHt9O1xuICAgICAgICBbJ3RvcC1sZWZ0JywgJ3RvcC1yaWdodCcsICdib3R0b20tbGVmdCcsICdib3R0b20tcmlnaHQnXS5mb3JFYWNoKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgIGNvcm5lcnNbcG9zXSA9IERPTS5jcmVhdGUoJ2RpdicsICdtYXBib3hnbC1jdHJsLScgKyBwb3MsIGNvbnRyb2xDb250YWluZXIpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX3NldHVwUGFpbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuX2NhbnZhcy5nZXRXZWJHTENvbnRleHQoe1xuICAgICAgICAgICAgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogdGhpcy5fZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCxcbiAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdGhpcy5fcHJlc2VydmVEcmF3aW5nQnVmZmVyXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnZXJyb3InLCB7IGVycm9yOiBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIFdlYkdMJykgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhaW50ZXIgPSBuZXcgUGFpbnRlcihnbCwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBXZWJHTCBjb250ZXh0IGlzIGxvc3QuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgd2ViZ2xjb250ZXh0bG9zdFxuICAgICAqIEBtZW1iZXJvZiBNYXBcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7V2ViR0xDb250ZXh0RXZlbnR9IG9yaWdpbmFsRXZlbnQgVGhlIG9yaWdpbmFsIERPTSBldmVudC5cbiAgICAgKi9cbiAgICBfY29udGV4dExvc3Q6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICh0aGlzLl9mcmFtZUlkKSB7XG4gICAgICAgICAgICBicm93c2VyLmNhbmNlbEZyYW1lKHRoaXMuX2ZyYW1lSWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlyZSgnd2ViZ2xjb250ZXh0bG9zdCcsIHtvcmlnaW5hbEV2ZW50OiBldmVudH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBXZWJHTCBjb250ZXh0IGlzIHJlc3RvcmVkLlxuICAgICAqXG4gICAgICogQGV2ZW50IHdlYmdsY29udGV4dHJlc3RvcmVkXG4gICAgICogQG1lbWJlcm9mIE1hcFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtXZWJHTENvbnRleHRFdmVudH0gb3JpZ2luYWxFdmVudCBUaGUgb3JpZ2luYWwgRE9NIGV2ZW50LlxuICAgICAqL1xuICAgIF9jb250ZXh0UmVzdG9yZWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3NldHVwUGFpbnRlcigpO1xuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgdGhpcy5maXJlKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIHtvcmlnaW5hbEV2ZW50OiBldmVudH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIG1hcCBpcyBmdWxseSBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGBmYWxzZWAgaWYgdGhlIHN0eWxlIGlzIG5vdCB5ZXQgZnVsbHkgbG9hZGVkLFxuICAgICAqIG9yIGlmIHRoZXJlIGhhcyBiZWVuIGEgY2hhbmdlIHRvIHRoZSBzb3VyY2VzIG9yIHN0eWxlIHRoYXRcbiAgICAgKiBoYXMgbm90IHlldCBmdWxseSBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gQSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgbWFwIGlzIGZ1bGx5IGxvYWRlZC5cbiAgICAgKi9cbiAgICBsb2FkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fc3R5bGVEaXJ0eSB8fCB0aGlzLl9zb3VyY2VzRGlydHkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5zdHlsZSB8fCAhdGhpcy5zdHlsZS5sb2FkZWQoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGlzIG1hcCdzIHN0eWxlIGFuZCBzb3VyY2VzLCBhbmQgcmUtcmVuZGVyIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVwZGF0ZVN0eWxlIG1hcmsgdGhlIG1hcCdzIHN0eWxlIGZvciByZXByb2Nlc3NpbmcgYXNcbiAgICAgKiB3ZWxsIGFzIGl0cyBzb3VyY2VzXG4gICAgICogQHJldHVybnMge01hcH0gdGhpc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24odXBkYXRlU3R5bGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0eWxlKSByZXR1cm4gdGhpcztcblxuICAgICAgICB0aGlzLl9zdHlsZURpcnR5ID0gdGhpcy5fc3R5bGVEaXJ0eSB8fCB1cGRhdGVTdHlsZTtcbiAgICAgICAgdGhpcy5fc291cmNlc0RpcnR5ID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLl9yZXJlbmRlcigpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxsIHdoZW4gYSAocmUtKXJlbmRlciBvZiB0aGUgbWFwIGlzIHJlcXVpcmVkLCBlLmcuIHdoZW4gdGhlXG4gICAgICogdXNlciBwYW5uZWQgb3Igem9vbWVkLGYgb3IgbmV3IGRhdGEgaXMgYXZhaWxhYmxlLlxuICAgICAqIEByZXR1cm5zIHtNYXB9IHRoaXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUgJiYgdGhpcy5fc3R5bGVEaXJ0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0eWxlRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLnVwZGF0ZSh0aGlzLl9jbGFzc2VzLCB0aGlzLl9jbGFzc09wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsYXNzT3B0aW9ucyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZS5fcmVjYWxjdWxhdGUodGhpcy50cmFuc2Zvcm0uem9vbSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlICYmIHRoaXMuX3NvdXJjZXNEaXJ0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUuX3VwZGF0ZVNvdXJjZXModGhpcy50cmFuc2Zvcm0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIucmVuZGVyKHRoaXMuc3R5bGUsIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZzogdGhpcy5zaG93VGlsZUJvdW5kYXJpZXMsXG4gICAgICAgICAgICAgICAgc2hvd092ZXJkcmF3SW5zcGVjdG9yOiB0aGlzLl9zaG93T3ZlcmRyYXdJbnNwZWN0b3IsXG4gICAgICAgICAgICAgICAgdmVydGljZXM6IHRoaXMudmVydGljZXMsXG4gICAgICAgICAgICAgICAgcm90YXRpbmc6IHRoaXMucm90YXRpbmcsXG4gICAgICAgICAgICAgICAgem9vbWluZzogdGhpcy56b29taW5nXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5maXJlKCdyZW5kZXInKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMubG9hZGVkKCkgJiYgIXRoaXMuX2xvYWRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdsb2FkJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lSWQgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuYW5pbWF0aW9uTG9vcC5zdG9wcGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHlsZURpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZXNEaXJ0eSB8fCB0aGlzLl9yZXBhaW50IHx8IHRoaXMuX3N0eWxlRGlydHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXJlbmRlcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmUoJ2Vycm9yJywge2Vycm9yOiBlcnJvcn0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBtYXAncyB1bmRlcmx5aW5nIHJlc291cmNlcywgaW5jbHVkaW5nIHdlYiB3b3JrZXJzIGFuZCBET00gZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBBZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kLCB5b3UgbXVzdCBub3QgY2FsbCBhbnkgb3RoZXIgbWV0aG9kcyBvbiB0aGUgbWFwLlxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNoKSB0aGlzLl9oYXNoLnJlbW92ZSgpO1xuICAgICAgICBicm93c2VyLmNhbmNlbEZyYW1lKHRoaXMuX2ZyYW1lSWQpO1xuICAgICAgICB0aGlzLnNldFN0eWxlKG51bGwpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleHRlbnNpb24gPSB0aGlzLnBhaW50ZXIuZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9sb3NlX2NvbnRleHQnKTtcbiAgICAgICAgaWYgKGV4dGVuc2lvbikgZXh0ZW5zaW9uLmxvc2VDb250ZXh0KCk7XG4gICAgICAgIHJlbW92ZU5vZGUodGhpcy5fY2FudmFzQ29udGFpbmVyKTtcbiAgICAgICAgcmVtb3ZlTm9kZSh0aGlzLl9jb250cm9sQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ21hcGJveGdsLW1hcCcpO1xuICAgIH0sXG5cbiAgICBfcmVyZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZSAmJiAhdGhpcy5fZnJhbWVJZCkge1xuICAgICAgICAgICAgdGhpcy5fZnJhbWVJZCA9IGJyb3dzZXIuZnJhbWUodGhpcy5fcmVuZGVyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZm9yd2FyZFN0eWxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5maXJlKCdzdHlsZS4nICsgZS50eXBlLCB1dGlsLmV4dGVuZCh7c3R5bGU6IGUudGFyZ2V0fSwgZSkpO1xuICAgIH0sXG5cbiAgICBfZm9yd2FyZFNvdXJjZUV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuZmlyZShlLnR5cGUsIHV0aWwuZXh0ZW5kKHtzdHlsZTogZS50YXJnZXR9LCBlKSk7XG4gICAgfSxcblxuICAgIF9mb3J3YXJkTGF5ZXJFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmZpcmUoZS50eXBlLCB1dGlsLmV4dGVuZCh7c3R5bGU6IGUudGFyZ2V0fSwgZSkpO1xuICAgIH0sXG5cbiAgICBfZm9yd2FyZFRpbGVFdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmZpcmUoZS50eXBlLCB1dGlsLmV4dGVuZCh7c3R5bGU6IGUudGFyZ2V0fSwgZSkpO1xuICAgIH0sXG5cbiAgICBfb25TdHlsZUxvYWQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtLnVubW9kaWZpZWQpIHtcbiAgICAgICAgICAgIHRoaXMuanVtcFRvKHRoaXMuc3R5bGUuc3R5bGVzaGVldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdHlsZS51cGRhdGUodGhpcy5fY2xhc3Nlcywge3RyYW5zaXRpb246IGZhbHNlfSk7XG4gICAgICAgIHRoaXMuX2ZvcndhcmRTdHlsZUV2ZW50KGUpO1xuICAgIH0sXG5cbiAgICBfb25TdHlsZUNoYW5nZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLl91cGRhdGUodHJ1ZSk7XG4gICAgICAgIHRoaXMuX2ZvcndhcmRTdHlsZUV2ZW50KGUpO1xuICAgIH0sXG5cbiAgICBfb25Tb3VyY2VBZGQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGUuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlLm9uQWRkKVxuICAgICAgICAgICAgc291cmNlLm9uQWRkKHRoaXMpO1xuICAgICAgICB0aGlzLl9mb3J3YXJkU291cmNlRXZlbnQoZSk7XG4gICAgfSxcblxuICAgIF9vblNvdXJjZVJlbW92ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgc291cmNlID0gZS5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2Uub25SZW1vdmUpXG4gICAgICAgICAgICBzb3VyY2Uub25SZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMuX2ZvcndhcmRTb3VyY2VFdmVudChlKTtcbiAgICB9LFxuXG4gICAgX29uU291cmNlVXBkYXRlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICB0aGlzLl9mb3J3YXJkU291cmNlRXZlbnQoZSk7XG4gICAgfSxcblxuICAgIF9vbldpbmRvd09ubGluZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICBfb25XaW5kb3dSZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fdHJhY2tSZXNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpLnJlc2l6ZSgpLl91cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG51dGlsLmV4dGVuZEFsbChNYXAucHJvdG90eXBlLCAvKiogQGxlbmRzIE1hcC5wcm90b3R5cGUgKi97XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFuZCBzZXRzIGEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIG1hcCB3aWxsIHJlbmRlciBhbiBvdXRsaW5lXG4gICAgICogYXJvdW5kIGVhY2ggdGlsZS4gVGhlc2UgdGlsZSBib3VuZGFyaWVzIGFyZSB1c2VmdWwgZm9yIGRlYnVnZ2luZy5cbiAgICAgKlxuICAgICAqIEBuYW1lIHNob3dUaWxlQm91bmRhcmllc1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBtZW1iZXJvZiBNYXBcbiAgICAgKi9cbiAgICBfc2hvd1RpbGVCb3VuZGFyaWVzOiBmYWxzZSxcbiAgICBnZXQgc2hvd1RpbGVCb3VuZGFyaWVzKCkgeyByZXR1cm4gdGhpcy5fc2hvd1RpbGVCb3VuZGFyaWVzOyB9LFxuICAgIHNldCBzaG93VGlsZUJvdW5kYXJpZXModmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Nob3dUaWxlQm91bmRhcmllcyA9PT0gdmFsdWUpIHJldHVybjtcbiAgICAgICAgdGhpcy5fc2hvd1RpbGVCb3VuZGFyaWVzID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFuZCBzZXRzIGEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIG1hcCB3aWxsIHJlbmRlciBib3hlc1xuICAgICAqIGFyb3VuZCBhbGwgc3ltYm9scyBpbiB0aGUgZGF0YSBzb3VyY2UsIHJldmVhbGluZyB3aGljaCBzeW1ib2xzXG4gICAgICogd2VyZSByZW5kZXJlZCBvciB3aGljaCB3ZXJlIGhpZGRlbiBkdWUgdG8gY29sbGlzaW9ucy5cbiAgICAgKiBUaGlzIGluZm9ybWF0aW9uIGlzIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuICAgICAqXG4gICAgICogQG5hbWUgc2hvd0NvbGxpc2lvbkJveGVzXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE1hcFxuICAgICAqL1xuICAgIF9zaG93Q29sbGlzaW9uQm94ZXM6IGZhbHNlLFxuICAgIGdldCBzaG93Q29sbGlzaW9uQm94ZXMoKSB7IHJldHVybiB0aGlzLl9zaG93Q29sbGlzaW9uQm94ZXM7IH0sXG4gICAgc2V0IHNob3dDb2xsaXNpb25Cb3hlcyh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fc2hvd0NvbGxpc2lvbkJveGVzID09PSB2YWx1ZSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9zaG93Q29sbGlzaW9uQm94ZXMgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zdHlsZS5fcmVkb1BsYWNlbWVudCgpO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIEdldHMgYW5kIHNldHMgYSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgbWFwIHNob3VsZCBjb2xvci1jb2RlXG4gICAgICogZWFjaCBmcmFnbWVudCB0byBzaG93IGhvdyBtYW55IHRpbWVzIGl0IGhhcyBiZWVuIHNoYWRlZC5cbiAgICAgKiBXaGl0ZSBmcmFnbWVudHMgaGF2ZSBiZWVuIHNoYWRlZCA4IG9yIG1vcmUgdGltZXMuXG4gICAgICogQmxhY2sgZnJhZ21lbnRzIGhhdmUgYmVlbiBzaGFkZWQgMCB0aW1lcy5cbiAgICAgKiBUaGlzIGluZm9ybWF0aW9uIGlzIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuICAgICAqXG4gICAgICogQG5hbWUgc2hvd092ZXJkcmF3XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQG1lbWJlcm9mIE1hcFxuICAgICAqL1xuICAgIF9zaG93T3ZlcmRyYXdJbnNwZWN0b3I6IGZhbHNlLFxuICAgIGdldCBzaG93T3ZlcmRyYXdJbnNwZWN0b3IoKSB7IHJldHVybiB0aGlzLl9zaG93T3ZlcmRyYXdJbnNwZWN0b3I7IH0sXG4gICAgc2V0IHNob3dPdmVyZHJhd0luc3BlY3Rvcih2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fc2hvd092ZXJkcmF3SW5zcGVjdG9yID09PSB2YWx1ZSkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9zaG93T3ZlcmRyYXdJbnNwZWN0b3IgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgYW5kIHNldHMgYSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgbWFwIHdpbGxcbiAgICAgKiBjb250aW51b3VzbHkgcmVwYWludC4gVGhpcyBpbmZvcm1hdGlvbiBpcyB1c2VmdWwgZm9yIGFuYWx5emluZyBwZXJmb3JtYW5jZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHJlcGFpbnRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAbWVtYmVyb2YgTWFwXG4gICAgICovXG4gICAgX3JlcGFpbnQ6IGZhbHNlLFxuICAgIGdldCByZXBhaW50KCkgeyByZXR1cm4gdGhpcy5fcmVwYWludDsgfSxcbiAgICBzZXQgcmVwYWludCh2YWx1ZSkgeyB0aGlzLl9yZXBhaW50ID0gdmFsdWU7IHRoaXMuX3VwZGF0ZSgpOyB9LFxuXG4gICAgLy8gc2hvdyB2ZXJ0aWNlc1xuICAgIF92ZXJ0aWNlczogZmFsc2UsXG4gICAgZ2V0IHZlcnRpY2VzKCkgeyByZXR1cm4gdGhpcy5fdmVydGljZXM7IH0sXG4gICAgc2V0IHZlcnRpY2VzKHZhbHVlKSB7IHRoaXMuX3ZlcnRpY2VzID0gdmFsdWU7IHRoaXMuX3VwZGF0ZSgpOyB9XG59KTtcblxuZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlKSB7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgW2BMbmdMYXRgXSgjTG5nTGF0KSBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgdHdvIG51bWJlcnMgcmVwcmVzZW50aW5nIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUuXG4gKlxuICogQHR5cGVkZWYgeyhMbmdMYXQgfCBBcnJheTxudW1iZXI+KX0gTG5nTGF0TGlrZVxuICogQGV4YW1wbGVcbiAqIHZhciB2MSA9IG5ldyBtYXBib3hnbC5MbmdMYXQoLTEyMi40MjA2NzksIDM3Ljc3MjUzNyk7XG4gKiB2YXIgdjIgPSBbLTEyMi40MjA2NzksIDM3Ljc3MjUzN107XG4gKi9cblxuLyoqXG4gKiBBIFtgTG5nTGF0Qm91bmRzYF0oI0xuZ0xhdEJvdW5kcykgb2JqZWN0IG9yIGFuIGFycmF5IG9mIFtgTG5nTGF0TGlrZWBdKCNMbmdMYXRMaWtlKSBvYmplY3RzLlxuICpcbiAqIEB0eXBlZGVmIHsoTG5nTGF0Qm91bmRzIHwgQXJyYXk8TG5nTGF0TGlrZT4pfSBMbmdMYXRCb3VuZHNMaWtlXG4gKiBAZXhhbXBsZVxuICogdmFyIHYxID0gbmV3IG1hcGJveGdsLkxuZ0xhdEJvdW5kcyhcbiAqICAgbmV3IG1hcGJveGdsLkxuZ0xhdCgtNzMuOTg3NiwgNDAuNzY2MSksXG4gKiAgIG5ldyBtYXBib3hnbC5MbmdMYXQoLTczLjkzOTcsIDQwLjgwMDIpXG4gKiApO1xuICogdmFyIHYyID0gbmV3IG1hcGJveGdsLkxuZ0xhdEJvdW5kcyhbLTczLjk4NzYsIDQwLjc2NjFdLCBbLTczLjkzOTcsIDQwLjgwMDJdKVxuICogdmFyIHYzID0gW1stNzMuOTg3NiwgNDAuNzY2MV0sIFstNzMuOTM5NywgNDAuODAwMl1dO1xuICovXG5cbi8qKlxuICogQSBbYFBvaW50YCBnZW9tZXRyeV0oaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9wb2ludC1nZW9tZXRyeSkgb2JqZWN0LCB3aGljaCBoYXNcbiAqIGB4YCBhbmQgYHlgIHByb3BlcnRpZXMgcmVwcmVzZW50aW5nIGNvb3JkaW5hdGVzLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBvaW50XG4gKi9cblxuLyoqXG4gKiBBIFtgUG9pbnRgXSgjUG9pbnQpIG9yIGFuIGFycmF5IG9mIHR3byBudW1iZXJzIHJlcHJlc2VudGluZyBgeGAgYW5kIGB5YCBjb29yZGluYXRlcy5cbiAqXG4gKiBAdHlwZWRlZiB7KFBvaW50IHwgQXJyYXk8bnVtYmVyPil9IFBvaW50TGlrZVxuICovXG5cbi8qKlxuICogT3B0aW9ucyBjb21tb24gdG8ge0BsaW5rIE1hcCNhZGRDbGFzc30sIHtAbGluayBNYXAjcmVtb3ZlQ2xhc3N9LFxuICogYW5kIHtAbGluayBNYXAjc2V0Q2xhc3Nlc30sIGNvbnRyb2xsaW5nXG4gKiB3aGV0aGVyIG9yIG5vdCB0byBzbW9vdGhseSB0cmFuc2l0aW9uIHByb3BlcnR5IGNoYW5nZXMgdHJpZ2dlcmVkIGJ5IGEgY2xhc3MgY2hhbmdlLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0eWxlT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSB0cmFuc2l0aW9uIElmIGB0cnVlYCwgcHJvcGVydHkgY2hhbmdlcyB3aWxsIHNtb290bHkgdHJhbnNpdGlvbi5cbiAqL1xuXG4vKipcbiAqIEZpcmVkIHdoZW5ldmVyIHRoZSBtYXAgaXMgZHJhd24gdG8gdGhlIHNjcmVlbiwgYXMgdGhlIHJlc3VsdCBvZlxuICpcbiAqIC0gYSBjaGFuZ2UgdG8gdGhlIG1hcCdzIHBvc2l0aW9uLCB6b29tLCBwaXRjaCwgb3IgYmVhcmluZ1xuICogLSBhIGNoYW5nZSB0byB0aGUgbWFwJ3Mgc3R5bGVcbiAqIC0gYSBjaGFuZ2UgdG8gYSBHZW9KU09OIHNvdXJjZVxuICogLSB0aGUgbG9hZGluZyBvZiBhIHZlY3RvciB0aWxlLCBHZW9KU09OIGZpbGUsIGdseXBoLCBvciBzcHJpdGVcbiAqXG4gKiBAZXZlbnQgcmVuZGVyXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gYSBwb2ludCBkZXZpY2UgKHVzdWFsbHkgYSBtb3VzZSkgbGVhdmVzIHRoZSBtYXAncyBjYW52YXMuXG4gKlxuICogQGV2ZW50IG1vdXNlb3V0XG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7TWFwTW91c2VFdmVudH0gZGF0YVxuICovXG5cbi8qKlxuICogRmlyZWQgd2hlbiBhIHBvaW50aW5nIGRldmljZSAodXN1YWxseSBhIG1vdXNlKSBpcyBwcmVzc2VkIHdpdGhpbiB0aGUgbWFwLlxuICpcbiAqIEBldmVudCBtb3VzZWRvd25cbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtNYXBNb3VzZUV2ZW50fSBkYXRhXG4gKi9cblxuLyoqXG4gKiBGaXJlZCB3aGVuIGEgcG9pbnRpbmcgZGV2aWNlICh1c3VhbGx5IGEgbW91c2UpIGlzIHJlbGVhc2VkIHdpdGhpbiB0aGUgbWFwLlxuICpcbiAqIEBldmVudCBtb3VzZXVwXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7TWFwTW91c2VFdmVudH0gZGF0YVxuICovXG5cbi8qKlxuICogRmlyZWQgd2hlbiBhIHBvaW50aW5nIGRldmljZSAodXN1YWxseSBhIG1vdXNlKSBpcyBtb3ZlZCB3aXRoaW4gdGhlIG1hcC5cbiAqXG4gKiBAZXZlbnQgbW91c2Vtb3ZlXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7TWFwTW91c2VFdmVudH0gZGF0YVxuICovXG5cbi8qKlxuICogRmlyZWQgd2hlbiBhIHRvdWNoIHBvaW50IGlzIHBsYWNlZCBvbiB0aGUgbWFwLlxuICpcbiAqIEBldmVudCB0b3VjaHN0YXJ0XG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7TWFwVG91Y2hFdmVudH0gZGF0YVxuICovXG5cbi8qKlxuICogRmlyZWQgd2hlbiBhIHRvdWNoIHBvaW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBldmVudCB0b3VjaGVuZFxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge01hcFRvdWNoRXZlbnR9IGRhdGFcbiAqL1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gYSB0b3VjaCBwb2ludCBpcyBtb3ZlZCB3aXRoaW4gdGhlIG1hcC5cbiAqXG4gKiBAZXZlbnQgdG91Y2htb3ZlXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7TWFwVG91Y2hFdmVudH0gZGF0YVxuICovXG5cbi8qKlxuICogRmlyZWQgd2hlbiBhIHRvdWNoIHBvaW50IGhhcyBiZWVuIGRpc3J1cHRlZC5cbiAqXG4gKiBAZXZlbnQgdG91Y2hjYW5jZWxcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtNYXBUb3VjaEV2ZW50fSBkYXRhXG4gKi9cblxuLyoqXG4gKiBGaXJlZCB3aGVuIGEgcG9pbnRpbmcgZGV2aWNlICh1c3VhbGx5IGEgbW91c2UpIGlzIHByZXNzZWQgYW5kIHJlbGVhc2VkIGF0IHRoZSBzYW1lIHBvaW50IG9uIHRoZSBtYXAuXG4gKlxuICogQGV2ZW50IGNsaWNrXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7TWFwTW91c2VFdmVudH0gZGF0YVxuICovXG5cbi8qKlxuICogRmlyZWQgd2hlbiBhIHBvaW50aW5nIGRldmljZSAodXN1YWxseSBhIG1vdXNlKSBpcyBjbGlja2VkIHR3aWNlIGF0IHRoZSBzYW1lIHBvaW50IG9uIHRoZSBtYXAuXG4gKlxuICogQGV2ZW50IGRibGNsaWNrXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7TWFwTW91c2VFdmVudH0gZGF0YVxuICovXG5cbi8qKlxuICogRmlyZWQgd2hlbiB0aGUgcmlnaHQgYnV0dG9uIG9mIHRoZSBtb3VzZSBpcyBjbGlja2VkIG9yIHRoZSBjb250ZXh0IG1lbnUga2V5IGlzIHByZXNzZWQgd2l0aGluIHRoZSBtYXAuXG4gKlxuICogQGV2ZW50IGNvbnRleHRtZW51XG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7TWFwTW91c2VFdmVudH0gZGF0YVxuICovXG5cbi8qKlxuICogRmlyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgYWxsIG5lY2Vzc2FyeSByZXNvdXJjZXMgaGF2ZSBiZWVuIGRvd25sb2FkZWRcbiAqIGFuZCB0aGUgZmlyc3QgdmlzdWFsbHkgY29tcGxldGUgcmVuZGVyaW5nIG9mIHRoZSBtYXAgaGFzIG9jY3VycmVkLlxuICpcbiAqIEBldmVudCBsb2FkXG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxuLyoqXG4gKiBGaXJlZCBqdXN0IGJlZm9yZSB0aGUgbWFwIGJlZ2lucyBhIHRyYW5zaXRpb24gZnJvbSBvbmVcbiAqIHZpZXcgdG8gYW5vdGhlciwgYXMgdGhlIHJlc3VsdCBvZiBlaXRoZXIgdXNlciBpbnRlcmFjdGlvbiBvciBtZXRob2RzIHN1Y2ggYXMgW01hcCNqdW1wVG9dKCNNYXAjanVtcFRvKS5cbiAqXG4gKiBAZXZlbnQgbW92ZXN0YXJ0XG4gKiBAbWVtYmVyb2YgTWFwXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7TWFwTW91c2VFdmVudCB8IE1hcFRvdWNoRXZlbnR9IGRhdGFcbiAqL1xuXG4vKipcbiAqIEZpcmVkIHJlcGVhdGVkbHkgZHVyaW5nIGFuIGFuaW1hdGVkIHRyYW5zaXRpb24gZnJvbSBvbmUgdmlldyB0b1xuICogYW5vdGhlciwgYXMgdGhlIHJlc3VsdCBvZiBlaXRoZXIgdXNlciBpbnRlcmFjdGlvbiBvciBtZXRob2RzIHN1Y2ggYXMgW01hcCNmbHlUb10oI01hcCNmbHlUbykuXG4gKlxuICogQGV2ZW50IG1vdmVcbiAqIEBtZW1iZXJvZiBNYXBcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtNYXBNb3VzZUV2ZW50IHwgTWFwVG91Y2hFdmVudH0gZGF0YVxuICovXG5cbi8qKlxuICogRmlyZWQganVzdCBhZnRlciB0aGUgbWFwIGNvbXBsZXRlcyBhIHRyYW5zaXRpb24gZnJvbSBvbmVcbiAqIHZpZXcgdG8gYW5vdGhlciwgYXMgdGhlIHJlc3VsdCBvZiBlaXRoZXIgdXNlciBpbnRlcmFjdGlvbiBvciBtZXRob2RzIHN1Y2ggYXMgW01hcCNqdW1wVG9dKCNNYXAjanVtcFRvKS5cbiAqXG4gKiBAZXZlbnQgbW92ZWVuZFxuICogQG1lbWJlcm9mIE1hcFxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge01hcE1vdXNlRXZlbnQgfCBNYXBUb3VjaEV2ZW50fSBkYXRhXG4gKi9cblxuIC8qKlxuICAqIEZpcmVkIGlmIGFueSBlcnJvciBvY2N1cnMuIFRoaXMgaXMgR0wgSlMncyBwcmltYXJ5IGVycm9yIHJlcG9ydGluZ1xuICAqIG1lY2hhbmlzbS4gV2UgdXNlIGFuIGV2ZW50IGluc3RlYWQgb2YgYHRocm93YCB0byBiZXR0ZXIgYWNjb21tb2RhdGVcbiAgKiBhc3luY3Jvbm91cyBvcGVyYXRpb25zLiBJZiBubyBsaXN0ZW5lcnMgYXJlIGJvdW5kIHRvIHRoZSBgZXJyb3JgIGV2ZW50LCB0aGVcbiAgKiBlcnJvciB3aWxsIGJlIHByaW50ZWQgdG8gdGhlIGNvbnNvbGUuXG4gICpcbiAgKiBAZXZlbnQgZXJyb3JcbiAgKiBAbWVtYmVyb2YgTWFwXG4gICogQGluc3RhbmNlXG4gICogQHByb3BlcnR5IHt7ZXJyb3I6IHttZXNzYWdlOiBzdHJpbmd9fX0gZGF0YVxuICAqL1xuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBNYXJrZXI7XG5cbnZhciBET00gPSByZXF1aXJlKCcuLi91dGlsL2RvbScpO1xudmFyIExuZ0xhdCA9IHJlcXVpcmUoJy4uL2dlby9sbmdfbGF0Jyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXJrZXIgY29tcG9uZW50XG4gKiBAY2xhc3MgTWFya2VyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50PX0gZWxlbWVudCBET00gZWxlbWVudCB0byB1c2UgYXMgYSBtYXJrZXIgKGNyZWF0ZXMgYSBkaXYgZWxlbWVudCBieSBkZWZhdWx0KVxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAcGFyYW0ge1BvaW50TGlrZT19IG9wdGlvbnMub2Zmc2V0IFRoZSBvZmZzZXQgaW4gcGl4ZWxzIGFzIGEgW2BQb2ludExpa2VgXSgjUG9pbnRMaWtlKSBvYmplY3QgdG8gYXBwbHkgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQncyB0b3AgbGVmdCBjb3JuZXIuIE5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgbWFya2VyID0gbmV3IG1hcGJveGdsLk1hcmtlcigpXG4gKiAgIC5zZXRMbmdMYXQoWzMwLjUsIDUwLjVdKVxuICogICAuYWRkVG8obWFwKTtcbiAqL1xuZnVuY3Rpb24gTWFya2VyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudCA9IERPTS5jcmVhdGUoJ2RpdicpO1xuICAgIH1cbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ21hcGJveGdsLW1hcmtlcicpO1xuICAgIHRoaXMuX2VsID0gZWxlbWVudDtcblxuICAgIHRoaXMuX29mZnNldCA9IFBvaW50LmNvbnZlcnQob3B0aW9ucyAmJiBvcHRpb25zLm9mZnNldCB8fCBbMCwgMF0pO1xuXG4gICAgdGhpcy5fdXBkYXRlID0gdGhpcy5fdXBkYXRlLmJpbmQodGhpcyk7XG59XG5cbk1hcmtlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgdGhlIG1hcmtlciB0byBhIG1hcFxuICAgICAqIEBwYXJhbSB7TWFwfSBtYXBcbiAgICAgKiBAcmV0dXJucyB7TWFya2VyfSBgdGhpc2BcbiAgICAgKi9cbiAgICBhZGRUbzogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICAgICAgbWFwLmdldENhbnZhc0NvbnRhaW5lcigpLmFwcGVuZENoaWxkKHRoaXMuX2VsKTtcbiAgICAgICAgbWFwLm9uKCdtb3ZlJywgdGhpcy5fdXBkYXRlKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBtYXJrZXIgZnJvbSBhIG1hcFxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIG1hcmtlciA9IG5ldyBtYXBib3hnbC5NYXJrZXIoKS5hZGRUbyhtYXApO1xuICAgICAqIG1hcmtlci5yZW1vdmUoKTtcbiAgICAgKiBAcmV0dXJucyB7TWFya2VyfSBgdGhpc2BcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fbWFwKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAub2ZmKCdtb3ZlJywgdGhpcy5fdXBkYXRlKTtcbiAgICAgICAgICAgIHRoaXMuX21hcCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX2VsLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLl9lbCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1hcmtlcidzIGdlb2dyYXBoaWNhbCBsb2NhdGlvblxuICAgICAqIEByZXR1cm5zIHtMbmdMYXR9XG4gICAgICovXG4gICAgZ2V0TG5nTGF0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xuZ0xhdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBtYXJrZXIncyBnZW9ncmFwaGljYWwgcG9zaXRpb24gYW5kIG1vdmUgaXQuXG4gICAgICogQHBhcmFtIHtMbmdMYXR9IGxuZ2xhdFxuICAgICAqIEByZXR1cm5zIHtNYXJrZXJ9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldExuZ0xhdDogZnVuY3Rpb24obG5nbGF0KSB7XG4gICAgICAgIHRoaXMuX2xuZ0xhdCA9IExuZ0xhdC5jb252ZXJ0KGxuZ2xhdCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0RWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbDtcbiAgICB9LFxuXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5fbWFwKSByZXR1cm47XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLl9tYXAucHJvamVjdCh0aGlzLl9sbmdMYXQpLl9hZGQodGhpcy5fb2Zmc2V0KTtcbiAgICAgICAgRE9NLnNldFRyYW5zZm9ybSh0aGlzLl9lbCwgJ3RyYW5zbGF0ZSgnICsgcG9zLnggKyAncHgsJyArIHBvcy55ICsgJ3B4KScpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUG9wdXA7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91dGlsJyk7XG52YXIgRXZlbnRlZCA9IHJlcXVpcmUoJy4uL3V0aWwvZXZlbnRlZCcpO1xudmFyIERPTSA9IHJlcXVpcmUoJy4uL3V0aWwvZG9tJyk7XG52YXIgTG5nTGF0ID0gcmVxdWlyZSgnLi4vZ2VvL2xuZ19sYXQnKTtcblxuLyoqXG4gKiBBIHBvcHVwIGNvbXBvbmVudC5cbiAqXG4gKiBAY2xhc3MgUG9wdXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2xvc2VCdXR0b249dHJ1ZV0gSWYgYHRydWVgLCBhIGNsb3NlIGJ1dHRvbiB3aWxsIGFwcGVhciBpbiB0aGVcbiAqICAgdG9wIHJpZ2h0IGNvcm5lciBvZiB0aGUgcG9wdXAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsb3NlT25DbGljaz10cnVlXSBJZiBgdHJ1ZWAsIHRoZSBwb3B1cCB3aWxsIGNsb3NlZCB3aGVuIHRoZVxuICogICBtYXAgaXMgY2xpY2tlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmFuY2hvciAtIEEgc3RyaW5nIGluZGljYXRpbmcgdGhlIHBvcHVwJ3MgbG9jYXRpb24gcmVsYXRpdmUgdG9cbiAqICAgdGhlIGNvb3JkaW5hdGUgc2V0IHZpYSBbUG9wdXAjc2V0TG5nTGF0XSgjUG9wdXAjc2V0TG5nTGF0KS5cbiAqICAgT3B0aW9ucyBhcmUgYCd0b3AnYCwgYCdib3R0b20nYCwgYCdsZWZ0J2AsIGAncmlnaHQnYCwgYCd0b3AtbGVmdCdgLFxuICogYCd0b3AtcmlnaHQnYCwgYCdib3R0b20tbGVmdCdgLCBhbmQgYCdib3R0b20tcmlnaHQnYC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9wdXAgPSBuZXcgbWFwYm94Z2wuUG9wdXAoKVxuICogICAuc2V0TG5nTGF0KGUubG5nTGF0KVxuICogICAuc2V0SFRNTChcIjxoMT5IZWxsbyBXb3JsZCE8L2gxPlwiKVxuICogICAuYWRkVG8obWFwKTtcbiAqL1xuZnVuY3Rpb24gUG9wdXAob3B0aW9ucykge1xuICAgIHV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICB1dGlsLmJpbmRBbGwoW1xuICAgICAgICAnX3VwZGF0ZScsXG4gICAgICAgICdfb25DbGlja0Nsb3NlJ10sXG4gICAgICAgIHRoaXMpO1xufVxuXG5Qb3B1cC5wcm90b3R5cGUgPSB1dGlsLmluaGVyaXQoRXZlbnRlZCwgLyoqIEBsZW5kcyBQb3B1cC5wcm90b3R5cGUgKi97XG4gICAgb3B0aW9uczoge1xuICAgICAgICBjbG9zZUJ1dHRvbjogdHJ1ZSxcbiAgICAgICAgY2xvc2VPbkNsaWNrOiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIHBvcHVwIHRvIGEgbWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtNYXB9IG1hcCBUaGUgTWFwYm94IEdMIEpTIG1hcCB0byBhZGQgdGhlIHBvcHVwIHRvLlxuICAgICAqIEByZXR1cm5zIHtQb3B1cH0gYHRoaXNgXG4gICAgICovXG4gICAgYWRkVG86IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgICAgIHRoaXMuX21hcC5vbignbW92ZScsIHRoaXMuX3VwZGF0ZSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5fb25DbGlja0Nsb3NlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHBvcHVwIGZyb20gdGhlIG1hcCBpdCBoYXMgYmVlbiBhZGRlZCB0by5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHBvcHVwID0gbmV3IG1hcGJveGdsLlBvcHVwKCkuYWRkVG8obWFwKTtcbiAgICAgKiBwb3B1cC5yZW1vdmUoKTtcbiAgICAgKiBAcmV0dXJucyB7UG9wdXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb250ZW50ICYmIHRoaXMuX2NvbnRlbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fY29udGVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb250YWluZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbWFwKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAub2ZmKCdtb3ZlJywgdGhpcy5fdXBkYXRlKTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5vZmYoJ2NsaWNrJywgdGhpcy5fb25DbGlja0Nsb3NlKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9tYXA7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiB0aGUgcG9wdXAgaXMgY2xvc2VkIG1hbnVhbGx5IG9yIHByb2dyYW1hdGljYWxseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IGNsb3NlXG4gICAgICAgICAqIEBtZW1iZXJvZiBQb3B1cFxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByb3BlcnR5IHtQb3B1cH0gcG9wdXAgb2JqZWN0IHRoYXQgd2FzIGNsb3NlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maXJlKCdjbG9zZScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBnZW9ncmFwaGljYWwgbG9jYXRpb24gb2YgdGhlIHBvcHVwJ3MgYW5jaG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0xuZ0xhdH0gVGhlIGdlb2dyYXBoaWNhbCBsb2NhdGlvbiBvZiB0aGUgcG9wdXAncyBhbmNob3IuXG4gICAgICovXG4gICAgZ2V0TG5nTGF0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xuZ0xhdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uIG9mIHRoZSBwb3B1cCdzIGFuY2hvciwgYW5kIG1vdmVzIHRoZSBwb3B1cCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG5nTGF0TGlrZX0gbG5nbGF0IFRoZSBnZW9ncmFwaGljYWwgbG9jYXRpb24gdG8gc2V0IGFzIHRoZSBwb3B1cCdzIGFuY2hvci5cbiAgICAgKiBAcmV0dXJucyB7UG9wdXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldExuZ0xhdDogZnVuY3Rpb24obG5nbGF0KSB7XG4gICAgICAgIHRoaXMuX2xuZ0xhdCA9IExuZ0xhdC5jb252ZXJ0KGxuZ2xhdCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcG9wdXAncyBjb250ZW50IHRvIGEgc3RyaW5nIG9mIHRleHQuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYSBbVGV4dF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RleHQpIG5vZGUgaW4gdGhlIERPTSxcbiAgICAgKiBzbyBpdCBjYW5ub3QgaW5zZXJ0IHJhdyBIVE1MLiBVc2UgdGhpcyBtZXRob2QgZm9yIHNlY3VyaXR5IGFnYWluc3QgWFNTXG4gICAgICogaWYgdGhlIHBvcHVwIGNvbnRlbnQgaXMgdXNlci1wcm92aWRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHR1YWwgY29udGVudCBmb3IgdGhlIHBvcHVwLlxuICAgICAqIEByZXR1cm5zIHtQb3B1cH0gYHRoaXNgXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcG9wdXAgPSBuZXcgbWFwYm94Z2wuUG9wdXAoKVxuICAgICAqICAgLnNldExuZ0xhdChlLmxuZ0xhdClcbiAgICAgKiAgIC5zZXRUZXh0KCdIZWxsbywgd29ybGQhJylcbiAgICAgKiAgIC5hZGRUbyhtYXApO1xuICAgICAqL1xuICAgIHNldFRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0RE9NQ29udGVudChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBvcHVwJ3MgY29udGVudCB0byB0aGUgSFRNTCBwcm92aWRlZCBhcyBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sIEEgc3RyaW5nIHJlcHJlc2VudGluZyBIVE1MIGNvbnRlbnQgZm9yIHRoZSBwb3B1cC5cbiAgICAgKiBAcmV0dXJucyB7UG9wdXB9IGB0aGlzYFxuICAgICAqL1xuICAgIHNldEhUTUw6IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIHZhciB0ZW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYm9keScpLCBjaGlsZDtcbiAgICAgICAgdGVtcC5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY2hpbGQgPSB0ZW1wLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoIWNoaWxkKSBicmVhaztcbiAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0RE9NQ29udGVudChmcmFnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcG9wdXAncyBjb250ZW50IHRvIHRoZSBlbGVtZW50IHByb3ZpZGVkIGFzIGEgRE9NIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IGh0bWxOb2RlIEEgRE9NIG5vZGUgdG8gYmUgdXNlZCBhcyBjb250ZW50IGZvciB0aGUgcG9wdXAuXG4gICAgICogQHJldHVybnMge1BvcHVwfSBgdGhpc2BcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGNyZWF0ZSBhbiBlbGVtZW50IHdpdGggdGhlIHBvcHVwIGNvbnRlbnRcbiAgICAgKiB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICogZGl2LmlubmVySFRNTCA9ICdIZWxsbywgd29ybGQhJztcbiAgICAgKiB2YXIgcG9wdXAgPSBuZXcgbWFwYm94Z2wuUG9wdXAoKVxuICAgICAqICAgLnNldExuZ0xhdChlLmxuZ0xhdClcbiAgICAgKiAgIC5zZXRET01Db250ZW50KGRpdilcbiAgICAgKiAgIC5hZGRUbyhtYXApO1xuICAgICAqL1xuICAgIHNldERPTUNvbnRlbnQ6IGZ1bmN0aW9uKGh0bWxOb2RlKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUNvbnRlbnQoKTtcbiAgICAgICAgdGhpcy5fY29udGVudC5hcHBlbmRDaGlsZChodG1sTm9kZSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2NyZWF0ZUNvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fY29udGVudCAmJiB0aGlzLl9jb250ZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9jb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBET00uY3JlYXRlKCdkaXYnLCAnbWFwYm94Z2wtcG9wdXAtY29udGVudCcsIHRoaXMuX2NvbnRhaW5lcik7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZUJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5fY2xvc2VCdXR0b24gPSBET00uY3JlYXRlKCdidXR0b24nLCAnbWFwYm94Z2wtcG9wdXAtY2xvc2UtYnV0dG9uJywgdGhpcy5fY29udGVudCk7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZUJ1dHRvbi50eXBlID0gJ2J1dHRvbic7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSAnJiMyMTU7JztcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGlja0Nsb3NlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tYXAgfHwgIXRoaXMuX2xuZ0xhdCB8fCAhdGhpcy5fY29udGVudCkgeyByZXR1cm47IH1cblxuICAgICAgICBpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyID0gRE9NLmNyZWF0ZSgnZGl2JywgJ21hcGJveGdsLXBvcHVwJywgdGhpcy5fbWFwLmdldENvbnRhaW5lcigpKTtcbiAgICAgICAgICAgIHRoaXMuX3RpcCAgICAgICA9IERPTS5jcmVhdGUoJ2RpdicsICdtYXBib3hnbC1wb3B1cC10aXAnLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuX21hcC5wcm9qZWN0KHRoaXMuX2xuZ0xhdCkucm91bmQoKSxcbiAgICAgICAgICAgIGFuY2hvciA9IHRoaXMub3B0aW9ucy5hbmNob3I7XG5cbiAgICAgICAgaWYgKCFhbmNob3IpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9jb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAocG9zLnkgPCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSBbJ3RvcCddO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb3MueSA+IHRoaXMuX21hcC50cmFuc2Zvcm0uaGVpZ2h0IC0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gWydib3R0b20nXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb3MueCA8IHdpZHRoIC8gMikge1xuICAgICAgICAgICAgICAgIGFuY2hvci5wdXNoKCdsZWZ0Jyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvcy54ID4gdGhpcy5fbWFwLnRyYW5zZm9ybS53aWR0aCAtIHdpZHRoIC8gMikge1xuICAgICAgICAgICAgICAgIGFuY2hvci5wdXNoKCdyaWdodCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYW5jaG9yLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGFuY2hvciA9ICdib3R0b20nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSBhbmNob3Iuam9pbignLScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFuY2hvclRyYW5zbGF0ZSA9IHtcbiAgICAgICAgICAgICd0b3AnOiAndHJhbnNsYXRlKC01MCUsMCknLFxuICAgICAgICAgICAgJ3RvcC1sZWZ0JzogJ3RyYW5zbGF0ZSgwLDApJyxcbiAgICAgICAgICAgICd0b3AtcmlnaHQnOiAndHJhbnNsYXRlKC0xMDAlLDApJyxcbiAgICAgICAgICAgICdib3R0b20nOiAndHJhbnNsYXRlKC01MCUsLTEwMCUpJyxcbiAgICAgICAgICAgICdib3R0b20tbGVmdCc6ICd0cmFuc2xhdGUoMCwtMTAwJSknLFxuICAgICAgICAgICAgJ2JvdHRvbS1yaWdodCc6ICd0cmFuc2xhdGUoLTEwMCUsLTEwMCUpJyxcbiAgICAgICAgICAgICdsZWZ0JzogJ3RyYW5zbGF0ZSgwLC01MCUpJyxcbiAgICAgICAgICAgICdyaWdodCc6ICd0cmFuc2xhdGUoLTEwMCUsLTUwJSknXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNsYXNzTGlzdCA9IHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3Q7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhbmNob3JUcmFuc2xhdGUpIHtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ21hcGJveGdsLXBvcHVwLWFuY2hvci0nICsga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjbGFzc0xpc3QuYWRkKCdtYXBib3hnbC1wb3B1cC1hbmNob3ItJyArIGFuY2hvcik7XG5cbiAgICAgICAgRE9NLnNldFRyYW5zZm9ybSh0aGlzLl9jb250YWluZXIsIGFuY2hvclRyYW5zbGF0ZVthbmNob3JdICsgJyB0cmFuc2xhdGUoJyArIHBvcy54ICsgJ3B4LCcgKyBwb3MueSArICdweCknKTtcbiAgICB9LFxuXG4gICAgX29uQ2xpY2tDbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQWN0b3I7XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIFtBY3RvciBkZXNpZ24gcGF0dGVybl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BY3Rvcl9tb2RlbClcbiAqIHRoYXQgbWFpbnRhaW5zIHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiBhc3luY2hyb25vdXMgdGFza3MgYW5kIHRoZSBvYmplY3RzXG4gKiB0aGF0IHNwaW4gdGhlbSBvZmYgLSBpbiB0aGlzIGNhc2UsIHRhc2tzIGxpa2UgcGFyc2luZyBwYXJ0cyBvZiBzdHlsZXMsXG4gKiBvd25lZCBieSB0aGUgc3R5bGVzXG4gKlxuICogQHBhcmFtIHtXZWJXb3JrZXJ9IHRhcmdldFxuICogQHBhcmFtIHtXZWJXb3JrZXJ9IHBhcmVudFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQWN0b3IodGFyZ2V0LCBwYXJlbnQpIHtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IHt9O1xuICAgIHRoaXMuY2FsbGJhY2tJRCA9IDA7XG4gICAgdGhpcy5yZWNlaXZlID0gdGhpcy5yZWNlaXZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMucmVjZWl2ZSwgZmFsc2UpO1xufVxuXG5BY3Rvci5wcm90b3R5cGUucmVjZWl2ZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICB2YXIgZGF0YSA9IG1lc3NhZ2UuZGF0YSxcbiAgICAgICAgaWQgPSBkYXRhLmlkLFxuICAgICAgICBjYWxsYmFjaztcblxuICAgIGlmIChkYXRhLnR5cGUgPT09ICc8cmVzcG9uc2U+Jykge1xuICAgICAgICBjYWxsYmFjayA9IHRoaXMuY2FsbGJhY2tzW2RhdGEuaWRdO1xuICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFja3NbZGF0YS5pZF07XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZGF0YS5lcnJvciB8fCBudWxsLCBkYXRhLmRhdGEpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEuaWQgIT09ICd1bmRlZmluZWQnICYmIHRoaXMucGFyZW50W2RhdGEudHlwZV0pIHtcbiAgICAgICAgLy8gZGF0YS50eXBlID09ICdsb2FkIHRpbGUnLCAncmVtb3ZlIHRpbGUnLCBldGMuXG4gICAgICAgIHRoaXMucGFyZW50W2RhdGEudHlwZV0oZGF0YS5kYXRhLCBkb25lLmJpbmQodGhpcykpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEuaWQgIT09ICd1bmRlZmluZWQnICYmIHRoaXMucGFyZW50LndvcmtlclNvdXJjZXMpIHtcbiAgICAgICAgLy8gZGF0YS50eXBlID09IHNvdXJjZXR5cGUubWV0aG9kXG4gICAgICAgIHZhciBrZXlzID0gZGF0YS50eXBlLnNwbGl0KCcuJyk7XG4gICAgICAgIHRoaXMucGFyZW50LndvcmtlclNvdXJjZXNba2V5c1swXV1ba2V5c1sxXV0oZGF0YS5kYXRhLCBkb25lLmJpbmQodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyZW50W2RhdGEudHlwZV0oZGF0YS5kYXRhKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb25lKGVyciwgZGF0YSwgYnVmZmVycykge1xuICAgICAgICB0aGlzLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICc8cmVzcG9uc2U+JyxcbiAgICAgICAgICAgIGlkOiBTdHJpbmcoaWQpLFxuICAgICAgICAgICAgZXJyb3I6IGVyciA/IFN0cmluZyhlcnIpIDogbnVsbCxcbiAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgfSwgYnVmZmVycyk7XG4gICAgfVxufTtcblxuQWN0b3IucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbih0eXBlLCBkYXRhLCBjYWxsYmFjaywgYnVmZmVycykge1xuICAgIHZhciBpZCA9IG51bGw7XG4gICAgaWYgKGNhbGxiYWNrKSB0aGlzLmNhbGxiYWNrc1tpZCA9IHRoaXMuY2FsbGJhY2tJRCsrXSA9IGNhbGxiYWNrO1xuICAgIHRoaXMucG9zdE1lc3NhZ2UoeyB0eXBlOiB0eXBlLCBpZDogU3RyaW5nKGlkKSwgZGF0YTogZGF0YSB9LCBidWZmZXJzKTtcbn07XG5cbi8qKlxuICogV3JhcHBlZCBwb3N0TWVzc2FnZSBBUEkgdGhhdCBhYnN0cmFjdHMgYXJvdW5kIElFJ3MgbGFjayBvZlxuICogYHRyYW5zZmVyTGlzdGAgc3VwcG9ydC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZVxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZmVyTGlzdFxuICogQHByaXZhdGVcbiAqL1xuQWN0b3IucHJvdG90eXBlLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSwgdHJhbnNmZXJMaXN0KSB7XG4gICAgdGhpcy50YXJnZXQucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXJMaXN0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZ2V0SlNPTiA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGNhbGxiYWNrKGUpO1xuICAgIH07XG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCAmJiB4aHIucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHZhciBkYXRhO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcih4aHIuc3RhdHVzVGV4dCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB4aHIuc2VuZCgpO1xuICAgIHJldHVybiB4aHI7XG59O1xuXG5leHBvcnRzLmdldEFycmF5QnVmZmVyID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgfTtcbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwICYmIHhoci5yZXNwb25zZSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcih4aHIuc3RhdHVzVGV4dCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB4aHIuc2VuZCgpO1xuICAgIHJldHVybiB4aHI7XG59O1xuXG5mdW5jdGlvbiBzYW1lT3JpZ2luKHVybCkge1xuICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGEuaHJlZiA9IHVybDtcbiAgICByZXR1cm4gYS5wcm90b2NvbCA9PT0gZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2wgJiYgYS5ob3N0ID09PSBkb2N1bWVudC5sb2NhdGlvbi5ob3N0O1xufVxuXG5leHBvcnRzLmdldEltYWdlID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBleHBvcnRzLmdldEFycmF5QnVmZmVyKHVybCwgZnVuY3Rpb24oZXJyLCBpbWdEYXRhKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGltZyk7XG4gICAgICAgICAgICAod2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMKS5yZXZva2VPYmplY3RVUkwoaW1nLnNyYyk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW25ldyBVaW50OEFycmF5KGltZ0RhdGEpXSwgeyB0eXBlOiAnaW1hZ2UvcG5nJyB9KTtcbiAgICAgICAgaW1nLnNyYyA9ICh3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwpLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgaW1nLmdldERhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBpbWcud2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMCk7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0KS5kYXRhO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW1nO1xuICAgIH0pO1xufTtcblxuZXhwb3J0cy5nZXRWaWRlbyA9IGZ1bmN0aW9uKHVybHMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICB2aWRlby5vbmxvYWRzdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCB2aWRlbyk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzb3VyY2UnKTtcbiAgICAgICAgaWYgKCFzYW1lT3JpZ2luKHVybHNbaV0pKSB7XG4gICAgICAgICAgICB2aWRlby5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuICAgICAgICB9XG4gICAgICAgIHMuc3JjID0gdXJsc1tpXTtcbiAgICAgICAgdmlkZW8uYXBwZW5kQ2hpbGQocyk7XG4gICAgfVxuICAgIHZpZGVvLmdldERhdGEgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHZpZGVvOyB9O1xuICAgIHJldHVybiB2aWRlbztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVW5saWtlIGpzL3V0aWwvYnJvd3Nlci5qcywgdGhpcyBjb2RlIGlzIHdyaXR0ZW4gd2l0aCB0aGUgZXhwZWN0YXRpb25cbiAqIG9mIGEgYnJvd3NlciBlbnZpcm9ubWVudCB3aXRoIGEgZ2xvYmFsICd3aW5kb3cnIG9iamVjdFxuICogQG1vZHVsZSBicm93c2VyXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMud2luZG93ID0gd2luZG93O1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgZnVuY3Rpb24gdGhhdCBvdXRwdXRzIG1pbGxpc2Vjb25kczogZWl0aGVyIHBlcmZvcm1hbmNlLm5vdygpXG4gKiBvciBhIGZhbGxiYWNrIHRvIERhdGUubm93KClcbiAqL1xubW9kdWxlLmV4cG9ydHMubm93ID0gKGZ1bmN0aW9uKCkge1xuICAgIGlmICh3aW5kb3cucGVyZm9ybWFuY2UgJiZcbiAgICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm5vdykge1xuICAgICAgICByZXR1cm4gd2luZG93LnBlcmZvcm1hbmNlLm5vdy5iaW5kKHdpbmRvdy5wZXJmb3JtYW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93LmJpbmQoRGF0ZSk7XG4gICAgfVxufSgpKTtcblxudmFyIGZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG5leHBvcnRzLmZyYW1lID0gZnVuY3Rpb24oZm4pIHtcbiAgICByZXR1cm4gZnJhbWUoZm4pO1xufTtcblxudmFyIGNhbmNlbCA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lO1xuXG5leHBvcnRzLmNhbmNlbEZyYW1lID0gZnVuY3Rpb24oaWQpIHtcbiAgICBjYW5jZWwoaWQpO1xufTtcblxuZXhwb3J0cy50aW1lZCA9IGZ1bmN0aW9uIChmbiwgZHVyLCBjdHgpIHtcbiAgICBpZiAoIWR1cikge1xuICAgICAgICBmbi5jYWxsKGN0eCwgMSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBhYm9ydCA9IGZhbHNlLFxuICAgICAgICBzdGFydCA9IG1vZHVsZS5leHBvcnRzLm5vdygpO1xuXG4gICAgZnVuY3Rpb24gdGljayhub3cpIHtcbiAgICAgICAgaWYgKGFib3J0KSByZXR1cm47XG4gICAgICAgIG5vdyA9IG1vZHVsZS5leHBvcnRzLm5vdygpO1xuXG4gICAgICAgIGlmIChub3cgPj0gc3RhcnQgKyBkdXIpIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCAobm93IC0gc3RhcnQpIC8gZHVyKTtcbiAgICAgICAgICAgIGV4cG9ydHMuZnJhbWUodGljayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzLmZyYW1lKHRpY2spO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyBhYm9ydCA9IHRydWU7IH07XG59O1xuXG4vKipcbiAqIFRlc3QgaWYgdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBNYXBib3ggR0wgSlNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ9ZmFsc2VdIFJldHVybiBgZmFsc2VgXG4gKiAgIGlmIHRoZSBwZXJmb3JtYW5jZSBvZiBNYXBib3ggR0wgSlMgd291bGQgYmUgZHJhbWF0aWNhbGx5IHdvcnNlIHRoYW5cbiAqICAgZXhwZWN0ZWQgKGkuZS4gYSBzb2Z0d2FyZSByZW5kZXJlciB3b3VsZCBiZSB1c2VkKVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5zdXBwb3J0ZWQgPSByZXF1aXJlKCdtYXBib3gtZ2wtc3VwcG9ydGVkJyk7XG5cbmV4cG9ydHMuaGFyZHdhcmVDb25jdXJyZW5jeSA9IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5IHx8IDQ7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZGV2aWNlUGl4ZWxSYXRpbycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87IH1cbn0pO1xuXG5leHBvcnRzLnN1cHBvcnRzV2VicCA9IGZhbHNlO1xuXG52YXIgd2VicEltZ1Rlc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbndlYnBJbWdUZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGV4cG9ydHMuc3VwcG9ydHNXZWJwID0gdHJ1ZTtcbn07XG53ZWJwSW1nVGVzdC5zcmMgPSAnZGF0YTppbWFnZS93ZWJwO2Jhc2U2NCxVa2xHUmg0QUFBQlhSVUpRVmxBNFRCRUFBQUF2QVFBQUFBZlEvLzczdi8rQmlPaC9BQUE9JztcblxuZXhwb3J0cy5zdXBwb3J0c0dlb2xvY2F0aW9uID0gISFuYXZpZ2F0b3IuZ2VvbG9jYXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIGlzU3VwcG9ydGVkID0gcmVxdWlyZSgnbWFwYm94LWdsLXN1cHBvcnRlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhcztcblxuZnVuY3Rpb24gQ2FudmFzKHBhcmVudCwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgIGlmIChwYXJlbnQgJiYgY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGhpcy5jYW52YXMuY2xhc3NMaXN0LmFkZCgnbWFwYm94Z2wtY2FudmFzJyk7XG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCBwYXJlbnQuX2NvbnRleHRMb3N0LmJpbmQocGFyZW50KSwgZmFsc2UpO1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIHBhcmVudC5fY29udGV4dFJlc3RvcmVkLmJpbmQocGFyZW50KSwgZmFsc2UpO1xuICAgICAgICB0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgfVxufVxuXG5DYW52YXMucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cbiAgICAvLyBSZXF1ZXN0IHRoZSByZXF1aXJlZCBjYW52YXMgc2l6ZSB0YWtpbmcgdGhlIHBpeGVscmF0aW8gaW50byBhY2NvdW50LlxuICAgIHRoaXMuY2FudmFzLndpZHRoID0gcGl4ZWxSYXRpbyAqIHdpZHRoO1xuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHBpeGVsUmF0aW8gKiBoZWlnaHQ7XG5cbiAgICAvLyBNYWludGFpbiB0aGUgc2FtZSBjYW52YXMgc2l6ZSwgcG90ZW50aWFsbHkgZG93bnNjYWxpbmcgaXQgZm9yIEhpRFBJIGRpc3BsYXlzXG4gICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgdGhpcy5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4Jztcbn07XG5cbkNhbnZhcy5wcm90b3R5cGUuZ2V0V2ViR0xDb250ZXh0ID0gZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICAgIGF0dHJpYnV0ZXMgPSB1dGlsLmV4dGVuZCh7fSwgYXR0cmlidXRlcywgaXNTdXBwb3J0ZWQud2ViR0xDb250ZXh0QXR0cmlidXRlcyk7XG5cbiAgICByZXR1cm4gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBhdHRyaWJ1dGVzKSB8fFxuICAgICAgICB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBhdHRyaWJ1dGVzKTtcbn07XG5cbkNhbnZhcy5wcm90b3R5cGUuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNhbnZhcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gKHRhZ05hbWUsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICBpZiAoY2xhc3NOYW1lKSBlbC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgaWYgKGNvbnRhaW5lcikgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcbiAgICByZXR1cm4gZWw7XG59O1xuXG52YXIgZG9jU3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5cbmZ1bmN0aW9uIHRlc3RQcm9wKHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocHJvcHNbaV0gaW4gZG9jU3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIHNlbGVjdFByb3AgPSB0ZXN0UHJvcChbJ3VzZXJTZWxlY3QnLCAnTW96VXNlclNlbGVjdCcsICdXZWJraXRVc2VyU2VsZWN0JywgJ21zVXNlclNlbGVjdCddKSxcbiAgICB1c2VyU2VsZWN0O1xuZXhwb3J0cy5kaXNhYmxlRHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZWN0UHJvcCkge1xuICAgICAgICB1c2VyU2VsZWN0ID0gZG9jU3R5bGVbc2VsZWN0UHJvcF07XG4gICAgICAgIGRvY1N0eWxlW3NlbGVjdFByb3BdID0gJ25vbmUnO1xuICAgIH1cbn07XG5leHBvcnRzLmVuYWJsZURyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGVjdFByb3ApIHtcbiAgICAgICAgZG9jU3R5bGVbc2VsZWN0UHJvcF0gPSB1c2VyU2VsZWN0O1xuICAgIH1cbn07XG5cbnZhciB0cmFuc2Zvcm1Qcm9wID0gdGVzdFByb3AoWyd0cmFuc2Zvcm0nLCAnV2Via2l0VHJhbnNmb3JtJ10pO1xuZXhwb3J0cy5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbihlbCwgdmFsdWUpIHtcbiAgICBlbC5zdHlsZVt0cmFuc2Zvcm1Qcm9wXSA9IHZhbHVlO1xufTtcblxuLy8gU3VwcHJlc3MgdGhlIG5leHQgY2xpY2ssIGJ1dCBvbmx5IGlmIGl0J3MgaW1tZWRpYXRlLlxuZnVuY3Rpb24gc3VwcHJlc3NDbGljayhlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3VwcHJlc3NDbGljaywgdHJ1ZSk7XG59XG5leHBvcnRzLnN1cHByZXNzQ2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzdXBwcmVzc0NsaWNrLCB0cnVlKTtcbiAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3VwcHJlc3NDbGljaywgdHJ1ZSk7XG4gICAgfSwgMCk7XG59O1xuXG5leHBvcnRzLm1vdXNlUG9zID0gZnVuY3Rpb24gKGVsLCBlKSB7XG4gICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBlID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcbiAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICBlLmNsaWVudFggLSByZWN0LmxlZnQgLSBlbC5jbGllbnRMZWZ0LFxuICAgICAgICBlLmNsaWVudFkgLSByZWN0LnRvcCAtIGVsLmNsaWVudFRvcFxuICAgICk7XG59O1xuXG5leHBvcnRzLnRvdWNoUG9zID0gZnVuY3Rpb24gKGVsLCBlKSB7XG4gICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgcG9pbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLnRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcG9pbnRzLnB1c2gobmV3IFBvaW50KFxuICAgICAgICAgICAgZS50b3VjaGVzW2ldLmNsaWVudFggLSByZWN0LmxlZnQgLSBlbC5jbGllbnRMZWZ0LFxuICAgICAgICAgICAgZS50b3VjaGVzW2ldLmNsaWVudFkgLSByZWN0LnRvcCAtIGVsLmNsaWVudFRvcFxuICAgICAgICApKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgV2ViV29ya2lmeSA9IHJlcXVpcmUoJ3dlYndvcmtpZnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBXZWJXb3JraWZ5KHJlcXVpcmUoJy4uLy4uL3NvdXJjZS93b3JrZXInKSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcXVpY2tzZWxlY3QgPSByZXF1aXJlKCdxdWlja3NlbGVjdCcpO1xudmFyIGNhbGN1bGF0ZVNpZ25lZEFyZWEgPSByZXF1aXJlKCcuL3V0aWwnKS5jYWxjdWxhdGVTaWduZWRBcmVhO1xuXG4vLyBjbGFzc2lmaWVzIGFuIGFycmF5IG9mIHJpbmdzIGludG8gcG9seWdvbnMgd2l0aCBvdXRlciByaW5ncyBhbmQgaG9sZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2xhc3NpZnlSaW5ncyhyaW5ncywgbWF4UmluZ3MpIHtcbiAgICB2YXIgbGVuID0gcmluZ3MubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiA8PSAxKSByZXR1cm4gW3JpbmdzXTtcblxuICAgIHZhciBwb2x5Z29ucyA9IFtdLFxuICAgICAgICBwb2x5Z29uLFxuICAgICAgICBjY3c7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBhcmVhID0gY2FsY3VsYXRlU2lnbmVkQXJlYShyaW5nc1tpXSk7XG4gICAgICAgIGlmIChhcmVhID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICByaW5nc1tpXS5hcmVhID0gTWF0aC5hYnMoYXJlYSk7XG5cbiAgICAgICAgaWYgKGNjdyA9PT0gdW5kZWZpbmVkKSBjY3cgPSBhcmVhIDwgMDtcblxuICAgICAgICBpZiAoY2N3ID09PSBhcmVhIDwgMCkge1xuICAgICAgICAgICAgaWYgKHBvbHlnb24pIHBvbHlnb25zLnB1c2gocG9seWdvbik7XG4gICAgICAgICAgICBwb2x5Z29uID0gW3JpbmdzW2ldXTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9seWdvbi5wdXNoKHJpbmdzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocG9seWdvbikgcG9seWdvbnMucHVzaChwb2x5Z29uKTtcblxuICAgIC8vIEVhcmN1dCBwZXJmb3JtYW5jZSBkZWdyYWdlcyB3aXRoIHRoZSAjIG9mIHJpbmdzIGluIGEgcG9seWdvbi4gRm9yIHRoaXNcbiAgICAvLyByZWFzb24sIHdlIGxpbWl0IHN0cmlwIG91dCBhbGwgYnV0IHRoZSBgbWF4UmluZ3NgIGxhcmdlc3QgcmluZ3MuXG4gICAgaWYgKG1heFJpbmdzID4gMSkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvbHlnb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAocG9seWdvbnNbal0ubGVuZ3RoIDw9IG1heFJpbmdzKSBjb250aW51ZTtcbiAgICAgICAgICAgIHF1aWNrc2VsZWN0KHBvbHlnb25zW2pdLCBtYXhSaW5ncywgMSwgcG9seWdvbnNbal0ubGVuZ3RoIC0gMSwgY29tcGFyZUFyZWFzKTtcbiAgICAgICAgICAgIHBvbHlnb25zW2pdID0gcG9seWdvbnNbal0uc2xpY2UoMCwgbWF4UmluZ3MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvbHlnb25zO1xufTtcblxuZnVuY3Rpb24gY29tcGFyZUFyZWFzKGEsIGIpIHtcbiAgICByZXR1cm4gYi5hcmVhIC0gYS5hcmVhO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBBUElfVVJMOiAnaHR0cHM6Ly9hcGkubWFwYm94LmNvbScsXG4gICAgUkVRVUlSRV9BQ0NFU1NfVE9LRU46IHRydWVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEaWN0aW9uYXJ5Q29kZXI7XG5cbmZ1bmN0aW9uIERpY3Rpb25hcnlDb2RlcihzdHJpbmdzKSB7XG4gICAgdGhpcy5fc3RyaW5nVG9OdW1iZXIgPSB7fTtcbiAgICB0aGlzLl9udW1iZXJUb1N0cmluZyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3RyaW5nID0gc3RyaW5nc1tpXTtcbiAgICAgICAgdGhpcy5fc3RyaW5nVG9OdW1iZXJbc3RyaW5nXSA9IGk7XG4gICAgICAgIHRoaXMuX251bWJlclRvU3RyaW5nW2ldID0gc3RyaW5nO1xuICAgIH1cbn1cblxuRGljdGlvbmFyeUNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICBhc3NlcnQoc3RyaW5nIGluIHRoaXMuX3N0cmluZ1RvTnVtYmVyKTtcbiAgICByZXR1cm4gdGhpcy5fc3RyaW5nVG9OdW1iZXJbc3RyaW5nXTtcbn07XG5cbkRpY3Rpb25hcnlDb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24obikge1xuICAgIGFzc2VydChuIDwgdGhpcy5fbnVtYmVyVG9TdHJpbmcubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5fbnVtYmVyVG9TdHJpbmdbbl07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIEFjdG9yID0gcmVxdWlyZSgnLi9hY3RvcicpO1xudmFyIFdlYldvcmtlciA9IHJlcXVpcmUoJy4vd2ViX3dvcmtlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3BhdGNoZXI7XG5cbi8qKlxuICogUmVzcG9uc2libGUgZm9yIHNlbmRpbmcgbWVzc2FnZXMgZnJvbSBhIHtAbGluayBTb3VyY2V9IHRvIGFuIGFzc29jaWF0ZWRcbiAqIHtAbGluayBXb3JrZXJTb3VyY2V9LlxuICpcbiAqIEBpbnRlcmZhY2UgRGlzcGF0Y2hlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRGlzcGF0Y2hlcihsZW5ndGgsIHBhcmVudCkge1xuICAgIHRoaXMuYWN0b3JzID0gW107XG4gICAgdGhpcy5jdXJyZW50QWN0b3IgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBXZWJXb3JrZXIoKTtcbiAgICAgICAgdmFyIGFjdG9yID0gbmV3IEFjdG9yKHdvcmtlciwgcGFyZW50KTtcbiAgICAgICAgYWN0b3IubmFtZSA9IFwiV29ya2VyIFwiICsgaTtcbiAgICAgICAgdGhpcy5hY3RvcnMucHVzaChhY3Rvcik7XG4gICAgfVxufVxuXG5EaXNwYXRjaGVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBCcm9hZGNhc3QgYSBtZXNzYWdlIHRvIGFsbCBXb3JrZXJzLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbmFtZSBicm9hZGNhc3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAbWVtYmVyb2YgRGlzcGF0Y2hlclxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGJyb2FkY2FzdDogZnVuY3Rpb24odHlwZSwgZGF0YSwgY2IpIHtcbiAgICAgICAgY2IgPSBjYiB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgdXRpbC5hc3luY0FsbCh0aGlzLmFjdG9ycywgZnVuY3Rpb24gKGFjdG9yLCBkb25lKSB7XG4gICAgICAgICAgICBhY3Rvci5zZW5kKHR5cGUsIGRhdGEsIGRvbmUpO1xuICAgICAgICB9LCBjYik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBtZXNzYWdlIHRvIGEgV29ya2VyLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbmFtZSBzZW5kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSBbdGFyZ2V0SURdIFRoZSBJRCBvZiB0aGUgV29ya2VyIHRvIHdoaWNoIHRvIHNlbmQgdGhpcyBtZXNzYWdlLiBPbWl0IHRvIGFsbG93IHRoZSBkaXNwYXRjaGVyIHRvIGNob29zZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgSUQgb2YgdGhlIHdvcmtlciB0byB3aGljaCB0aGUgbWVzc2FnZSB3YXMgc2VudC5cbiAgICAgKiBAbWVtYmVyb2YgRGlzcGF0Y2hlclxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNlbmQ6IGZ1bmN0aW9uKHR5cGUsIGRhdGEsIGNhbGxiYWNrLCB0YXJnZXRJRCwgYnVmZmVycykge1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldElEICE9PSAnbnVtYmVyJyB8fCBpc05hTih0YXJnZXRJRCkpIHtcbiAgICAgICAgICAgIC8vIFVzZSByb3VuZCByb2JpbiB0byBzZW5kIHJlcXVlc3RzIHRvIHdlYiB3b3JrZXJzLlxuICAgICAgICAgICAgdGFyZ2V0SUQgPSB0aGlzLmN1cnJlbnRBY3RvciA9ICh0aGlzLmN1cnJlbnRBY3RvciArIDEpICUgdGhpcy5hY3RvcnMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hY3RvcnNbdGFyZ2V0SURdLnNlbmQodHlwZSwgZGF0YSwgY2FsbGJhY2ssIGJ1ZmZlcnMpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0SUQ7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYWN0b3JzW2ldLnRhcmdldC50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdG9ycyA9IFtdO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qKlxuICogTWV0aG9kcyBtaXhlZCBpbiB0byBvdGhlciBjbGFzc2VzIGZvciBldmVudCBjYXBhYmlsaXRpZXMuXG4gKlxuICogQG1peGluIEV2ZW50ZWRcbiAqL1xudmFyIEV2ZW50ZWQgPSB7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgdG8gYSBzcGVjaWZpZWQgZXZlbnQgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlIHRvIGFkZCBhIGxpc3RlbiBmb3IuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBmaXJlZC5cbiAgICAgKiAgIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCB0aGUgZGF0YSBvYmplY3QgcGFzc2VkIHRvIGBmaXJlYCxcbiAgICAgKiAgIGV4dGVuZGVkIHdpdGggYHRhcmdldGAgYW5kIGB0eXBlYCBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGB0aGlzYFxuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IHRoaXMuX2V2ZW50c1t0eXBlXSB8fCBbXTtcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgcHJldmlvdXNseSByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBUaGUgZXZlbnQgdHlwZSB0byByZW1vdmUgbGlzdGVuZXJzIGZvci5cbiAgICAgKiAgIElmIG5vbmUgaXMgc3BlY2lmaWVkLCBsaXN0ZW5lcnMgd2lsbCBiZSByZW1vdmVkIGZvciBhbGwgZXZlbnQgdHlwZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2xpc3RlbmVyXSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlLlxuICAgICAqICAgSWYgbm9uZSBpcyBzcGVjaWZpZWQsIGFsbCBsaXN0ZW5lcnMgd2lsbCBiZSByZW1vdmVkIGZvciB0aGUgZXZlbnQgdHlwZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBgdGhpc2BcbiAgICAgKi9cbiAgICBvZmY6IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgLy8gY2xlYXIgYWxsIGxpc3RlbmVycyBpZiBubyBhcmd1bWVudHMgc3BlY2lmaWVkXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMubGlzdGVucyh0eXBlKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gdGhpcy5fZXZlbnRzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlIHRvIGEgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXG4gICAgICpcbiAgICAgKiBUaGUgbGlzdGVuZXIgd2lsbCBiZSBjYWxsZWQgZmlyc3QgdGltZSB0aGUgZXZlbnQgZmlyZXMgYWZ0ZXIgdGhlIGxpc3RlbmVyIGlzIHJlZ2lzdGVyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gZm9yLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZmlyZWQgdGhlIGZpcnN0IHRpbWUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gYHRoaXNgXG4gICAgICovXG4gICAgb25jZTogZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLm9mZih0eXBlLCB3cmFwcGVyKTtcbiAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZGF0YSk7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbih0eXBlLCB3cmFwcGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpcmVzIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIGV2ZW50IHRvIGZpcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXSBEYXRhIHRvIGJlIHBhc3NlZCB0byBhbnkgbGlzdGVuZXJzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGB0aGlzYFxuICAgICAqL1xuICAgIGZpcmU6IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpc3RlbnModHlwZSkpIHtcbiAgICAgICAgICAgIC8vIFRvIGVuc3VyZSB0aGF0IG5vIGVycm9yIGV2ZW50cyBhcmUgZHJvcHBlZCwgcHJpbnQgdGhlbSB0byB0aGVcbiAgICAgICAgICAgIC8vIGNvbnNvbGUgaWYgdGhleSBoYXZlIG5vIGxpc3RlbmVycy5cbiAgICAgICAgICAgIGlmICh1dGlsLmVuZHNXaXRoKHR5cGUsICdlcnJvcicpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigoZGF0YSAmJiBkYXRhLmVycm9yKSB8fCBkYXRhIHx8ICdFbXB0eSBlcnJvciBldmVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhID0gdXRpbC5leHRlbmQoe30sIGRhdGEpO1xuICAgICAgICB1dGlsLmV4dGVuZChkYXRhLCB7dHlwZTogdHlwZSwgdGFyZ2V0OiB0aGlzfSk7XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIGFkZGluZy9yZW1vdmluZyBsaXN0ZW5lcnMgaW5zaWRlIG90aGVyIGxpc3RlbmVycyB3b24ndCBjYXVzZSBpbmZpbml0ZSBsb29wXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmNhbGwodGhpcywgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGFueSBsaXN0ZW5lcnMgYXJlIHJlZ2lzdGVyZWQgZm9yIGEgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSByZWdpc3RlcmVkIGxpc3RlbmVyIGZvciBzcGVjaWZpZWQgZXZlbnQgdHlwZS5cbiAgICAgKi9cbiAgICBsaXN0ZW5zOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzW3R5cGVdKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50ZWQ7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgUXVldWUgPSByZXF1aXJlKCd0aW55cXVldWUnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3BvaW50LWdlb21ldHJ5Jyk7XG52YXIgZGlzdFRvU2VnbWVudFNxdWFyZWQgPSByZXF1aXJlKCcuL2ludGVyc2VjdGlvbl90ZXN0cycpLmRpc3RUb1NlZ21lbnRTcXVhcmVkO1xuXG4vKipcbiAqIEZpbmRzIGFuIGFwcHJveGltYXRpb24gb2YgYSBwb2x5Z29uJ3MgUG9sZSBPZiBJbmFjY2Vzc2liaWxpeSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qb2xlX29mX2luYWNjZXNzaWJpbGl0eVxuICogVGhpcyBpcyBhIGNvcHkgb2YgaHR0cDovL2dpdGh1Yi5jb20vbWFwYm94L3BvbHlsYWJlbCBhZGFwdGVkIHRvIHVzZSBQb2ludHNcbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PFBvaW50Pj59IExpc3Qgb2YgcG9seWdvbiByaW5ncyBmaXJzdCBpdGVtIGluIGFycmF5IGlzIHRoZSBvdXRlciByaW5nIGZvbGxvd2VkIG9wdGlvbmFsbHkgYnkgdGhlIGxpc3Qgb2YgaG9sZXMsIHNob3VsZCBiZSBhbiBlbGVtZW50IG9mIHRoZSByZXN1bHQgb2YgdXRpbC9jbGFzc2lmeV9yaW5nc1xuICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MV0gU3BlY2lmaWVkIGluIGlucHV0IGNvb3JkaW5hdGUgdW5pdHMuIElmIDAgcmV0dXJucyBhZnRlciBmaXJzdCBydW4sIGlmID4gMCByZXBlYXRlZGx5IG5hcnJvd3MgdGhlIHNlYXJjaCBzcGFjZSB1bnRpbCB0aGUgcmFkaXVzIG9mIHRoZSBhcmVhIHNlYXJjaGVkIGZvciB0aGUgYmVzdCBwb2xlIGlzIGxlc3MgdGhhbiBwcmVjaXNpb25cbiAqIEBwYXJhbSB7Ym9vbH0gW2RlYnVnPWZhbHNlXSBQcmludCBzb21lIHN0YXRpc3RpY3MgdG8gdGhlIGNvbnNvbGUgZHVyaW5nIGV4ZWN1dGlvblxuICpcbiAqIEByZXR1cm5zIHtQb2ludH0gUG9sZSBvZiBJbmFjY2Vzc2liaWxpeS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocG9seWdvblJpbmdzLCBwcmVjaXNpb24sIGRlYnVnKSB7XG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDEuMDtcblxuICAgIC8vIGZpbmQgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgb3V0ZXIgcmluZ1xuICAgIHZhciBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZO1xuICAgIHZhciBvdXRlclJpbmcgPSBwb2x5Z29uUmluZ3NbMF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRlclJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHAgPSBvdXRlclJpbmdbaV07XG4gICAgICAgIGlmICghaSB8fCBwLnggPCBtaW5YKSBtaW5YID0gcC54O1xuICAgICAgICBpZiAoIWkgfHwgcC55IDwgbWluWSkgbWluWSA9IHAueTtcbiAgICAgICAgaWYgKCFpIHx8IHAueCA+IG1heFgpIG1heFggPSBwLng7XG4gICAgICAgIGlmICghaSB8fCBwLnkgPiBtYXhZKSBtYXhZID0gcC55O1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IG1heFggLSBtaW5YO1xuICAgIHZhciBoZWlnaHQgPSBtYXhZIC0gbWluWTtcbiAgICB2YXIgY2VsbFNpemUgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcbiAgICB2YXIgaCA9IGNlbGxTaXplIC8gMjtcblxuICAgIC8vIGEgcHJpb3JpdHkgcXVldWUgb2YgY2VsbHMgaW4gb3JkZXIgb2YgdGhlaXIgXCJwb3RlbnRpYWxcIiAobWF4IGRpc3RhbmNlIHRvIHBvbHlnb24pXG4gICAgdmFyIGNlbGxRdWV1ZSA9IG5ldyBRdWV1ZShudWxsLCBjb21wYXJlTWF4KTtcblxuICAgIC8vIGNvdmVyIHBvbHlnb24gd2l0aCBpbml0aWFsIGNlbGxzXG4gICAgZm9yICh2YXIgeCA9IG1pblg7IHggPCBtYXhYOyB4ICs9IGNlbGxTaXplKSB7XG4gICAgICAgIGZvciAodmFyIHkgPSBtaW5ZOyB5IDwgbWF4WTsgeSArPSBjZWxsU2l6ZSkge1xuICAgICAgICAgICAgY2VsbFF1ZXVlLnB1c2gobmV3IENlbGwoeCArIGgsIHkgKyBoLCBoLCBwb2x5Z29uUmluZ3MpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRha2UgY2VudHJvaWQgYXMgdGhlIGZpcnN0IGJlc3QgZ3Vlc3NcbiAgICB2YXIgYmVzdENlbGwgPSBnZXRDZW50cm9pZENlbGwocG9seWdvblJpbmdzKTtcbiAgICB2YXIgbnVtUHJvYmVzID0gY2VsbFF1ZXVlLmxlbmd0aDtcblxuICAgIHdoaWxlIChjZWxsUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIC8vIHBpY2sgdGhlIG1vc3QgcHJvbWlzaW5nIGNlbGwgZnJvbSB0aGUgcXVldWVcbiAgICAgICAgdmFyIGNlbGwgPSBjZWxsUXVldWUucG9wKCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBiZXN0IGNlbGwgaWYgd2UgZm91bmQgYSBiZXR0ZXIgb25lXG4gICAgICAgIGlmIChjZWxsLmQgPiBiZXN0Q2VsbC5kKSB7XG4gICAgICAgICAgICBiZXN0Q2VsbCA9IGNlbGw7XG4gICAgICAgICAgICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKCdmb3VuZCBiZXN0ICVkIGFmdGVyICVkIHByb2JlcycsIE1hdGgucm91bmQoMWU0ICogY2VsbC5kKSAvIDFlNCwgbnVtUHJvYmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvIG5vdCBkcmlsbCBkb3duIGZ1cnRoZXIgaWYgdGhlcmUncyBubyBjaGFuY2Ugb2YgYSBiZXR0ZXIgc29sdXRpb25cbiAgICAgICAgaWYgKGNlbGwubWF4IC0gYmVzdENlbGwuZCA8PSBwcmVjaXNpb24pIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIHNwbGl0IHRoZSBjZWxsIGludG8gZm91ciBjZWxsc1xuICAgICAgICBoID0gY2VsbC5oIC8gMjtcbiAgICAgICAgY2VsbFF1ZXVlLnB1c2gobmV3IENlbGwoY2VsbC5wLnggLSBoLCBjZWxsLnAueSAtIGgsIGgsIHBvbHlnb25SaW5ncykpO1xuICAgICAgICBjZWxsUXVldWUucHVzaChuZXcgQ2VsbChjZWxsLnAueCArIGgsIGNlbGwucC55IC0gaCwgaCwgcG9seWdvblJpbmdzKSk7XG4gICAgICAgIGNlbGxRdWV1ZS5wdXNoKG5ldyBDZWxsKGNlbGwucC54IC0gaCwgY2VsbC5wLnkgKyBoLCBoLCBwb2x5Z29uUmluZ3MpKTtcbiAgICAgICAgY2VsbFF1ZXVlLnB1c2gobmV3IENlbGwoY2VsbC5wLnggKyBoLCBjZWxsLnAueSArIGgsIGgsIHBvbHlnb25SaW5ncykpO1xuICAgICAgICBudW1Qcm9iZXMgKz0gNDtcbiAgICB9XG5cbiAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ251bSBwcm9iZXM6ICcgKyBudW1Qcm9iZXMpO1xuICAgICAgICBjb25zb2xlLmxvZygnYmVzdCBkaXN0YW5jZTogJyArIGJlc3RDZWxsLmQpO1xuICAgIH1cblxuICAgIHJldHVybiBiZXN0Q2VsbC5wO1xufTtcblxuZnVuY3Rpb24gY29tcGFyZU1heChhLCBiKSB7XG4gICAgcmV0dXJuIGIubWF4IC0gYS5tYXg7XG59XG5cbmZ1bmN0aW9uIENlbGwoeCwgeSwgaCwgcG9seWdvbikge1xuICAgIHRoaXMucCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICB0aGlzLmggPSBoOyAvLyBoYWxmIHRoZSBjZWxsIHNpemVcbiAgICB0aGlzLmQgPSBwb2ludFRvUG9seWdvbkRpc3QodGhpcy5wLCBwb2x5Z29uKTsgLy8gZGlzdGFuY2UgZnJvbSBjZWxsIGNlbnRlciB0byBwb2x5Z29uXG4gICAgdGhpcy5tYXggPSB0aGlzLmQgKyB0aGlzLmggKiBNYXRoLlNRUlQyOyAvLyBtYXggZGlzdGFuY2UgdG8gcG9seWdvbiB3aXRoaW4gYSBjZWxsXG59XG5cbi8vIHNpZ25lZCBkaXN0YW5jZSBmcm9tIHBvaW50IHRvIHBvbHlnb24gb3V0bGluZSAobmVnYXRpdmUgaWYgcG9pbnQgaXMgb3V0c2lkZSlcbmZ1bmN0aW9uIHBvaW50VG9Qb2x5Z29uRGlzdChwLCBwb2x5Z29uKSB7XG4gICAgdmFyIGluc2lkZSA9IGZhbHNlO1xuICAgIHZhciBtaW5EaXN0U3EgPSBJbmZpbml0eTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcG9seWdvbi5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgcmluZyA9IHBvbHlnb25ba107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJpbmcubGVuZ3RoLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xuICAgICAgICAgICAgdmFyIGEgPSByaW5nW2ldO1xuICAgICAgICAgICAgdmFyIGIgPSByaW5nW2pdO1xuXG4gICAgICAgICAgICBpZiAoKGEueSA+IHAueSAhPT0gYi55ID4gcC55KSAmJlxuICAgICAgICAgICAgICAgIChwLnggPCAoYi54IC0gYS54KSAqIChwLnkgLSBhLnkpIC8gKGIueSAtIGEueSkgKyBhLngpKSBpbnNpZGUgPSAhaW5zaWRlO1xuXG4gICAgICAgICAgICBtaW5EaXN0U3EgPSBNYXRoLm1pbihtaW5EaXN0U3EsIGRpc3RUb1NlZ21lbnRTcXVhcmVkKHAsIGEsIGIpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoaW5zaWRlID8gMSA6IC0xKSAqIE1hdGguc3FydChtaW5EaXN0U3EpO1xufVxuXG4vLyBnZXQgcG9seWdvbiBjZW50cm9pZFxuZnVuY3Rpb24gZ2V0Q2VudHJvaWRDZWxsKHBvbHlnb24pIHtcbiAgICB2YXIgYXJlYSA9IDA7XG4gICAgdmFyIHggPSAwO1xuICAgIHZhciB5ID0gMDtcbiAgICB2YXIgcG9pbnRzID0gcG9seWdvblswXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aCwgaiA9IGxlbiAtIDE7IGkgPCBsZW47IGogPSBpKyspIHtcbiAgICAgICAgdmFyIGEgPSBwb2ludHNbaV07XG4gICAgICAgIHZhciBiID0gcG9pbnRzW2pdO1xuICAgICAgICB2YXIgZiA9IGEueCAqIGIueSAtIGIueCAqIGEueTtcbiAgICAgICAgeCArPSAoYS54ICsgYi54KSAqIGY7XG4gICAgICAgIHkgKz0gKGEueSArIGIueSkgKiBmO1xuICAgICAgICBhcmVhICs9IGYgKiAzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENlbGwoeCAvIGFyZWEsIHkgLyBhcmVhLCAwLCBwb2x5Z29uKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBHbHlwaHM7XG5cbmZ1bmN0aW9uIEdseXBocyhwYmYsIGVuZCkge1xuICAgIHRoaXMuc3RhY2tzID0gcGJmLnJlYWRGaWVsZHMocmVhZEZvbnRzdGFja3MsIFtdLCBlbmQpO1xufVxuXG5mdW5jdGlvbiByZWFkRm9udHN0YWNrcyh0YWcsIHN0YWNrcywgcGJmKSB7XG4gICAgaWYgKHRhZyA9PT0gMSkge1xuICAgICAgICB2YXIgZm9udHN0YWNrID0gcGJmLnJlYWRNZXNzYWdlKHJlYWRGb250c3RhY2ssIHtnbHlwaHM6IHt9fSk7XG4gICAgICAgIHN0YWNrcy5wdXNoKGZvbnRzdGFjayk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWFkRm9udHN0YWNrKHRhZywgZm9udHN0YWNrLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAxKSBmb250c3RhY2submFtZSA9IHBiZi5yZWFkU3RyaW5nKCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAyKSBmb250c3RhY2sucmFuZ2UgPSBwYmYucmVhZFN0cmluZygpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMykge1xuICAgICAgICB2YXIgZ2x5cGggPSBwYmYucmVhZE1lc3NhZ2UocmVhZEdseXBoLCB7fSk7XG4gICAgICAgIGZvbnRzdGFjay5nbHlwaHNbZ2x5cGguaWRdID0gZ2x5cGg7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWFkR2x5cGgodGFnLCBnbHlwaCwgcGJmKSB7XG4gICAgaWYgKHRhZyA9PT0gMSkgZ2x5cGguaWQgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMikgZ2x5cGguYml0bWFwID0gcGJmLnJlYWRCeXRlcygpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMykgZ2x5cGgud2lkdGggPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNCkgZ2x5cGguaGVpZ2h0ID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDUpIGdseXBoLmxlZnQgPSBwYmYucmVhZFNWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDYpIGdseXBoLnRvcCA9IHBiZi5yZWFkU1ZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNykgZ2x5cGguYWR2YW5jZSA9IHBiZi5yZWFkVmFyaW50KCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJwb2xhdGU7XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKGEsIGIsIHQpIHtcbiAgICByZXR1cm4gKGEgKiAoMSAtIHQpKSArIChiICogdCk7XG59XG5cbmludGVycG9sYXRlLm51bWJlciA9IGludGVycG9sYXRlO1xuXG5pbnRlcnBvbGF0ZS52ZWMyID0gZnVuY3Rpb24oZnJvbSwgdG8sIHQpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBpbnRlcnBvbGF0ZShmcm9tWzBdLCB0b1swXSwgdCksXG4gICAgICAgIGludGVycG9sYXRlKGZyb21bMV0sIHRvWzFdLCB0KVxuICAgIF07XG59O1xuXG4vKlxuICogSW50ZXJwb2xhdGUgYmV0d2VlbiB0d28gY29sb3JzIGdpdmVuIGFzIDQtZWxlbWVudCBhcnJheXMuXG4gKlxuICogQHBhcmFtIHtDb2xvcn0gZnJvbVxuICogQHBhcmFtIHtDb2xvcn0gdG9cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IGludGVycG9sYXRpb24gZmFjdG9yIGJldHdlZW4gMCBhbmQgMVxuICogQHJldHVybnMge0NvbG9yfSBpbnRlcnBvbGF0ZWQgY29sb3JcbiAqL1xuaW50ZXJwb2xhdGUuY29sb3IgPSBmdW5jdGlvbihmcm9tLCB0bywgdCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGludGVycG9sYXRlKGZyb21bMF0sIHRvWzBdLCB0KSxcbiAgICAgICAgaW50ZXJwb2xhdGUoZnJvbVsxXSwgdG9bMV0sIHQpLFxuICAgICAgICBpbnRlcnBvbGF0ZShmcm9tWzJdLCB0b1syXSwgdCksXG4gICAgICAgIGludGVycG9sYXRlKGZyb21bM10sIHRvWzNdLCB0KVxuICAgIF07XG59O1xuXG5pbnRlcnBvbGF0ZS5hcnJheSA9IGZ1bmN0aW9uKGZyb20sIHRvLCB0KSB7XG4gICAgcmV0dXJuIGZyb20ubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRlKGQsIHRvW2ldLCB0KTtcbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0NvdW50ZXJDbG9ja3dpc2UgPSByZXF1aXJlKCcuL3V0aWwnKS5pc0NvdW50ZXJDbG9ja3dpc2U7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG11bHRpUG9seWdvbkludGVyc2VjdHNCdWZmZXJlZE11bHRpUG9pbnQ6IG11bHRpUG9seWdvbkludGVyc2VjdHNCdWZmZXJlZE11bHRpUG9pbnQsXG4gICAgbXVsdGlQb2x5Z29uSW50ZXJzZWN0c011bHRpUG9seWdvbjogbXVsdGlQb2x5Z29uSW50ZXJzZWN0c011bHRpUG9seWdvbixcbiAgICBtdWx0aVBvbHlnb25JbnRlcnNlY3RzQnVmZmVyZWRNdWx0aUxpbmU6IG11bHRpUG9seWdvbkludGVyc2VjdHNCdWZmZXJlZE11bHRpTGluZSxcbiAgICBkaXN0VG9TZWdtZW50U3F1YXJlZDogZGlzdFRvU2VnbWVudFNxdWFyZWRcbn07XG5cbmZ1bmN0aW9uIG11bHRpUG9seWdvbkludGVyc2VjdHNCdWZmZXJlZE11bHRpUG9pbnQobXVsdGlQb2x5Z29uLCByaW5ncywgcmFkaXVzKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBtdWx0aVBvbHlnb24ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHBvbHlnb24gPSBtdWx0aVBvbHlnb25bal07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByaW5nID0gcmluZ3NbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHJpbmcubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSByaW5nW2tdO1xuICAgICAgICAgICAgICAgIGlmIChwb2x5Z29uQ29udGFpbnNQb2ludChwb2x5Z29uLCBwb2ludCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChwb2ludEludGVyc2VjdHNCdWZmZXJlZExpbmUocG9pbnQsIHBvbHlnb24sIHJhZGl1cykpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbXVsdGlQb2x5Z29uSW50ZXJzZWN0c011bHRpUG9seWdvbihtdWx0aVBvbHlnb25BLCBtdWx0aVBvbHlnb25CKSB7XG5cbiAgICBpZiAobXVsdGlQb2x5Z29uQS5sZW5ndGggPT09IDEgJiYgbXVsdGlQb2x5Z29uQVswXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG11bHRpUG9seWdvbkNvbnRhaW5zUG9pbnQobXVsdGlQb2x5Z29uQiwgbXVsdGlQb2x5Z29uQVswXVswXSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgbSA9IDA7IG0gPCBtdWx0aVBvbHlnb25CLmxlbmd0aDsgbSsrKSB7XG4gICAgICAgIHZhciByaW5nID0gbXVsdGlQb2x5Z29uQlttXTtcbiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCByaW5nLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICBpZiAobXVsdGlQb2x5Z29uQ29udGFpbnNQb2ludChtdWx0aVBvbHlnb25BLCByaW5nW25dKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG11bHRpUG9seWdvbkEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHBvbHlnb24gPSBtdWx0aVBvbHlnb25BW2pdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChtdWx0aVBvbHlnb25Db250YWluc1BvaW50KG11bHRpUG9seWdvbkIsIHBvbHlnb25baV0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbXVsdGlQb2x5Z29uQi5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgaWYgKGxpbmVJbnRlcnNlY3RzTGluZShwb2x5Z29uLCBtdWx0aVBvbHlnb25CW2tdKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG11bHRpUG9seWdvbkludGVyc2VjdHNCdWZmZXJlZE11bHRpTGluZShtdWx0aVBvbHlnb24sIG11bHRpTGluZSwgcmFkaXVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdWx0aUxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBtdWx0aUxpbmVbaV07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtdWx0aVBvbHlnb24ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBwb2x5Z29uID0gbXVsdGlQb2x5Z29uW2pdO1xuXG4gICAgICAgICAgICBpZiAocG9seWdvbi5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGluZS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9seWdvbkNvbnRhaW5zUG9pbnQocG9seWdvbiwgbGluZVtrXSkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxpbmVJbnRlcnNlY3RzQnVmZmVyZWRMaW5lKHBvbHlnb24sIGxpbmUsIHJhZGl1cykpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGluZUludGVyc2VjdHNCdWZmZXJlZExpbmUobGluZUEsIGxpbmVCLCByYWRpdXMpIHtcblxuICAgIGlmIChsaW5lQS5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmIChsaW5lSW50ZXJzZWN0c0xpbmUobGluZUEsIGxpbmVCKSkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciBhbnkgcG9pbnQgaW4gZWl0aGVyIGxpbmUgaXMgd2l0aGluIHJhZGl1cyBvZiB0aGUgb3RoZXIgbGluZVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmVCLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAocG9pbnRJbnRlcnNlY3RzQnVmZmVyZWRMaW5lKGxpbmVCW2pdLCBsaW5lQSwgcmFkaXVzKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGxpbmVBLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGlmIChwb2ludEludGVyc2VjdHNCdWZmZXJlZExpbmUobGluZUFba10sIGxpbmVCLCByYWRpdXMpKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RzTGluZShsaW5lQSwgbGluZUIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVBLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICB2YXIgYTAgPSBsaW5lQVtpXTtcbiAgICAgICAgdmFyIGExID0gbGluZUFbaSArIDFdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmVCLmxlbmd0aCAtIDE7IGorKykge1xuICAgICAgICAgICAgdmFyIGIwID0gbGluZUJbal07XG4gICAgICAgICAgICB2YXIgYjEgPSBsaW5lQltqICsgMV07XG4gICAgICAgICAgICBpZiAobGluZVNlZ21lbnRJbnRlcnNlY3RzTGluZVNlZ21lbnQoYTAsIGExLCBiMCwgYjEpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpbmVTZWdtZW50SW50ZXJzZWN0c0xpbmVTZWdtZW50KGEwLCBhMSwgYjAsIGIxKSB7XG4gICAgcmV0dXJuIGlzQ291bnRlckNsb2Nrd2lzZShhMCwgYjAsIGIxKSAhPT0gaXNDb3VudGVyQ2xvY2t3aXNlKGExLCBiMCwgYjEpICYmXG4gICAgICAgIGlzQ291bnRlckNsb2Nrd2lzZShhMCwgYTEsIGIwKSAhPT0gaXNDb3VudGVyQ2xvY2t3aXNlKGEwLCBhMSwgYjEpO1xufVxuXG5mdW5jdGlvbiBwb2ludEludGVyc2VjdHNCdWZmZXJlZExpbmUocCwgbGluZSwgcmFkaXVzKSB7XG4gICAgdmFyIHJhZGl1c1NxdWFyZWQgPSByYWRpdXMgKiByYWRpdXM7XG5cbiAgICBpZiAobGluZS5sZW5ndGggPT09IDEpIHJldHVybiBwLmRpc3RTcXIobGluZVswXSkgPCByYWRpdXNTcXVhcmVkO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEZpbmQgbGluZSBzZWdtZW50cyB0aGF0IGhhdmUgYSBkaXN0YW5jZSA8PSByYWRpdXNeMiB0byBwXG4gICAgICAgIC8vIEluIHRoYXQgY2FzZSwgd2UgdHJlYXQgdGhlIGxpbmUgYXMgXCJjb250YWluaW5nIHBvaW50IHBcIi5cbiAgICAgICAgdmFyIHYgPSBsaW5lW2kgLSAxXSwgdyA9IGxpbmVbaV07XG4gICAgICAgIGlmIChkaXN0VG9TZWdtZW50U3F1YXJlZChwLCB2LCB3KSA8IHJhZGl1c1NxdWFyZWQpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNTAxNzI1LzMzMTM3OS5cbmZ1bmN0aW9uIGRpc3RUb1NlZ21lbnRTcXVhcmVkKHAsIHYsIHcpIHtcbiAgICB2YXIgbDIgPSB2LmRpc3RTcXIodyk7XG4gICAgaWYgKGwyID09PSAwKSByZXR1cm4gcC5kaXN0U3FyKHYpO1xuICAgIHZhciB0ID0gKChwLnggLSB2LngpICogKHcueCAtIHYueCkgKyAocC55IC0gdi55KSAqICh3LnkgLSB2LnkpKSAvIGwyO1xuICAgIGlmICh0IDwgMCkgcmV0dXJuIHAuZGlzdFNxcih2KTtcbiAgICBpZiAodCA+IDEpIHJldHVybiBwLmRpc3RTcXIodyk7XG4gICAgcmV0dXJuIHAuZGlzdFNxcih3LnN1Yih2KS5fbXVsdCh0KS5fYWRkKHYpKTtcbn1cblxuLy8gcG9pbnQgaW4gcG9seWdvbiByYXkgY2FzdGluZyBhbGdvcml0aG1cbmZ1bmN0aW9uIG11bHRpUG9seWdvbkNvbnRhaW5zUG9pbnQocmluZ3MsIHApIHtcbiAgICB2YXIgYyA9IGZhbHNlLFxuICAgICAgICByaW5nLCBwMSwgcDI7XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHJpbmdzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHJpbmcgPSByaW5nc1trXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSByaW5nLmxlbmd0aCAtIDE7IGkgPCByaW5nLmxlbmd0aDsgaiA9IGkrKykge1xuICAgICAgICAgICAgcDEgPSByaW5nW2ldO1xuICAgICAgICAgICAgcDIgPSByaW5nW2pdO1xuICAgICAgICAgICAgaWYgKCgocDEueSA+IHAueSkgIT09IChwMi55ID4gcC55KSkgJiYgKHAueCA8IChwMi54IC0gcDEueCkgKiAocC55IC0gcDEueSkgLyAocDIueSAtIHAxLnkpICsgcDEueCkpIHtcbiAgICAgICAgICAgICAgICBjID0gIWM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIHBvbHlnb25Db250YWluc1BvaW50KHJpbmcsIHApIHtcbiAgICB2YXIgYyA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gcmluZy5sZW5ndGggLSAxOyBpIDwgcmluZy5sZW5ndGg7IGogPSBpKyspIHtcbiAgICAgICAgdmFyIHAxID0gcmluZ1tpXTtcbiAgICAgICAgdmFyIHAyID0gcmluZ1tqXTtcbiAgICAgICAgaWYgKCgocDEueSA+IHAueSkgIT09IChwMi55ID4gcC55KSkgJiYgKHAueCA8IChwMi54IC0gcDEueCkgKiAocC55IC0gcDEueSkgLyAocDIueSAtIHAxLnkpICsgcDEueCkpIHtcbiAgICAgICAgICAgIGMgPSAhYztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBMUlVDYWNoZTtcblxuLyoqXG4gKiBBIFtsZWFzdC1yZWNlbnRseS11c2VkIGNhY2hlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhY2hlX2FsZ29yaXRobXMpXG4gKiB3aXRoIGhhc2ggbG9va3VwIG1hZGUgcG9zc2libGUgYnkga2VlcGluZyBhIGxpc3Qgb2Yga2V5cyBpbiBwYXJhbGxlbCB0b1xuICogYW4gYXJyYXkgb2YgZGljdGlvbmFyeSBvZiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IG51bWJlciBvZiBwZXJtaXR0ZWQgdmFsdWVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlbW92ZSBjYWxsYmFjayBjYWxsZWQgd2l0aCBpdGVtcyB3aGVuIHRoZXkgZXhwaXJlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBMUlVDYWNoZShtYXgsIG9uUmVtb3ZlKSB7XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gICAgdGhpcy5vblJlbW92ZSA9IG9uUmVtb3ZlO1xuICAgIHRoaXMucmVzZXQoKTtcbn1cblxuLyoqXG4gKiBDbGVhciB0aGUgY2FjaGVcbiAqXG4gKiBAcmV0dXJucyB7TFJVQ2FjaGV9IHRoaXMgY2FjaGVcbiAqIEBwcml2YXRlXG4gKi9cbkxSVUNhY2hlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmRhdGEpIHtcbiAgICAgICAgdGhpcy5vblJlbW92ZSh0aGlzLmRhdGFba2V5XSk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhID0ge307XG4gICAgdGhpcy5vcmRlciA9IFtdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIGtleSwgdmFsdWUgY29tYmluYXRpb24gdG8gdGhlIGNhY2hlLCB0cmltbWluZyBpdHMgc2l6ZSBpZiB0aGlzIHB1c2hlc1xuICogaXQgb3ZlciBtYXggbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgbG9va3VwIGtleSBmb3IgdGhlIGl0ZW1cbiAqIEBwYXJhbSB7Kn0gZGF0YSBhbnkgdmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7TFJVQ2FjaGV9IHRoaXMgY2FjaGVcbiAqIEBwcml2YXRlXG4gKi9cbkxSVUNhY2hlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihrZXksIGRhdGEpIHtcblxuICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgIHRoaXMub3JkZXIuc3BsaWNlKHRoaXMub3JkZXIuaW5kZXhPZihrZXkpLCAxKTtcbiAgICAgICAgdGhpcy5kYXRhW2tleV0gPSBkYXRhO1xuICAgICAgICB0aGlzLm9yZGVyLnB1c2goa2V5KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGF0YVtrZXldID0gZGF0YTtcbiAgICAgICAgdGhpcy5vcmRlci5wdXNoKGtleSk7XG5cbiAgICAgICAgaWYgKHRoaXMub3JkZXIubGVuZ3RoID4gdGhpcy5tYXgpIHtcbiAgICAgICAgICAgIHZhciByZW1vdmVkRGF0YSA9IHRoaXMuZ2V0KHRoaXMub3JkZXJbMF0pO1xuICAgICAgICAgICAgaWYgKHJlbW92ZWREYXRhKSB0aGlzLm9uUmVtb3ZlKHJlbW92ZWREYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgdmFsdWUgYXR0YWNoZWQgdG8gYGtleWAgaXMgcHJlc2VudFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdGhlIGtleSB0byBiZSBsb29rZWQtdXBcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBjYWNoZSBoYXMgdGhpcyB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuTFJVQ2FjaGUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBrZXkgaW4gdGhpcy5kYXRhO1xufTtcblxuLyoqXG4gKiBMaXN0IGFsbCBrZXlzIGluIHRoZSBjYWNoZVxuICpcbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSBhbiBhcnJheSBvZiBrZXlzIGluIHRoaXMgY2FjaGUuXG4gKiBAcHJpdmF0ZVxuICovXG5MUlVDYWNoZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm9yZGVyO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGF0dGFjaGVkIHRvIGEgc3BlY2lmaWMga2V5LiBJZiB0aGUga2V5IGlzIG5vdCBmb3VuZCxcbiAqIHJldHVybnMgYG51bGxgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0aGUga2V5IHRvIGxvb2sgdXBcbiAqIEByZXR1cm5zIHsqfSB0aGUgZGF0YSwgb3IgbnVsbCBpZiBpdCBpc24ndCBmb3VuZFxuICogQHByaXZhdGVcbiAqL1xuTFJVQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICghdGhpcy5oYXMoa2V5KSkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGFba2V5XTtcblxuICAgIGRlbGV0ZSB0aGlzLmRhdGFba2V5XTtcbiAgICB0aGlzLm9yZGVyLnNwbGljZSh0aGlzLm9yZGVyLmluZGV4T2Yoa2V5KSwgMSk7XG5cbiAgICByZXR1cm4gZGF0YTtcbn07XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBtYXggc2l6ZSBvZiB0aGUgY2FjaGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCB0aGUgbWF4IHNpemUgb2YgdGhlIGNhY2hlXG4gKiBAcmV0dXJucyB7TFJVQ2FjaGV9IHRoaXMgY2FjaGVcbiAqIEBwcml2YXRlXG4gKi9cbkxSVUNhY2hlLnByb3RvdHlwZS5zZXRNYXhTaXplID0gZnVuY3Rpb24obWF4KSB7XG4gICAgdGhpcy5tYXggPSBtYXg7XG5cbiAgICB3aGlsZSAodGhpcy5vcmRlci5sZW5ndGggPiB0aGlzLm1heCkge1xuICAgICAgICB2YXIgcmVtb3ZlZERhdGEgPSB0aGlzLmdldCh0aGlzLm9yZGVyWzBdKTtcbiAgICAgICAgaWYgKHJlbW92ZWREYXRhKSB0aGlzLm9uUmVtb3ZlKHJlbW92ZWREYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xudmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuL2Jyb3dzZXInKTtcbnZhciBVUkwgPSByZXF1aXJlKCd1cmwnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVSTCh1cmwsIHBhdGhQcmVmaXgsIGFjY2Vzc1Rva2VuKSB7XG4gICAgYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbiB8fCBjb25maWcuQUNDRVNTX1RPS0VOO1xuXG4gICAgaWYgKCFhY2Nlc3NUb2tlbiAmJiBjb25maWcuUkVRVUlSRV9BQ0NFU1NfVE9LRU4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBBUEkgYWNjZXNzIHRva2VuIGlzIHJlcXVpcmVkIHRvIHVzZSBNYXBib3ggR0wuICcgK1xuICAgICAgICAgICAgJ1NlZSBodHRwczovL3d3dy5tYXBib3guY29tL2RldmVsb3BlcnMvYXBpLyNhY2Nlc3MtdG9rZW5zJyk7XG4gICAgfVxuXG4gICAgdXJsID0gdXJsLnJlcGxhY2UoL15tYXBib3g6XFwvXFwvLywgY29uZmlnLkFQSV9VUkwgKyBwYXRoUHJlZml4KTtcbiAgICB1cmwgKz0gdXJsLmluZGV4T2YoJz8nKSAhPT0gLTEgPyAnJmFjY2Vzc190b2tlbj0nIDogJz9hY2Nlc3NfdG9rZW49JztcblxuICAgIGlmIChjb25maWcuUkVRVUlSRV9BQ0NFU1NfVE9LRU4pIHtcbiAgICAgICAgaWYgKGFjY2Vzc1Rva2VuWzBdID09PSAncycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXNlIGEgcHVibGljIGFjY2VzcyB0b2tlbiAocGsuKikgd2l0aCBNYXBib3ggR0wgSlMsIG5vdCBhIHNlY3JldCBhY2Nlc3MgdG9rZW4gKHNrLiopLiAnICtcbiAgICAgICAgICAgICAgICAnU2VlIGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vZGV2ZWxvcGVycy9hcGkvI2FjY2Vzcy10b2tlbnMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVybCArPSBhY2Nlc3NUb2tlbjtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVTdHlsZVVSTCA9IGZ1bmN0aW9uKHVybCwgYWNjZXNzVG9rZW4pIHtcbiAgICB2YXIgdXJsT2JqZWN0ID0gVVJMLnBhcnNlKHVybCk7XG5cbiAgICBpZiAodXJsT2JqZWN0LnByb3RvY29sICE9PSAnbWFwYm94OicpIHtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplVVJMKFxuICAgICAgICAgICAgJ21hcGJveDovJyArIHVybE9iamVjdC5wYXRobmFtZSArIGZvcm1hdFF1ZXJ5KHVybE9iamVjdC5xdWVyeSksXG4gICAgICAgICAgICAnL3N0eWxlcy92MS8nLFxuICAgICAgICAgICAgYWNjZXNzVG9rZW5cbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVTb3VyY2VVUkwgPSBmdW5jdGlvbih1cmwsIGFjY2Vzc1Rva2VuKSB7XG4gICAgdmFyIHVybE9iamVjdCA9IFVSTC5wYXJzZSh1cmwpO1xuXG4gICAgaWYgKHVybE9iamVjdC5wcm90b2NvbCAhPT0gJ21hcGJveDonKSB7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGlsZUpTT04gcmVxdWVzdHMgbmVlZCBhIHNlY3VyZSBmbGFnIGFwcGVuZGVkIHRvIHRoZWlyIFVSTHMgc29cbiAgICAgICAgLy8gdGhhdCB0aGUgc2VydmVyIGtub3dzIHRvIHNlbmQgU1NMLWlmaWVkIHJlc291cmNlIHJlZmVyZW5jZXMuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVVUkwoXG4gICAgICAgICAgICB1cmwgKyAnLmpzb24nLFxuICAgICAgICAgICAgJy92NC8nLFxuICAgICAgICAgICAgYWNjZXNzVG9rZW5cbiAgICAgICAgKSArICcmc2VjdXJlJztcbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzLm5vcm1hbGl6ZUdseXBoc1VSTCA9IGZ1bmN0aW9uKHVybCwgYWNjZXNzVG9rZW4pIHtcbiAgICB2YXIgdXJsT2JqZWN0ID0gVVJMLnBhcnNlKHVybCk7XG5cbiAgICBpZiAodXJsT2JqZWN0LnByb3RvY29sICE9PSAnbWFwYm94OicpIHtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdXNlciA9IHVybE9iamVjdC5wYXRobmFtZS5zcGxpdCgnLycpWzFdO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplVVJMKFxuICAgICAgICAgICAgJ21hcGJveDovLycgKyB1c2VyICsgJy97Zm9udHN0YWNrfS97cmFuZ2V9LnBiZicgKyBmb3JtYXRRdWVyeSh1cmxPYmplY3QucXVlcnkpLFxuICAgICAgICAgICAgJy9mb250cy92MS8nLFxuICAgICAgICAgICAgYWNjZXNzVG9rZW5cbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemVTcHJpdGVVUkwgPSBmdW5jdGlvbih1cmwsIGZvcm1hdCwgZXh0ZW5zaW9uLCBhY2Nlc3NUb2tlbikge1xuICAgIHZhciB1cmxPYmplY3QgPSBVUkwucGFyc2UodXJsKTtcblxuICAgIGlmICh1cmxPYmplY3QucHJvdG9jb2wgIT09ICdtYXBib3g6Jykge1xuICAgICAgICB1cmxPYmplY3QucGF0aG5hbWUgKz0gZm9ybWF0ICsgZXh0ZW5zaW9uO1xuICAgICAgICByZXR1cm4gVVJMLmZvcm1hdCh1cmxPYmplY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVVUkwoXG4gICAgICAgICAgICAnbWFwYm94Oi8nICsgdXJsT2JqZWN0LnBhdGhuYW1lICsgJy9zcHJpdGUnICsgZm9ybWF0ICsgZXh0ZW5zaW9uICsgZm9ybWF0UXVlcnkodXJsT2JqZWN0LnF1ZXJ5KSxcbiAgICAgICAgICAgICcvc3R5bGVzL3YxLycsXG4gICAgICAgICAgICBhY2Nlc3NUb2tlblxuICAgICAgICApO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLm5vcm1hbGl6ZVRpbGVVUkwgPSBmdW5jdGlvbih0aWxlVVJMLCBzb3VyY2VVUkwsIHRpbGVTaXplKSB7XG4gICAgdmFyIHRpbGVVUkxPYmplY3QgPSBVUkwucGFyc2UodGlsZVVSTCwgdHJ1ZSk7XG4gICAgaWYgKCFzb3VyY2VVUkwpIHJldHVybiB0aWxlVVJMO1xuICAgIHZhciBzb3VyY2VVUkxPYmplY3QgPSBVUkwucGFyc2Uoc291cmNlVVJMKTtcbiAgICBpZiAoc291cmNlVVJMT2JqZWN0LnByb3RvY29sICE9PSAnbWFwYm94OicpIHJldHVybiB0aWxlVVJMO1xuXG4gICAgLy8gVGhlIHY0IG1hcGJveCB0aWxlIEFQSSBzdXBwb3J0cyA1MTJ4NTEyIGltYWdlIHRpbGVzIG9ubHkgd2hlbiBAMnhcbiAgICAvLyBpcyBhcHBlbmRlZCB0byB0aGUgdGlsZSBVUkwuIElmIGB0aWxlU2l6ZTogNTEyYCBpcyBzcGVjaWZpZWQgZm9yXG4gICAgLy8gYSBNYXBib3ggcmFzdGVyIHNvdXJjZSBmb3JjZSB0aGUgQDJ4IHN1ZmZpeCBldmVuIGlmIGEgbm9uIGhpZHBpXG4gICAgLy8gZGV2aWNlLlxuXG4gICAgdmFyIGV4dGVuc2lvbiA9IGJyb3dzZXIuc3VwcG9ydHNXZWJwID8gJy53ZWJwJyA6ICckMSc7XG4gICAgdmFyIHJlc29sdXRpb24gPSAoYnJvd3Nlci5kZXZpY2VQaXhlbFJhdGlvID49IDIgfHwgdGlsZVNpemUgPT09IDUxMikgPyAnQDJ4JyA6ICcnO1xuXG4gICAgcmV0dXJuIFVSTC5mb3JtYXQoe1xuICAgICAgICBwcm90b2NvbDogdGlsZVVSTE9iamVjdC5wcm90b2NvbCxcbiAgICAgICAgaG9zdG5hbWU6IHRpbGVVUkxPYmplY3QuaG9zdG5hbWUsXG4gICAgICAgIHBhdGhuYW1lOiB0aWxlVVJMT2JqZWN0LnBhdGhuYW1lLnJlcGxhY2UoLyhcXC4oPzpwbmd8anBnKVxcZCopLywgcmVzb2x1dGlvbiArIGV4dGVuc2lvbiksXG4gICAgICAgIHF1ZXJ5OiByZXBsYWNlVGVtcEFjY2Vzc1Rva2VuKHRpbGVVUkxPYmplY3QucXVlcnkpXG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiBmb3JtYXRRdWVyeShxdWVyeSkge1xuICAgIHJldHVybiAocXVlcnkgPyAnPycgKyBxdWVyeSA6ICcnKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVRlbXBBY2Nlc3NUb2tlbihxdWVyeSkge1xuICAgIGlmIChxdWVyeS5hY2Nlc3NfdG9rZW4gJiYgcXVlcnkuYWNjZXNzX3Rva2VuLnNsaWNlKDAsIDMpID09PSAndGsuJykge1xuICAgICAgICByZXR1cm4gdXRpbC5leHRlbmQoe30sIHF1ZXJ5LCB7XG4gICAgICAgICAgICAnYWNjZXNzX3Rva2VuJzogY29uZmlnLkFDQ0VTU19UT0tFTlxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiBhbGwgXCJzaXplc1wiIGFyZSBtZWFzdXJlZCBpbiBieXRlc1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RydWN0QXJyYXlUeXBlO1xuXG52YXIgdmlld1R5cGVzID0ge1xuICAgICdJbnQ4JzogSW50OEFycmF5LFxuICAgICdVaW50OCc6IFVpbnQ4QXJyYXksXG4gICAgJ1VpbnQ4Q2xhbXBlZCc6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuICAgICdJbnQxNic6IEludDE2QXJyYXksXG4gICAgJ1VpbnQxNic6IFVpbnQxNkFycmF5LFxuICAgICdJbnQzMic6IEludDMyQXJyYXksXG4gICAgJ1VpbnQzMic6IFVpbnQzMkFycmF5LFxuICAgICdGbG9hdDMyJzogRmxvYXQzMkFycmF5LFxuICAgICdGbG9hdDY0JzogRmxvYXQ2NEFycmF5XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIFN0cnVjdE1lbWJlclxuICogQHByaXZhdGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvbXBvbmVudHNcbiAqL1xuXG52YXIgc3RydWN0QXJyYXlUeXBlQ2FjaGUgPSB7fTtcblxuLyoqXG4gKiBgU3RydWN0QXJyYXlUeXBlYCBpcyB1c2VkIHRvIGNyZWF0ZSBuZXcgYFN0cnVjdEFycmF5YCB0eXBlcy5cbiAqXG4gKiBgU3RydWN0QXJyYXlgIHByb3ZpZGVzIGFuIGFic3RyYWN0aW9uIG92ZXIgYEFycmF5QnVmZmVyYCBhbmQgYFR5cGVkQXJyYXlgIG1ha2luZyBpdCBiZWhhdmUgbGlrZVxuICogYW4gYXJyYXkgb2YgdHlwZWQgc3RydWN0cy4gQSBTdHJ1Y3RBcnJheSBpcyBjb21wcmlzZWQgb2YgZWxlbWVudHMuIEVhY2ggZWxlbWVudCBoYXMgYSBzZXQgb2ZcbiAqIG1lbWJlcnMgdGhhdCBhcmUgZGVmaW5lZCB3aGVuIHRoZSBgU3RydWN0QXJyYXlUeXBlYCBpcyBjcmVhdGVkLlxuICpcbiAqIFN0cnVjdEFycmF5cyB1c2VmdWwgZm9yIGNyZWF0aW5nIGxhcmdlIGFycmF5cyB0aGF0OlxuICogLSBjYW4gYmUgdHJhbnNmZXJyZWQgZnJvbSB3b3JrZXJzIGFzIGEgVHJhbnNmZXJhYmxlIG9iamVjdFxuICogLSBjYW4gYmUgY29waWVkIGNoZWFwbHlcbiAqIC0gdXNlIGxlc3MgbWVtb3J5IGZvciBsb3dlci1wcmVjaXNpb24gbWVtYmVyc1xuICogLSBjYW4gYmUgdXNlZCBhcyBidWZmZXJzIGluIFdlYkdMLlxuICpcbiAqIEBjbGFzcyBTdHJ1Y3RBcnJheVR5cGVcbiAqIEBwYXJhbSB7QXJyYXkuPFN0cnVjdE1lbWJlcj59XG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuYWxpZ25tZW50IFVzZSBgNGAgdG8gYWxpZ24gbWVtYmVycyB0byA0IGJ5dGUgYm91bmRhcmllcy4gRGVmYXVsdCBpcyAxLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIFBvaW50QXJyYXlUeXBlID0gbmV3IFN0cnVjdEFycmF5VHlwZSh7XG4gKiAgbWVtYmVyczogW1xuICogICAgICB7IHR5cGU6ICdJbnQxNicsIG5hbWU6ICd4JyB9LFxuICogICAgICB7IHR5cGU6ICdJbnQxNicsIG5hbWU6ICd5JyB9XG4gKiAgXX0pO1xuICpcbiAqICB2YXIgcG9pbnRBcnJheSA9IG5ldyBQb2ludEFycmF5VHlwZSgpO1xuICogIHBvaW50QXJyYXkuZW1wbGFjZUJhY2soMTAsIDE1KTtcbiAqICBwb2ludEFycmF5LmVtcGxhY2VCYWNrKDIwLCAzNSk7XG4gKlxuICogIHBvaW50ID0gcG9pbnRBcnJheS5nZXQoMCk7XG4gKiAgYXNzZXJ0KHBvaW50LnggPT09IDEwKTtcbiAqICBhc3NlcnQocG9pbnQueSA9PT0gMTUpO1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFN0cnVjdEFycmF5VHlwZShvcHRpb25zKSB7XG5cbiAgICB2YXIga2V5ID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XG4gICAgaWYgKHN0cnVjdEFycmF5VHlwZUNhY2hlW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIHN0cnVjdEFycmF5VHlwZUNhY2hlW2tleV07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWxpZ25tZW50ID09PSB1bmRlZmluZWQpIG9wdGlvbnMuYWxpZ25tZW50ID0gMTtcblxuICAgIGZ1bmN0aW9uIFN0cnVjdFR5cGUoKSB7XG4gICAgICAgIFN0cnVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIFN0cnVjdFR5cGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdHJ1Y3QucHJvdG90eXBlKTtcblxuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBtYXhTaXplID0gMDtcbiAgICB2YXIgdXNlZFR5cGVzID0gWydVaW50OCddO1xuXG4gICAgU3RydWN0VHlwZS5wcm90b3R5cGUubWVtYmVycyA9IG9wdGlvbnMubWVtYmVycy5tYXAoZnVuY3Rpb24obWVtYmVyKSB7XG4gICAgICAgIG1lbWJlciA9IHtcbiAgICAgICAgICAgIG5hbWU6IG1lbWJlci5uYW1lLFxuICAgICAgICAgICAgdHlwZTogbWVtYmVyLnR5cGUsXG4gICAgICAgICAgICBjb21wb25lbnRzOiBtZW1iZXIuY29tcG9uZW50cyB8fCAxXG4gICAgICAgIH07XG5cbiAgICAgICAgYXNzZXJ0KG1lbWJlci5uYW1lLmxlbmd0aCk7XG4gICAgICAgIGFzc2VydChtZW1iZXIudHlwZSBpbiB2aWV3VHlwZXMpO1xuXG4gICAgICAgIGlmICh1c2VkVHlwZXMuaW5kZXhPZihtZW1iZXIudHlwZSkgPCAwKSB1c2VkVHlwZXMucHVzaChtZW1iZXIudHlwZSk7XG5cbiAgICAgICAgdmFyIHR5cGVTaXplID0gc2l6ZU9mKG1lbWJlci50eXBlKTtcbiAgICAgICAgbWF4U2l6ZSA9IE1hdGgubWF4KG1heFNpemUsIHR5cGVTaXplKTtcbiAgICAgICAgbWVtYmVyLm9mZnNldCA9IG9mZnNldCA9IGFsaWduKG9mZnNldCwgTWF0aC5tYXgob3B0aW9ucy5hbGlnbm1lbnQsIHR5cGVTaXplKSk7XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBtZW1iZXIuY29tcG9uZW50czsgYysrKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RydWN0VHlwZS5wcm90b3R5cGUsIG1lbWJlci5uYW1lICsgKG1lbWJlci5jb21wb25lbnRzID09PSAxID8gJycgOiBjKSwge1xuICAgICAgICAgICAgICAgIGdldDogY3JlYXRlR2V0dGVyKG1lbWJlciwgYyksXG4gICAgICAgICAgICAgICAgc2V0OiBjcmVhdGVTZXR0ZXIobWVtYmVyLCBjKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBvZmZzZXQgKz0gdHlwZVNpemUgKiBtZW1iZXIuY29tcG9uZW50cztcblxuICAgICAgICByZXR1cm4gbWVtYmVyO1xuICAgIH0pO1xuXG4gICAgU3RydWN0VHlwZS5wcm90b3R5cGUuYWxpZ25tZW50ID0gb3B0aW9ucy5hbGlnbm1lbnQ7XG4gICAgU3RydWN0VHlwZS5wcm90b3R5cGUuc2l6ZSA9IGFsaWduKG9mZnNldCwgTWF0aC5tYXgobWF4U2l6ZSwgb3B0aW9ucy5hbGlnbm1lbnQpKTtcblxuICAgIGZ1bmN0aW9uIFN0cnVjdEFycmF5VHlwZSgpIHtcbiAgICAgICAgU3RydWN0QXJyYXkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gU3RydWN0VHlwZS5wcm90b3R5cGUubWVtYmVycztcbiAgICB9XG5cbiAgICBTdHJ1Y3RBcnJheVR5cGUuc2VyaWFsaXplID0gc2VyaWFsaXplU3RydWN0QXJyYXlUeXBlO1xuXG4gICAgU3RydWN0QXJyYXlUeXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3RydWN0QXJyYXkucHJvdG90eXBlKTtcbiAgICBTdHJ1Y3RBcnJheVR5cGUucHJvdG90eXBlLlN0cnVjdFR5cGUgPSBTdHJ1Y3RUeXBlO1xuICAgIFN0cnVjdEFycmF5VHlwZS5wcm90b3R5cGUuYnl0ZXNQZXJFbGVtZW50ID0gU3RydWN0VHlwZS5wcm90b3R5cGUuc2l6ZTtcbiAgICBTdHJ1Y3RBcnJheVR5cGUucHJvdG90eXBlLmVtcGxhY2VCYWNrID0gY3JlYXRlRW1wbGFjZUJhY2soU3RydWN0VHlwZS5wcm90b3R5cGUubWVtYmVycywgU3RydWN0VHlwZS5wcm90b3R5cGUuc2l6ZSk7XG4gICAgU3RydWN0QXJyYXlUeXBlLnByb3RvdHlwZS5fdXNlZFR5cGVzID0gdXNlZFR5cGVzO1xuXG5cbiAgICBzdHJ1Y3RBcnJheVR5cGVDYWNoZVtrZXldID0gU3RydWN0QXJyYXlUeXBlO1xuXG4gICAgcmV0dXJuIFN0cnVjdEFycmF5VHlwZTtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIFN0cnVjdEFycmF5IHR5cGUuIFRoaXMgc2VyaWFsaXplcyB0aGUgKnR5cGUqIG5vdCBhbiBpbnN0YW5jZSBvZiB0aGUgdHlwZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZVN0cnVjdEFycmF5VHlwZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtZW1iZXJzOiB0aGlzLnByb3RvdHlwZS5TdHJ1Y3RUeXBlLnByb3RvdHlwZS5tZW1iZXJzLFxuICAgICAgICBhbGlnbm1lbnQ6IHRoaXMucHJvdG90eXBlLlN0cnVjdFR5cGUucHJvdG90eXBlLmFsaWdubWVudCxcbiAgICAgICAgYnl0ZXNQZXJFbGVtZW50OiB0aGlzLnByb3RvdHlwZS5ieXRlc1BlckVsZW1lbnRcbiAgICB9O1xufVxuXG5cbmZ1bmN0aW9uIGFsaWduKG9mZnNldCwgc2l6ZSkge1xuICAgIHJldHVybiBNYXRoLmNlaWwob2Zmc2V0IC8gc2l6ZSkgKiBzaXplO1xufVxuXG5mdW5jdGlvbiBzaXplT2YodHlwZSkge1xuICAgIHJldHVybiB2aWV3VHlwZXNbdHlwZV0uQllURVNfUEVSX0VMRU1FTlQ7XG59XG5cbmZ1bmN0aW9uIGdldEFycmF5Vmlld05hbWUodHlwZSkge1xuICAgIHJldHVybiB0eXBlLnRvTG93ZXJDYXNlKCk7XG59XG5cblxuLypcbiAqID4gSSBzYXcgbWFqb3IgcGVyZiBnYWlucyBieSBzaG9ydGVuaW5nIHRoZSBzb3VyY2Ugb2YgdGhlc2UgZ2VuZXJhdGVkIG1ldGhvZHMgKGkuZS4gcmVuYW1pbmdcbiAqID4gZWxlbWVudEluZGV4IHRvIGkpIChsaWtlbHkgZHVlIHRvIHY4IGlubGluaW5nIGhldXJpc3RpY3MpLlxuICogLSBsdWNhc3dvalxuICovXG5mdW5jdGlvbiBjcmVhdGVFbXBsYWNlQmFjayhtZW1iZXJzLCBieXRlc1BlckVsZW1lbnQpIHtcbiAgICB2YXIgdXNlZFR5cGVTaXplcyA9IFtdO1xuICAgIHZhciBhcmdOYW1lcyA9IFtdO1xuICAgIHZhciBib2R5ID0gJycgK1xuICAgICd2YXIgaSA9IHRoaXMubGVuZ3RoO1xcbicgK1xuICAgICd0aGlzLnJlc2l6ZSh0aGlzLmxlbmd0aCArIDEpO1xcbic7XG5cbiAgICBmb3IgKHZhciBtID0gMDsgbSA8IG1lbWJlcnMubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgdmFyIG1lbWJlciA9IG1lbWJlcnNbbV07XG4gICAgICAgIHZhciBzaXplID0gc2l6ZU9mKG1lbWJlci50eXBlKTtcblxuICAgICAgICAvLyBhcnJheSBvZmZzZXRzIHRvIHRoZSBlbmQgb2YgY3VycmVudCBkYXRhIGZvciBlYWNoIHR5cGUgc2l6ZVxuICAgICAgICAvLyB2YXIgb3tTSVpFfSA9IGkgKiBST1VOREVEKGJ5dGVzUGVyRWxlbWVudCAvIHNpemUpO1xuICAgICAgICBpZiAodXNlZFR5cGVTaXplcy5pbmRleE9mKHNpemUpIDwgMCkge1xuICAgICAgICAgICAgdXNlZFR5cGVTaXplcy5wdXNoKHNpemUpO1xuICAgICAgICAgICAgYm9keSArPSAndmFyIG8nICsgc2l6ZS50b0ZpeGVkKDApICsgJyA9IGkgKiAnICsgKGJ5dGVzUGVyRWxlbWVudCAvIHNpemUpLnRvRml4ZWQoMCkgKyAnO1xcbic7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG1lbWJlci5jb21wb25lbnRzOyBjKyspIHtcbiAgICAgICAgICAgIC8vIGFyZ3VtZW50cyB2MCwgdjEsIHYyLCAuLi4gYXJlLCBpbiBvcmRlciwgdGhlIGNvbXBvbmVudHMgb2ZcbiAgICAgICAgICAgIC8vIG1lbWJlciAwLCB0aGVuIHRoZSBjb21wb25lbnRzIG9mIG1lbWJlciAxLCBldGMuXG4gICAgICAgICAgICB2YXIgYXJnTmFtZSA9ICd2JyArIGFyZ05hbWVzLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIFRoZSBpbmRleCBmb3IgYG1lbWJlcmAgY29tcG9uZW50IGBjYCBpbnRvIHRoZSBhcHByb3ByaWF0ZSB0eXBlIGFycmF5IGlzOlxuICAgICAgICAgICAgLy8gdGhpcy57VFlQRX1bb3tTSVpFfSArIE1FTUJFUl9PRkZTRVQgKyB7Y31dID0gdntYfVxuICAgICAgICAgICAgLy8gd2hlcmUgTUVNQkVSX09GRlNFVCA9IFJPVU5EKG1lbWJlci5vZmZzZXQgLyBzaXplKSBpcyB0aGUgcGVyLWVsZW1lbnRcbiAgICAgICAgICAgIC8vIG9mZnNldCBvZiB0aGlzIG1lbWJlciBpbnRvIHRoZSBhcnJheVxuICAgICAgICAgICAgdmFyIGluZGV4ID0gJ28nICsgc2l6ZS50b0ZpeGVkKDApICsgJyArICcgKyAobWVtYmVyLm9mZnNldCAvIHNpemUgKyBjKS50b0ZpeGVkKDApO1xuICAgICAgICAgICAgYm9keSArPSAndGhpcy4nICsgZ2V0QXJyYXlWaWV3TmFtZShtZW1iZXIudHlwZSkgKyAnWycgKyBpbmRleCArICddID0gJyArIGFyZ05hbWUgKyAnO1xcbic7XG4gICAgICAgICAgICBhcmdOYW1lcy5wdXNoKGFyZ05hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYm9keSArPSAncmV0dXJuIGk7JztcblxuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oYXJnTmFtZXMsIGJvZHkpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNZW1iZXJDb21wb25lbnRTdHJpbmcobWVtYmVyLCBjb21wb25lbnQpIHtcbiAgICB2YXIgZWxlbWVudE9mZnNldCA9ICd0aGlzLl9wb3MnICsgc2l6ZU9mKG1lbWJlci50eXBlKS50b0ZpeGVkKDApO1xuICAgIHZhciBjb21wb25lbnRPZmZzZXQgPSAobWVtYmVyLm9mZnNldCAvIHNpemVPZihtZW1iZXIudHlwZSkgKyBjb21wb25lbnQpLnRvRml4ZWQoMCk7XG4gICAgdmFyIGluZGV4ID0gZWxlbWVudE9mZnNldCArICcgKyAnICsgY29tcG9uZW50T2Zmc2V0O1xuICAgIHJldHVybiAndGhpcy5fc3RydWN0QXJyYXkuJyArIGdldEFycmF5Vmlld05hbWUobWVtYmVyLnR5cGUpICsgJ1snICsgaW5kZXggKyAnXSc7XG5cbn1cblxuZnVuY3Rpb24gY3JlYXRlR2V0dGVyKG1lbWJlciwgYykge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oW10sICdyZXR1cm4gJyArIGNyZWF0ZU1lbWJlckNvbXBvbmVudFN0cmluZyhtZW1iZXIsIGMpICsgJzsnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2V0dGVyKG1lbWJlciwgYykge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oWyd4J10sIGNyZWF0ZU1lbWJlckNvbXBvbmVudFN0cmluZyhtZW1iZXIsIGMpICsgJyA9IHg7Jyk7XG59XG5cbi8qKlxuICogQGNsYXNzIFN0cnVjdFxuICogQHBhcmFtIHtTdHJ1Y3RBcnJheX0gc3RydWN0QXJyYXkgVGhlIFN0cnVjdEFycmF5IHRoZSBzdHJ1Y3QgaXMgc3RvcmVkIGluXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBzdHJ1Y3QgaW4gdGhlIFN0cnVjdEFycmF5LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gU3RydWN0KHN0cnVjdEFycmF5LCBpbmRleCkge1xuICAgIHRoaXMuX3N0cnVjdEFycmF5ID0gc3RydWN0QXJyYXk7XG4gICAgdGhpcy5fcG9zMSA9IGluZGV4ICogdGhpcy5zaXplO1xuICAgIHRoaXMuX3BvczIgPSB0aGlzLl9wb3MxIC8gMjtcbiAgICB0aGlzLl9wb3M0ID0gdGhpcy5fcG9zMSAvIDQ7XG4gICAgdGhpcy5fcG9zOCA9IHRoaXMuX3BvczEgLyA4O1xufVxuXG4vKipcbiAqIEBjbGFzcyBTdHJ1Y3RBcnJheVxuICogVGhlIFN0cnVjdEFycmF5IGNsYXNzIGlzIGluaGVyaXRlZCBieSB0aGUgY3VzdG9tIFN0cnVjdEFycmF5VHlwZSBjbGFzc2VzIGNyZWF0ZWQgd2l0aFxuICogYG5ldyBTdHJ1Y3RBcnJheVR5cGUobWVtYmVycywgb3B0aW9ucylgLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gU3RydWN0QXJyYXkoc2VyaWFsaXplZCkge1xuICAgIGlmIChzZXJpYWxpemVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBDcmVhdGUgZnJvbSBhbiBzZXJpYWxpemVkIFN0cnVjdEFycmF5XG4gICAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBzZXJpYWxpemVkLmFycmF5QnVmZmVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHNlcmlhbGl6ZWQubGVuZ3RoO1xuICAgICAgICB0aGlzLmNhcGFjaXR5ID0gdGhpcy5hcnJheUJ1ZmZlci5ieXRlTGVuZ3RoIC8gdGhpcy5ieXRlc1BlckVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hWaWV3cygpO1xuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IFN0cnVjdEFycmF5XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYXBhY2l0eSA9IC0xO1xuICAgICAgICB0aGlzLnJlc2l6ZSgwKTtcbiAgICB9XG59XG5cbi8qKlxuICogQHByb3BlcnR5IHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICogQHJlYWRvbmx5XG4gKi9cblN0cnVjdEFycmF5LnByb3RvdHlwZS5ERUZBVUxUX0NBUEFDSVRZID0gMTI4O1xuXG4vKipcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfVxuICogQHByaXZhdGVcbiAqIEByZWFkb25seVxuICovXG5TdHJ1Y3RBcnJheS5wcm90b3R5cGUuUkVTSVpFX01VTFRJUExJRVIgPSA1O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGlzIFN0cnVjdEFycmF5IGluc3RhbmNlXG4gKiBAcHJpdmF0ZVxuICovXG5TdHJ1Y3RBcnJheS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50cmltKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVuZ3RoOiB0aGlzLmxlbmd0aCxcbiAgICAgICAgYXJyYXlCdWZmZXI6IHRoaXMuYXJyYXlCdWZmZXJcbiAgICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIFN0cnVjdCBhdCB0aGUgZ2l2ZW4gbG9jYXRpb24gaW4gdGhlIGFycmF5LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQuXG4gKi9cblN0cnVjdEFycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5TdHJ1Y3RUeXBlKHRoaXMsIGluZGV4KTtcbn07XG5cbi8qKlxuICogUmVzaXplIHRoZSBhcnJheSB0byBkaXNjYXJkIHVudXNlZCBjYXBhY2l0eS5cbiAqIEBwcml2YXRlXG4gKi9cblN0cnVjdEFycmF5LnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoICE9PSB0aGlzLmNhcGFjaXR5KSB7XG4gICAgICAgIHRoaXMuY2FwYWNpdHkgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IHRoaXMuYXJyYXlCdWZmZXIuc2xpY2UoMCwgdGhpcy5sZW5ndGggKiB0aGlzLmJ5dGVzUGVyRWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hWaWV3cygpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVzaXplIHRoZSBhcnJheS5cbiAqIElmIGBuYCBpcyBncmVhdGVyIHRoYW4gdGhlIGN1cnJlbnQgbGVuZ3RoIHRoZW4gYWRkaXRpb25hbCBlbGVtZW50cyB3aXRoIHVuZGVmaW5lZCB2YWx1ZXMgYXJlIGFkZGVkLlxuICogSWYgYG5gIGlzIGxlc3MgdGhhbiB0aGUgY3VycmVudCBsZW5ndGggdGhlbiB0aGUgYXJyYXkgd2lsbCBiZSByZWR1Y2VkIHRvIHRoZSBmaXJzdCBgbmAgZWxlbWVudHMuXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbmV3IHNpemUgb2YgdGhlIGFycmF5LlxuICovXG5TdHJ1Y3RBcnJheS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24obikge1xuICAgIHRoaXMubGVuZ3RoID0gbjtcbiAgICBpZiAobiA+IHRoaXMuY2FwYWNpdHkpIHtcbiAgICAgICAgdGhpcy5jYXBhY2l0eSA9IE1hdGgubWF4KG4sIE1hdGguZmxvb3IodGhpcy5jYXBhY2l0eSAqIHRoaXMuUkVTSVpFX01VTFRJUExJRVIpLCB0aGlzLkRFRkFVTFRfQ0FQQUNJVFkpO1xuICAgICAgICB0aGlzLmFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuY2FwYWNpdHkgKiB0aGlzLmJ5dGVzUGVyRWxlbWVudCk7XG5cbiAgICAgICAgdmFyIG9sZFVpbnQ4QXJyYXkgPSB0aGlzLnVpbnQ4O1xuICAgICAgICB0aGlzLl9yZWZyZXNoVmlld3MoKTtcbiAgICAgICAgaWYgKG9sZFVpbnQ4QXJyYXkpIHRoaXMudWludDguc2V0KG9sZFVpbnQ4QXJyYXkpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIFR5cGVkQXJyYXkgdmlld3MgZm9yIHRoZSBjdXJyZW50IEFycmF5QnVmZmVyLlxuICogQHByaXZhdGVcbiAqL1xuU3RydWN0QXJyYXkucHJvdG90eXBlLl9yZWZyZXNoVmlld3MgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IHRoaXMuX3VzZWRUeXBlcy5sZW5ndGg7IHQrKykge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMuX3VzZWRUeXBlc1t0XTtcbiAgICAgICAgdGhpc1tnZXRBcnJheVZpZXdOYW1lKHR5cGUpXSA9IG5ldyB2aWV3VHlwZXNbdHlwZV0odGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBPdXRwdXQgdGhlIGBTdHJ1Y3RBcnJheWAgYmV0d2VlbiBpbmRpY2VzIGBzdGFydEluZGV4YCBhbmQgYGVuZEluZGV4YCBhcyBhbiBhcnJheSBvZiBgU3RydWN0VHlwZXNgIHRvIGVuYWJsZSBzb3J0aW5nXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGVuZEluZGV4XG4gKiBAcHJpdmF0ZVxuICovXG5TdHJ1Y3RBcnJheS5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gICAgdmFyIGFycmF5ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgdmFyIHN0cnVjdCA9IHRoaXMuZ2V0KGkpO1xuICAgICAgICBhcnJheS5wdXNoKHN0cnVjdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlVG9rZW5zO1xuXG4vKipcbiAqIFJlcGxhY2UgdG9rZW5zIGluIGEgc3RyaW5nIHRlbXBsYXRlIHdpdGggdmFsdWVzIGluIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIGEga2V5L3ZhbHVlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHRva2VucyBhbmQgcmVwbGFjZW1lbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCB0aGUgdGVtcGxhdGUgc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgdGVtcGxhdGUgd2l0aCB0b2tlbnMgcmVwbGFjZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVUb2tlbnMocHJvcGVydGllcywgdGV4dCkge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL3soW157fV0rKX0vZywgZnVuY3Rpb24obWF0Y2gsIGtleSkge1xuICAgICAgICByZXR1cm4ga2V5IGluIHByb3BlcnRpZXMgPyBwcm9wZXJ0aWVzW2tleV0gOiAnJztcbiAgICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFVuaXRCZXppZXIgPSByZXF1aXJlKCd1bml0YmV6aWVyJyk7XG52YXIgQ29vcmRpbmF0ZSA9IHJlcXVpcmUoJy4uL2dlby9jb29yZGluYXRlJyk7XG5cbi8qKlxuICogR2l2ZW4gYSB2YWx1ZSBgdGAgdGhhdCB2YXJpZXMgYmV0d2VlbiAwIGFuZCAxLCByZXR1cm5cbiAqIGFuIGludGVycG9sYXRpb24gZnVuY3Rpb24gdGhhdCBlYXNlcyBiZXR3ZWVuIDAgYW5kIDEgaW4gYSBwbGVhc2luZ1xuICogY3ViaWMgaW4tb3V0IGZhc2hpb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHQgaW5wdXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGlucHV0XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmVhc2VDdWJpY0luT3V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICBpZiAodCA8PSAwKSByZXR1cm4gMDtcbiAgICBpZiAodCA+PSAxKSByZXR1cm4gMTtcbiAgICB2YXIgdDIgPSB0ICogdCxcbiAgICAgICAgdDMgPSB0MiAqIHQ7XG4gICAgcmV0dXJuIDQgKiAodCA8IDAuNSA/IHQzIDogMyAqICh0IC0gdDIpICsgdDMgLSAwLjc1KTtcbn07XG5cbi8qKlxuICogR2l2ZW4gZ2l2ZW4gKHgsIHkpLCAoeDEsIHkxKSBjb250cm9sIHBvaW50cyBmb3IgYSBiZXppZXIgY3VydmUsXG4gKiByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGludGVycG9sYXRlcyBhbG9uZyB0aGF0IGN1cnZlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBwMXggY29udHJvbCBwb2ludCAxIHggY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHAxeSBjb250cm9sIHBvaW50IDEgeSBjb29yZGluYXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcDJ4IGNvbnRyb2wgcG9pbnQgMiB4IGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBwMnkgY29udHJvbCBwb2ludCAyIHkgY29vcmRpbmF0ZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBpbnRlcnBvbGF0b3I6IHJlY2VpdmVzIG51bWJlciB2YWx1ZSwgcmV0dXJuc1xuICogbnVtYmVyIHZhbHVlLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5iZXppZXIgPSBmdW5jdGlvbihwMXgsIHAxeSwgcDJ4LCBwMnkpIHtcbiAgICB2YXIgYmV6aWVyID0gbmV3IFVuaXRCZXppZXIocDF4LCBwMXksIHAyeCwgcDJ5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gYmV6aWVyLnNvbHZlKHQpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIEEgZGVmYXVsdCBiZXppZXItY3VydmUgcG93ZXJlZCBlYXNpbmcgZnVuY3Rpb24gd2l0aFxuICogY29udHJvbCBwb2ludHMgKDAuMjUsIDAuMSkgYW5kICgwLjI1LCAxKVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBvdXRwdXRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZWFzZSA9IGV4cG9ydHMuYmV6aWVyKDAuMjUsIDAuMSwgMC4yNSwgMSk7XG5cbi8qKlxuICogY29uc3RyYWluIG4gdG8gdGhlIGdpdmVuIHJhbmdlIHZpYSBtaW4gKyBtYXhcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbiB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiB0aGUgbWluaW11bSB2YWx1ZSB0byBiZSByZXR1cm5lZFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCB0aGUgbWF4aW11bSB2YWx1ZSB0byBiZSByZXR1cm5lZFxuICogQHJldHVybnMge251bWJlcn0gdGhlIGNsYW1wZWQgdmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuY2xhbXAgPSBmdW5jdGlvbiAobiwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIG4pKTtcbn07XG5cbi8qXG4gKiBjb25zdHJhaW4gbiB0byB0aGUgZ2l2ZW4gcmFuZ2UsIGV4Y2x1ZGluZyB0aGUgbWluaW11bSwgdmlhIG1vZHVsYXIgYXJpdGhtZXRpY1xuICogQHBhcmFtIHtudW1iZXJ9IG4gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gdGhlIG1pbmltdW0gdmFsdWUgdG8gYmUgcmV0dXJuZWQsIGV4Y2x1c2l2ZVxuICogQHBhcmFtIHtudW1iZXJ9IG1heCB0aGUgbWF4aW11bSB2YWx1ZSB0byBiZSByZXR1cm5lZCwgaW5jbHVzaXZlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBjb25zdHJhaW5lZCBudW1iZXJcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMud3JhcCA9IGZ1bmN0aW9uIChuLCBtaW4sIG1heCkge1xuICAgIHZhciBkID0gbWF4IC0gbWluO1xuICAgIHZhciB3ID0gKChuIC0gbWluKSAlIGQgKyBkKSAlIGQgKyBtaW47XG4gICAgcmV0dXJuICh3ID09PSBtaW4pID8gbWF4IDogdztcbn07XG5cbi8qXG4gKiByZXR1cm4gdGhlIGZpcnN0IG5vbi1udWxsIGFuZCBub24tdW5kZWZpbmVkIGFyZ3VtZW50IHRvIHRoaXMgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7Kn0gYXJndW1lbnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuY29hbGVzY2UgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpZiAoYXJnICE9PSBudWxsICYmIGFyZyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG59O1xuXG4vKlxuICogQ2FsbCBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gb24gYW4gYXJyYXkgb2YgYXJndW1lbnRzLFxuICogY2FsbGluZyBgY2FsbGJhY2tgIHdpdGggdGhlIGNvbXBsZXRlZCByZXN1bHRzIG9mIGFsbCBjYWxscy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhcnJheSBpbnB1dCB0byBlYWNoIGNhbGwgb2YgdGhlIGFzeW5jIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gYW4gYXN5bmMgZnVuY3Rpb24gd2l0aCBzaWduYXR1cmUgKGRhdGEsIGNhbGxiYWNrKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBjYWxsYmFjayBydW4gYWZ0ZXIgYWxsIGFzeW5jIHdvcmsgaXMgZG9uZS5cbiAqIGNhbGxlZCB3aXRoIGFuIGFycmF5LCBjb250YWluaW5nIHRoZSByZXN1bHRzIG9mIGVhY2ggYXN5bmMgY2FsbC5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmFzeW5jQWxsID0gZnVuY3Rpb24gKGFycmF5LCBmbiwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWFycmF5Lmxlbmd0aCkgeyByZXR1cm4gY2FsbGJhY2sobnVsbCwgW10pOyB9XG4gICAgdmFyIHJlbWFpbmluZyA9IGFycmF5Lmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShhcnJheS5sZW5ndGgpO1xuICAgIHZhciBlcnJvciA9IG51bGw7XG4gICAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICBmbihpdGVtLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGlmICgtLXJlbWFpbmluZyA9PT0gMCkgY2FsbGJhY2soZXJyb3IsIHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbi8qXG4gKiBDb21wdXRlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGtleXMgaW4gb25lIG9iamVjdCBhbmQgdGhlIGtleXNcbiAqIGluIGFub3RoZXIgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlclxuICogQHJldHVybnMge0FycmF5PHN0cmluZz59IGtleXMgZGlmZmVyZW5jZVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5rZXlzRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChvYmosIG90aGVyKSB7XG4gICAgdmFyIGRpZmZlcmVuY2UgPSBbXTtcbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgICBpZiAoIShpIGluIG90aGVyKSkge1xuICAgICAgICAgICAgZGlmZmVyZW5jZS5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWZmZXJlbmNlO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIGRlc3RpbmF0aW9uIG9iamVjdCBhbmQgb3B0aW9uYWxseSBtYW55IHNvdXJjZSBvYmplY3RzLFxuICogY29weSBhbGwgcHJvcGVydGllcyBmcm9tIHRoZSBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZSBkZXN0aW5hdGlvbi5cbiAqIFRoZSBsYXN0IHNvdXJjZSBvYmplY3QgZ2l2ZW4gb3ZlcnJpZGVzIHByb3BlcnRpZXMgZnJvbSBwcmV2aW91c1xuICogc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBkZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIHNvdXJjZXMgZnJvbSB3aGljaCBwcm9wZXJ0aWVzIGFyZSBwdWxsZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3JjID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBmb3IgKHZhciBrIGluIHNyYykge1xuICAgICAgICAgICAgZGVzdFtrXSA9IHNyY1trXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn07XG5cbi8qKlxuICogRXh0ZW5kIGEgZGVzdGluYXRpb24gb2JqZWN0IHdpdGggYWxsIHByb3BlcnRpZXMgb2YgdGhlIHNyYyBvYmplY3QsXG4gKiB1c2luZyBkZWZpbmVQcm9wZXJ0eSBpbnN0ZWFkIG9mIHNpbXBsZSBhc3NpZ25tZW50LlxuICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZXh0ZW5kQWxsID0gZnVuY3Rpb24gKGRlc3QsIHNyYykge1xuICAgIGZvciAodmFyIGkgaW4gc3JjKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXN0LCBpLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNyYywgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbn07XG5cbi8qKlxuICogRXh0ZW5kIGEgcGFyZW50J3MgcHJvdG90eXBlIHdpdGggYWxsIHByb3BlcnRpZXMgaW4gYSBwcm9wZXJ0aWVzXG4gKiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5pbmhlcml0ID0gZnVuY3Rpb24gKHBhcmVudCwgcHJvcHMpIHtcbiAgICB2YXIgcGFyZW50UHJvdG8gPSB0eXBlb2YgcGFyZW50ID09PSAnZnVuY3Rpb24nID8gcGFyZW50LnByb3RvdHlwZSA6IHBhcmVudCxcbiAgICAgICAgcHJvdG8gPSBPYmplY3QuY3JlYXRlKHBhcmVudFByb3RvKTtcbiAgICBleHBvcnRzLmV4dGVuZEFsbChwcm90bywgcHJvcHMpO1xuICAgIHJldHVybiBwcm90bztcbn07XG5cbi8qKlxuICogR2l2ZW4gYW4gb2JqZWN0IGFuZCBhIG51bWJlciBvZiBwcm9wZXJ0aWVzIGFzIHN0cmluZ3MsIHJldHVybiB2ZXJzaW9uXG4gKiBvZiB0aGF0IG9iamVjdCB3aXRoIG9ubHkgdGhvc2UgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3JjIHRoZSBvYmplY3RcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gcHJvcGVydGllcyBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBjaG9zZW5cbiAqIHRvIGFwcGVhciBvbiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCB3aXRoIGxpbWl0ZWQgcHJvcGVydGllcy5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZm9vID0geyBuYW1lOiAnQ2hhcmxpZScsIGFnZTogMTAgfTtcbiAqIHZhciBqdXN0TmFtZSA9IHBpY2soZm9vLCBbJ25hbWUnXSk7XG4gKiAvLyBqdXN0TmFtZSA9IHsgbmFtZTogJ0NoYXJsaWUnIH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMucGljayA9IGZ1bmN0aW9uIChzcmMsIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgaWYgKGsgaW4gc3JjKSB7XG4gICAgICAgICAgICByZXN1bHRba10gPSBzcmNba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBpZCA9IDE7XG5cbi8qKlxuICogUmV0dXJuIGEgdW5pcXVlIG51bWVyaWMgaWQsIHN0YXJ0aW5nIGF0IDEgYW5kIGluY3JlbWVudGluZyB3aXRoXG4gKiBlYWNoIGNhbGwuXG4gKlxuICogQHJldHVybnMge251bWJlcn0gdW5pcXVlIG51bWVyaWMgaWQuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLnVuaXF1ZUlkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpZCsrO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSB2ZXJzaW9uIG9mIGBmbmAgdGhhdCBpcyBvbmx5IGNhbGxlZCBgdGltZWAgbWlsbGlzZWNvbmRzXG4gKiBhZnRlciBpdHMgbGFzdCBpbnZvY2F0aW9uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdGhlIGZ1bmN0aW9uIHRvIGJlIGRlYm91bmNlZFxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgbWlsbHNlY29uZHMgYWZ0ZXIgd2hpY2ggdGhlIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZGVib3VuY2UgPSBmdW5jdGlvbihmbiwgdGltZSkge1xuICAgIHZhciB0aW1lciwgYXJncztcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSwgdGltZSk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2YgbWVtYmVyIGZ1bmN0aW9uIG5hbWVzIGFzIHN0cmluZ3MsIHJlcGxhY2UgYWxsIG9mIHRoZW1cbiAqIHdpdGggYm91bmQgdmVyc2lvbnMgdGhhdCB3aWxsIGFsd2F5cyByZWZlciB0byBgY29udGV4dGAgYXMgYHRoaXNgLiBUaGlzXG4gKiBpcyB1c2VmdWwgZm9yIGNsYXNzZXMgd2hlcmUgb3RoZXJ3aXNlIGV2ZW50IGJpbmRpbmdzIHdvdWxkIHJlYXNzaWduXG4gKiBgdGhpc2AgdG8gdGhlIGV2ZW50ZWQgb2JqZWN0IG9yIHNvbWUgb3RoZXIgdmFsdWU6IHRoaXMgbGV0cyB5b3UgZW5zdXJlXG4gKiB0aGUgYHRoaXNgIHZhbHVlIGFsd2F5cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGZucyBsaXN0IG9mIG1lbWJlciBmdW5jdGlvbiBuYW1lc1xuICogQHBhcmFtIHsqfSBjb250ZXh0IHRoZSBjb250ZXh0IHZhbHVlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfSBjaGFuZ2VzIGZ1bmN0aW9ucyBpbi1wbGFjZVxuICogQGV4YW1wbGVcbiAqIGZ1bmN0aW9uIE15Q2xhc3MoKSB7XG4gKiAgIGJpbmRBbGwoWydvbnRpbWVyJ10sIHRoaXMpO1xuICogICB0aGlzLm5hbWUgPSAnVG9tJztcbiAqIH1cbiAqIE15Q2xhc3MucHJvdG90eXBlLm9udGltZXIgPSBmdW5jdGlvbigpIHtcbiAqICAgYWxlcnQodGhpcy5uYW1lKTtcbiAqIH07XG4gKiB2YXIgbXlDbGFzcyA9IG5ldyBNeUNsYXNzKCk7XG4gKiBzZXRUaW1lb3V0KG15Q2xhc3Mub250aW1lciwgMTAwKTtcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuYmluZEFsbCA9IGZ1bmN0aW9uKGZucywgY29udGV4dCkge1xuICAgIGZucy5mb3JFYWNoKGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIGlmICghY29udGV4dFtmbl0pIHsgcmV0dXJuOyB9XG4gICAgICAgIGNvbnRleHRbZm5dID0gY29udGV4dFtmbl0uYmluZChjb250ZXh0KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBjbGFzcywgYmluZCBhbGwgb2YgdGhlIG1ldGhvZHMgdGhhdCBsb29rIGxpa2UgaGFuZGxlcnM6IHRoYXRcbiAqIGJlZ2luIHdpdGggX29uLCBhbmQgYmluZCB0aGVtIHRvIHRoZSBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBhbiBvYmplY3Qgd2l0aCBtZXRob2RzXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmJpbmRIYW5kbGVycyA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpIGluIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0W2ldID09PSAnZnVuY3Rpb24nICYmIGkuaW5kZXhPZignX29uJykgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRleHRbaV0gPSBjb250ZXh0W2ldLmJpbmQoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCB0aGUgJ29wdGlvbnMnIHByb3BlcnR5IG9uIGBvYmpgIHdpdGggcHJvcGVydGllc1xuICogZnJvbSB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50LiBQcm9wZXJ0aWVzIGluIHRoZSBgb3B0aW9uc2BcbiAqIG9iamVjdCB3aWxsIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBkZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9iamVjdCBvZiBvdmVycmlkZSBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXJpdmVkIG9wdGlvbnMgb2JqZWN0LlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5zZXRPcHRpb25zID0gZnVuY3Rpb24ob2JqLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoJ29wdGlvbnMnKSkge1xuICAgICAgICBvYmoub3B0aW9ucyA9IG9iai5vcHRpb25zID8gT2JqZWN0LmNyZWF0ZShvYmoub3B0aW9ucykgOiB7fTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICAgIG9iai5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iai5vcHRpb25zO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIGxpc3Qgb2YgY29vcmRpbmF0ZXMsIGdldCB0aGVpciBjZW50ZXIgYXMgYSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtBcnJheTxDb29yZGluYXRlPn0gY29vcmRzXG4gKiBAcmV0dXJucyB7Q29vcmRpbmF0ZX0gY2VudGVycG9pbnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZ2V0Q29vcmRpbmF0ZXNDZW50ZXIgPSBmdW5jdGlvbihjb29yZHMpIHtcbiAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFggPSAtSW5maW5pdHk7XG4gICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgY29vcmRzW2ldLmNvbHVtbik7XG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBjb29yZHNbaV0ucm93KTtcbiAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIGNvb3Jkc1tpXS5jb2x1bW4pO1xuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgY29vcmRzW2ldLnJvdyk7XG4gICAgfVxuXG4gICAgdmFyIGR4ID0gbWF4WCAtIG1pblg7XG4gICAgdmFyIGR5ID0gbWF4WSAtIG1pblk7XG4gICAgdmFyIGRNYXggPSBNYXRoLm1heChkeCwgZHkpO1xuICAgIHJldHVybiBuZXcgQ29vcmRpbmF0ZSgobWluWCArIG1heFgpIC8gMiwgKG1pblkgKyBtYXhZKSAvIDIsIDApXG4gICAgICAgIC56b29tVG8oTWF0aC5mbG9vcigtTWF0aC5sb2coZE1heCkgLyBNYXRoLkxOMikpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSBzdHJpbmcgZW5kcyB3aXRoIGEgcGFydGljdWxhciBzdWJzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdWZmaXhcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5lbmRzV2l0aCA9IGZ1bmN0aW9uKHN0cmluZywgc3VmZml4KSB7XG4gICAgcmV0dXJuIHN0cmluZy5pbmRleE9mKHN1ZmZpeCwgc3RyaW5nLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpICE9PSAtMTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoIGEgcGFydGljdWxhciBzdWJzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5zdGFydHNXaXRoID0gZnVuY3Rpb24oc3RyaW5nLCBwcmVmaXgpIHtcbiAgICByZXR1cm4gc3RyaW5nLmluZGV4T2YocHJlZml4KSA9PT0gMDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIG9iamVjdCBieSBtYXBwaW5nIGFsbCB0aGUgdmFsdWVzIG9mIGFuIGV4aXN0aW5nIG9iamVjdCB3aGlsZVxuICogcHJlc2VydmluZyB0aGVpciBrZXlzLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMubWFwT2JqZWN0ID0gZnVuY3Rpb24oaW5wdXQsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIG91dHB1dCA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBpbnB1dCkge1xuICAgICAgICBvdXRwdXRba2V5XSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCB8fCB0aGlzLCBpbnB1dFtrZXldLCBrZXksIGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIG9iamVjdCBieSBmaWx0ZXJpbmcgb3V0IHZhbHVlcyBvZiBhbiBleGlzdGluZyBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmZpbHRlck9iamVjdCA9IGZ1bmN0aW9uKGlucHV0LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciBvdXRwdXQgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCB8fCB0aGlzLCBpbnB1dFtrZXldLCBrZXksIGlucHV0KSkge1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBpbnB1dFtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIERlZXBseSBjb21wYXJlcyB0d28gb2JqZWN0IGxpdGVyYWxzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iajFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYikgfHwgYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhICE9PSBudWxsICYmIGIgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIGIgPT09ICdvYmplY3QnKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYSkge1xuICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhID09PSBiO1xufTtcblxuLyoqXG4gKiBEZWVwbHkgY2xvbmVzIHR3byBvYmplY3RzLlxuICogQHBhcmFtIHtPYmplY3R9IG9iajFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuY2xvbmUgPSBmdW5jdGlvbiBkZWVwRXF1YWwoaW5wdXQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0Lm1hcChleHBvcnRzLmNsb25lKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMubWFwT2JqZWN0KGlucHV0LCBleHBvcnRzLmNsb25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0d28gYXJyYXlzIGhhdmUgYXQgbGVhc3Qgb25lIGNvbW1vbiBlbGVtZW50LlxuICogQHBhcmFtIHtBcnJheX0gYVxuICogQHBhcmFtIHtBcnJheX0gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmFycmF5c0ludGVyc2VjdCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBmb3IgKHZhciBsID0gMDsgbCA8IGEubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgaWYgKGIuaW5kZXhPZihhW2xdKSA+PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIHdhcm5PbmNlSGlzdG9yeSA9IHt9O1xuZXhwb3J0cy53YXJuT25jZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICBpZiAoIXdhcm5PbmNlSGlzdG9yeVttZXNzYWdlXSkge1xuICAgICAgICAvLyBjb25zb2xlIGlzbid0IGRlZmluZWQgaW4gc29tZSBXZWJXb3JrZXJzLCBzZWUgIzI1NThcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgIHdhcm5PbmNlSGlzdG9yeVttZXNzYWdlXSA9IHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBJbmRpY2F0ZXMgaWYgdGhlIHByb3ZpZGVkIFBvaW50cyBhcmUgaW4gYSBjb3VudGVyIGNsb2Nrd2lzZSAodHJ1ZSkgb3IgY2xvY2t3aXNlIChmYWxzZSkgb3JkZXJcbiAqXG4gKiBAcGFyYW0ge1BvaW50fSBhXG4gKiBAcGFyYW0ge1BvaW50fSBiXG4gKiBAcGFyYW0ge1BvaW50fSBjXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgZm9yIGEgY291bnRlciBjbG9ja3dpc2Ugc2V0IG9mIHBvaW50c1xuICovXG4vLyBodHRwOi8vYnJ5Y2Vib2UuY29tLzIwMDYvMTAvMjMvbGluZS1zZWdtZW50LWludGVyc2VjdGlvbi1hbGdvcml0aG0vXG5leHBvcnRzLmlzQ291bnRlckNsb2Nrd2lzZSA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gKGMueSAtIGEueSkgKiAoYi54IC0gYS54KSA+IChiLnkgLSBhLnkpICogKGMueCAtIGEueCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHNpZ25lZCBhcmVhIGZvciB0aGUgcG9seWdvbiByaW5nLiAgUG9zdGl2ZSBhcmVhcyBhcmUgZXh0ZXJpb3IgcmluZ3MgYW5kXG4gKiBoYXZlIGEgY2xvY2t3aXNlIHdpbmRpbmcuICBOZWdhdGl2ZSBhcmVhcyBhcmUgaW50ZXJpb3IgcmluZ3MgYW5kIGhhdmUgYSBjb3VudGVyIGNsb2Nrd2lzZVxuICogb3JkZXJpbmcuXG4gKlxuICogQHBhcmFtIHtBcnJheTxQb2ludD59IHJpbmcgLSBFeHRlcmlvciBvciBpbnRlcmlvciByaW5nXG4gKlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0cy5jYWxjdWxhdGVTaWduZWRBcmVhID0gZnVuY3Rpb24ocmluZykge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByaW5nLmxlbmd0aCwgaiA9IGxlbiAtIDEsIHAxLCBwMjsgaSA8IGxlbjsgaiA9IGkrKykge1xuICAgICAgICBwMSA9IHJpbmdbaV07XG4gICAgICAgIHAyID0gcmluZ1tqXTtcbiAgICAgICAgc3VtICs9IChwMi54IC0gcDEueCkgKiAocDEueSArIHAyLnkpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufTtcblxuLyoqXG4gKiBEZXRlY3RzIGNsb3NlZCBwb2x5Z29ucywgZmlyc3QgKyBsYXN0IHBvaW50IGFyZSBlcXVhbFxuICogQHBhcmFtIHtBcnJheTxQb2ludD59IHBvaW50cyBhcnJheSBvZiBwb2ludHNcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBwb2ludHMgYXJlIGEgY2xvc2VkIHBvbHlnb25cbiAqL1xuZXhwb3J0cy5pc0Nsb3NlZFBvbHlnb24gPSBmdW5jdGlvbihwb2ludHMpIHtcbiAgICAvLyBJZiBpdCBpcyAyIHBvaW50cyB0aGF0IGFyZSB0aGUgc2FtZSB0aGVuIGl0IGlzIGEgcG9pbnRcbiAgICAvLyBJZiBpdCBpcyAzIHBvaW50cyB3aXRoIHN0YXJ0IGFuZCBlbmQgdGhlIHNhbWUgdGhlbiBpdCBpcyBhIGxpbmVcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBwMSA9IHBvaW50c1swXTtcbiAgICB2YXIgcDIgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKE1hdGguYWJzKHAxLnggLSBwMi54KSA+IDAgfHxcbiAgICAgICAgTWF0aC5hYnMocDEueSAtIHAyLnkpID4gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gcG9seWdvbiBzaW1wbGlmaWNhdGlvbiBjYW4gcHJvZHVjZSBwb2x5Z29ucyB3aXRoIHplcm8gYXJlYSBhbmQgbW9yZSB0aGFuIDMgcG9pbnRzXG4gICAgcmV0dXJuIChNYXRoLmFicyhleHBvcnRzLmNhbGN1bGF0ZVNpZ25lZEFyZWEocG9pbnRzKSkgPiAwLjAxKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gRmVhdHVyZTtcblxuZnVuY3Rpb24gRmVhdHVyZSh2ZWN0b3JUaWxlRmVhdHVyZSwgeiwgeCwgeSkge1xuICAgIHRoaXMuX3ZlY3RvclRpbGVGZWF0dXJlID0gdmVjdG9yVGlsZUZlYXR1cmU7XG4gICAgdmVjdG9yVGlsZUZlYXR1cmUuX3ogPSB6O1xuICAgIHZlY3RvclRpbGVGZWF0dXJlLl94ID0geDtcbiAgICB2ZWN0b3JUaWxlRmVhdHVyZS5feSA9IHk7XG5cbiAgICB0aGlzLnByb3BlcnRpZXMgPSB2ZWN0b3JUaWxlRmVhdHVyZS5wcm9wZXJ0aWVzO1xuXG4gICAgaWYgKHZlY3RvclRpbGVGZWF0dXJlLmlkICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5pZCA9IHZlY3RvclRpbGVGZWF0dXJlLmlkO1xuICAgIH1cbn1cblxuRmVhdHVyZS5wcm90b3R5cGUgPSB7XG4gICAgdHlwZTogXCJGZWF0dXJlXCIsXG5cbiAgICBnZXQgZ2VvbWV0cnkoKSB7XG4gICAgICAgIGlmICh0aGlzLl9nZW9tZXRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9nZW9tZXRyeSA9IHRoaXMuX3ZlY3RvclRpbGVGZWF0dXJlLnRvR2VvSlNPTihcbiAgICAgICAgICAgICAgICB0aGlzLl92ZWN0b3JUaWxlRmVhdHVyZS5feCxcbiAgICAgICAgICAgICAgICB0aGlzLl92ZWN0b3JUaWxlRmVhdHVyZS5feSxcbiAgICAgICAgICAgICAgICB0aGlzLl92ZWN0b3JUaWxlRmVhdHVyZS5feikuZ2VvbWV0cnk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dlb21ldHJ5O1xuICAgIH0sXG5cbiAgICBzZXQgZ2VvbWV0cnkoZykge1xuICAgICAgICB0aGlzLl9nZW9tZXRyeSA9IGc7XG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBqc29uID0ge307XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcykge1xuICAgICAgICAgICAgaWYgKGkgPT09ICdfZ2VvbWV0cnknIHx8IGkgPT09ICdfdmVjdG9yVGlsZUZlYXR1cmUnIHx8IGkgPT09ICd0b0pTT04nKSBjb250aW51ZTtcbiAgICAgICAgICAgIGpzb25baV0gPSB0aGlzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbn07XG4iLCIvLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gd2hlbiB1c2VkIGluIG5vZGUsIHRoaXMgd2lsbCBhY3R1YWxseSBsb2FkIHRoZSB1dGlsIG1vZHVsZSB3ZSBkZXBlbmQgb25cbi8vIHZlcnN1cyBsb2FkaW5nIHRoZSBidWlsdGluIHV0aWwgbW9kdWxlIGFzIGhhcHBlbnMgb3RoZXJ3aXNlXG4vLyB0aGlzIGlzIGEgYnVnIGluIG5vZGUgbW9kdWxlIGxvYWRpbmcgYXMgZmFyIGFzIEkgYW0gY29uY2VybmVkXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG5cbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gc3RhY2tTdGFydEZ1bmN0aW9uLm5hbWU7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gIGlmICh1dGlsLmlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlO1xuICB9XG4gIGlmICh1dGlsLmlzTnVtYmVyKHZhbHVlKSAmJiAhaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbih2YWx1ZSkgfHwgdXRpbC5pc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocykpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeShzZWxmLmFjdHVhbCwgcmVwbGFjZXIpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoc2VsZi5leHBlY3RlZCwgcmVwbGFjZXIpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGFjdHVhbCkgJiYgdXRpbC5pc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICBpZiAoYWN0dWFsLmxlbmd0aCAhPSBleHBlY3RlZC5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0dWFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWN0dWFsW2ldICE9PSBleHBlY3RlZFtpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghdXRpbC5pc09iamVjdChhY3R1YWwpICYmICF1dGlsLmlzT2JqZWN0KGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYikge1xuICBpZiAodXRpbC5pc051bGxPclVuZGVmaW5lZChhKSB8fCB1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuICBpZiAodXRpbC5pc1ByaW1pdGl2ZShhKSB8fCB1dGlsLmlzUHJpbWl0aXZlKGIpKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbiAgdmFyIGFJc0FyZ3MgPSBpc0FyZ3VtZW50cyhhKSxcbiAgICAgIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcbiAgaWYgKChhSXNBcmdzICYmICFiSXNBcmdzKSB8fCAoIWFJc0FyZ3MgJiYgYklzQXJncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYUlzQXJncykge1xuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYik7XG4gIH1cbiAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgIGtiID0gb2JqZWN0S2V5cyhiKSxcbiAgICAgIGtleSwgaTtcbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHV0aWwuaXNTdHJpbmcoZXhwZWN0ZWQpKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGFjdHVhbCA9IGU7XG4gIH1cblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICghc2hvdWxkVGhyb3cgJiYgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW3RydWVdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFtmYWxzZV0uY29uY2F0KHBTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHt0aHJvdyBlcnI7fX07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH1cbn0gKCkpXG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBjYWNoZWRTZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiLy8gKGMpIERlYW4gTWNOYW1lZSA8ZGVhbkBnbWFpbC5jb20+LCAyMDEyLlxuLy9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWFubS9jc3MtY29sb3ItcGFyc2VyLWpzXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbi8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1Ncbi8vIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci9cbnZhciBrQ1NTQ29sb3JUYWJsZSA9IHtcbiAgXCJ0cmFuc3BhcmVudFwiOiBbMCwwLDAsMF0sIFwiYWxpY2VibHVlXCI6IFsyNDAsMjQ4LDI1NSwxXSxcbiAgXCJhbnRpcXVld2hpdGVcIjogWzI1MCwyMzUsMjE1LDFdLCBcImFxdWFcIjogWzAsMjU1LDI1NSwxXSxcbiAgXCJhcXVhbWFyaW5lXCI6IFsxMjcsMjU1LDIxMiwxXSwgXCJhenVyZVwiOiBbMjQwLDI1NSwyNTUsMV0sXG4gIFwiYmVpZ2VcIjogWzI0NSwyNDUsMjIwLDFdLCBcImJpc3F1ZVwiOiBbMjU1LDIyOCwxOTYsMV0sXG4gIFwiYmxhY2tcIjogWzAsMCwwLDFdLCBcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsMjM1LDIwNSwxXSxcbiAgXCJibHVlXCI6IFswLDAsMjU1LDFdLCBcImJsdWV2aW9sZXRcIjogWzEzOCw0MywyMjYsMV0sXG4gIFwiYnJvd25cIjogWzE2NSw0Miw0MiwxXSwgXCJidXJseXdvb2RcIjogWzIyMiwxODQsMTM1LDFdLFxuICBcImNhZGV0Ymx1ZVwiOiBbOTUsMTU4LDE2MCwxXSwgXCJjaGFydHJldXNlXCI6IFsxMjcsMjU1LDAsMV0sXG4gIFwiY2hvY29sYXRlXCI6IFsyMTAsMTA1LDMwLDFdLCBcImNvcmFsXCI6IFsyNTUsMTI3LDgwLDFdLFxuICBcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsMTQ5LDIzNywxXSwgXCJjb3Juc2lsa1wiOiBbMjU1LDI0OCwyMjAsMV0sXG4gIFwiY3JpbXNvblwiOiBbMjIwLDIwLDYwLDFdLCBcImN5YW5cIjogWzAsMjU1LDI1NSwxXSxcbiAgXCJkYXJrYmx1ZVwiOiBbMCwwLDEzOSwxXSwgXCJkYXJrY3lhblwiOiBbMCwxMzksMTM5LDFdLFxuICBcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwxMzQsMTEsMV0sIFwiZGFya2dyYXlcIjogWzE2OSwxNjksMTY5LDFdLFxuICBcImRhcmtncmVlblwiOiBbMCwxMDAsMCwxXSwgXCJkYXJrZ3JleVwiOiBbMTY5LDE2OSwxNjksMV0sXG4gIFwiZGFya2toYWtpXCI6IFsxODksMTgzLDEwNywxXSwgXCJkYXJrbWFnZW50YVwiOiBbMTM5LDAsMTM5LDFdLFxuICBcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwxMDcsNDcsMV0sIFwiZGFya29yYW5nZVwiOiBbMjU1LDE0MCwwLDFdLFxuICBcImRhcmtvcmNoaWRcIjogWzE1Myw1MCwyMDQsMV0sIFwiZGFya3JlZFwiOiBbMTM5LDAsMCwxXSxcbiAgXCJkYXJrc2FsbW9uXCI6IFsyMzMsMTUwLDEyMiwxXSwgXCJkYXJrc2VhZ3JlZW5cIjogWzE0MywxODgsMTQzLDFdLFxuICBcImRhcmtzbGF0ZWJsdWVcIjogWzcyLDYxLDEzOSwxXSwgXCJkYXJrc2xhdGVncmF5XCI6IFs0Nyw3OSw3OSwxXSxcbiAgXCJkYXJrc2xhdGVncmV5XCI6IFs0Nyw3OSw3OSwxXSwgXCJkYXJrdHVycXVvaXNlXCI6IFswLDIwNiwyMDksMV0sXG4gIFwiZGFya3Zpb2xldFwiOiBbMTQ4LDAsMjExLDFdLCBcImRlZXBwaW5rXCI6IFsyNTUsMjAsMTQ3LDFdLFxuICBcImRlZXBza3libHVlXCI6IFswLDE5MSwyNTUsMV0sIFwiZGltZ3JheVwiOiBbMTA1LDEwNSwxMDUsMV0sXG4gIFwiZGltZ3JleVwiOiBbMTA1LDEwNSwxMDUsMV0sIFwiZG9kZ2VyYmx1ZVwiOiBbMzAsMTQ0LDI1NSwxXSxcbiAgXCJmaXJlYnJpY2tcIjogWzE3OCwzNCwzNCwxXSwgXCJmbG9yYWx3aGl0ZVwiOiBbMjU1LDI1MCwyNDAsMV0sXG4gIFwiZm9yZXN0Z3JlZW5cIjogWzM0LDEzOSwzNCwxXSwgXCJmdWNoc2lhXCI6IFsyNTUsMCwyNTUsMV0sXG4gIFwiZ2FpbnNib3JvXCI6IFsyMjAsMjIwLDIyMCwxXSwgXCJnaG9zdHdoaXRlXCI6IFsyNDgsMjQ4LDI1NSwxXSxcbiAgXCJnb2xkXCI6IFsyNTUsMjE1LDAsMV0sIFwiZ29sZGVucm9kXCI6IFsyMTgsMTY1LDMyLDFdLFxuICBcImdyYXlcIjogWzEyOCwxMjgsMTI4LDFdLCBcImdyZWVuXCI6IFswLDEyOCwwLDFdLFxuICBcImdyZWVueWVsbG93XCI6IFsxNzMsMjU1LDQ3LDFdLCBcImdyZXlcIjogWzEyOCwxMjgsMTI4LDFdLFxuICBcImhvbmV5ZGV3XCI6IFsyNDAsMjU1LDI0MCwxXSwgXCJob3RwaW5rXCI6IFsyNTUsMTA1LDE4MCwxXSxcbiAgXCJpbmRpYW5yZWRcIjogWzIwNSw5Miw5MiwxXSwgXCJpbmRpZ29cIjogWzc1LDAsMTMwLDFdLFxuICBcIml2b3J5XCI6IFsyNTUsMjU1LDI0MCwxXSwgXCJraGFraVwiOiBbMjQwLDIzMCwxNDAsMV0sXG4gIFwibGF2ZW5kZXJcIjogWzIzMCwyMzAsMjUwLDFdLCBcImxhdmVuZGVyYmx1c2hcIjogWzI1NSwyNDAsMjQ1LDFdLFxuICBcImxhd25ncmVlblwiOiBbMTI0LDI1MiwwLDFdLCBcImxlbW9uY2hpZmZvblwiOiBbMjU1LDI1MCwyMDUsMV0sXG4gIFwibGlnaHRibHVlXCI6IFsxNzMsMjE2LDIzMCwxXSwgXCJsaWdodGNvcmFsXCI6IFsyNDAsMTI4LDEyOCwxXSxcbiAgXCJsaWdodGN5YW5cIjogWzIyNCwyNTUsMjU1LDFdLCBcImxpZ2h0Z29sZGVucm9keWVsbG93XCI6IFsyNTAsMjUwLDIxMCwxXSxcbiAgXCJsaWdodGdyYXlcIjogWzIxMSwyMTEsMjExLDFdLCBcImxpZ2h0Z3JlZW5cIjogWzE0NCwyMzgsMTQ0LDFdLFxuICBcImxpZ2h0Z3JleVwiOiBbMjExLDIxMSwyMTEsMV0sIFwibGlnaHRwaW5rXCI6IFsyNTUsMTgyLDE5MywxXSxcbiAgXCJsaWdodHNhbG1vblwiOiBbMjU1LDE2MCwxMjIsMV0sIFwibGlnaHRzZWFncmVlblwiOiBbMzIsMTc4LDE3MCwxXSxcbiAgXCJsaWdodHNreWJsdWVcIjogWzEzNSwyMDYsMjUwLDFdLCBcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksMTM2LDE1MywxXSxcbiAgXCJsaWdodHNsYXRlZ3JleVwiOiBbMTE5LDEzNiwxNTMsMV0sIFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwxOTYsMjIyLDFdLFxuICBcImxpZ2h0eWVsbG93XCI6IFsyNTUsMjU1LDIyNCwxXSwgXCJsaW1lXCI6IFswLDI1NSwwLDFdLFxuICBcImxpbWVncmVlblwiOiBbNTAsMjA1LDUwLDFdLCBcImxpbmVuXCI6IFsyNTAsMjQwLDIzMCwxXSxcbiAgXCJtYWdlbnRhXCI6IFsyNTUsMCwyNTUsMV0sIFwibWFyb29uXCI6IFsxMjgsMCwwLDFdLFxuICBcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwyMDUsMTcwLDFdLCBcIm1lZGl1bWJsdWVcIjogWzAsMCwyMDUsMV0sXG4gIFwibWVkaXVtb3JjaGlkXCI6IFsxODYsODUsMjExLDFdLCBcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LDExMiwyMTksMV0sXG4gIFwibWVkaXVtc2VhZ3JlZW5cIjogWzYwLDE3OSwxMTMsMV0sIFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsMTA0LDIzOCwxXSxcbiAgXCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwyNTAsMTU0LDFdLCBcIm1lZGl1bXR1cnF1b2lzZVwiOiBbNzIsMjA5LDIwNCwxXSxcbiAgXCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwyMSwxMzMsMV0sIFwibWlkbmlnaHRibHVlXCI6IFsyNSwyNSwxMTIsMV0sXG4gIFwibWludGNyZWFtXCI6IFsyNDUsMjU1LDI1MCwxXSwgXCJtaXN0eXJvc2VcIjogWzI1NSwyMjgsMjI1LDFdLFxuICBcIm1vY2Nhc2luXCI6IFsyNTUsMjI4LDE4MSwxXSwgXCJuYXZham93aGl0ZVwiOiBbMjU1LDIyMiwxNzMsMV0sXG4gIFwibmF2eVwiOiBbMCwwLDEyOCwxXSwgXCJvbGRsYWNlXCI6IFsyNTMsMjQ1LDIzMCwxXSxcbiAgXCJvbGl2ZVwiOiBbMTI4LDEyOCwwLDFdLCBcIm9saXZlZHJhYlwiOiBbMTA3LDE0MiwzNSwxXSxcbiAgXCJvcmFuZ2VcIjogWzI1NSwxNjUsMCwxXSwgXCJvcmFuZ2VyZWRcIjogWzI1NSw2OSwwLDFdLFxuICBcIm9yY2hpZFwiOiBbMjE4LDExMiwyMTQsMV0sIFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LDIzMiwxNzAsMV0sXG4gIFwicGFsZWdyZWVuXCI6IFsxNTIsMjUxLDE1MiwxXSwgXCJwYWxldHVycXVvaXNlXCI6IFsxNzUsMjM4LDIzOCwxXSxcbiAgXCJwYWxldmlvbGV0cmVkXCI6IFsyMTksMTEyLDE0NywxXSwgXCJwYXBheWF3aGlwXCI6IFsyNTUsMjM5LDIxMywxXSxcbiAgXCJwZWFjaHB1ZmZcIjogWzI1NSwyMTgsMTg1LDFdLCBcInBlcnVcIjogWzIwNSwxMzMsNjMsMV0sXG4gIFwicGlua1wiOiBbMjU1LDE5MiwyMDMsMV0sIFwicGx1bVwiOiBbMjIxLDE2MCwyMjEsMV0sXG4gIFwicG93ZGVyYmx1ZVwiOiBbMTc2LDIyNCwyMzAsMV0sIFwicHVycGxlXCI6IFsxMjgsMCwxMjgsMV0sXG4gIFwicmVkXCI6IFsyNTUsMCwwLDFdLCBcInJvc3licm93blwiOiBbMTg4LDE0MywxNDMsMV0sXG4gIFwicm95YWxibHVlXCI6IFs2NSwxMDUsMjI1LDFdLCBcInNhZGRsZWJyb3duXCI6IFsxMzksNjksMTksMV0sXG4gIFwic2FsbW9uXCI6IFsyNTAsMTI4LDExNCwxXSwgXCJzYW5keWJyb3duXCI6IFsyNDQsMTY0LDk2LDFdLFxuICBcInNlYWdyZWVuXCI6IFs0NiwxMzksODcsMV0sIFwic2Vhc2hlbGxcIjogWzI1NSwyNDUsMjM4LDFdLFxuICBcInNpZW5uYVwiOiBbMTYwLDgyLDQ1LDFdLCBcInNpbHZlclwiOiBbMTkyLDE5MiwxOTIsMV0sXG4gIFwic2t5Ymx1ZVwiOiBbMTM1LDIwNiwyMzUsMV0sIFwic2xhdGVibHVlXCI6IFsxMDYsOTAsMjA1LDFdLFxuICBcInNsYXRlZ3JheVwiOiBbMTEyLDEyOCwxNDQsMV0sIFwic2xhdGVncmV5XCI6IFsxMTIsMTI4LDE0NCwxXSxcbiAgXCJzbm93XCI6IFsyNTUsMjUwLDI1MCwxXSwgXCJzcHJpbmdncmVlblwiOiBbMCwyNTUsMTI3LDFdLFxuICBcInN0ZWVsYmx1ZVwiOiBbNzAsMTMwLDE4MCwxXSwgXCJ0YW5cIjogWzIxMCwxODAsMTQwLDFdLFxuICBcInRlYWxcIjogWzAsMTI4LDEyOCwxXSwgXCJ0aGlzdGxlXCI6IFsyMTYsMTkxLDIxNiwxXSxcbiAgXCJ0b21hdG9cIjogWzI1NSw5OSw3MSwxXSwgXCJ0dXJxdW9pc2VcIjogWzY0LDIyNCwyMDgsMV0sXG4gIFwidmlvbGV0XCI6IFsyMzgsMTMwLDIzOCwxXSwgXCJ3aGVhdFwiOiBbMjQ1LDIyMiwxNzksMV0sXG4gIFwid2hpdGVcIjogWzI1NSwyNTUsMjU1LDFdLCBcIndoaXRlc21va2VcIjogWzI0NSwyNDUsMjQ1LDFdLFxuICBcInllbGxvd1wiOiBbMjU1LDI1NSwwLDFdLCBcInllbGxvd2dyZWVuXCI6IFsxNTQsMjA1LDUwLDFdfVxuXG5mdW5jdGlvbiBjbGFtcF9jc3NfYnl0ZShpKSB7ICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMjU1LlxuICBpID0gTWF0aC5yb3VuZChpKTsgIC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDI1NSA/IDI1NSA6IGk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wX2Nzc19mbG9hdChmKSB7ICAvLyBDbGFtcCB0byBmbG9hdCAwLjAgLi4gMS4wLlxuICByZXR1cm4gZiA8IDAgPyAwIDogZiA+IDEgPyAxIDogZjtcbn1cblxuZnVuY3Rpb24gcGFyc2VfY3NzX2ludChzdHIpIHsgIC8vIGludCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJyUnKVxuICAgIHJldHVybiBjbGFtcF9jc3NfYnl0ZShwYXJzZUZsb2F0KHN0cikgLyAxMDAgKiAyNTUpO1xuICByZXR1cm4gY2xhbXBfY3NzX2J5dGUocGFyc2VJbnQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlX2Nzc19mbG9hdChzdHIpIHsgIC8vIGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnJScpXG4gICAgcmV0dXJuIGNsYW1wX2Nzc19mbG9hdChwYXJzZUZsb2F0KHN0cikgLyAxMDApO1xuICByZXR1cm4gY2xhbXBfY3NzX2Zsb2F0KHBhcnNlRmxvYXQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCkge1xuICBpZiAoaCA8IDApIGggKz0gMTtcbiAgZWxzZSBpZiAoaCA+IDEpIGggLT0gMTtcblxuICBpZiAoaCAqIDYgPCAxKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoICogNjtcbiAgaWYgKGggKiAyIDwgMSkgcmV0dXJuIG0yO1xuICBpZiAoaCAqIDMgPCAyKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMi8zIC0gaCkgKiA2O1xuICByZXR1cm4gbTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ1NTQ29sb3IoY3NzX3N0cikge1xuICAvLyBSZW1vdmUgYWxsIHdoaXRlc3BhY2UsIG5vdCBjb21wbGlhbnQsIGJ1dCBzaG91bGQganVzdCBiZSBtb3JlIGFjY2VwdGluZy5cbiAgdmFyIHN0ciA9IGNzc19zdHIucmVwbGFjZSgvIC9nLCAnJykudG9Mb3dlckNhc2UoKTtcblxuICAvLyBDb2xvciBrZXl3b3JkcyAoYW5kIHRyYW5zcGFyZW50KSBsb29rdXAuXG4gIGlmIChzdHIgaW4ga0NTU0NvbG9yVGFibGUpIHJldHVybiBrQ1NTQ29sb3JUYWJsZVtzdHJdLnNsaWNlKCk7ICAvLyBkdXAuXG5cbiAgLy8gI2FiYyBhbmQgI2FiYzEyMyBzeW50YXguXG4gIGlmIChzdHJbMF0gPT09ICcjJykge1xuICAgIGlmIChzdHIubGVuZ3RoID09PSA0KSB7XG4gICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSByZXR1cm4gbnVsbDsgIC8vIENvdmVycyBOYU4uXG4gICAgICByZXR1cm4gWygoaXYgJiAweGYwMCkgPj4gNCkgfCAoKGl2ICYgMHhmMDApID4+IDgpLFxuICAgICAgICAgICAgICAoaXYgJiAweGYwKSB8ICgoaXYgJiAweGYwKSA+PiA0KSxcbiAgICAgICAgICAgICAgKGl2ICYgMHhmKSB8ICgoaXYgJiAweGYpIDw8IDQpLFxuICAgICAgICAgICAgICAxXTtcbiAgICB9IGVsc2UgaWYgKHN0ci5sZW5ndGggPT09IDcpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgIC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZmZmZikpIHJldHVybiBudWxsOyAgLy8gQ292ZXJzIE5hTi5cbiAgICAgIHJldHVybiBbKGl2ICYgMHhmZjAwMDApID4+IDE2LFxuICAgICAgICAgICAgICAoaXYgJiAweGZmMDApID4+IDgsXG4gICAgICAgICAgICAgIGl2ICYgMHhmZixcbiAgICAgICAgICAgICAgMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgb3AgPSBzdHIuaW5kZXhPZignKCcpLCBlcCA9IHN0ci5pbmRleE9mKCcpJyk7XG4gIGlmIChvcCAhPT0gLTEgJiYgZXAgKyAxID09PSBzdHIubGVuZ3RoKSB7XG4gICAgdmFyIGZuYW1lID0gc3RyLnN1YnN0cigwLCBvcCk7XG4gICAgdmFyIHBhcmFtcyA9IHN0ci5zdWJzdHIob3ArMSwgZXAtKG9wKzEpKS5zcGxpdCgnLCcpO1xuICAgIHZhciBhbHBoYSA9IDE7ICAvLyBUbyBhbGxvdyBjYXNlIGZhbGx0aHJvdWdoLlxuICAgIHN3aXRjaCAoZm5hbWUpIHtcbiAgICAgIGNhc2UgJ3JnYmEnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGFscGhhID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtcy5wb3AoKSk7XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cbiAgICAgIGNhc2UgJ3JnYic6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIFtwYXJzZV9jc3NfaW50KHBhcmFtc1swXSksXG4gICAgICAgICAgICAgICAgcGFyc2VfY3NzX2ludChwYXJhbXNbMV0pLFxuICAgICAgICAgICAgICAgIHBhcnNlX2Nzc19pbnQocGFyYW1zWzJdKSxcbiAgICAgICAgICAgICAgICBhbHBoYV07XG4gICAgICBjYXNlICdoc2xhJzpcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHJldHVybiBudWxsO1xuICAgICAgICBhbHBoYSA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICBjYXNlICdoc2wnOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBoID0gKCgocGFyc2VGbG9hdChwYXJhbXNbMF0pICUgMzYwKSArIDM2MCkgJSAzNjApIC8gMzYwOyAgLy8gMCAuLiAxXG4gICAgICAgIC8vIE5PVEUoZGVhbm0pOiBBY2NvcmRpbmcgdG8gdGhlIENTUyBzcGVjIHMvbCBzaG91bGQgb25seSBiZVxuICAgICAgICAvLyBwZXJjZW50YWdlcywgYnV0IHdlIGRvbid0IGJvdGhlciBhbmQgbGV0IGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIHZhciBzID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtc1sxXSk7XG4gICAgICAgIHZhciBsID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtc1syXSk7XG4gICAgICAgIHZhciBtMiA9IGwgPD0gMC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICB2YXIgbTEgPSBsICogMiAtIG0yO1xuICAgICAgICByZXR1cm4gW2NsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCsxLzMpICogMjU1KSxcbiAgICAgICAgICAgICAgICBjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgpICogMjU1KSxcbiAgICAgICAgICAgICAgICBjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgtMS8zKSAqIDI1NSksXG4gICAgICAgICAgICAgICAgYWxwaGFdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnRyeSB7IGV4cG9ydHMucGFyc2VDU1NDb2xvciA9IHBhcnNlQ1NTQ29sb3IgfSBjYXRjaChlKSB7IH1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBlYXJjdXQ7XG5cbmZ1bmN0aW9uIGVhcmN1dChkYXRhLCBob2xlSW5kaWNlcywgZGltKSB7XG5cbiAgICBkaW0gPSBkaW0gfHwgMjtcblxuICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aCxcbiAgICAgICAgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGgsXG4gICAgICAgIG91dGVyTm9kZSA9IGxpbmtlZExpc3QoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSksXG4gICAgICAgIHRyaWFuZ2xlcyA9IFtdO1xuXG4gICAgaWYgKCFvdXRlck5vZGUpIHJldHVybiB0cmlhbmdsZXM7XG5cbiAgICB2YXIgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgeCwgeSwgc2l6ZTtcblxuICAgIGlmIChoYXNIb2xlcykgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKTtcblxuICAgIC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDgwICogZGltKSB7XG4gICAgICAgIG1pblggPSBtYXhYID0gZGF0YVswXTtcbiAgICAgICAgbWluWSA9IG1heFkgPSBkYXRhWzFdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBkaW07IGkgPCBvdXRlckxlbjsgaSArPSBkaW0pIHtcbiAgICAgICAgICAgIHggPSBkYXRhW2ldO1xuICAgICAgICAgICAgeSA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgaWYgKHggPCBtaW5YKSBtaW5YID0geDtcbiAgICAgICAgICAgIGlmICh5IDwgbWluWSkgbWluWSA9IHk7XG4gICAgICAgICAgICBpZiAoeCA+IG1heFgpIG1heFggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPiBtYXhZKSBtYXhZID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1pblgsIG1pblkgYW5kIHNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXG4gICAgICAgIHNpemUgPSBNYXRoLm1heChtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgIH1cblxuICAgIGVhcmN1dExpbmtlZChvdXRlck5vZGUsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKTtcblxuICAgIHJldHVybiB0cmlhbmdsZXM7XG59XG5cbi8vIGNyZWF0ZSBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdCBmcm9tIHBvbHlnb24gcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgd2luZGluZyBvcmRlclxuZnVuY3Rpb24gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGNsb2Nrd2lzZSkge1xuICAgIHZhciBpLCBsYXN0O1xuXG4gICAgaWYgKGNsb2Nrd2lzZSA9PT0gKHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSA+IDApKSB7XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IGVuZCAtIGRpbTsgaSA+PSBzdGFydDsgaSAtPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgICB9XG5cbiAgICBpZiAobGFzdCAmJiBlcXVhbHMobGFzdCwgbGFzdC5uZXh0KSkge1xuICAgICAgICByZW1vdmVOb2RlKGxhc3QpO1xuICAgICAgICBsYXN0ID0gbGFzdC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBsYXN0O1xufVxuXG4vLyBlbGltaW5hdGUgY29saW5lYXIgb3IgZHVwbGljYXRlIHBvaW50c1xuZnVuY3Rpb24gZmlsdGVyUG9pbnRzKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoIXN0YXJ0KSByZXR1cm4gc3RhcnQ7XG4gICAgaWYgKCFlbmQpIGVuZCA9IHN0YXJ0O1xuXG4gICAgdmFyIHAgPSBzdGFydCxcbiAgICAgICAgYWdhaW47XG4gICAgZG8ge1xuICAgICAgICBhZ2FpbiA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghcC5zdGVpbmVyICYmIChlcXVhbHMocCwgcC5uZXh0KSB8fCBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICBwID0gZW5kID0gcC5wcmV2O1xuICAgICAgICAgICAgaWYgKHAgPT09IHAubmV4dCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBhZ2FpbiA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChhZ2FpbiB8fCBwICE9PSBlbmQpO1xuXG4gICAgcmV0dXJuIGVuZDtcbn1cblxuLy8gbWFpbiBlYXIgc2xpY2luZyBsb29wIHdoaWNoIHRyaWFuZ3VsYXRlcyBhIHBvbHlnb24gKGdpdmVuIGFzIGEgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSwgcGFzcykge1xuICAgIGlmICghZWFyKSByZXR1cm47XG5cbiAgICAvLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG4gICAgaWYgKCFwYXNzICYmIHNpemUpIGluZGV4Q3VydmUoZWFyLCBtaW5YLCBtaW5ZLCBzaXplKTtcblxuICAgIHZhciBzdG9wID0gZWFyLFxuICAgICAgICBwcmV2LCBuZXh0O1xuXG4gICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXG4gICAgd2hpbGUgKGVhci5wcmV2ICE9PSBlYXIubmV4dCkge1xuICAgICAgICBwcmV2ID0gZWFyLnByZXY7XG4gICAgICAgIG5leHQgPSBlYXIubmV4dDtcblxuICAgICAgICBpZiAoc2l6ZSA/IGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgc2l6ZSkgOiBpc0VhcihlYXIpKSB7XG4gICAgICAgICAgICAvLyBjdXQgb2ZmIHRoZSB0cmlhbmdsZVxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocHJldi5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGVhci5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKG5leHQuaSAvIGRpbSk7XG5cbiAgICAgICAgICAgIHJlbW92ZU5vZGUoZWFyKTtcblxuICAgICAgICAgICAgLy8gc2tpcHBpbmcgdGhlIG5leHQgdmVydGljZSBsZWFkcyB0byBsZXNzIHNsaXZlciB0cmlhbmdsZXNcbiAgICAgICAgICAgIGVhciA9IG5leHQubmV4dDtcbiAgICAgICAgICAgIHN0b3AgPSBuZXh0Lm5leHQ7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWFyID0gbmV4dDtcblxuICAgICAgICAvLyBpZiB3ZSBsb29wZWQgdGhyb3VnaCB0aGUgd2hvbGUgcmVtYWluaW5nIHBvbHlnb24gYW5kIGNhbid0IGZpbmQgYW55IG1vcmUgZWFyc1xuICAgICAgICBpZiAoZWFyID09PSBzdG9wKSB7XG4gICAgICAgICAgICAvLyB0cnkgZmlsdGVyaW5nIHBvaW50cyBhbmQgc2xpY2luZyBhZ2FpblxuICAgICAgICAgICAgaWYgKCFwYXNzKSB7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGZpbHRlclBvaW50cyhlYXIpLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgc2l6ZSwgMSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlkbid0IHdvcmssIHRyeSBjdXJpbmcgYWxsIHNtYWxsIHNlbGYtaW50ZXJzZWN0aW9ucyBsb2NhbGx5XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBlYXIgPSBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKGVhciwgdHJpYW5nbGVzLCBkaW0pO1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplLCAyKTtcblxuICAgICAgICAgICAgLy8gYXMgYSBsYXN0IHJlc29ydCwgdHJ5IHNwbGl0dGluZyB0aGUgcmVtYWluaW5nIHBvbHlnb24gaW50byB0d29cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzcyA9PT0gMikge1xuICAgICAgICAgICAgICAgIHNwbGl0RWFyY3V0KGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXG5mdW5jdGlvbiBpc0VhcihlYXIpIHtcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICAvLyBub3cgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgb3RoZXIgcG9pbnRzIGluc2lkZSB0aGUgcG90ZW50aWFsIGVhclxuICAgIHZhciBwID0gZWFyLm5leHQubmV4dDtcblxuICAgIHdoaWxlIChwICE9PSBlYXIucHJldikge1xuICAgICAgICBpZiAocG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIHNpemUpIHtcbiAgICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgICBiID0gZWFyLFxuICAgICAgICBjID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cbiAgICAvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxuICAgIHZhciBtaW5UWCA9IGEueCA8IGIueCA/IChhLnggPCBjLnggPyBhLnggOiBjLngpIDogKGIueCA8IGMueCA/IGIueCA6IGMueCksXG4gICAgICAgIG1pblRZID0gYS55IDwgYi55ID8gKGEueSA8IGMueSA/IGEueSA6IGMueSkgOiAoYi55IDwgYy55ID8gYi55IDogYy55KSxcbiAgICAgICAgbWF4VFggPSBhLnggPiBiLnggPyAoYS54ID4gYy54ID8gYS54IDogYy54KSA6IChiLnggPiBjLnggPyBiLnggOiBjLngpLFxuICAgICAgICBtYXhUWSA9IGEueSA+IGIueSA/IChhLnkgPiBjLnkgPyBhLnkgOiBjLnkpIDogKGIueSA+IGMueSA/IGIueSA6IGMueSk7XG5cbiAgICAvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xuICAgIHZhciBtaW5aID0gek9yZGVyKG1pblRYLCBtaW5UWSwgbWluWCwgbWluWSwgc2l6ZSksXG4gICAgICAgIG1heFogPSB6T3JkZXIobWF4VFgsIG1heFRZLCBtaW5YLCBtaW5ZLCBzaXplKTtcblxuICAgIC8vIGZpcnN0IGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGluY3JlYXNpbmcgei1vcmRlclxuICAgIHZhciBwID0gZWFyLm5leHRaO1xuXG4gICAgd2hpbGUgKHAgJiYgcC56IDw9IG1heFopIHtcbiAgICAgICAgaWYgKHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLm5leHRaO1xuICAgIH1cblxuICAgIC8vIHRoZW4gbG9vayBmb3IgcG9pbnRzIGluIGRlY3JlYXNpbmcgei1vcmRlclxuICAgIHAgPSBlYXIucHJldlo7XG5cbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWikge1xuICAgICAgICBpZiAocCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAucHJldlo7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXG5mdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSkge1xuICAgIHZhciBwID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYSA9IHAucHJldixcbiAgICAgICAgICAgIGIgPSBwLm5leHQubmV4dDtcblxuICAgICAgICBpZiAoIWVxdWFscyhhLCBiKSAmJiBpbnRlcnNlY3RzKGEsIHAsIHAubmV4dCwgYikgJiYgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpKSB7XG5cbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGEuaSAvIGRpbSk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwLmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYi5pIC8gZGltKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHR3byBub2RlcyBpbnZvbHZlZFxuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocC5uZXh0KTtcblxuICAgICAgICAgICAgcCA9IHN0YXJ0ID0gYjtcbiAgICAgICAgfVxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBwO1xufVxuXG4vLyB0cnkgc3BsaXR0aW5nIHBvbHlnb24gaW50byB0d28gYW5kIHRyaWFuZ3VsYXRlIHRoZW0gaW5kZXBlbmRlbnRseVxuZnVuY3Rpb24gc3BsaXRFYXJjdXQoc3RhcnQsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgLy8gbG9vayBmb3IgYSB2YWxpZCBkaWFnb25hbCB0aGF0IGRpdmlkZXMgdGhlIHBvbHlnb24gaW50byB0d29cbiAgICB2YXIgYSA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGIgPSBhLm5leHQubmV4dDtcbiAgICAgICAgd2hpbGUgKGIgIT09IGEucHJldikge1xuICAgICAgICAgICAgaWYgKGEuaSAhPT0gYi5pICYmIGlzVmFsaWREaWFnb25hbChhLCBiKSkge1xuICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBwb2x5Z29uIGluIHR3byBieSB0aGUgZGlhZ29uYWxcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHNwbGl0UG9seWdvbihhLCBiKTtcblxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBjb2xpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXG4gICAgICAgICAgICAgICAgYSA9IGZpbHRlclBvaW50cyhhLCBhLm5leHQpO1xuICAgICAgICAgICAgICAgIGMgPSBmaWx0ZXJQb2ludHMoYywgYy5uZXh0KTtcblxuICAgICAgICAgICAgICAgIC8vIHJ1biBlYXJjdXQgb24gZWFjaCBoYWxmXG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGEsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYywgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIHNpemUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIgPSBiLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGEubmV4dDtcbiAgICB9IHdoaWxlIChhICE9PSBzdGFydCk7XG59XG5cbi8vIGxpbmsgZXZlcnkgaG9sZSBpbnRvIHRoZSBvdXRlciBsb29wLCBwcm9kdWNpbmcgYSBzaW5nbGUtcmluZyBwb2x5Z29uIHdpdGhvdXQgaG9sZXNcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSkge1xuICAgIHZhciBxdWV1ZSA9IFtdLFxuICAgICAgICBpLCBsZW4sIHN0YXJ0LCBlbmQsIGxpc3Q7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgICAgICBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICBsaXN0ID0gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGZhbHNlKTtcbiAgICAgICAgaWYgKGxpc3QgPT09IGxpc3QubmV4dCkgbGlzdC5zdGVpbmVyID0gdHJ1ZTtcbiAgICAgICAgcXVldWUucHVzaChnZXRMZWZ0bW9zdChsaXN0KSk7XG4gICAgfVxuXG4gICAgcXVldWUuc29ydChjb21wYXJlWCk7XG5cbiAgICAvLyBwcm9jZXNzIGhvbGVzIGZyb20gbGVmdCB0byByaWdodFxuICAgIGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGltaW5hdGVIb2xlKHF1ZXVlW2ldLCBvdXRlck5vZGUpO1xuICAgICAgICBvdXRlck5vZGUgPSBmaWx0ZXJQb2ludHMob3V0ZXJOb2RlLCBvdXRlck5vZGUubmV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dGVyTm9kZTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZVgoYSwgYikge1xuICAgIHJldHVybiBhLnggLSBiLng7XG59XG5cbi8vIGZpbmQgYSBicmlkZ2UgYmV0d2VlbiB2ZXJ0aWNlcyB0aGF0IGNvbm5lY3RzIGhvbGUgd2l0aCBhbiBvdXRlciByaW5nIGFuZCBhbmQgbGluayBpdFxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICBvdXRlck5vZGUgPSBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpO1xuICAgIGlmIChvdXRlck5vZGUpIHtcbiAgICAgICAgdmFyIGIgPSBzcGxpdFBvbHlnb24ob3V0ZXJOb2RlLCBob2xlKTtcbiAgICAgICAgZmlsdGVyUG9pbnRzKGIsIGIubmV4dCk7XG4gICAgfVxufVxuXG4vLyBEYXZpZCBFYmVybHkncyBhbGdvcml0aG0gZm9yIGZpbmRpbmcgYSBicmlkZ2UgYmV0d2VlbiBob2xlIGFuZCBvdXRlciBwb2x5Z29uXG5mdW5jdGlvbiBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICB2YXIgcCA9IG91dGVyTm9kZSxcbiAgICAgICAgaHggPSBob2xlLngsXG4gICAgICAgIGh5ID0gaG9sZS55LFxuICAgICAgICBxeCA9IC1JbmZpbml0eSxcbiAgICAgICAgbTtcblxuICAgIC8vIGZpbmQgYSBzZWdtZW50IGludGVyc2VjdGVkIGJ5IGEgcmF5IGZyb20gdGhlIGhvbGUncyBsZWZ0bW9zdCBwb2ludCB0byB0aGUgbGVmdDtcbiAgICAvLyBzZWdtZW50J3MgZW5kcG9pbnQgd2l0aCBsZXNzZXIgeCB3aWxsIGJlIHBvdGVudGlhbCBjb25uZWN0aW9uIHBvaW50XG4gICAgZG8ge1xuICAgICAgICBpZiAoaHkgPD0gcC55ICYmIGh5ID49IHAubmV4dC55KSB7XG4gICAgICAgICAgICB2YXIgeCA9IHAueCArIChoeSAtIHAueSkgKiAocC5uZXh0LnggLSBwLngpIC8gKHAubmV4dC55IC0gcC55KTtcbiAgICAgICAgICAgIGlmICh4IDw9IGh4ICYmIHggPiBxeCkge1xuICAgICAgICAgICAgICAgIHF4ID0geDtcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gaHgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGh5ID09PSBwLnkpIHJldHVybiBwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHkgPT09IHAubmV4dC55KSByZXR1cm4gcC5uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtID0gcC54IDwgcC5uZXh0LnggPyBwIDogcC5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gb3V0ZXJOb2RlKTtcblxuICAgIGlmICghbSkgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAoaHggPT09IHF4KSByZXR1cm4gbS5wcmV2OyAvLyBob2xlIHRvdWNoZXMgb3V0ZXIgc2VnbWVudDsgcGljayBsb3dlciBlbmRwb2ludFxuXG4gICAgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgb2YgaG9sZSBwb2ludCwgc2VnbWVudCBpbnRlcnNlY3Rpb24gYW5kIGVuZHBvaW50O1xuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBwb2ludHMgZm91bmQsIHdlIGhhdmUgYSB2YWxpZCBjb25uZWN0aW9uO1xuICAgIC8vIG90aGVyd2lzZSBjaG9vc2UgdGhlIHBvaW50IG9mIHRoZSBtaW5pbXVtIGFuZ2xlIHdpdGggdGhlIHJheSBhcyBjb25uZWN0aW9uIHBvaW50XG5cbiAgICB2YXIgc3RvcCA9IG0sXG4gICAgICAgIG14ID0gbS54LFxuICAgICAgICBteSA9IG0ueSxcbiAgICAgICAgdGFuTWluID0gSW5maW5pdHksXG4gICAgICAgIHRhbjtcblxuICAgIHAgPSBtLm5leHQ7XG5cbiAgICB3aGlsZSAocCAhPT0gc3RvcCkge1xuICAgICAgICBpZiAoaHggPj0gcC54ICYmIHAueCA+PSBteCAmJlxuICAgICAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShoeSA8IG15ID8gaHggOiBxeCwgaHksIG14LCBteSwgaHkgPCBteSA/IHF4IDogaHgsIGh5LCBwLngsIHAueSkpIHtcblxuICAgICAgICAgICAgdGFuID0gTWF0aC5hYnMoaHkgLSBwLnkpIC8gKGh4IC0gcC54KTsgLy8gdGFuZ2VudGlhbFxuXG4gICAgICAgICAgICBpZiAoKHRhbiA8IHRhbk1pbiB8fCAodGFuID09PSB0YW5NaW4gJiYgcC54ID4gbS54KSkgJiYgbG9jYWxseUluc2lkZShwLCBob2xlKSkge1xuICAgICAgICAgICAgICAgIG0gPSBwO1xuICAgICAgICAgICAgICAgIHRhbk1pbiA9IHRhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG07XG59XG5cbi8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbmZ1bmN0aW9uIGluZGV4Q3VydmUoc3RhcnQsIG1pblgsIG1pblksIHNpemUpIHtcbiAgICB2YXIgcCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueiA9PT0gbnVsbCkgcC56ID0gek9yZGVyKHAueCwgcC55LCBtaW5YLCBtaW5ZLCBzaXplKTtcbiAgICAgICAgcC5wcmV2WiA9IHAucHJldjtcbiAgICAgICAgcC5uZXh0WiA9IHAubmV4dDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICBwLnByZXZaLm5leHRaID0gbnVsbDtcbiAgICBwLnByZXZaID0gbnVsbDtcblxuICAgIHNvcnRMaW5rZWQocCk7XG59XG5cbi8vIFNpbW9uIFRhdGhhbSdzIGxpbmtlZCBsaXN0IG1lcmdlIHNvcnQgYWxnb3JpdGhtXG4vLyBodHRwOi8vd3d3LmNoaWFyay5ncmVlbmVuZC5vcmcudWsvfnNndGF0aGFtL2FsZ29yaXRobXMvbGlzdHNvcnQuaHRtbFxuZnVuY3Rpb24gc29ydExpbmtlZChsaXN0KSB7XG4gICAgdmFyIGksIHAsIHEsIGUsIHRhaWwsIG51bU1lcmdlcywgcFNpemUsIHFTaXplLFxuICAgICAgICBpblNpemUgPSAxO1xuXG4gICAgZG8ge1xuICAgICAgICBwID0gbGlzdDtcbiAgICAgICAgbGlzdCA9IG51bGw7XG4gICAgICAgIHRhaWwgPSBudWxsO1xuICAgICAgICBudW1NZXJnZXMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBudW1NZXJnZXMrKztcbiAgICAgICAgICAgIHEgPSBwO1xuICAgICAgICAgICAgcFNpemUgPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcFNpemUrKztcbiAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICBpZiAoIXEpIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBxU2l6ZSA9IGluU2l6ZTtcblxuICAgICAgICAgICAgd2hpbGUgKHBTaXplID4gMCB8fCAocVNpemUgPiAwICYmIHEpKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocFNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHE7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBxU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocVNpemUgPT09IDAgfHwgIXEpIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocC56IDw9IHEueikge1xuICAgICAgICAgICAgICAgICAgICBlID0gcDtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHBTaXplLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHE7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBxU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0YWlsKSB0YWlsLm5leHRaID0gZTtcbiAgICAgICAgICAgICAgICBlbHNlIGxpc3QgPSBlO1xuXG4gICAgICAgICAgICAgICAgZS5wcmV2WiA9IHRhaWw7XG4gICAgICAgICAgICAgICAgdGFpbCA9IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAgPSBxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFpbC5uZXh0WiA9IG51bGw7XG4gICAgICAgIGluU2l6ZSAqPSAyO1xuXG4gICAgfSB3aGlsZSAobnVtTWVyZ2VzID4gMSk7XG5cbiAgICByZXR1cm4gbGlzdDtcbn1cblxuLy8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgc2l6ZSBvZiB0aGUgZGF0YSBib3VuZGluZyBib3hcbmZ1bmN0aW9uIHpPcmRlcih4LCB5LCBtaW5YLCBtaW5ZLCBzaXplKSB7XG4gICAgLy8gY29vcmRzIGFyZSB0cmFuc2Zvcm1lZCBpbnRvIG5vbi1uZWdhdGl2ZSAxNS1iaXQgaW50ZWdlciByYW5nZVxuICAgIHggPSAzMjc2NyAqICh4IC0gbWluWCkgLyBzaXplO1xuICAgIHkgPSAzMjc2NyAqICh5IC0gbWluWSkgLyBzaXplO1xuXG4gICAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIHggPSAoeCB8ICh4IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG4vLyBmaW5kIHRoZSBsZWZ0bW9zdCBub2RlIG9mIGEgcG9seWdvbiByaW5nXG5mdW5jdGlvbiBnZXRMZWZ0bW9zdChzdGFydCkge1xuICAgIHZhciBwID0gc3RhcnQsXG4gICAgICAgIGxlZnRtb3N0ID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC54IDwgbGVmdG1vc3QueCkgbGVmdG1vc3QgPSBwO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBsZWZ0bW9zdDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2ludCBsaWVzIHdpdGhpbiBhIGNvbnZleCB0cmlhbmdsZVxuZnVuY3Rpb24gcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSkge1xuICAgIHJldHVybiAoY3ggLSBweCkgKiAoYXkgLSBweSkgLSAoYXggLSBweCkgKiAoY3kgLSBweSkgPj0gMCAmJlxuICAgICAgICAgICAoYXggLSBweCkgKiAoYnkgLSBweSkgLSAoYnggLSBweCkgKiAoYXkgLSBweSkgPj0gMCAmJlxuICAgICAgICAgICAoYnggLSBweCkgKiAoY3kgLSBweSkgLSAoY3ggLSBweCkgKiAoYnkgLSBweSkgPj0gMDtcbn1cblxuLy8gY2hlY2sgaWYgYSBkaWFnb25hbCBiZXR3ZWVuIHR3byBwb2x5Z29uIG5vZGVzIGlzIHZhbGlkIChsaWVzIGluIHBvbHlnb24gaW50ZXJpb3IpXG5mdW5jdGlvbiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikge1xuICAgIHJldHVybiBhLm5leHQuaSAhPT0gYi5pICYmIGEucHJldi5pICE9PSBiLmkgJiYgIWludGVyc2VjdHNQb2x5Z29uKGEsIGIpICYmXG4gICAgICAgICAgIGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSAmJiBtaWRkbGVJbnNpZGUoYSwgYik7XG59XG5cbi8vIHNpZ25lZCBhcmVhIG9mIGEgdHJpYW5nbGVcbmZ1bmN0aW9uIGFyZWEocCwgcSwgcikge1xuICAgIHJldHVybiAocS55IC0gcC55KSAqIChyLnggLSBxLngpIC0gKHEueCAtIHAueCkgKiAoci55IC0gcS55KTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWxcbmZ1bmN0aW9uIGVxdWFscyhwMSwgcDIpIHtcbiAgICByZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xufVxuXG4vLyBjaGVjayBpZiB0d28gc2VnbWVudHMgaW50ZXJzZWN0XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHAxLCBxMSwgcDIsIHEyKSB7XG4gICAgaWYgKChlcXVhbHMocDEsIHExKSAmJiBlcXVhbHMocDIsIHEyKSkgfHxcbiAgICAgICAgKGVxdWFscyhwMSwgcTIpICYmIGVxdWFscyhwMiwgcTEpKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGFyZWEocDEsIHExLCBwMikgPiAwICE9PSBhcmVhKHAxLCBxMSwgcTIpID4gMCAmJlxuICAgICAgICAgICBhcmVhKHAyLCBxMiwgcDEpID4gMCAhPT0gYXJlYShwMiwgcTIsIHExKSA+IDA7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpbnRlcnNlY3RzIGFueSBwb2x5Z29uIHNlZ21lbnRzXG5mdW5jdGlvbiBpbnRlcnNlY3RzUG9seWdvbihhLCBiKSB7XG4gICAgdmFyIHAgPSBhO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJlxuICAgICAgICAgICAgICAgIGludGVyc2VjdHMocCwgcC5uZXh0LCBhLCBiKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gYSk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpcyBsb2NhbGx5IGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbG9jYWxseUluc2lkZShhLCBiKSB7XG4gICAgcmV0dXJuIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpIDwgMCA/XG4gICAgICAgIGFyZWEoYSwgYiwgYS5uZXh0KSA+PSAwICYmIGFyZWEoYSwgYS5wcmV2LCBiKSA+PSAwIDpcbiAgICAgICAgYXJlYShhLCBiLCBhLnByZXYpIDwgMCB8fCBhcmVhKGEsIGEubmV4dCwgYikgPCAwO1xufVxuXG4vLyBjaGVjayBpZiB0aGUgbWlkZGxlIHBvaW50IG9mIGEgcG9seWdvbiBkaWFnb25hbCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIG1pZGRsZUluc2lkZShhLCBiKSB7XG4gICAgdmFyIHAgPSBhLFxuICAgICAgICBpbnNpZGUgPSBmYWxzZSxcbiAgICAgICAgcHggPSAoYS54ICsgYi54KSAvIDIsXG4gICAgICAgIHB5ID0gKGEueSArIGIueSkgLyAyO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKCgocC55ID4gcHkpICE9PSAocC5uZXh0LnkgPiBweSkpICYmIChweCA8IChwLm5leHQueCAtIHAueCkgKiAocHkgLSBwLnkpIC8gKHAubmV4dC55IC0gcC55KSArIHAueCkpXG4gICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gICAgcmV0dXJuIGluc2lkZTtcbn1cblxuLy8gbGluayB0d28gcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgYnJpZGdlOyBpZiB0aGUgdmVydGljZXMgYmVsb25nIHRvIHRoZSBzYW1lIHJpbmcsIGl0IHNwbGl0cyBwb2x5Z29uIGludG8gdHdvO1xuLy8gaWYgb25lIGJlbG9uZ3MgdG8gdGhlIG91dGVyIHJpbmcgYW5kIGFub3RoZXIgdG8gYSBob2xlLCBpdCBtZXJnZXMgaXQgaW50byBhIHNpbmdsZSByaW5nXG5mdW5jdGlvbiBzcGxpdFBvbHlnb24oYSwgYikge1xuICAgIHZhciBhMiA9IG5ldyBOb2RlKGEuaSwgYS54LCBhLnkpLFxuICAgICAgICBiMiA9IG5ldyBOb2RlKGIuaSwgYi54LCBiLnkpLFxuICAgICAgICBhbiA9IGEubmV4dCxcbiAgICAgICAgYnAgPSBiLnByZXY7XG5cbiAgICBhLm5leHQgPSBiO1xuICAgIGIucHJldiA9IGE7XG5cbiAgICBhMi5uZXh0ID0gYW47XG4gICAgYW4ucHJldiA9IGEyO1xuXG4gICAgYjIubmV4dCA9IGEyO1xuICAgIGEyLnByZXYgPSBiMjtcblxuICAgIGJwLm5leHQgPSBiMjtcbiAgICBiMi5wcmV2ID0gYnA7XG5cbiAgICByZXR1cm4gYjI7XG59XG5cbi8vIGNyZWF0ZSBhIG5vZGUgYW5kIG9wdGlvbmFsbHkgbGluayBpdCB3aXRoIHByZXZpb3VzIG9uZSAoaW4gYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBpbnNlcnROb2RlKGksIHgsIHksIGxhc3QpIHtcbiAgICB2YXIgcCA9IG5ldyBOb2RlKGksIHgsIHkpO1xuXG4gICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIHAucHJldiA9IHA7XG4gICAgICAgIHAubmV4dCA9IHA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBwLm5leHQgPSBsYXN0Lm5leHQ7XG4gICAgICAgIHAucHJldiA9IGxhc3Q7XG4gICAgICAgIGxhc3QubmV4dC5wcmV2ID0gcDtcbiAgICAgICAgbGFzdC5uZXh0ID0gcDtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUocCkge1xuICAgIHAubmV4dC5wcmV2ID0gcC5wcmV2O1xuICAgIHAucHJldi5uZXh0ID0gcC5uZXh0O1xuXG4gICAgaWYgKHAucHJldlopIHAucHJldloubmV4dFogPSBwLm5leHRaO1xuICAgIGlmIChwLm5leHRaKSBwLm5leHRaLnByZXZaID0gcC5wcmV2Wjtcbn1cblxuZnVuY3Rpb24gTm9kZShpLCB4LCB5KSB7XG4gICAgLy8gdmVydGljZSBpbmRleCBpbiBjb29yZGluYXRlcyBhcnJheVxuICAgIHRoaXMuaSA9IGk7XG5cbiAgICAvLyB2ZXJ0ZXggY29vcmRpbmF0ZXNcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG5cbiAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCB2ZXJ0aWNlIG5vZGVzIGluIGEgcG9seWdvbiByaW5nXG4gICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuXG4gICAgLy8gei1vcmRlciBjdXJ2ZSB2YWx1ZVxuICAgIHRoaXMueiA9IG51bGw7XG5cbiAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCBub2RlcyBpbiB6LW9yZGVyXG4gICAgdGhpcy5wcmV2WiA9IG51bGw7XG4gICAgdGhpcy5uZXh0WiA9IG51bGw7XG5cbiAgICAvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGEgc3RlaW5lciBwb2ludFxuICAgIHRoaXMuc3RlaW5lciA9IGZhbHNlO1xufVxuXG4vLyByZXR1cm4gYSBwZXJjZW50YWdlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcG9seWdvbiBhcmVhIGFuZCBpdHMgdHJpYW5ndWxhdGlvbiBhcmVhO1xuLy8gdXNlZCB0byB2ZXJpZnkgY29ycmVjdG5lc3Mgb2YgdHJpYW5ndWxhdGlvblxuZWFyY3V0LmRldmlhdGlvbiA9IGZ1bmN0aW9uIChkYXRhLCBob2xlSW5kaWNlcywgZGltLCB0cmlhbmdsZXMpIHtcbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGg7XG4gICAgdmFyIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuXG4gICAgdmFyIHBvbHlnb25BcmVhID0gTWF0aC5hYnMoc2lnbmVkQXJlYShkYXRhLCAwLCBvdXRlckxlbiwgZGltKSk7XG4gICAgaWYgKGhhc0hvbGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgICAgICAgICB2YXIgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHBvbHlnb25BcmVhIC09IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdHJpYW5nbGVzQXJlYSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB2YXIgYSA9IHRyaWFuZ2xlc1tpXSAqIGRpbTtcbiAgICAgICAgdmFyIGIgPSB0cmlhbmdsZXNbaSArIDFdICogZGltO1xuICAgICAgICB2YXIgYyA9IHRyaWFuZ2xlc1tpICsgMl0gKiBkaW07XG4gICAgICAgIHRyaWFuZ2xlc0FyZWEgKz0gTWF0aC5hYnMoXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbY10pICogKGRhdGFbYiArIDFdIC0gZGF0YVthICsgMV0pIC1cbiAgICAgICAgICAgIChkYXRhW2FdIC0gZGF0YVtiXSkgKiAoZGF0YVtjICsgMV0gLSBkYXRhW2EgKyAxXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBwb2x5Z29uQXJlYSA9PT0gMCAmJiB0cmlhbmdsZXNBcmVhID09PSAwID8gMCA6XG4gICAgICAgIE1hdGguYWJzKCh0cmlhbmdsZXNBcmVhIC0gcG9seWdvbkFyZWEpIC8gcG9seWdvbkFyZWEpO1xufTtcblxuZnVuY3Rpb24gc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQsIGogPSBlbmQgLSBkaW07IGkgPCBlbmQ7IGkgKz0gZGltKSB7XG4gICAgICAgIHN1bSArPSAoZGF0YVtqXSAtIGRhdGFbaV0pICogKGRhdGFbaSArIDFdICsgZGF0YVtqICsgMV0pO1xuICAgICAgICBqID0gaTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuLy8gdHVybiBhIHBvbHlnb24gaW4gYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSBmb3JtIChlLmcuIGFzIGluIEdlb0pTT04pIGludG8gYSBmb3JtIEVhcmN1dCBhY2NlcHRzXG5lYXJjdXQuZmxhdHRlbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGRpbSA9IGRhdGFbMF1bMF0ubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSB7dmVydGljZXM6IFtdLCBob2xlczogW10sIGRpbWVuc2lvbnM6IGRpbX0sXG4gICAgICAgIGhvbGVJbmRleCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkYXRhW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRpbTsgZCsrKSByZXN1bHQudmVydGljZXMucHVzaChkYXRhW2ldW2pdW2RdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGhvbGVJbmRleCArPSBkYXRhW2kgLSAxXS5sZW5ndGg7XG4gICAgICAgICAgICByZXN1bHQuaG9sZXMucHVzaChob2xlSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUZpbHRlcjtcblxudmFyIHR5cGVzID0gWydVbmtub3duJywgJ1BvaW50JywgJ0xpbmVTdHJpbmcnLCAnUG9seWdvbiddO1xuXG4vKipcbiAqIEdpdmVuIGEgZmlsdGVyIGV4cHJlc3NlZCBhcyBuZXN0ZWQgYXJyYXlzLCByZXR1cm4gYSBuZXcgZnVuY3Rpb25cbiAqIHRoYXQgZXZhbHVhdGVzIHdoZXRoZXIgYSBnaXZlbiBmZWF0dXJlICh3aXRoIGEgLnByb3BlcnRpZXMgb3IgLnRhZ3MgcHJvcGVydHkpXG4gKiBwYXNzZXMgaXRzIHRlc3QuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZmlsdGVyIG1hcGJveCBnbCBmaWx0ZXJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gZmlsdGVyLWV2YWx1YXRpbmcgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmlsdGVyKGZpbHRlcikge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ2YnLCAndmFyIHAgPSAoZiAmJiBmLnByb3BlcnRpZXMgfHwge30pOyByZXR1cm4gJyArIGNvbXBpbGUoZmlsdGVyKSk7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGUoZmlsdGVyKSB7XG4gICAgaWYgKCFmaWx0ZXIpIHJldHVybiAndHJ1ZSc7XG4gICAgdmFyIG9wID0gZmlsdGVyWzBdO1xuICAgIGlmIChmaWx0ZXIubGVuZ3RoIDw9IDEpIHJldHVybiBvcCA9PT0gJ2FueScgPyAnZmFsc2UnIDogJ3RydWUnO1xuICAgIHZhciBzdHIgPVxuICAgICAgICBvcCA9PT0gJz09JyA/IGNvbXBpbGVDb21wYXJpc29uT3AoZmlsdGVyWzFdLCBmaWx0ZXJbMl0sICc9PT0nLCBmYWxzZSkgOlxuICAgICAgICBvcCA9PT0gJyE9JyA/IGNvbXBpbGVDb21wYXJpc29uT3AoZmlsdGVyWzFdLCBmaWx0ZXJbMl0sICchPT0nLCBmYWxzZSkgOlxuICAgICAgICBvcCA9PT0gJzwnIHx8XG4gICAgICAgIG9wID09PSAnPicgfHxcbiAgICAgICAgb3AgPT09ICc8PScgfHxcbiAgICAgICAgb3AgPT09ICc+PScgPyBjb21waWxlQ29tcGFyaXNvbk9wKGZpbHRlclsxXSwgZmlsdGVyWzJdLCBvcCwgdHJ1ZSkgOlxuICAgICAgICBvcCA9PT0gJ2FueScgPyBjb21waWxlTG9naWNhbE9wKGZpbHRlci5zbGljZSgxKSwgJ3x8JykgOlxuICAgICAgICBvcCA9PT0gJ2FsbCcgPyBjb21waWxlTG9naWNhbE9wKGZpbHRlci5zbGljZSgxKSwgJyYmJykgOlxuICAgICAgICBvcCA9PT0gJ25vbmUnID8gY29tcGlsZU5lZ2F0aW9uKGNvbXBpbGVMb2dpY2FsT3AoZmlsdGVyLnNsaWNlKDEpLCAnfHwnKSkgOlxuICAgICAgICBvcCA9PT0gJ2luJyA/IGNvbXBpbGVJbk9wKGZpbHRlclsxXSwgZmlsdGVyLnNsaWNlKDIpKSA6XG4gICAgICAgIG9wID09PSAnIWluJyA/IGNvbXBpbGVOZWdhdGlvbihjb21waWxlSW5PcChmaWx0ZXJbMV0sIGZpbHRlci5zbGljZSgyKSkpIDpcbiAgICAgICAgb3AgPT09ICdoYXMnID8gY29tcGlsZUhhc09wKGZpbHRlclsxXSkgOlxuICAgICAgICBvcCA9PT0gJyFoYXMnID8gY29tcGlsZU5lZ2F0aW9uKGNvbXBpbGVIYXNPcChbZmlsdGVyWzFdXSkpIDpcbiAgICAgICAgJ3RydWUnO1xuICAgIHJldHVybiAnKCcgKyBzdHIgKyAnKSc7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVQcm9wZXJ0eVJlZmVyZW5jZShwcm9wZXJ0eSkge1xuICAgIHJldHVybiBwcm9wZXJ0eSA9PT0gJyR0eXBlJyA/ICdmLnR5cGUnIDogJ3BbJyArIEpTT04uc3RyaW5naWZ5KHByb3BlcnR5KSArICddJztcbn1cblxuZnVuY3Rpb24gY29tcGlsZUNvbXBhcmlzb25PcChwcm9wZXJ0eSwgdmFsdWUsIG9wLCBjaGVja1R5cGUpIHtcbiAgICB2YXIgbGVmdCA9IGNvbXBpbGVQcm9wZXJ0eVJlZmVyZW5jZShwcm9wZXJ0eSk7XG4gICAgdmFyIHJpZ2h0ID0gcHJvcGVydHkgPT09ICckdHlwZScgPyB0eXBlcy5pbmRleE9mKHZhbHVlKSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICByZXR1cm4gKGNoZWNrVHlwZSA/ICd0eXBlb2YgJyArIGxlZnQgKyAnPT09IHR5cGVvZiAnICsgcmlnaHQgKyAnJiYnIDogJycpICsgbGVmdCArIG9wICsgcmlnaHQ7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVMb2dpY2FsT3AoZXhwcmVzc2lvbnMsIG9wKSB7XG4gICAgcmV0dXJuIGV4cHJlc3Npb25zLm1hcChjb21waWxlKS5qb2luKG9wKTtcbn1cblxuZnVuY3Rpb24gY29tcGlsZUluT3AocHJvcGVydHksIHZhbHVlcykge1xuICAgIGlmIChwcm9wZXJ0eSA9PT0gJyR0eXBlJykgdmFsdWVzID0gdmFsdWVzLm1hcChmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdHlwZXMuaW5kZXhPZih2YWx1ZSk7IH0pO1xuICAgIHZhciBsZWZ0ID0gSlNPTi5zdHJpbmdpZnkodmFsdWVzLnNvcnQoY29tcGFyZSkpO1xuICAgIHZhciByaWdodCA9IGNvbXBpbGVQcm9wZXJ0eVJlZmVyZW5jZShwcm9wZXJ0eSk7XG5cbiAgICBpZiAodmFsdWVzLmxlbmd0aCA8PSAyMDApIHJldHVybiBsZWZ0ICsgJy5pbmRleE9mKCcgKyByaWdodCArICcpICE9PSAtMSc7XG5cbiAgICByZXR1cm4gJ2Z1bmN0aW9uKHYsIGEsIGksIGopIHsnICtcbiAgICAgICAgJ3doaWxlIChpIDw9IGopIHsgdmFyIG0gPSAoaSArIGopID4+IDE7JyArXG4gICAgICAgICcgICAgaWYgKGFbbV0gPT09IHYpIHJldHVybiB0cnVlOyBpZiAoYVttXSA+IHYpIGogPSBtIC0gMTsgZWxzZSBpID0gbSArIDE7JyArXG4gICAgICAgICd9JyArXG4gICAgJ3JldHVybiBmYWxzZTsgfSgnICsgcmlnaHQgKyAnLCAnICsgbGVmdCArICcsMCwnICsgKHZhbHVlcy5sZW5ndGggLSAxKSArICcpJztcbn1cblxuZnVuY3Rpb24gY29tcGlsZUhhc09wKHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByb3BlcnR5KSArICcgaW4gcCc7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVOZWdhdGlvbihleHByZXNzaW9uKSB7XG4gICAgcmV0dXJuICchKCcgKyBleHByZXNzaW9uICsgJyknO1xufVxuXG4vLyBDb21wYXJpc29uIGZ1bmN0aW9uIHRvIHNvcnQgbnVtYmVycyBhbmQgc3RyaW5nc1xuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xufVxuIiwidmFyIGdlb2pzb25BcmVhID0gcmVxdWlyZSgnZ2VvanNvbi1hcmVhJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmV3aW5kO1xuXG5mdW5jdGlvbiByZXdpbmQoZ2osIG91dGVyKSB7XG4gICAgc3dpdGNoICgoZ2ogJiYgZ2oudHlwZSkgfHwgbnVsbCkge1xuICAgICAgICBjYXNlICdGZWF0dXJlQ29sbGVjdGlvbic6XG4gICAgICAgICAgICBnai5mZWF0dXJlcyA9IGdqLmZlYXR1cmVzLm1hcChjdXJyeU91dGVyKHJld2luZCwgb3V0ZXIpKTtcbiAgICAgICAgICAgIHJldHVybiBnajtcbiAgICAgICAgY2FzZSAnRmVhdHVyZSc6XG4gICAgICAgICAgICBnai5nZW9tZXRyeSA9IHJld2luZChnai5nZW9tZXRyeSwgb3V0ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGdqO1xuICAgICAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgICAgICAgIHJldHVybiBjb3JyZWN0KGdqLCBvdXRlcik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZ2o7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjdXJyeU91dGVyKGEsIGIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oXykgeyByZXR1cm4gYShfLCBiKTsgfTtcbn1cblxuZnVuY3Rpb24gY29ycmVjdChfLCBvdXRlcikge1xuICAgIGlmIChfLnR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICBfLmNvb3JkaW5hdGVzID0gY29ycmVjdFJpbmdzKF8uY29vcmRpbmF0ZXMsIG91dGVyKTtcbiAgICB9IGVsc2UgaWYgKF8udHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgXy5jb29yZGluYXRlcyA9IF8uY29vcmRpbmF0ZXMubWFwKGN1cnJ5T3V0ZXIoY29ycmVjdFJpbmdzLCBvdXRlcikpO1xuICAgIH1cbiAgICByZXR1cm4gXztcbn1cblxuZnVuY3Rpb24gY29ycmVjdFJpbmdzKF8sIG91dGVyKSB7XG4gICAgb3V0ZXIgPSAhIW91dGVyO1xuICAgIF9bMF0gPSB3aW5kKF9bMF0sICFvdXRlcik7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9baV0gPSB3aW5kKF9baV0sIG91dGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIF87XG59XG5cbmZ1bmN0aW9uIHdpbmQoXywgZGlyKSB7XG4gICAgcmV0dXJuIGN3KF8pID09PSBkaXIgPyBfIDogXy5yZXZlcnNlKCk7XG59XG5cbmZ1bmN0aW9uIGN3KF8pIHtcbiAgICByZXR1cm4gZ2VvanNvbkFyZWEucmluZyhfKSA+PSAwO1xufVxuIiwidmFyIHdnczg0ID0gcmVxdWlyZSgnd2dzODQnKTtcblxubW9kdWxlLmV4cG9ydHMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbm1vZHVsZS5leHBvcnRzLnJpbmcgPSByaW5nQXJlYTtcblxuZnVuY3Rpb24gZ2VvbWV0cnkoXykge1xuICAgIGlmIChfLnR5cGUgPT09ICdQb2x5Z29uJykgcmV0dXJuIHBvbHlnb25BcmVhKF8uY29vcmRpbmF0ZXMpO1xuICAgIGVsc2UgaWYgKF8udHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgdmFyIGFyZWEgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF8uY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZWEgKz0gcG9seWdvbkFyZWEoXy5jb29yZGluYXRlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwb2x5Z29uQXJlYShjb29yZHMpIHtcbiAgICB2YXIgYXJlYSA9IDA7XG4gICAgaWYgKGNvb3JkcyAmJiBjb29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBhcmVhICs9IE1hdGguYWJzKHJpbmdBcmVhKGNvb3Jkc1swXSkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJlYSAtPSBNYXRoLmFicyhyaW5nQXJlYShjb29yZHNbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJlYTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGFwcHJveGltYXRlIGFyZWEgb2YgdGhlIHBvbHlnb24gd2VyZSBpdCBwcm9qZWN0ZWQgb250b1xuICogICAgIHRoZSBlYXJ0aC4gIE5vdGUgdGhhdCB0aGlzIGFyZWEgd2lsbCBiZSBwb3NpdGl2ZSBpZiByaW5nIGlzIG9yaWVudGVkXG4gKiAgICAgY2xvY2t3aXNlLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBuZWdhdGl2ZS5cbiAqXG4gKiBSZWZlcmVuY2U6XG4gKiBSb2JlcnQuIEcuIENoYW1iZXJsYWluIGFuZCBXaWxsaWFtIEguIER1cXVldHRlLCBcIlNvbWUgQWxnb3JpdGhtcyBmb3JcbiAqICAgICBQb2x5Z29ucyBvbiBhIFNwaGVyZVwiLCBKUEwgUHVibGljYXRpb24gMDctMDMsIEpldCBQcm9wdWxzaW9uXG4gKiAgICAgTGFib3JhdG9yeSwgUGFzYWRlbmEsIENBLCBKdW5lIDIwMDcgaHR0cDovL3Rycy1uZXcuanBsLm5hc2EuZ292L2RzcGFjZS9oYW5kbGUvMjAxNC80MDQwOVxuICpcbiAqIFJldHVybnM6XG4gKiB7ZmxvYXR9IFRoZSBhcHByb3hpbWF0ZSBzaWduZWQgZ2VvZGVzaWMgYXJlYSBvZiB0aGUgcG9seWdvbiBpbiBzcXVhcmVcbiAqICAgICBtZXRlcnMuXG4gKi9cblxuZnVuY3Rpb24gcmluZ0FyZWEoY29vcmRzKSB7XG4gICAgdmFyIGFyZWEgPSAwO1xuXG4gICAgaWYgKGNvb3Jkcy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHZhciBwMSwgcDI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgcDEgPSBjb29yZHNbaV07XG4gICAgICAgICAgICBwMiA9IGNvb3Jkc1tpICsgMV07XG4gICAgICAgICAgICBhcmVhICs9IHJhZChwMlswXSAtIHAxWzBdKSAqICgyICsgTWF0aC5zaW4ocmFkKHAxWzFdKSkgKyBNYXRoLnNpbihyYWQocDJbMV0pKSk7XG4gICAgICAgIH1cblxuICAgICAgICBhcmVhID0gYXJlYSAqIHdnczg0LlJBRElVUyAqIHdnczg0LlJBRElVUyAvIDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZWE7XG59XG5cbmZ1bmN0aW9uIHJhZChfKSB7XG4gICAgcmV0dXJuIF8gKiBNYXRoLlBJIC8gMTgwO1xufVxuIiwibW9kdWxlLmV4cG9ydHMuUkFESVVTID0gNjM3ODEzNztcbm1vZHVsZS5leHBvcnRzLkZMQVRURU5JTkcgPSAxLzI5OC4yNTcyMjM1NjM7XG5tb2R1bGUuZXhwb3J0cy5QT0xBUl9SQURJVVMgPSA2MzU2NzUyLjMxNDI7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xpcDtcblxuLyogY2xpcCBmZWF0dXJlcyBiZXR3ZWVuIHR3byBheGlzLXBhcmFsbGVsIGxpbmVzOlxuICogICAgIHwgICAgICAgIHxcbiAqICBfX198X19fICAgICB8ICAgICAvXG4gKiAvICAgfCAgIFxcX19fX3xfX19fL1xuICogICAgIHwgICAgICAgIHxcbiAqL1xuXG5mdW5jdGlvbiBjbGlwKGZlYXR1cmVzLCBzY2FsZSwgazEsIGsyLCBheGlzLCBpbnRlcnNlY3QsIG1pbkFsbCwgbWF4QWxsKSB7XG5cbiAgICBrMSAvPSBzY2FsZTtcbiAgICBrMiAvPSBzY2FsZTtcblxuICAgIGlmIChtaW5BbGwgPj0gazEgJiYgbWF4QWxsIDw9IGsyKSByZXR1cm4gZmVhdHVyZXM7IC8vIHRyaXZpYWwgYWNjZXB0XG4gICAgZWxzZSBpZiAobWluQWxsID4gazIgfHwgbWF4QWxsIDwgazEpIHJldHVybiBudWxsOyAvLyB0cml2aWFsIHJlamVjdFxuXG4gICAgdmFyIGNsaXBwZWQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2ldLFxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBmZWF0dXJlLmdlb21ldHJ5LFxuICAgICAgICAgICAgdHlwZSA9IGZlYXR1cmUudHlwZSxcbiAgICAgICAgICAgIG1pbiwgbWF4O1xuXG4gICAgICAgIG1pbiA9IGZlYXR1cmUubWluW2F4aXNdO1xuICAgICAgICBtYXggPSBmZWF0dXJlLm1heFtheGlzXTtcblxuICAgICAgICBpZiAobWluID49IGsxICYmIG1heCA8PSBrMikgeyAvLyB0cml2aWFsIGFjY2VwdFxuICAgICAgICAgICAgY2xpcHBlZC5wdXNoKGZlYXR1cmUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAobWluID4gazIgfHwgbWF4IDwgazEpIGNvbnRpbnVlOyAvLyB0cml2aWFsIHJlamVjdFxuXG4gICAgICAgIHZhciBzbGljZXMgPSB0eXBlID09PSAxID9cbiAgICAgICAgICAgICAgICBjbGlwUG9pbnRzKGdlb21ldHJ5LCBrMSwgazIsIGF4aXMpIDpcbiAgICAgICAgICAgICAgICBjbGlwR2VvbWV0cnkoZ2VvbWV0cnksIGsxLCBrMiwgYXhpcywgaW50ZXJzZWN0LCB0eXBlID09PSAzKTtcblxuICAgICAgICBpZiAoc2xpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gaWYgYSBmZWF0dXJlIGdvdCBjbGlwcGVkLCBpdCB3aWxsIGxpa2VseSBnZXQgY2xpcHBlZCBvbiB0aGUgbmV4dCB6b29tIGxldmVsIGFzIHdlbGwsXG4gICAgICAgICAgICAvLyBzbyB0aGVyZSdzIG5vIG5lZWQgdG8gcmVjYWxjdWxhdGUgYmJveGVzXG4gICAgICAgICAgICBjbGlwcGVkLnB1c2goe1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBzbGljZXMsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICB0YWdzOiBmZWF0dXJlc1tpXS50YWdzIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgbWluOiBmZWF0dXJlLm1pbixcbiAgICAgICAgICAgICAgICBtYXg6IGZlYXR1cmUubWF4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbGlwcGVkLmxlbmd0aCA/IGNsaXBwZWQgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBjbGlwUG9pbnRzKGdlb21ldHJ5LCBrMSwgazIsIGF4aXMpIHtcbiAgICB2YXIgc2xpY2UgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGEgPSBnZW9tZXRyeVtpXSxcbiAgICAgICAgICAgIGFrID0gYVtheGlzXTtcblxuICAgICAgICBpZiAoYWsgPj0gazEgJiYgYWsgPD0gazIpIHNsaWNlLnB1c2goYSk7XG4gICAgfVxuICAgIHJldHVybiBzbGljZTtcbn1cblxuZnVuY3Rpb24gY2xpcEdlb21ldHJ5KGdlb21ldHJ5LCBrMSwgazIsIGF4aXMsIGludGVyc2VjdCwgY2xvc2VkKSB7XG5cbiAgICB2YXIgc2xpY2VzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJ5Lmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgdmFyIGFrID0gMCxcbiAgICAgICAgICAgIGJrID0gMCxcbiAgICAgICAgICAgIGIgPSBudWxsLFxuICAgICAgICAgICAgcG9pbnRzID0gZ2VvbWV0cnlbaV0sXG4gICAgICAgICAgICBhcmVhID0gcG9pbnRzLmFyZWEsXG4gICAgICAgICAgICBkaXN0ID0gcG9pbnRzLmRpc3QsXG4gICAgICAgICAgICBvdXRlciA9IHBvaW50cy5vdXRlcixcbiAgICAgICAgICAgIGxlbiA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgICAgICBhLCBqLCBsYXN0O1xuXG4gICAgICAgIHZhciBzbGljZSA9IFtdO1xuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsZW4gLSAxOyBqKyspIHtcbiAgICAgICAgICAgIGEgPSBiIHx8IHBvaW50c1tqXTtcbiAgICAgICAgICAgIGIgPSBwb2ludHNbaiArIDFdO1xuICAgICAgICAgICAgYWsgPSBiayB8fCBhW2F4aXNdO1xuICAgICAgICAgICAgYmsgPSBiW2F4aXNdO1xuXG4gICAgICAgICAgICBpZiAoYWsgPCBrMSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKChiayA+IGsyKSkgeyAvLyAtLS18LS0tLS18LS0+XG4gICAgICAgICAgICAgICAgICAgIHNsaWNlLnB1c2goaW50ZXJzZWN0KGEsIGIsIGsxKSwgaW50ZXJzZWN0KGEsIGIsIGsyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKSBzbGljZSA9IG5ld1NsaWNlKHNsaWNlcywgc2xpY2UsIGFyZWEsIGRpc3QsIG91dGVyKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYmsgPj0gazEpIHNsaWNlLnB1c2goaW50ZXJzZWN0KGEsIGIsIGsxKSk7IC8vIC0tLXwtLT4gIHxcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChhayA+IGsyKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoKGJrIDwgazEpKSB7IC8vIDwtLXwtLS0tLXwtLS1cbiAgICAgICAgICAgICAgICAgICAgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazIpLCBpbnRlcnNlY3QoYSwgYiwgazEpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHNsaWNlID0gbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCwgb3V0ZXIpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiayA8PSBrMikgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazIpKTsgLy8gfCAgPC0tfC0tLVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgc2xpY2UucHVzaChhKTtcblxuICAgICAgICAgICAgICAgIGlmIChiayA8IGsxKSB7IC8vIDwtLXwtLS0gIHxcbiAgICAgICAgICAgICAgICAgICAgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazEpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHNsaWNlID0gbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCwgb3V0ZXIpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiayA+IGsyKSB7IC8vIHwgIC0tLXwtLT5cbiAgICAgICAgICAgICAgICAgICAgc2xpY2UucHVzaChpbnRlcnNlY3QoYSwgYiwgazIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHNsaWNlID0gbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCwgb3V0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB8IC0tPiB8XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdGhlIGxhc3QgcG9pbnRcbiAgICAgICAgYSA9IHBvaW50c1tsZW4gLSAxXTtcbiAgICAgICAgYWsgPSBhW2F4aXNdO1xuICAgICAgICBpZiAoYWsgPj0gazEgJiYgYWsgPD0gazIpIHNsaWNlLnB1c2goYSk7XG5cbiAgICAgICAgLy8gY2xvc2UgdGhlIHBvbHlnb24gaWYgaXRzIGVuZHBvaW50cyBhcmUgbm90IHRoZSBzYW1lIGFmdGVyIGNsaXBwaW5nXG5cbiAgICAgICAgbGFzdCA9IHNsaWNlW3NsaWNlLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoY2xvc2VkICYmIGxhc3QgJiYgKHNsaWNlWzBdWzBdICE9PSBsYXN0WzBdIHx8IHNsaWNlWzBdWzFdICE9PSBsYXN0WzFdKSkgc2xpY2UucHVzaChzbGljZVswXSk7XG5cbiAgICAgICAgLy8gYWRkIHRoZSBmaW5hbCBzbGljZVxuICAgICAgICBuZXdTbGljZShzbGljZXMsIHNsaWNlLCBhcmVhLCBkaXN0LCBvdXRlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNsaWNlcztcbn1cblxuZnVuY3Rpb24gbmV3U2xpY2Uoc2xpY2VzLCBzbGljZSwgYXJlYSwgZGlzdCwgb3V0ZXIpIHtcbiAgICBpZiAoc2xpY2UubGVuZ3RoKSB7XG4gICAgICAgIC8vIHdlIGRvbid0IHJlY2FsY3VsYXRlIHRoZSBhcmVhL2xlbmd0aCBvZiB0aGUgdW5jbGlwcGVkIGdlb21ldHJ5IGJlY2F1c2UgdGhlIGNhc2Ugd2hlcmUgaXQgZ29lc1xuICAgICAgICAvLyBiZWxvdyB0aGUgdmlzaWJpbGl0eSB0aHJlc2hvbGQgYXMgYSByZXN1bHQgb2YgY2xpcHBpbmcgaXMgcmFyZSwgc28gd2UgYXZvaWQgZG9pbmcgdW5uZWNlc3Nhcnkgd29ya1xuICAgICAgICBzbGljZS5hcmVhID0gYXJlYTtcbiAgICAgICAgc2xpY2UuZGlzdCA9IGRpc3Q7XG4gICAgICAgIGlmIChvdXRlciAhPT0gdW5kZWZpbmVkKSBzbGljZS5vdXRlciA9IG91dGVyO1xuXG4gICAgICAgIHNsaWNlcy5wdXNoKHNsaWNlKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnZlcnQ7XG5cbnZhciBzaW1wbGlmeSA9IHJlcXVpcmUoJy4vc2ltcGxpZnknKTtcblxuLy8gY29udmVydHMgR2VvSlNPTiBmZWF0dXJlIGludG8gYW4gaW50ZXJtZWRpYXRlIHByb2plY3RlZCBKU09OIHZlY3RvciBmb3JtYXQgd2l0aCBzaW1wbGlmaWNhdGlvbiBkYXRhXG5cbmZ1bmN0aW9uIGNvbnZlcnQoZGF0YSwgdG9sZXJhbmNlKSB7XG4gICAgdmFyIGZlYXR1cmVzID0gW107XG5cbiAgICBpZiAoZGF0YS50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29udmVydEZlYXR1cmUoZmVhdHVyZXMsIGRhdGEuZmVhdHVyZXNbaV0sIHRvbGVyYW5jZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XG4gICAgICAgIGNvbnZlcnRGZWF0dXJlKGZlYXR1cmVzLCBkYXRhLCB0b2xlcmFuY2UpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2luZ2xlIGdlb21ldHJ5IG9yIGEgZ2VvbWV0cnkgY29sbGVjdGlvblxuICAgICAgICBjb252ZXJ0RmVhdHVyZShmZWF0dXJlcywge2dlb21ldHJ5OiBkYXRhfSwgdG9sZXJhbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0RmVhdHVyZShmZWF0dXJlcywgZmVhdHVyZSwgdG9sZXJhbmNlKSB7XG4gICAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkgPT09IG51bGwpIHtcbiAgICAgICAgLy8gaWdub3JlIGZlYXR1cmVzIHdpdGggbnVsbCBnZW9tZXRyeVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGdlb20gPSBmZWF0dXJlLmdlb21ldHJ5LFxuICAgICAgICB0eXBlID0gZ2VvbS50eXBlLFxuICAgICAgICBjb29yZHMgPSBnZW9tLmNvb3JkaW5hdGVzLFxuICAgICAgICB0YWdzID0gZmVhdHVyZS5wcm9wZXJ0aWVzLFxuICAgICAgICBpLCBqLCByaW5ncywgcHJvamVjdGVkUmluZztcblxuICAgIGlmICh0eXBlID09PSAnUG9pbnQnKSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goY3JlYXRlKHRhZ3MsIDEsIFtwcm9qZWN0UG9pbnQoY29vcmRzKV0pKTtcblxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goY3JlYXRlKHRhZ3MsIDEsIHByb2plY3QoY29vcmRzKSkpO1xuXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTGluZVN0cmluZycpIHtcbiAgICAgICAgZmVhdHVyZXMucHVzaChjcmVhdGUodGFncywgMiwgW3Byb2plY3QoY29vcmRzLCB0b2xlcmFuY2UpXSkpO1xuXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnTXVsdGlMaW5lU3RyaW5nJyB8fCB0eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgcmluZ3MgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcHJvamVjdGVkUmluZyA9IHByb2plY3QoY29vcmRzW2ldLCB0b2xlcmFuY2UpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdQb2x5Z29uJykgcHJvamVjdGVkUmluZy5vdXRlciA9IChpID09PSAwKTtcbiAgICAgICAgICAgIHJpbmdzLnB1c2gocHJvamVjdGVkUmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZmVhdHVyZXMucHVzaChjcmVhdGUodGFncywgdHlwZSA9PT0gJ1BvbHlnb24nID8gMyA6IDIsIHJpbmdzKSk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIHJpbmdzID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb29yZHNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0ZWRSaW5nID0gcHJvamVjdChjb29yZHNbaV1bal0sIHRvbGVyYW5jZSk7XG4gICAgICAgICAgICAgICAgcHJvamVjdGVkUmluZy5vdXRlciA9IChqID09PSAwKTtcbiAgICAgICAgICAgICAgICByaW5ncy5wdXNoKHByb2plY3RlZFJpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZlYXR1cmVzLnB1c2goY3JlYXRlKHRhZ3MsIDMsIHJpbmdzKSk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZW9tLmdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnZlcnRGZWF0dXJlKGZlYXR1cmVzLCB7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IGdlb20uZ2VvbWV0cmllc1tpXSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB0YWdzXG4gICAgICAgICAgICB9LCB0b2xlcmFuY2UpO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgaXMgbm90IGEgdmFsaWQgR2VvSlNPTiBvYmplY3QuJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGUodGFncywgdHlwZSwgZ2VvbWV0cnkpIHtcbiAgICB2YXIgZmVhdHVyZSA9IHtcbiAgICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB0YWdzOiB0YWdzIHx8IG51bGwsXG4gICAgICAgIG1pbjogWzIsIDFdLCAvLyBpbml0aWFsIGJib3ggdmFsdWVzO1xuICAgICAgICBtYXg6IFstMSwgMF0gIC8vIG5vdGUgdGhhdCBjb29yZHMgYXJlIHVzdWFsbHkgaW4gWzAuLjFdIHJhbmdlXG4gICAgfTtcbiAgICBjYWxjQkJveChmZWF0dXJlKTtcbiAgICByZXR1cm4gZmVhdHVyZTtcbn1cblxuZnVuY3Rpb24gcHJvamVjdChsb25sYXRzLCB0b2xlcmFuY2UpIHtcbiAgICB2YXIgcHJvamVjdGVkID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb25sYXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByb2plY3RlZC5wdXNoKHByb2plY3RQb2ludChsb25sYXRzW2ldKSk7XG4gICAgfVxuICAgIGlmICh0b2xlcmFuY2UpIHtcbiAgICAgICAgc2ltcGxpZnkocHJvamVjdGVkLCB0b2xlcmFuY2UpO1xuICAgICAgICBjYWxjU2l6ZShwcm9qZWN0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvamVjdGVkO1xufVxuXG5mdW5jdGlvbiBwcm9qZWN0UG9pbnQocCkge1xuICAgIHZhciBzaW4gPSBNYXRoLnNpbihwWzFdICogTWF0aC5QSSAvIDE4MCksXG4gICAgICAgIHggPSAocFswXSAvIDM2MCArIDAuNSksXG4gICAgICAgIHkgPSAoMC41IC0gMC4yNSAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyBNYXRoLlBJKTtcblxuICAgIHkgPSB5IDwgMCA/IDAgOlxuICAgICAgICB5ID4gMSA/IDEgOiB5O1xuXG4gICAgcmV0dXJuIFt4LCB5LCAwXTtcbn1cblxuLy8gY2FsY3VsYXRlIGFyZWEgYW5kIGxlbmd0aCBvZiB0aGUgcG9seVxuZnVuY3Rpb24gY2FsY1NpemUocG9pbnRzKSB7XG4gICAgdmFyIGFyZWEgPSAwLFxuICAgICAgICBkaXN0ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBhLCBiOyBpIDwgcG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBhID0gYiB8fCBwb2ludHNbaV07XG4gICAgICAgIGIgPSBwb2ludHNbaSArIDFdO1xuXG4gICAgICAgIGFyZWEgKz0gYVswXSAqIGJbMV0gLSBiWzBdICogYVsxXTtcblxuICAgICAgICAvLyB1c2UgTWFuaGF0dGFuIGRpc3RhbmNlIGluc3RlYWQgb2YgRXVjbGlkaWFuIG9uZSB0byBhdm9pZCBleHBlbnNpdmUgc3F1YXJlIHJvb3QgY29tcHV0YXRpb25cbiAgICAgICAgZGlzdCArPSBNYXRoLmFicyhiWzBdIC0gYVswXSkgKyBNYXRoLmFicyhiWzFdIC0gYVsxXSk7XG4gICAgfVxuICAgIHBvaW50cy5hcmVhID0gTWF0aC5hYnMoYXJlYSAvIDIpO1xuICAgIHBvaW50cy5kaXN0ID0gZGlzdDtcbn1cblxuLy8gY2FsY3VsYXRlIHRoZSBmZWF0dXJlIGJvdW5kaW5nIGJveCBmb3IgZmFzdGVyIGNsaXBwaW5nIGxhdGVyXG5mdW5jdGlvbiBjYWxjQkJveChmZWF0dXJlKSB7XG4gICAgdmFyIGdlb21ldHJ5ID0gZmVhdHVyZS5nZW9tZXRyeSxcbiAgICAgICAgbWluID0gZmVhdHVyZS5taW4sXG4gICAgICAgIG1heCA9IGZlYXR1cmUubWF4O1xuXG4gICAgaWYgKGZlYXR1cmUudHlwZSA9PT0gMSkgY2FsY1JpbmdCQm94KG1pbiwgbWF4LCBnZW9tZXRyeSk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJ5Lmxlbmd0aDsgaSsrKSBjYWxjUmluZ0JCb3gobWluLCBtYXgsIGdlb21ldHJ5W2ldKTtcblxuICAgIHJldHVybiBmZWF0dXJlO1xufVxuXG5mdW5jdGlvbiBjYWxjUmluZ0JCb3gobWluLCBtYXgsIHBvaW50cykge1xuICAgIGZvciAodmFyIGkgPSAwLCBwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHAgPSBwb2ludHNbaV07XG4gICAgICAgIG1pblswXSA9IE1hdGgubWluKHBbMF0sIG1pblswXSk7XG4gICAgICAgIG1heFswXSA9IE1hdGgubWF4KHBbMF0sIG1heFswXSk7XG4gICAgICAgIG1pblsxXSA9IE1hdGgubWluKHBbMV0sIG1pblsxXSk7XG4gICAgICAgIG1heFsxXSA9IE1hdGgubWF4KHBbMV0sIG1heFsxXSk7XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdlb2pzb252dDtcblxudmFyIGNvbnZlcnQgPSByZXF1aXJlKCcuL2NvbnZlcnQnKSwgICAgIC8vIEdlb0pTT04gY29udmVyc2lvbiBhbmQgcHJlcHJvY2Vzc2luZ1xuICAgIHRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtJyksIC8vIGNvb3JkaW5hdGUgdHJhbnNmb3JtYXRpb25cbiAgICBjbGlwID0gcmVxdWlyZSgnLi9jbGlwJyksICAgICAgICAgICAvLyBzdHJpcGUgY2xpcHBpbmcgYWxnb3JpdGhtXG4gICAgd3JhcCA9IHJlcXVpcmUoJy4vd3JhcCcpLCAgICAgICAgICAgLy8gZGF0ZSBsaW5lIHByb2Nlc3NpbmdcbiAgICBjcmVhdGVUaWxlID0gcmVxdWlyZSgnLi90aWxlJyk7ICAgICAvLyBmaW5hbCBzaW1wbGlmaWVkIHRpbGUgZ2VuZXJhdGlvblxuXG5cbmZ1bmN0aW9uIGdlb2pzb252dChkYXRhLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBHZW9KU09OVlQoZGF0YSwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIEdlb0pTT05WVChkYXRhLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyA9IGV4dGVuZChPYmplY3QuY3JlYXRlKHRoaXMub3B0aW9ucyksIG9wdGlvbnMpO1xuXG4gICAgdmFyIGRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcblxuICAgIGlmIChkZWJ1ZykgY29uc29sZS50aW1lKCdwcmVwcm9jZXNzIGRhdGEnKTtcblxuICAgIHZhciB6MiA9IDEgPDwgb3B0aW9ucy5tYXhab29tLCAvLyAyXnpcbiAgICAgICAgZmVhdHVyZXMgPSBjb252ZXJ0KGRhdGEsIG9wdGlvbnMudG9sZXJhbmNlIC8gKHoyICogb3B0aW9ucy5leHRlbnQpKTtcblxuICAgIHRoaXMudGlsZXMgPSB7fTtcbiAgICB0aGlzLnRpbGVDb29yZHMgPSBbXTtcblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBjb25zb2xlLnRpbWVFbmQoJ3ByZXByb2Nlc3MgZGF0YScpO1xuICAgICAgICBjb25zb2xlLmxvZygnaW5kZXg6IG1heFpvb206ICVkLCBtYXhQb2ludHM6ICVkJywgb3B0aW9ucy5pbmRleE1heFpvb20sIG9wdGlvbnMuaW5kZXhNYXhQb2ludHMpO1xuICAgICAgICBjb25zb2xlLnRpbWUoJ2dlbmVyYXRlIHRpbGVzJyk7XG4gICAgICAgIHRoaXMuc3RhdHMgPSB7fTtcbiAgICAgICAgdGhpcy50b3RhbCA9IDA7XG4gICAgfVxuXG4gICAgZmVhdHVyZXMgPSB3cmFwKGZlYXR1cmVzLCBvcHRpb25zLmJ1ZmZlciAvIG9wdGlvbnMuZXh0ZW50LCBpbnRlcnNlY3RYKTtcblxuICAgIC8vIHN0YXJ0IHNsaWNpbmcgZnJvbSB0aGUgdG9wIHRpbGUgZG93blxuICAgIGlmIChmZWF0dXJlcy5sZW5ndGgpIHRoaXMuc3BsaXRUaWxlKGZlYXR1cmVzLCAwLCAwLCAwKTtcblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBpZiAoZmVhdHVyZXMubGVuZ3RoKSBjb25zb2xlLmxvZygnZmVhdHVyZXM6ICVkLCBwb2ludHM6ICVkJywgdGhpcy50aWxlc1swXS5udW1GZWF0dXJlcywgdGhpcy50aWxlc1swXS5udW1Qb2ludHMpO1xuICAgICAgICBjb25zb2xlLnRpbWVFbmQoJ2dlbmVyYXRlIHRpbGVzJyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCd0aWxlcyBnZW5lcmF0ZWQ6JywgdGhpcy50b3RhbCwgSlNPTi5zdHJpbmdpZnkodGhpcy5zdGF0cykpO1xuICAgIH1cbn1cblxuR2VvSlNPTlZULnByb3RvdHlwZS5vcHRpb25zID0ge1xuICAgIG1heFpvb206IDE0LCAgICAgICAgICAgIC8vIG1heCB6b29tIHRvIHByZXNlcnZlIGRldGFpbCBvblxuICAgIGluZGV4TWF4Wm9vbTogNSwgICAgICAgIC8vIG1heCB6b29tIGluIHRoZSB0aWxlIGluZGV4XG4gICAgaW5kZXhNYXhQb2ludHM6IDEwMDAwMCwgLy8gbWF4IG51bWJlciBvZiBwb2ludHMgcGVyIHRpbGUgaW4gdGhlIHRpbGUgaW5kZXhcbiAgICBzb2xpZENoaWxkcmVuOiBmYWxzZSwgICAvLyB3aGV0aGVyIHRvIHRpbGUgc29saWQgc3F1YXJlIHRpbGVzIGZ1cnRoZXJcbiAgICB0b2xlcmFuY2U6IDMsICAgICAgICAgICAvLyBzaW1wbGlmaWNhdGlvbiB0b2xlcmFuY2UgKGhpZ2hlciBtZWFucyBzaW1wbGVyKVxuICAgIGV4dGVudDogNDA5NiwgICAgICAgICAgIC8vIHRpbGUgZXh0ZW50XG4gICAgYnVmZmVyOiA2NCwgICAgICAgICAgICAgLy8gdGlsZSBidWZmZXIgb24gZWFjaCBzaWRlXG4gICAgZGVidWc6IDAgICAgICAgICAgICAgICAgLy8gbG9nZ2luZyBsZXZlbCAoMCwgMSBvciAyKVxufTtcblxuR2VvSlNPTlZULnByb3RvdHlwZS5zcGxpdFRpbGUgPSBmdW5jdGlvbiAoZmVhdHVyZXMsIHosIHgsIHksIGN6LCBjeCwgY3kpIHtcblxuICAgIHZhciBzdGFjayA9IFtmZWF0dXJlcywgeiwgeCwgeV0sXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGRlYnVnID0gb3B0aW9ucy5kZWJ1ZyxcbiAgICAgICAgc29saWQgPSBudWxsO1xuXG4gICAgLy8gYXZvaWQgcmVjdXJzaW9uIGJ5IHVzaW5nIGEgcHJvY2Vzc2luZyBxdWV1ZVxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgeSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB4ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHogPSBzdGFjay5wb3AoKTtcbiAgICAgICAgZmVhdHVyZXMgPSBzdGFjay5wb3AoKTtcblxuICAgICAgICB2YXIgejIgPSAxIDw8IHosXG4gICAgICAgICAgICBpZCA9IHRvSUQoeiwgeCwgeSksXG4gICAgICAgICAgICB0aWxlID0gdGhpcy50aWxlc1tpZF0sXG4gICAgICAgICAgICB0aWxlVG9sZXJhbmNlID0geiA9PT0gb3B0aW9ucy5tYXhab29tID8gMCA6IG9wdGlvbnMudG9sZXJhbmNlIC8gKHoyICogb3B0aW9ucy5leHRlbnQpO1xuXG4gICAgICAgIGlmICghdGlsZSkge1xuICAgICAgICAgICAgaWYgKGRlYnVnID4gMSkgY29uc29sZS50aW1lKCdjcmVhdGlvbicpO1xuXG4gICAgICAgICAgICB0aWxlID0gdGhpcy50aWxlc1tpZF0gPSBjcmVhdGVUaWxlKGZlYXR1cmVzLCB6MiwgeCwgeSwgdGlsZVRvbGVyYW5jZSwgeiA9PT0gb3B0aW9ucy5tYXhab29tKTtcbiAgICAgICAgICAgIHRoaXMudGlsZUNvb3Jkcy5wdXNoKHt6OiB6LCB4OiB4LCB5OiB5fSk7XG5cbiAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgIGlmIChkZWJ1ZyA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3RpbGUgeiVkLSVkLSVkIChmZWF0dXJlczogJWQsIHBvaW50czogJWQsIHNpbXBsaWZpZWQ6ICVkKScsXG4gICAgICAgICAgICAgICAgICAgICAgICB6LCB4LCB5LCB0aWxlLm51bUZlYXR1cmVzLCB0aWxlLm51bVBvaW50cywgdGlsZS5udW1TaW1wbGlmaWVkKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS50aW1lRW5kKCdjcmVhdGlvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gJ3onICsgejtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRzW2tleV0gPSAodGhpcy5zdGF0c1trZXldIHx8IDApICsgMTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvdGFsKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBnZW9tZXRyeSBpbiB0aWxlIHNvIHRoYXQgd2UgY2FuIGRyaWxsIGRvd24gbGF0ZXIgaWYgd2Ugc3RvcCBub3dcbiAgICAgICAgdGlsZS5zb3VyY2UgPSBmZWF0dXJlcztcblxuICAgICAgICAvLyBpZiBpdCdzIHRoZSBmaXJzdC1wYXNzIHRpbGluZ1xuICAgICAgICBpZiAoIWN6KSB7XG4gICAgICAgICAgICAvLyBzdG9wIHRpbGluZyBpZiB3ZSByZWFjaGVkIG1heCB6b29tLCBvciBpZiB0aGUgdGlsZSBpcyB0b28gc2ltcGxlXG4gICAgICAgICAgICBpZiAoeiA9PT0gb3B0aW9ucy5pbmRleE1heFpvb20gfHwgdGlsZS5udW1Qb2ludHMgPD0gb3B0aW9ucy5pbmRleE1heFBvaW50cykgY29udGludWU7XG5cbiAgICAgICAgLy8gaWYgYSBkcmlsbGRvd24gdG8gYSBzcGVjaWZpYyB0aWxlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzdG9wIHRpbGluZyBpZiB3ZSByZWFjaGVkIGJhc2Ugem9vbSBvciBvdXIgdGFyZ2V0IHRpbGUgem9vbVxuICAgICAgICAgICAgaWYgKHogPT09IG9wdGlvbnMubWF4Wm9vbSB8fCB6ID09PSBjeikgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIHN0b3AgdGlsaW5nIGlmIGl0J3Mgbm90IGFuIGFuY2VzdG9yIG9mIHRoZSB0YXJnZXQgdGlsZVxuICAgICAgICAgICAgdmFyIG0gPSAxIDw8IChjeiAtIHopO1xuICAgICAgICAgICAgaWYgKHggIT09IE1hdGguZmxvb3IoY3ggLyBtKSB8fCB5ICE9PSBNYXRoLmZsb29yKGN5IC8gbSkpIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcCB0aWxpbmcgaWYgdGhlIHRpbGUgaXMgc29saWQgY2xpcHBlZCBzcXVhcmVcbiAgICAgICAgaWYgKCFvcHRpb25zLnNvbGlkQ2hpbGRyZW4gJiYgaXNDbGlwcGVkU3F1YXJlKHRpbGUsIG9wdGlvbnMuZXh0ZW50LCBvcHRpb25zLmJ1ZmZlcikpIHtcbiAgICAgICAgICAgIGlmIChjeikgc29saWQgPSB6OyAvLyBhbmQgcmVtZW1iZXIgdGhlIHpvb20gaWYgd2UncmUgZHJpbGxpbmcgZG93blxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBzbGljZSBmdXJ0aGVyIGRvd24sIG5vIG5lZWQgdG8ga2VlcCBzb3VyY2UgZ2VvbWV0cnlcbiAgICAgICAgdGlsZS5zb3VyY2UgPSBudWxsO1xuXG4gICAgICAgIGlmIChkZWJ1ZyA+IDEpIGNvbnNvbGUudGltZSgnY2xpcHBpbmcnKTtcblxuICAgICAgICAvLyB2YWx1ZXMgd2UnbGwgdXNlIGZvciBjbGlwcGluZ1xuICAgICAgICB2YXIgazEgPSAwLjUgKiBvcHRpb25zLmJ1ZmZlciAvIG9wdGlvbnMuZXh0ZW50LFxuICAgICAgICAgICAgazIgPSAwLjUgLSBrMSxcbiAgICAgICAgICAgIGszID0gMC41ICsgazEsXG4gICAgICAgICAgICBrNCA9IDEgKyBrMSxcbiAgICAgICAgICAgIHRsLCBibCwgdHIsIGJyLCBsZWZ0LCByaWdodDtcblxuICAgICAgICB0bCA9IGJsID0gdHIgPSBiciA9IG51bGw7XG5cbiAgICAgICAgbGVmdCAgPSBjbGlwKGZlYXR1cmVzLCB6MiwgeCAtIGsxLCB4ICsgazMsIDAsIGludGVyc2VjdFgsIHRpbGUubWluWzBdLCB0aWxlLm1heFswXSk7XG4gICAgICAgIHJpZ2h0ID0gY2xpcChmZWF0dXJlcywgejIsIHggKyBrMiwgeCArIGs0LCAwLCBpbnRlcnNlY3RYLCB0aWxlLm1pblswXSwgdGlsZS5tYXhbMF0pO1xuXG4gICAgICAgIGlmIChsZWZ0KSB7XG4gICAgICAgICAgICB0bCA9IGNsaXAobGVmdCwgejIsIHkgLSBrMSwgeSArIGszLCAxLCBpbnRlcnNlY3RZLCB0aWxlLm1pblsxXSwgdGlsZS5tYXhbMV0pO1xuICAgICAgICAgICAgYmwgPSBjbGlwKGxlZnQsIHoyLCB5ICsgazIsIHkgKyBrNCwgMSwgaW50ZXJzZWN0WSwgdGlsZS5taW5bMV0sIHRpbGUubWF4WzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyaWdodCkge1xuICAgICAgICAgICAgdHIgPSBjbGlwKHJpZ2h0LCB6MiwgeSAtIGsxLCB5ICsgazMsIDEsIGludGVyc2VjdFksIHRpbGUubWluWzFdLCB0aWxlLm1heFsxXSk7XG4gICAgICAgICAgICBiciA9IGNsaXAocmlnaHQsIHoyLCB5ICsgazIsIHkgKyBrNCwgMSwgaW50ZXJzZWN0WSwgdGlsZS5taW5bMV0sIHRpbGUubWF4WzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWJ1ZyA+IDEpIGNvbnNvbGUudGltZUVuZCgnY2xpcHBpbmcnKTtcblxuICAgICAgICBpZiAodGwpIHN0YWNrLnB1c2godGwsIHogKyAxLCB4ICogMiwgICAgIHkgKiAyKTtcbiAgICAgICAgaWYgKGJsKSBzdGFjay5wdXNoKGJsLCB6ICsgMSwgeCAqIDIsICAgICB5ICogMiArIDEpO1xuICAgICAgICBpZiAodHIpIHN0YWNrLnB1c2godHIsIHogKyAxLCB4ICogMiArIDEsIHkgKiAyKTtcbiAgICAgICAgaWYgKGJyKSBzdGFjay5wdXNoKGJyLCB6ICsgMSwgeCAqIDIgKyAxLCB5ICogMiArIDEpO1xuICAgIH1cblxuICAgIHJldHVybiBzb2xpZDtcbn07XG5cbkdlb0pTT05WVC5wcm90b3R5cGUuZ2V0VGlsZSA9IGZ1bmN0aW9uICh6LCB4LCB5KSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIGV4dGVudCA9IG9wdGlvbnMuZXh0ZW50LFxuICAgICAgICBkZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG5cbiAgICB2YXIgejIgPSAxIDw8IHo7XG4gICAgeCA9ICgoeCAlIHoyKSArIHoyKSAlIHoyOyAvLyB3cmFwIHRpbGUgeCBjb29yZGluYXRlXG5cbiAgICB2YXIgaWQgPSB0b0lEKHosIHgsIHkpO1xuICAgIGlmICh0aGlzLnRpbGVzW2lkXSkgcmV0dXJuIHRyYW5zZm9ybS50aWxlKHRoaXMudGlsZXNbaWRdLCBleHRlbnQpO1xuXG4gICAgaWYgKGRlYnVnID4gMSkgY29uc29sZS5sb2coJ2RyaWxsaW5nIGRvd24gdG8geiVkLSVkLSVkJywgeiwgeCwgeSk7XG5cbiAgICB2YXIgejAgPSB6LFxuICAgICAgICB4MCA9IHgsXG4gICAgICAgIHkwID0geSxcbiAgICAgICAgcGFyZW50O1xuXG4gICAgd2hpbGUgKCFwYXJlbnQgJiYgejAgPiAwKSB7XG4gICAgICAgIHowLS07XG4gICAgICAgIHgwID0gTWF0aC5mbG9vcih4MCAvIDIpO1xuICAgICAgICB5MCA9IE1hdGguZmxvb3IoeTAgLyAyKTtcbiAgICAgICAgcGFyZW50ID0gdGhpcy50aWxlc1t0b0lEKHowLCB4MCwgeTApXTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmVudCB8fCAhcGFyZW50LnNvdXJjZSkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBpZiB3ZSBmb3VuZCBhIHBhcmVudCB0aWxlIGNvbnRhaW5pbmcgdGhlIG9yaWdpbmFsIGdlb21ldHJ5LCB3ZSBjYW4gZHJpbGwgZG93biBmcm9tIGl0XG4gICAgaWYgKGRlYnVnID4gMSkgY29uc29sZS5sb2coJ2ZvdW5kIHBhcmVudCB0aWxlIHolZC0lZC0lZCcsIHowLCB4MCwgeTApO1xuXG4gICAgLy8gaXQgcGFyZW50IHRpbGUgaXMgYSBzb2xpZCBjbGlwcGVkIHNxdWFyZSwgcmV0dXJuIGl0IGluc3RlYWQgc2luY2UgaXQncyBpZGVudGljYWxcbiAgICBpZiAoaXNDbGlwcGVkU3F1YXJlKHBhcmVudCwgZXh0ZW50LCBvcHRpb25zLmJ1ZmZlcikpIHJldHVybiB0cmFuc2Zvcm0udGlsZShwYXJlbnQsIGV4dGVudCk7XG5cbiAgICBpZiAoZGVidWcgPiAxKSBjb25zb2xlLnRpbWUoJ2RyaWxsaW5nIGRvd24nKTtcbiAgICB2YXIgc29saWQgPSB0aGlzLnNwbGl0VGlsZShwYXJlbnQuc291cmNlLCB6MCwgeDAsIHkwLCB6LCB4LCB5KTtcbiAgICBpZiAoZGVidWcgPiAxKSBjb25zb2xlLnRpbWVFbmQoJ2RyaWxsaW5nIGRvd24nKTtcblxuICAgIC8vIG9uZSBvZiB0aGUgcGFyZW50IHRpbGVzIHdhcyBhIHNvbGlkIGNsaXBwZWQgc3F1YXJlXG4gICAgaWYgKHNvbGlkICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBtID0gMSA8PCAoeiAtIHNvbGlkKTtcbiAgICAgICAgaWQgPSB0b0lEKHNvbGlkLCBNYXRoLmZsb29yKHggLyBtKSwgTWF0aC5mbG9vcih5IC8gbSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRpbGVzW2lkXSA/IHRyYW5zZm9ybS50aWxlKHRoaXMudGlsZXNbaWRdLCBleHRlbnQpIDogbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHRvSUQoeiwgeCwgeSkge1xuICAgIHJldHVybiAoKCgxIDw8IHopICogeSArIHgpICogMzIpICsgejtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0WChhLCBiLCB4KSB7XG4gICAgcmV0dXJuIFt4LCAoeCAtIGFbMF0pICogKGJbMV0gLSBhWzFdKSAvIChiWzBdIC0gYVswXSkgKyBhWzFdLCAxXTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdFkoYSwgYiwgeSkge1xuICAgIHJldHVybiBbKHkgLSBhWzFdKSAqIChiWzBdIC0gYVswXSkgLyAoYlsxXSAtIGFbMV0pICsgYVswXSwgeSwgMV07XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzcmMpIHtcbiAgICBmb3IgKHZhciBpIGluIHNyYykgZGVzdFtpXSA9IHNyY1tpXTtcbiAgICByZXR1cm4gZGVzdDtcbn1cblxuLy8gY2hlY2tzIHdoZXRoZXIgYSB0aWxlIGlzIGEgd2hvbGUtYXJlYSBmaWxsIGFmdGVyIGNsaXBwaW5nOyBpZiBpdCBpcywgdGhlcmUncyBubyBzZW5zZSBzbGljaW5nIGl0IGZ1cnRoZXJcbmZ1bmN0aW9uIGlzQ2xpcHBlZFNxdWFyZSh0aWxlLCBleHRlbnQsIGJ1ZmZlcikge1xuXG4gICAgdmFyIGZlYXR1cmVzID0gdGlsZS5zb3VyY2U7XG4gICAgaWYgKGZlYXR1cmVzLmxlbmd0aCAhPT0gMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlc1swXTtcbiAgICBpZiAoZmVhdHVyZS50eXBlICE9PSAzIHx8IGZlYXR1cmUuZ2VvbWV0cnkubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbiA9IGZlYXR1cmUuZ2VvbWV0cnlbMF0ubGVuZ3RoO1xuICAgIGlmIChsZW4gIT09IDUpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHAgPSB0cmFuc2Zvcm0ucG9pbnQoZmVhdHVyZS5nZW9tZXRyeVswXVtpXSwgZXh0ZW50LCB0aWxlLnoyLCB0aWxlLngsIHRpbGUueSk7XG4gICAgICAgIGlmICgocFswXSAhPT0gLWJ1ZmZlciAmJiBwWzBdICE9PSBleHRlbnQgKyBidWZmZXIpIHx8XG4gICAgICAgICAgICAocFsxXSAhPT0gLWJ1ZmZlciAmJiBwWzFdICE9PSBleHRlbnQgKyBidWZmZXIpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gc2ltcGxpZnk7XG5cbi8vIGNhbGN1bGF0ZSBzaW1wbGlmaWNhdGlvbiBkYXRhIHVzaW5nIG9wdGltaXplZCBEb3VnbGFzLVBldWNrZXIgYWxnb3JpdGhtXG5cbmZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50cywgdG9sZXJhbmNlKSB7XG5cbiAgICB2YXIgc3FUb2xlcmFuY2UgPSB0b2xlcmFuY2UgKiB0b2xlcmFuY2UsXG4gICAgICAgIGxlbiA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIGZpcnN0ID0gMCxcbiAgICAgICAgbGFzdCA9IGxlbiAtIDEsXG4gICAgICAgIHN0YWNrID0gW10sXG4gICAgICAgIGksIG1heFNxRGlzdCwgc3FEaXN0LCBpbmRleDtcblxuICAgIC8vIGFsd2F5cyByZXRhaW4gdGhlIGVuZHBvaW50cyAoMSBpcyB0aGUgbWF4IHZhbHVlKVxuICAgIHBvaW50c1tmaXJzdF1bMl0gPSAxO1xuICAgIHBvaW50c1tsYXN0XVsyXSA9IDE7XG5cbiAgICAvLyBhdm9pZCByZWN1cnNpb24gYnkgdXNpbmcgYSBzdGFja1xuICAgIHdoaWxlIChsYXN0KSB7XG5cbiAgICAgICAgbWF4U3FEaXN0ID0gMDtcblxuICAgICAgICBmb3IgKGkgPSBmaXJzdCArIDE7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgICAgICAgIHNxRGlzdCA9IGdldFNxU2VnRGlzdChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSk7XG5cbiAgICAgICAgICAgIGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgbWF4U3FEaXN0ID0gc3FEaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heFNxRGlzdCA+IHNxVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICBwb2ludHNbaW5kZXhdWzJdID0gbWF4U3FEaXN0OyAvLyBzYXZlIHRoZSBwb2ludCBpbXBvcnRhbmNlIGluIHNxdWFyZWQgcGl4ZWxzIGFzIGEgeiBjb29yZGluYXRlXG4gICAgICAgICAgICBzdGFjay5wdXNoKGZpcnN0KTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgZmlyc3QgPSBpbmRleDtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgZmlyc3QgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gc3F1YXJlIGRpc3RhbmNlIGZyb20gYSBwb2ludCB0byBhIHNlZ21lbnRcbmZ1bmN0aW9uIGdldFNxU2VnRGlzdChwLCBhLCBiKSB7XG5cbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSxcbiAgICAgICAgcHggPSBwWzBdLCBweSA9IHBbMV0sXG4gICAgICAgIGR4ID0gYnggLSB4LFxuICAgICAgICBkeSA9IGJ5IC0geTtcblxuICAgIGlmIChkeCAhPT0gMCB8fCBkeSAhPT0gMCkge1xuXG4gICAgICAgIHZhciB0ID0gKChweCAtIHgpICogZHggKyAocHkgLSB5KSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgaWYgKHQgPiAxKSB7XG4gICAgICAgICAgICB4ID0gYng7XG4gICAgICAgICAgICB5ID0gYnk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0ID4gMCkge1xuICAgICAgICAgICAgeCArPSBkeCAqIHQ7XG4gICAgICAgICAgICB5ICs9IGR5ICogdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGR4ID0gcHggLSB4O1xuICAgIGR5ID0gcHkgLSB5O1xuXG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVRpbGU7XG5cbmZ1bmN0aW9uIGNyZWF0ZVRpbGUoZmVhdHVyZXMsIHoyLCB0eCwgdHksIHRvbGVyYW5jZSwgbm9TaW1wbGlmeSkge1xuICAgIHZhciB0aWxlID0ge1xuICAgICAgICBmZWF0dXJlczogW10sXG4gICAgICAgIG51bVBvaW50czogMCxcbiAgICAgICAgbnVtU2ltcGxpZmllZDogMCxcbiAgICAgICAgbnVtRmVhdHVyZXM6IDAsXG4gICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgeDogdHgsXG4gICAgICAgIHk6IHR5LFxuICAgICAgICB6MjogejIsXG4gICAgICAgIHRyYW5zZm9ybWVkOiBmYWxzZSxcbiAgICAgICAgbWluOiBbMiwgMV0sXG4gICAgICAgIG1heDogWy0xLCAwXVxuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aWxlLm51bUZlYXR1cmVzKys7XG4gICAgICAgIGFkZEZlYXR1cmUodGlsZSwgZmVhdHVyZXNbaV0sIHRvbGVyYW5jZSwgbm9TaW1wbGlmeSk7XG5cbiAgICAgICAgdmFyIG1pbiA9IGZlYXR1cmVzW2ldLm1pbixcbiAgICAgICAgICAgIG1heCA9IGZlYXR1cmVzW2ldLm1heDtcblxuICAgICAgICBpZiAobWluWzBdIDwgdGlsZS5taW5bMF0pIHRpbGUubWluWzBdID0gbWluWzBdO1xuICAgICAgICBpZiAobWluWzFdIDwgdGlsZS5taW5bMV0pIHRpbGUubWluWzFdID0gbWluWzFdO1xuICAgICAgICBpZiAobWF4WzBdID4gdGlsZS5tYXhbMF0pIHRpbGUubWF4WzBdID0gbWF4WzBdO1xuICAgICAgICBpZiAobWF4WzFdID4gdGlsZS5tYXhbMV0pIHRpbGUubWF4WzFdID0gbWF4WzFdO1xuICAgIH1cbiAgICByZXR1cm4gdGlsZTtcbn1cblxuZnVuY3Rpb24gYWRkRmVhdHVyZSh0aWxlLCBmZWF0dXJlLCB0b2xlcmFuY2UsIG5vU2ltcGxpZnkpIHtcblxuICAgIHZhciBnZW9tID0gZmVhdHVyZS5nZW9tZXRyeSxcbiAgICAgICAgdHlwZSA9IGZlYXR1cmUudHlwZSxcbiAgICAgICAgc2ltcGxpZmllZCA9IFtdLFxuICAgICAgICBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZSxcbiAgICAgICAgaSwgaiwgcmluZywgcDtcblxuICAgIGlmICh0eXBlID09PSAxKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZW9tLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzaW1wbGlmaWVkLnB1c2goZ2VvbVtpXSk7XG4gICAgICAgICAgICB0aWxlLm51bVBvaW50cysrO1xuICAgICAgICAgICAgdGlsZS5udW1TaW1wbGlmaWVkKys7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gc2ltcGxpZnkgYW5kIHRyYW5zZm9ybSBwcm9qZWN0ZWQgY29vcmRpbmF0ZXMgZm9yIHRpbGUgZ2VvbWV0cnlcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdlb20ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJpbmcgPSBnZW9tW2ldO1xuXG4gICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IHRpbnkgcG9seWxpbmVzICYgcG9seWdvbnNcbiAgICAgICAgICAgIGlmICghbm9TaW1wbGlmeSAmJiAoKHR5cGUgPT09IDIgJiYgcmluZy5kaXN0IDwgdG9sZXJhbmNlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZSA9PT0gMyAmJiByaW5nLmFyZWEgPCBzcVRvbGVyYW5jZSkpKSB7XG4gICAgICAgICAgICAgICAgdGlsZS5udW1Qb2ludHMgKz0gcmluZy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzaW1wbGlmaWVkUmluZyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcmluZy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHAgPSByaW5nW2pdO1xuICAgICAgICAgICAgICAgIC8vIGtlZXAgcG9pbnRzIHdpdGggaW1wb3J0YW5jZSA+IHRvbGVyYW5jZVxuICAgICAgICAgICAgICAgIGlmIChub1NpbXBsaWZ5IHx8IHBbMl0gPiBzcVRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBzaW1wbGlmaWVkUmluZy5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB0aWxlLm51bVNpbXBsaWZpZWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGlsZS5udW1Qb2ludHMrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IDMpIHJld2luZChzaW1wbGlmaWVkUmluZywgcmluZy5vdXRlcik7XG5cbiAgICAgICAgICAgIHNpbXBsaWZpZWQucHVzaChzaW1wbGlmaWVkUmluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2ltcGxpZmllZC5sZW5ndGgpIHtcbiAgICAgICAgdGlsZS5mZWF0dXJlcy5wdXNoKHtcbiAgICAgICAgICAgIGdlb21ldHJ5OiBzaW1wbGlmaWVkLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHRhZ3M6IGZlYXR1cmUudGFncyB8fCBudWxsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmV3aW5kKHJpbmcsIGNsb2Nrd2lzZSkge1xuICAgIHZhciBhcmVhID0gc2lnbmVkQXJlYShyaW5nKTtcbiAgICBpZiAoYXJlYSA8IDAgPT09IGNsb2Nrd2lzZSkgcmluZy5yZXZlcnNlKCk7XG59XG5cbmZ1bmN0aW9uIHNpZ25lZEFyZWEocmluZykge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByaW5nLmxlbmd0aCwgaiA9IGxlbiAtIDEsIHAxLCBwMjsgaSA8IGxlbjsgaiA9IGkrKykge1xuICAgICAgICBwMSA9IHJpbmdbaV07XG4gICAgICAgIHAyID0gcmluZ1tqXTtcbiAgICAgICAgc3VtICs9IChwMlswXSAtIHAxWzBdKSAqIChwMVsxXSArIHAyWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy50aWxlID0gdHJhbnNmb3JtVGlsZTtcbmV4cG9ydHMucG9pbnQgPSB0cmFuc2Zvcm1Qb2ludDtcblxuLy8gVHJhbnNmb3JtcyB0aGUgY29vcmRpbmF0ZXMgb2YgZWFjaCBmZWF0dXJlIGluIHRoZSBnaXZlbiB0aWxlIGZyb21cbi8vIG1lcmNhdG9yLXByb2plY3RlZCBzcGFjZSBpbnRvIChleHRlbnQgeCBleHRlbnQpIHRpbGUgc3BhY2UuXG5mdW5jdGlvbiB0cmFuc2Zvcm1UaWxlKHRpbGUsIGV4dGVudCkge1xuICAgIGlmICh0aWxlLnRyYW5zZm9ybWVkKSByZXR1cm4gdGlsZTtcblxuICAgIHZhciB6MiA9IHRpbGUuejIsXG4gICAgICAgIHR4ID0gdGlsZS54LFxuICAgICAgICB0eSA9IHRpbGUueSxcbiAgICAgICAgaSwgaiwgaztcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aWxlLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmZWF0dXJlID0gdGlsZS5mZWF0dXJlc1tpXSxcbiAgICAgICAgICAgIGdlb20gPSBmZWF0dXJlLmdlb21ldHJ5LFxuICAgICAgICAgICAgdHlwZSA9IGZlYXR1cmUudHlwZTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdlb20ubGVuZ3RoOyBqKyspIGdlb21bal0gPSB0cmFuc2Zvcm1Qb2ludChnZW9tW2pdLCBleHRlbnQsIHoyLCB0eCwgdHkpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2VvbS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciByaW5nID0gZ2VvbVtqXTtcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgcmluZy5sZW5ndGg7IGsrKykgcmluZ1trXSA9IHRyYW5zZm9ybVBvaW50KHJpbmdba10sIGV4dGVudCwgejIsIHR4LCB0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aWxlLnRyYW5zZm9ybWVkID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aWxlO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludChwLCBleHRlbnQsIHoyLCB0eCwgdHkpIHtcbiAgICB2YXIgeCA9IE1hdGgucm91bmQoZXh0ZW50ICogKHBbMF0gKiB6MiAtIHR4KSksXG4gICAgICAgIHkgPSBNYXRoLnJvdW5kKGV4dGVudCAqIChwWzFdICogejIgLSB0eSkpO1xuICAgIHJldHVybiBbeCwgeV07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjbGlwID0gcmVxdWlyZSgnLi9jbGlwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gd3JhcDtcblxuZnVuY3Rpb24gd3JhcChmZWF0dXJlcywgYnVmZmVyLCBpbnRlcnNlY3RYKSB7XG4gICAgdmFyIG1lcmdlZCA9IGZlYXR1cmVzLFxuICAgICAgICBsZWZ0ICA9IGNsaXAoZmVhdHVyZXMsIDEsIC0xIC0gYnVmZmVyLCBidWZmZXIsICAgICAwLCBpbnRlcnNlY3RYLCAtMSwgMiksIC8vIGxlZnQgd29ybGQgY29weVxuICAgICAgICByaWdodCA9IGNsaXAoZmVhdHVyZXMsIDEsICAxIC0gYnVmZmVyLCAyICsgYnVmZmVyLCAwLCBpbnRlcnNlY3RYLCAtMSwgMik7IC8vIHJpZ2h0IHdvcmxkIGNvcHlcblxuICAgIGlmIChsZWZ0IHx8IHJpZ2h0KSB7XG4gICAgICAgIG1lcmdlZCA9IGNsaXAoZmVhdHVyZXMsIDEsIC1idWZmZXIsIDEgKyBidWZmZXIsIDAsIGludGVyc2VjdFgsIC0xLCAyKTsgLy8gY2VudGVyIHdvcmxkIGNvcHlcblxuICAgICAgICBpZiAobGVmdCkgbWVyZ2VkID0gc2hpZnRGZWF0dXJlQ29vcmRzKGxlZnQsIDEpLmNvbmNhdChtZXJnZWQpOyAvLyBtZXJnZSBsZWZ0IGludG8gY2VudGVyXG4gICAgICAgIGlmIChyaWdodCkgbWVyZ2VkID0gbWVyZ2VkLmNvbmNhdChzaGlmdEZlYXR1cmVDb29yZHMocmlnaHQsIC0xKSk7IC8vIG1lcmdlIHJpZ2h0IGludG8gY2VudGVyXG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cblxuZnVuY3Rpb24gc2hpZnRGZWF0dXJlQ29vcmRzKGZlYXR1cmVzLCBvZmZzZXQpIHtcbiAgICB2YXIgbmV3RmVhdHVyZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlc1tpXSxcbiAgICAgICAgICAgIHR5cGUgPSBmZWF0dXJlLnR5cGU7XG5cbiAgICAgICAgdmFyIG5ld0dlb21ldHJ5O1xuXG4gICAgICAgIGlmICh0eXBlID09PSAxKSB7XG4gICAgICAgICAgICBuZXdHZW9tZXRyeSA9IHNoaWZ0Q29vcmRzKGZlYXR1cmUuZ2VvbWV0cnksIG9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdHZW9tZXRyeSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmZWF0dXJlLmdlb21ldHJ5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbmV3R2VvbWV0cnkucHVzaChzaGlmdENvb3JkcyhmZWF0dXJlLmdlb21ldHJ5W2pdLCBvZmZzZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0ZlYXR1cmVzLnB1c2goe1xuICAgICAgICAgICAgZ2VvbWV0cnk6IG5ld0dlb21ldHJ5LFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHRhZ3M6IGZlYXR1cmUudGFncyxcbiAgICAgICAgICAgIG1pbjogW2ZlYXR1cmUubWluWzBdICsgb2Zmc2V0LCBmZWF0dXJlLm1pblsxXV0sXG4gICAgICAgICAgICBtYXg6IFtmZWF0dXJlLm1heFswXSArIG9mZnNldCwgZmVhdHVyZS5tYXhbMV1dXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdGZWF0dXJlcztcbn1cblxuZnVuY3Rpb24gc2hpZnRDb29yZHMocG9pbnRzLCBvZmZzZXQpIHtcbiAgICB2YXIgbmV3UG9pbnRzID0gW107XG4gICAgbmV3UG9pbnRzLmFyZWEgPSBwb2ludHMuYXJlYTtcbiAgICBuZXdQb2ludHMuZGlzdCA9IHBvaW50cy5kaXN0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3UG9pbnRzLnB1c2goW3BvaW50c1tpXVswXSArIG9mZnNldCwgcG9pbnRzW2ldWzFdLCBwb2ludHNbaV1bMl1dKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1BvaW50cztcbn1cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBnbC1tYXRyaXggLSBIaWdoIHBlcmZvcm1hbmNlIG1hdHJpeCBhbmQgdmVjdG9yIG9wZXJhdGlvbnNcbiAqIEBhdXRob3IgQnJhbmRvbiBKb25lc1xuICogQGF1dGhvciBDb2xpbiBNYWNLZW56aWUgSVZcbiAqIEB2ZXJzaW9uIDIuMy4yXG4gKi9cblxuLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cbi8vIEVORCBIRUFERVJcblxuZXhwb3J0cy5nbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9jb21tb24uanNcIik7XG5leHBvcnRzLm1hdDIgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvbWF0Mi5qc1wiKTtcbmV4cG9ydHMubWF0MmQgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvbWF0MmQuanNcIik7XG5leHBvcnRzLm1hdDMgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvbWF0My5qc1wiKTtcbmV4cG9ydHMubWF0NCA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9tYXQ0LmpzXCIpO1xuZXhwb3J0cy5xdWF0ID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L3F1YXQuanNcIik7XG5leHBvcnRzLnZlYzIgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvdmVjMi5qc1wiKTtcbmV4cG9ydHMudmVjMyA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC92ZWMzLmpzXCIpO1xuZXhwb3J0cy52ZWM0ID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L3ZlYzQuanNcIik7IiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgQ29tbW9uIHV0aWxpdGllc1xuICogQG5hbWUgZ2xNYXRyaXhcbiAqL1xudmFyIGdsTWF0cml4ID0ge307XG5cbi8vIENvbmZpZ3VyYXRpb24gQ29uc3RhbnRzXG5nbE1hdHJpeC5FUFNJTE9OID0gMC4wMDAwMDE7XG5nbE1hdHJpeC5BUlJBWV9UWVBFID0gKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKSA/IEZsb2F0MzJBcnJheSA6IEFycmF5O1xuZ2xNYXRyaXguUkFORE9NID0gTWF0aC5yYW5kb207XG5nbE1hdHJpeC5FTkFCTEVfU0lNRCA9IGZhbHNlO1xuXG4vLyBDYXBhYmlsaXR5IGRldGVjdGlvblxuZ2xNYXRyaXguU0lNRF9BVkFJTEFCTEUgPSAoZ2xNYXRyaXguQVJSQVlfVFlQRSA9PT0gRmxvYXQzMkFycmF5KSAmJiAoJ1NJTUQnIGluIHRoaXMpO1xuZ2xNYXRyaXguVVNFX1NJTUQgPSBnbE1hdHJpeC5FTkFCTEVfU0lNRCAmJiBnbE1hdHJpeC5TSU1EX0FWQUlMQUJMRTtcblxuLyoqXG4gKiBTZXRzIHRoZSB0eXBlIG9mIGFycmF5IHVzZWQgd2hlbiBjcmVhdGluZyBuZXcgdmVjdG9ycyBhbmQgbWF0cmljZXNcbiAqXG4gKiBAcGFyYW0ge1R5cGV9IHR5cGUgQXJyYXkgdHlwZSwgc3VjaCBhcyBGbG9hdDMyQXJyYXkgb3IgQXJyYXlcbiAqL1xuZ2xNYXRyaXguc2V0TWF0cml4QXJyYXlUeXBlID0gZnVuY3Rpb24odHlwZSkge1xuICAgIGdsTWF0cml4LkFSUkFZX1RZUEUgPSB0eXBlO1xufVxuXG52YXIgZGVncmVlID0gTWF0aC5QSSAvIDE4MDtcblxuLyoqXG4qIENvbnZlcnQgRGVncmVlIFRvIFJhZGlhblxuKlxuKiBAcGFyYW0ge051bWJlcn0gQW5nbGUgaW4gRGVncmVlc1xuKi9cbmdsTWF0cml4LnRvUmFkaWFuID0gZnVuY3Rpb24oYSl7XG4gICAgIHJldHVybiBhICogZGVncmVlO1xufVxuXG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgb3Igbm90IHRoZSBhcmd1bWVudHMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHZhbHVlLCB3aXRoaW4gYW4gYWJzb2x1dGVcbiAqIG9yIHJlbGF0aXZlIHRvbGVyYW5jZSBvZiBnbE1hdHJpeC5FUFNJTE9OIChhbiBhYnNvbHV0ZSB0b2xlcmFuY2UgaXMgdXNlZCBmb3IgdmFsdWVzIGxlc3MgXG4gKiB0aGFuIG9yIGVxdWFsIHRvIDEuMCwgYW5kIGEgcmVsYXRpdmUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIGxhcmdlciB2YWx1ZXMpXG4gKiBcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCBudW1iZXIgdG8gdGVzdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgbnVtYmVyIHRvIHRlc3QuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbnVtYmVycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5nbE1hdHJpeC5lcXVhbHMgPSBmdW5jdGlvbihhLCBiKSB7XG5cdHJldHVybiBNYXRoLmFicyhhIC0gYikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEpLCBNYXRoLmFicyhiKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xNYXRyaXg7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDJ4MiBNYXRyaXhcbiAqIEBuYW1lIG1hdDJcbiAqL1xudmFyIG1hdDIgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJcbiAqXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5tYXQyLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbm1hdDIuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgYSBtYXQyIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0MiB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0IEEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xubWF0Mi5mcm9tVmFsdWVzID0gZnVuY3Rpb24obTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IG0wMDtcbiAgICBvdXRbMV0gPSBtMDE7XG4gICAgb3V0WzJdID0gbTEwO1xuICAgIG91dFszXSA9IG0xMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLnNldCA9IGZ1bmN0aW9uKG91dCwgbTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gICAgb3V0WzBdID0gbTAwO1xuICAgIG91dFsxXSA9IG0wMTtcbiAgICBvdXRbMl0gPSBtMTA7XG4gICAgb3V0WzNdID0gbTExO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMSA9IGFbMV07XG4gICAgICAgIG91dFsxXSA9IGFbMl07XG4gICAgICAgIG91dFsyXSA9IGExO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbMl07XG4gICAgICAgIG91dFsyXSA9IGFbMV07XG4gICAgICAgIG91dFszXSA9IGFbM107XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBhMCAqIGEzIC0gYTIgKiBhMTtcblxuICAgIGlmICghZGV0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgXG4gICAgb3V0WzBdID0gIGEzICogZGV0O1xuICAgIG91dFsxXSA9IC1hMSAqIGRldDtcbiAgICBvdXRbMl0gPSAtYTIgKiBkZXQ7XG4gICAgb3V0WzNdID0gIGEwICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBDYWNoaW5nIHRoaXMgdmFsdWUgaXMgbmVzc2VjYXJ5IGlmIG91dCA9PSBhXG4gICAgdmFyIGEwID0gYVswXTtcbiAgICBvdXRbMF0gPSAgYVszXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSAgYTA7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0Mi5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsyXSAqIGFbMV07XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdO1xuICAgIHZhciBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107XG4gICAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gICAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gICAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XG4gICAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDIubXVsID0gbWF0Mi5tdWx0aXBseTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MiBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG4gICAgICAgIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBhMCAqICBjICsgYTIgKiBzO1xuICAgIG91dFsxXSA9IGExICogIGMgKyBhMyAqIHM7XG4gICAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MiBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKiovXG5tYXQyLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gICAgb3V0WzBdID0gYTAgKiB2MDtcbiAgICBvdXRbMV0gPSBhMSAqIHYwO1xuICAgIG91dFsyXSA9IGEyICogdjE7XG4gICAgb3V0WzNdID0gYTMgKiB2MTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDIuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0Mi5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCBtYXQyIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmZyb21Sb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBjO1xuICAgIG91dFsxXSA9IHM7XG4gICAgb3V0WzJdID0gLXM7XG4gICAgb3V0WzNdID0gYztcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0Mi5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyLnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgbWF0MiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuZnJvbVNjYWxpbmcgPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSB2WzBdO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSB2WzFdO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQyLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0Mi5mcm9iID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpKSlcbn07XG5cbi8qKlxuICogUmV0dXJucyBMLCBEIGFuZCBVIG1hdHJpY2VzIChMb3dlciB0cmlhbmd1bGFyLCBEaWFnb25hbCBhbmQgVXBwZXIgdHJpYW5ndWxhcikgYnkgZmFjdG9yaXppbmcgdGhlIGlucHV0IG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBMIHRoZSBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gRCB0aGUgZGlhZ29uYWwgbWF0cml4IFxuICogQHBhcmFtIHttYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgaW5wdXQgbWF0cml4IHRvIGZhY3Rvcml6ZVxuICovXG5cbm1hdDIuTERVID0gZnVuY3Rpb24gKEwsIEQsIFUsIGEpIHsgXG4gICAgTFsyXSA9IGFbMl0vYVswXTsgXG4gICAgVVswXSA9IGFbMF07IFxuICAgIFVbMV0gPSBhWzFdOyBcbiAgICBVWzNdID0gYVszXSAtIExbMl0gKiBVWzFdOyBcbiAgICByZXR1cm4gW0wsIEQsIFVdOyAgICAgICBcbn07IFxuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDInc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0Mi5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQyLnN1YiA9IG1hdDIuc3VidHJhY3Q7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQyfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQyLmV4YWN0RXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQyfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQyLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICAgIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSk7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLm11bHRpcGx5U2NhbGFyID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgb3V0WzNdID0gYVszXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MidzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5tdWx0aXBseVNjYWxhckFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0MjtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgMngzIE1hdHJpeFxuICogQG5hbWUgbWF0MmRcbiAqIFxuICogQGRlc2NyaXB0aW9uIFxuICogQSBtYXQyZCBjb250YWlucyBzaXggZWxlbWVudHMgZGVmaW5lZCBhczpcbiAqIDxwcmU+XG4gKiBbYSwgYywgdHgsXG4gKiAgYiwgZCwgdHldXG4gKiA8L3ByZT5cbiAqIFRoaXMgaXMgYSBzaG9ydCBmb3JtIGZvciB0aGUgM3gzIG1hdHJpeDpcbiAqIDxwcmU+XG4gKiBbYSwgYywgdHgsXG4gKiAgYiwgZCwgdHksXG4gKiAgMCwgMCwgMV1cbiAqIDwvcHJlPlxuICogVGhlIGxhc3Qgcm93IGlzIGlnbm9yZWQgc28gdGhlIGFycmF5IGlzIHNob3J0ZXIgYW5kIG9wZXJhdGlvbnMgYXJlIGZhc3Rlci5cbiAqL1xudmFyIG1hdDJkID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyZFxuICpcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxuICovXG5tYXQyZC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQyZCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xubWF0MmQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyZCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0MmQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0MmQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQ29tcG9uZW50IEEgKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gYiBDb21wb25lbnQgQiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIENvbXBvbmVudCBDIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IGQgQ29tcG9uZW50IEQgKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gdHggQ29tcG9uZW50IFRYIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IHR5IENvbXBvbmVudCBUWSAoaW5kZXggNSlcbiAqIEByZXR1cm5zIHttYXQyZH0gQSBuZXcgbWF0MmRcbiAqL1xubWF0MmQuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcbiAgICBvdXRbMF0gPSBhO1xuICAgIG91dFsxXSA9IGI7XG4gICAgb3V0WzJdID0gYztcbiAgICBvdXRbM10gPSBkO1xuICAgIG91dFs0XSA9IHR4O1xuICAgIG91dFs1XSA9IHR5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDJkIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIENvbXBvbmVudCBBIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgQ29tcG9uZW50IEIgKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gYyBDb21wb25lbnQgQyAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBkIENvbXBvbmVudCBEIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IHR4IENvbXBvbmVudCBUWCAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eSBDb21wb25lbnQgVFkgKGluZGV4IDUpXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5zZXQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICAgIG91dFswXSA9IGE7XG4gICAgb3V0WzFdID0gYjtcbiAgICBvdXRbMl0gPSBjO1xuICAgIG91dFszXSA9IGQ7XG4gICAgb3V0WzRdID0gdHg7XG4gICAgb3V0WzVdID0gdHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYWEgPSBhWzBdLCBhYiA9IGFbMV0sIGFjID0gYVsyXSwgYWQgPSBhWzNdLFxuICAgICAgICBhdHggPSBhWzRdLCBhdHkgPSBhWzVdO1xuXG4gICAgdmFyIGRldCA9IGFhICogYWQgLSBhYiAqIGFjO1xuICAgIGlmKCFkZXQpe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gYWQgKiBkZXQ7XG4gICAgb3V0WzFdID0gLWFiICogZGV0O1xuICAgIG91dFsyXSA9IC1hYyAqIGRldDtcbiAgICBvdXRbM10gPSBhYSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDJkLmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzFdICogYVsyXTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MmQnc1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM10sIGI0ID0gYls0XSwgYjUgPSBiWzVdO1xuICAgIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICAgIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICAgIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICAgIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICAgIG91dFs0XSA9IGEwICogYjQgKyBhMiAqIGI1ICsgYTQ7XG4gICAgb3V0WzVdID0gYTEgKiBiNCArIGEzICogYjUgKyBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDJkLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDJkLm11bCA9IG1hdDJkLm11bHRpcGx5O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQyZCBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIG91dFswXSA9IGEwICogIGMgKyBhMiAqIHM7XG4gICAgb3V0WzFdID0gYTEgKiAgYyArIGEzICogcztcbiAgICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjO1xuICAgIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gICAgb3V0WzRdID0gYTQ7XG4gICAgb3V0WzVdID0gYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKiovXG5tYXQyZC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgICBvdXRbMF0gPSBhMCAqIHYwO1xuICAgIG91dFsxXSA9IGExICogdjA7XG4gICAgb3V0WzJdID0gYTIgKiB2MTtcbiAgICBvdXRbM10gPSBhMyAqIHYxO1xuICAgIG91dFs0XSA9IGE0O1xuICAgIG91dFs1XSA9IGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gdHJhbnNsYXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKiovXG5tYXQyZC50cmFuc2xhdGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gICAgb3V0WzBdID0gYTA7XG4gICAgb3V0WzFdID0gYTE7XG4gICAgb3V0WzJdID0gYTI7XG4gICAgb3V0WzNdID0gYTM7XG4gICAgb3V0WzRdID0gYTAgKiB2MCArIGEyICogdjEgKyBhNDtcbiAgICBvdXRbNV0gPSBhMSAqIHYwICsgYTMgKiB2MSArIGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0MmQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuZnJvbVJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIG91dFswXSA9IGM7XG4gICAgb3V0WzFdID0gcztcbiAgICBvdXRbMl0gPSAtcztcbiAgICBvdXRbM10gPSBjO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0MmQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuZnJvbVNjYWxpbmcgPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSB2WzBdO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSB2WzFdO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDJkLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDJkLnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuZnJvbVRyYW5zbGF0aW9uID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSB2WzBdO1xuICAgIG91dFs1XSA9IHZbMV07XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbm1hdDJkLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQyZCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5tYXQyZC5mcm9iID0gZnVuY3Rpb24gKGEpIHsgXG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyAxKSlcbn07IFxuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDJkJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gICAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gICAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyZC5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQyZC5zdWIgPSBtYXQyZC5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQubXVsdGlwbHlTY2FsYXIgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICBvdXRbM10gPSBhWzNdICogYjtcbiAgICBvdXRbNF0gPSBhWzRdICogYjtcbiAgICBvdXRbNV0gPSBhWzVdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byBtYXQyZCdzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLm11bHRpcGx5U2NhbGFyQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgICBvdXRbNF0gPSBhWzRdICsgKGJbNF0gKiBzY2FsZSk7XG4gICAgb3V0WzVdID0gYVs1XSArIChiWzVdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDJkfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQyZC5leGFjdEVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQyZH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xubWF0MmQuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdLCBiNCA9IGJbNF0sIGI1ID0gYls1XTtcbiAgICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtYXQyZDtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgM3gzIE1hdHJpeFxuICogQG5hbWUgbWF0M1xuICovXG52YXIgbWF0MyA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0M1xuICpcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XG4gKi9cbm1hdDMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMTtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcGllcyB0aGUgdXBwZXItbGVmdCAzeDMgdmFsdWVzIGludG8gdGhlIGdpdmVuIG1hdDMuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyAzeDMgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgICB0aGUgc291cmNlIDR4NCBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5mcm9tTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbNF07XG4gICAgb3V0WzRdID0gYVs1XTtcbiAgICBvdXRbNV0gPSBhWzZdO1xuICAgIG91dFs2XSA9IGFbOF07XG4gICAgb3V0WzddID0gYVs5XTtcbiAgICBvdXRbOF0gPSBhWzEwXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxuICovXG5tYXQzLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0MyB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDUpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDYpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDcpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDgpXG4gKiBAcmV0dXJucyB7bWF0M30gQSBuZXcgbWF0M1xuICovXG5tYXQzLmZyb21WYWx1ZXMgPSBmdW5jdGlvbihtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuICAgIG91dFswXSA9IG0wMDtcbiAgICBvdXRbMV0gPSBtMDE7XG4gICAgb3V0WzJdID0gbTAyO1xuICAgIG91dFszXSA9IG0xMDtcbiAgICBvdXRbNF0gPSBtMTE7XG4gICAgb3V0WzVdID0gbTEyO1xuICAgIG91dFs2XSA9IG0yMDtcbiAgICBvdXRbN10gPSBtMjE7XG4gICAgb3V0WzhdID0gbTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDUpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDYpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDcpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDgpXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuc2V0ID0gZnVuY3Rpb24ob3V0LCBtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKSB7XG4gICAgb3V0WzBdID0gbTAwO1xuICAgIG91dFsxXSA9IG0wMTtcbiAgICBvdXRbMl0gPSBtMDI7XG4gICAgb3V0WzNdID0gbTEwO1xuICAgIG91dFs0XSA9IG0xMTtcbiAgICBvdXRbNV0gPSBtMTI7XG4gICAgb3V0WzZdID0gbTIwO1xuICAgIG91dFs3XSA9IG0yMTtcbiAgICBvdXRbOF0gPSBtMjI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0MyB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMTtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My50cmFuc3Bvc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTEyID0gYVs1XTtcbiAgICAgICAgb3V0WzFdID0gYVszXTtcbiAgICAgICAgb3V0WzJdID0gYVs2XTtcbiAgICAgICAgb3V0WzNdID0gYTAxO1xuICAgICAgICBvdXRbNV0gPSBhWzddO1xuICAgICAgICBvdXRbNl0gPSBhMDI7XG4gICAgICAgIG91dFs3XSA9IGExMjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzNdO1xuICAgICAgICBvdXRbMl0gPSBhWzZdO1xuICAgICAgICBvdXRbM10gPSBhWzFdO1xuICAgICAgICBvdXRbNF0gPSBhWzRdO1xuICAgICAgICBvdXRbNV0gPSBhWzddO1xuICAgICAgICBvdXRbNl0gPSBhWzJdO1xuICAgICAgICBvdXRbN10gPSBhWzVdO1xuICAgICAgICBvdXRbOF0gPSBhWzhdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgICAgICBiMDEgPSBhMjIgKiBhMTEgLSBhMTIgKiBhMjEsXG4gICAgICAgIGIxMSA9IC1hMjIgKiBhMTAgKyBhMTIgKiBhMjAsXG4gICAgICAgIGIyMSA9IGEyMSAqIGExMCAtIGExMSAqIGEyMCxcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMTtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IGIwMSAqIGRldDtcbiAgICBvdXRbMV0gPSAoLWEyMiAqIGEwMSArIGEwMiAqIGEyMSkgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBkZXQ7XG4gICAgb3V0WzNdID0gYjExICogZGV0O1xuICAgIG91dFs0XSA9IChhMjIgKiBhMDAgLSBhMDIgKiBhMjApICogZGV0O1xuICAgIG91dFs1XSA9ICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGRldDtcbiAgICBvdXRbNl0gPSBiMjEgKiBkZXQ7XG4gICAgb3V0WzddID0gKC1hMjEgKiBhMDAgKyBhMDEgKiBhMjApICogZGV0O1xuICAgIG91dFs4XSA9IChhMTEgKiBhMDAgLSBhMDEgKiBhMTApICogZGV0O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5hZGpvaW50ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF07XG5cbiAgICBvdXRbMF0gPSAoYTExICogYTIyIC0gYTEyICogYTIxKTtcbiAgICBvdXRbMV0gPSAoYTAyICogYTIxIC0gYTAxICogYTIyKTtcbiAgICBvdXRbMl0gPSAoYTAxICogYTEyIC0gYTAyICogYTExKTtcbiAgICBvdXRbM10gPSAoYTEyICogYTIwIC0gYTEwICogYTIyKTtcbiAgICBvdXRbNF0gPSAoYTAwICogYTIyIC0gYTAyICogYTIwKTtcbiAgICBvdXRbNV0gPSAoYTAyICogYTEwIC0gYTAwICogYTEyKTtcbiAgICBvdXRbNl0gPSAoYTEwICogYTIxIC0gYTExICogYTIwKTtcbiAgICBvdXRbN10gPSAoYTAxICogYTIwIC0gYTAwICogYTIxKTtcbiAgICBvdXRbOF0gPSAoYTAwICogYTExIC0gYTAxICogYTEwKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0My5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF07XG5cbiAgICByZXR1cm4gYTAwICogKGEyMiAqIGExMSAtIGExMiAqIGEyMSkgKyBhMDEgKiAoLWEyMiAqIGExMCArIGExMiAqIGEyMCkgKyBhMDIgKiAoYTIxICogYTEwIC0gYTExICogYTIwKTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MydzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuXG4gICAgICAgIGIwMCA9IGJbMF0sIGIwMSA9IGJbMV0sIGIwMiA9IGJbMl0sXG4gICAgICAgIGIxMCA9IGJbM10sIGIxMSA9IGJbNF0sIGIxMiA9IGJbNV0sXG4gICAgICAgIGIyMCA9IGJbNl0sIGIyMSA9IGJbN10sIGIyMiA9IGJbOF07XG5cbiAgICBvdXRbMF0gPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjA7XG4gICAgb3V0WzFdID0gYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxO1xuICAgIG91dFsyXSA9IGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMjtcblxuICAgIG91dFszXSA9IGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMDtcbiAgICBvdXRbNF0gPSBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjE7XG4gICAgb3V0WzVdID0gYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyO1xuXG4gICAgb3V0WzZdID0gYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwO1xuICAgIG91dFs3XSA9IGIyMCAqIGEwMSArIGIyMSAqIGExMSArIGIyMiAqIGEyMTtcbiAgICBvdXRbOF0gPSBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQzLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDMubXVsID0gbWF0My5tdWx0aXBseTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQzIGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuICAgICAgICB4ID0gdlswXSwgeSA9IHZbMV07XG5cbiAgICBvdXRbMF0gPSBhMDA7XG4gICAgb3V0WzFdID0gYTAxO1xuICAgIG91dFsyXSA9IGEwMjtcblxuICAgIG91dFszXSA9IGExMDtcbiAgICBvdXRbNF0gPSBhMTE7XG4gICAgb3V0WzVdID0gYTEyO1xuXG4gICAgb3V0WzZdID0geCAqIGEwMCArIHkgKiBhMTAgKyBhMjA7XG4gICAgb3V0WzddID0geCAqIGEwMSArIHkgKiBhMTEgKyBhMjE7XG4gICAgb3V0WzhdID0geCAqIGEwMiArIHkgKiBhMTIgKyBhMjI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDMgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBjICogYTAwICsgcyAqIGExMDtcbiAgICBvdXRbMV0gPSBjICogYTAxICsgcyAqIGExMTtcbiAgICBvdXRbMl0gPSBjICogYTAyICsgcyAqIGExMjtcblxuICAgIG91dFszXSA9IGMgKiBhMTAgLSBzICogYTAwO1xuICAgIG91dFs0XSA9IGMgKiBhMTEgLSBzICogYTAxO1xuICAgIG91dFs1XSA9IGMgKiBhMTIgLSBzICogYTAyO1xuXG4gICAgb3V0WzZdID0gYTIwO1xuICAgIG91dFs3XSA9IGEyMTtcbiAgICBvdXRbOF0gPSBhMjI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQzIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqKi9cbm1hdDMuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdO1xuXG4gICAgb3V0WzBdID0geCAqIGFbMF07XG4gICAgb3V0WzFdID0geCAqIGFbMV07XG4gICAgb3V0WzJdID0geCAqIGFbMl07XG5cbiAgICBvdXRbM10gPSB5ICogYVszXTtcbiAgICBvdXRbNF0gPSB5ICogYVs0XTtcbiAgICBvdXRbNV0gPSB5ICogYVs1XTtcblxuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuZnJvbVRyYW5zbGF0aW9uID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAxO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gdlswXTtcbiAgICBvdXRbN10gPSB2WzFdO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmZyb21Sb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLCBjID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGM7XG4gICAgb3V0WzFdID0gcztcbiAgICBvdXRbMl0gPSAwO1xuXG4gICAgb3V0WzNdID0gLXM7XG4gICAgb3V0WzRdID0gYztcbiAgICBvdXRbNV0gPSAwO1xuXG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmZyb21TY2FsaW5nID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gdlswXTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG5cbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHZbMV07XG4gICAgb3V0WzVdID0gMDtcblxuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgZnJvbSBhIG1hdDJkIGludG8gYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBjb3B5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKiovXG5tYXQzLmZyb21NYXQyZCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSAwO1xuXG4gICAgb3V0WzNdID0gYVsyXTtcbiAgICBvdXRbNF0gPSBhWzNdO1xuICAgIG91dFs1XSA9IDA7XG5cbiAgICBvdXRbNl0gPSBhWzRdO1xuICAgIG91dFs3XSA9IGFbNV07XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4qIENhbGN1bGF0ZXMgYSAzeDMgbWF0cml4IGZyb20gdGhlIGdpdmVuIHF1YXRlcm5pb25cbipcbiogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuKiBAcGFyYW0ge3F1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cbipcbiogQHJldHVybnMge21hdDN9IG91dFxuKi9cbm1hdDMuZnJvbVF1YXQgPSBmdW5jdGlvbiAob3V0LCBxKSB7XG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB5eCA9IHkgKiB4MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHp4ID0geiAqIHgyLFxuICAgICAgICB6eSA9IHogKiB5MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgICBvdXRbM10gPSB5eCAtIHd6O1xuICAgIG91dFs2XSA9IHp4ICsgd3k7XG5cbiAgICBvdXRbMV0gPSB5eCArIHd6O1xuICAgIG91dFs0XSA9IDEgLSB4eCAtIHp6O1xuICAgIG91dFs3XSA9IHp5IC0gd3g7XG5cbiAgICBvdXRbMl0gPSB6eCAtIHd5O1xuICAgIG91dFs1XSA9IHp5ICsgd3g7XG4gICAgb3V0WzhdID0gMSAtIHh4IC0geXk7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4qIENhbGN1bGF0ZXMgYSAzeDMgbm9ybWFsIG1hdHJpeCAodHJhbnNwb3NlIGludmVyc2UpIGZyb20gdGhlIDR4NCBtYXRyaXhcbipcbiogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuKiBAcGFyYW0ge21hdDR9IGEgTWF0NCB0byBkZXJpdmUgdGhlIG5vcm1hbCBtYXRyaXggZnJvbVxuKlxuKiBAcmV0dXJucyB7bWF0M30gb3V0XG4qL1xubWF0My5ub3JtYWxGcm9tTWF0NCA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gICAgaWYgKCFkZXQpIHsgXG4gICAgICAgIHJldHVybiBudWxsOyBcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzFdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG5cbiAgICBvdXRbM10gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcblxuICAgIG91dFs2XSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIG91dFs3XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIG91dFs4XSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQzLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQzKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBcbiAgICAgICAgICAgICAgICAgICAgYVszXSArICcsICcgKyBhWzRdICsgJywgJyArIGFbNV0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgKyBhWzhdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0My5mcm9iID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIE1hdGgucG93KGFbNl0sIDIpICsgTWF0aC5wb3coYVs3XSwgMikgKyBNYXRoLnBvdyhhWzhdLCAyKSkpXG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDMnc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgICBvdXRbN10gPSBhWzddICsgYls3XTtcbiAgICBvdXRbOF0gPSBhWzhdICsgYls4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICAgIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICAgIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICAgIG91dFs2XSA9IGFbNl0gLSBiWzZdO1xuICAgIG91dFs3XSA9IGFbN10gLSBiWzddO1xuICAgIG91dFs4XSA9IGFbOF0gLSBiWzhdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQzLnN1YiA9IG1hdDMuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMubXVsdGlwbHlTY2FsYXIgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICBvdXRbM10gPSBhWzNdICogYjtcbiAgICBvdXRbNF0gPSBhWzRdICogYjtcbiAgICBvdXRbNV0gPSBhWzVdICogYjtcbiAgICBvdXRbNl0gPSBhWzZdICogYjtcbiAgICBvdXRbN10gPSBhWzddICogYjtcbiAgICBvdXRbOF0gPSBhWzhdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byBtYXQzJ3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLm11bHRpcGx5U2NhbGFyQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgICBvdXRbNF0gPSBhWzRdICsgKGJbNF0gKiBzY2FsZSk7XG4gICAgb3V0WzVdID0gYVs1XSArIChiWzVdICogc2NhbGUpO1xuICAgIG91dFs2XSA9IGFbNl0gKyAoYls2XSAqIHNjYWxlKTtcbiAgICBvdXRbN10gPSBhWzddICsgKGJbN10gKiBzY2FsZSk7XG4gICAgb3V0WzhdID0gYVs4XSArIChiWzhdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7bWF0M30gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQzfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQzLmV4YWN0RXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgXG4gICAgICAgICAgIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdICYmXG4gICAgICAgICAgIGFbNl0gPT09IGJbNl0gJiYgYVs3XSA9PT0gYls3XSAmJiBhWzhdID09PSBiWzhdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDN9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbm1hdDMuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSwgYTYgPSBhWzZdLCBhNyA9IGFbN10sIGE4ID0gYVs4XTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdLCBiNCA9IGJbNF0sIGI1ID0gYls1XSwgYjYgPSBhWzZdLCBiNyA9IGJbN10sIGI4ID0gYls4XTtcbiAgICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNiksIE1hdGguYWJzKGI2KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE3IC0gYjcpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNyksIE1hdGguYWJzKGI3KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE4IC0gYjgpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOCksIE1hdGguYWJzKGI4KSkpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdDM7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDR4NCBNYXRyaXhcbiAqIEBuYW1lIG1hdDRcbiAqL1xudmFyIG1hdDQgPSB7XG4gIHNjYWxhcjoge30sXG4gIFNJTUQ6IHt9LFxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDRcbiAqXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5tYXQ0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5tYXQ0LmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0NCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBtYXQ0IHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDMgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTMgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggNylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggOSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTApXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMCBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAxMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMTMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMyBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxNSlcbiAqIEByZXR1cm5zIHttYXQ0fSBBIG5ldyBtYXQ0XG4gKi9cbm1hdDQuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMykge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gICAgb3V0WzBdID0gbTAwO1xuICAgIG91dFsxXSA9IG0wMTtcbiAgICBvdXRbMl0gPSBtMDI7XG4gICAgb3V0WzNdID0gbTAzO1xuICAgIG91dFs0XSA9IG0xMDtcbiAgICBvdXRbNV0gPSBtMTE7XG4gICAgb3V0WzZdID0gbTEyO1xuICAgIG91dFs3XSA9IG0xMztcbiAgICBvdXRbOF0gPSBtMjA7XG4gICAgb3V0WzldID0gbTIxO1xuICAgIG91dFsxMF0gPSBtMjI7XG4gICAgb3V0WzExXSA9IG0yMztcbiAgICBvdXRbMTJdID0gbTMwO1xuICAgIG91dFsxM10gPSBtMzE7XG4gICAgb3V0WzE0XSA9IG0zMjtcbiAgICBvdXRbMTVdID0gbTMzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTAzIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDMgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDUpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEyIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDIgcG9zaXRpb24gKGluZGV4IDYpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEzIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDMgcG9zaXRpb24gKGluZGV4IDcpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDgpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDkpXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDEwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMyBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzAgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMTIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDEgcG9zaXRpb24gKGluZGV4IDEzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMiBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzMgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTUpXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc2V0ID0gZnVuY3Rpb24ob3V0LCBtMDAsIG0wMSwgbTAyLCBtMDMsIG0xMCwgbTExLCBtMTIsIG0xMywgbTIwLCBtMjEsIG0yMiwgbTIzLCBtMzAsIG0zMSwgbTMyLCBtMzMpIHtcbiAgICBvdXRbMF0gPSBtMDA7XG4gICAgb3V0WzFdID0gbTAxO1xuICAgIG91dFsyXSA9IG0wMjtcbiAgICBvdXRbM10gPSBtMDM7XG4gICAgb3V0WzRdID0gbTEwO1xuICAgIG91dFs1XSA9IG0xMTtcbiAgICBvdXRbNl0gPSBtMTI7XG4gICAgb3V0WzddID0gbTEzO1xuICAgIG91dFs4XSA9IG0yMDtcbiAgICBvdXRbOV0gPSBtMjE7XG4gICAgb3V0WzEwXSA9IG0yMjtcbiAgICBvdXRbMTFdID0gbTIzO1xuICAgIG91dFsxMl0gPSBtMzA7XG4gICAgb3V0WzEzXSA9IG0zMTtcbiAgICBvdXRbMTRdID0gbTMyO1xuICAgIG91dFsxNV0gPSBtMzM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cblxuLyoqXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDQgbm90IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc2NhbGFyLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICAgICAgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgICAgIG91dFsxXSA9IGFbNF07XG4gICAgICAgIG91dFsyXSA9IGFbOF07XG4gICAgICAgIG91dFszXSA9IGFbMTJdO1xuICAgICAgICBvdXRbNF0gPSBhMDE7XG4gICAgICAgIG91dFs2XSA9IGFbOV07XG4gICAgICAgIG91dFs3XSA9IGFbMTNdO1xuICAgICAgICBvdXRbOF0gPSBhMDI7XG4gICAgICAgIG91dFs5XSA9IGExMjtcbiAgICAgICAgb3V0WzExXSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTJdID0gYTAzO1xuICAgICAgICBvdXRbMTNdID0gYTEzO1xuICAgICAgICBvdXRbMTRdID0gYTIzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbNF07XG4gICAgICAgIG91dFsyXSA9IGFbOF07XG4gICAgICAgIG91dFszXSA9IGFbMTJdO1xuICAgICAgICBvdXRbNF0gPSBhWzFdO1xuICAgICAgICBvdXRbNV0gPSBhWzVdO1xuICAgICAgICBvdXRbNl0gPSBhWzldO1xuICAgICAgICBvdXRbN10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzhdID0gYVsyXTtcbiAgICAgICAgb3V0WzldID0gYVs2XTtcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgICAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgICAgIG91dFsxMl0gPSBhWzNdO1xuICAgICAgICBvdXRbMTNdID0gYVs3XTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTFdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQ0IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuU0lNRC50cmFuc3Bvc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAsIGExLCBhMiwgYTMsXG4gICAgICAgIHRtcDAxLCB0bXAyMyxcbiAgICAgICAgb3V0MCwgb3V0MSwgb3V0Miwgb3V0MztcblxuICAgIGEwID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAwKTtcbiAgICBhMSA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgNCk7XG4gICAgYTIgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDgpO1xuICAgIGEzID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAxMik7XG5cbiAgICB0bXAwMSA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTAsIGExLCAwLCAxLCA0LCA1KTtcbiAgICB0bXAyMyA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTIsIGEzLCAwLCAxLCA0LCA1KTtcbiAgICBvdXQwICA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUodG1wMDEsIHRtcDIzLCAwLCAyLCA0LCA2KTtcbiAgICBvdXQxICA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUodG1wMDEsIHRtcDIzLCAxLCAzLCA1LCA3KTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDAsICBvdXQwKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDQsICBvdXQxKTtcblxuICAgIHRtcDAxID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMCwgYTEsIDIsIDMsIDYsIDcpO1xuICAgIHRtcDIzID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMiwgYTMsIDIsIDMsIDYsIDcpO1xuICAgIG91dDIgID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZSh0bXAwMSwgdG1wMjMsIDAsIDIsIDQsIDYpO1xuICAgIG91dDMgID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZSh0bXAwMSwgdG1wMjMsIDEsIDMsIDUsIDcpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgOCwgIG91dDIpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMTIsIG91dDMpO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNwc2UgYSBtYXQ0IHVzaW5nIFNJTUQgaWYgYXZhaWxhYmxlIGFuZCBlbmFibGVkXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnRyYW5zcG9zZSA9IGdsTWF0cml4LlVTRV9TSU1EID8gbWF0NC5TSU1ELnRyYW5zcG9zZSA6IG1hdDQuc2NhbGFyLnRyYW5zcG9zZTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0NCBub3QgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zY2FsYXIuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzExXSA9IChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzE0XSA9IChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0O1xuICAgIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQ0IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuU0lNRC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgdmFyIHJvdzAsIHJvdzEsIHJvdzIsIHJvdzMsXG4gICAgICB0bXAxLFxuICAgICAgbWlub3IwLCBtaW5vcjEsIG1pbm9yMiwgbWlub3IzLFxuICAgICAgZGV0LFxuICAgICAgYTAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDApLFxuICAgICAgYTEgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDQpLFxuICAgICAgYTIgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDgpLFxuICAgICAgYTMgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDEyKTtcblxuICAvLyBDb21wdXRlIG1hdHJpeCBhZGp1Z2F0ZVxuICB0bXAxID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMCwgYTEsIDAsIDEsIDQsIDUpO1xuICByb3cxID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMiwgYTMsIDAsIDEsIDQsIDUpO1xuICByb3cwID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZSh0bXAxLCByb3cxLCAwLCAyLCA0LCA2KTtcbiAgcm93MSA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUocm93MSwgdG1wMSwgMSwgMywgNSwgNyk7XG4gIHRtcDEgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEwLCBhMSwgMiwgMywgNiwgNyk7XG4gIHJvdzMgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEyLCBhMywgMiwgMywgNiwgNyk7XG4gIHJvdzIgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHRtcDEsIHJvdzMsIDAsIDIsIDQsIDYpO1xuICByb3czID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShyb3czLCB0bXAxLCAxLCAzLCA1LCA3KTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93Miwgcm93Myk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpLCBtaW5vcjApO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpLCBtaW5vcjEpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKG1pbm9yMSwgMiwgMywgMCwgMSk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHJvdzIpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpLCBtaW5vcjApO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjAsIFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSk7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSksIG1pbm9yMyk7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUobWlub3IzLCAyLCAzLCAwLCAxKTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShyb3cxLCAyLCAzLCAwLCAxKSwgcm93Myk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIHJvdzIgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUocm93MiwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSksIG1pbm9yMCk7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMCwgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKSwgbWlub3IyKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZShtaW5vcjIsIDIsIDMsIDAsIDEpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCByb3cxKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSwgbWlub3IyKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSwgbWlub3IzKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSwgbWlub3IyKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMywgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpKTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgcm93Myk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjEsIFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSk7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSksIG1pbm9yMik7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSksIG1pbm9yMSk7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjIsIFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKSk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHJvdzIpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpLCBtaW5vcjEpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IzLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSkpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IxLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSkpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpLCBtaW5vcjMpO1xuXG4gIC8vIENvbXB1dGUgbWF0cml4IGRldGVybWluYW50XG4gIGRldCAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIG1pbm9yMCk7XG4gIGRldCAgID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoZGV0LCAyLCAzLCAwLCAxKSwgZGV0KTtcbiAgZGV0ICAgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShkZXQsIDEsIDAsIDMsIDIpLCBkZXQpO1xuICB0bXAxICA9IFNJTUQuRmxvYXQzMng0LnJlY2lwcm9jYWxBcHByb3hpbWF0aW9uKGRldCk7XG4gIGRldCAgID0gU0lNRC5GbG9hdDMyeDQuc3ViKFxuICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKHRtcDEsIHRtcDEpLFxuICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKGRldCwgU0lNRC5GbG9hdDMyeDQubXVsKHRtcDEsIHRtcDEpKSk7XG4gIGRldCAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZShkZXQsIDAsIDAsIDAsIDApO1xuICBpZiAoIWRldCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBDb21wdXRlIG1hdHJpeCBpbnZlcnNlXG4gIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMCwgIFNJTUQuRmxvYXQzMng0Lm11bChkZXQsIG1pbm9yMCkpO1xuICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDQsICBTSU1ELkZsb2F0MzJ4NC5tdWwoZGV0LCBtaW5vcjEpKTtcbiAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA4LCAgU0lNRC5GbG9hdDMyeDQubXVsKGRldCwgbWlub3IyKSk7XG4gIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMTIsIFNJTUQuRmxvYXQzMng0Lm11bChkZXQsIG1pbm9yMykpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEludmVydHMgYSBtYXQ0IHVzaW5nIFNJTUQgaWYgYXZhaWxhYmxlIGFuZCBlbmFibGVkXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmludmVydCA9IGdsTWF0cml4LlVTRV9TSU1EID8gbWF0NC5TSU1ELmludmVydCA6IG1hdDQuc2NhbGFyLmludmVydDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDQgbm90IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc2NhbGFyLmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICAgIG91dFswXSAgPSAgKGExMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gICAgb3V0WzFdICA9IC0oYTAxICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgICBvdXRbMl0gID0gIChhMDEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFszXSAgPSAtKGEwMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTExICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzRdICA9IC0oYTEwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgICBvdXRbNV0gID0gIChhMDAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICAgIG91dFs2XSAgPSAtKGEwMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTEwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzddICA9ICAoYTAwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbOF0gID0gIChhMTAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkpO1xuICAgIG91dFs5XSAgPSAtKGEwMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSk7XG4gICAgb3V0WzEwXSA9ICAoYTAwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgICBvdXRbMTFdID0gLShhMDAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICAgIG91dFsxMl0gPSAtKGExMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSk7XG4gICAgb3V0WzEzXSA9ICAoYTAwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpKTtcbiAgICBvdXRbMTRdID0gLShhMDAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICAgIG91dFsxNV0gPSAgKGEwMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQ0IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuU0lNRC5hZGpvaW50ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gIHZhciBhMCwgYTEsIGEyLCBhMztcbiAgdmFyIHJvdzAsIHJvdzEsIHJvdzIsIHJvdzM7XG4gIHZhciB0bXAxO1xuICB2YXIgbWlub3IwLCBtaW5vcjEsIG1pbm9yMiwgbWlub3IzO1xuXG4gIHZhciBhMCA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMCk7XG4gIHZhciBhMSA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgNCk7XG4gIHZhciBhMiA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgOCk7XG4gIHZhciBhMyA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMTIpO1xuXG4gIC8vIFRyYW5zcG9zZSB0aGUgc291cmNlIG1hdHJpeC4gIFNvcnQgb2YuICBOb3QgYSB0cnVlIHRyYW5zcG9zZSBvcGVyYXRpb25cbiAgdG1wMSA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTAsIGExLCAwLCAxLCA0LCA1KTtcbiAgcm93MSA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTIsIGEzLCAwLCAxLCA0LCA1KTtcbiAgcm93MCA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUodG1wMSwgcm93MSwgMCwgMiwgNCwgNik7XG4gIHJvdzEgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHJvdzEsIHRtcDEsIDEsIDMsIDUsIDcpO1xuXG4gIHRtcDEgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEwLCBhMSwgMiwgMywgNiwgNyk7XG4gIHJvdzMgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEyLCBhMywgMiwgMywgNiwgNyk7XG4gIHJvdzIgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHRtcDEsIHJvdzMsIDAsIDIsIDQsIDYpO1xuICByb3czID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShyb3czLCB0bXAxLCAxLCAzLCA1LCA3KTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93Miwgcm93Myk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpLCBtaW5vcjApO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpLCBtaW5vcjEpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKG1pbm9yMSwgMiwgMywgMCwgMSk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHJvdzIpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpLCBtaW5vcjApO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjAsIFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSk7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSksIG1pbm9yMyk7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUobWlub3IzLCAyLCAzLCAwLCAxKTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShyb3cxLCAyLCAzLCAwLCAxKSwgcm93Myk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIHJvdzIgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUocm93MiwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSksIG1pbm9yMCk7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMCwgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKSwgbWlub3IyKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZShtaW5vcjIsIDIsIDMsIDAsIDEpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCByb3cxKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSwgbWlub3IyKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSwgbWlub3IzKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSwgbWlub3IyKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMywgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpKTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgcm93Myk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjEsIFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSk7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSksIG1pbm9yMik7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSksIG1pbm9yMSk7XG4gIG1pbm9yMiA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjIsIFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKSk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHJvdzIpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpLCBtaW5vcjEpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IzLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSkpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IxLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSkpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpLCBtaW5vcjMpO1xuXG4gIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMCwgIG1pbm9yMCk7XG4gIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgNCwgIG1pbm9yMSk7XG4gIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgOCwgIG1pbm9yMik7XG4gIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMTIsIG1pbm9yMyk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0NCB1c2luZyBTSU1EIGlmIGF2YWlsYWJsZSBhbmQgZW5hYmxlZFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuIG1hdDQuYWRqb2ludCA9IGdsTWF0cml4LlVTRV9TSU1EID8gbWF0NC5TSU1ELmFkam9pbnQgOiBtYXQ0LnNjYWxhci5hZGpvaW50O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5tYXQ0LmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgIHJldHVybiBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDQncyBleHBsaWNpdGx5IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kLCBtdXN0IGJlIGEgRmxvYXQzMkFycmF5XG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kLCBtdXN0IGJlIGEgRmxvYXQzMkFycmF5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuU0lNRC5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDApO1xuICAgIHZhciBhMSA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgNCk7XG4gICAgdmFyIGEyID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA4KTtcbiAgICB2YXIgYTMgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDEyKTtcblxuICAgIHZhciBiMCA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYiwgMCk7XG4gICAgdmFyIG91dDAgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjAsIDAsIDAsIDAsIDApLCBhMCksXG4gICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMCwgMSwgMSwgMSwgMSksIGExKSxcbiAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjAsIDIsIDIsIDIsIDIpLCBhMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMCwgMywgMywgMywgMyksIGEzKSkpKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDAsIG91dDApO1xuXG4gICAgdmFyIGIxID0gU0lNRC5GbG9hdDMyeDQubG9hZChiLCA0KTtcbiAgICB2YXIgb3V0MSA9IFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMSwgMCwgMCwgMCwgMCksIGEwKSxcbiAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIxLCAxLCAxLCAxLCAxKSwgYTEpLFxuICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMSwgMiwgMiwgMiwgMiksIGEyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIxLCAzLCAzLCAzLCAzKSwgYTMpKSkpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgNCwgb3V0MSk7XG5cbiAgICB2YXIgYjIgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGIsIDgpO1xuICAgIHZhciBvdXQyID0gU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIyLCAwLCAwLCAwLCAwKSwgYTApLFxuICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjIsIDEsIDEsIDEsIDEpLCBhMSksXG4gICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMiwgMiwgMiwgMiwgMiksIGEyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMiwgMywgMywgMywgMyksIGEzKSkpKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDgsIG91dDIpO1xuXG4gICAgdmFyIGIzID0gU0lNRC5GbG9hdDMyeDQubG9hZChiLCAxMik7XG4gICAgdmFyIG91dDMgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjMsIDAsIDAsIDAsIDApLCBhMCksXG4gICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjMsIDEsIDEsIDEsIDEpLCBhMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjMsIDIsIDIsIDIsIDIpLCBhMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjMsIDMsIDMsIDMsIDMpLCBhMykpKSk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAxMiwgb3V0Myk7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0J3MgZXhwbGljaXRseSBub3QgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zY2FsYXIubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgICAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXhcbiAgICB2YXIgYjAgID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTtcbiAgICBvdXRbMF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzFdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsyXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbM10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbNF07IGIxID0gYls1XTsgYjIgPSBiWzZdOyBiMyA9IGJbN107XG4gICAgb3V0WzRdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFs1XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbNl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzddID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzhdOyBiMSA9IGJbOV07IGIyID0gYlsxMF07IGIzID0gYlsxMV07XG4gICAgb3V0WzhdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFs5XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMTBdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFsxMV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbMTJdOyBiMSA9IGJbMTNdOyBiMiA9IGJbMTRdOyBiMyA9IGJbMTVdO1xuICAgIG91dFsxMl0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzEzXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMTRdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFsxNV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0NCdzIHVzaW5nIFNJTUQgaWYgYXZhaWxhYmxlIGFuZCBlbmFibGVkXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lm11bHRpcGx5ID0gZ2xNYXRyaXguVVNFX1NJTUQgPyBtYXQ0LlNJTUQubXVsdGlwbHkgOiBtYXQ0LnNjYWxhci5tdWx0aXBseTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0NC5tdWwgPSBtYXQ0Lm11bHRpcGx5O1xuXG4vKipcbiAqIFRyYW5zbGF0ZSBhIG1hdDQgYnkgdGhlIGdpdmVuIHZlY3RvciBub3QgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjM30gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc2NhbGFyLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdLCB6ID0gdlsyXSxcbiAgICAgICAgYTAwLCBhMDEsIGEwMiwgYTAzLFxuICAgICAgICBhMTAsIGExMSwgYTEyLCBhMTMsXG4gICAgICAgIGEyMCwgYTIxLCBhMjIsIGEyMztcblxuICAgIGlmIChhID09PSBvdXQpIHtcbiAgICAgICAgb3V0WzEyXSA9IGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxXSAqIHggKyBhWzVdICogeSArIGFbOV0gKiB6ICsgYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6ICsgYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcbiAgICAgICAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgICAgICAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gICAgICAgIG91dFswXSA9IGEwMDsgb3V0WzFdID0gYTAxOyBvdXRbMl0gPSBhMDI7IG91dFszXSA9IGEwMztcbiAgICAgICAgb3V0WzRdID0gYTEwOyBvdXRbNV0gPSBhMTE7IG91dFs2XSA9IGExMjsgb3V0WzddID0gYTEzO1xuICAgICAgICBvdXRbOF0gPSBhMjA7IG91dFs5XSA9IGEyMTsgb3V0WzEwXSA9IGEyMjsgb3V0WzExXSA9IGEyMztcblxuICAgICAgICBvdXRbMTJdID0gYTAwICogeCArIGExMCAqIHkgKyBhMjAgKiB6ICsgYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhMDEgKiB4ICsgYTExICogeSArIGEyMSAqIHogKyBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGEwMiAqIHggKyBhMTIgKiB5ICsgYTIyICogeiArIGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYTAzICogeCArIGExMyAqIHkgKyBhMjMgKiB6ICsgYVsxNV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNsYXRlcyBhIG1hdDQgYnkgdGhlIGdpdmVuIHZlY3RvciB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5TSU1ELnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDApLFxuICAgICAgICBhMSA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgNCksXG4gICAgICAgIGEyID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA4KSxcbiAgICAgICAgYTMgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDEyKSxcbiAgICAgICAgdmVjID0gU0lNRC5GbG9hdDMyeDQodlswXSwgdlsxXSwgdlsyXSAsIDApO1xuXG4gICAgaWYgKGEgIT09IG91dCkge1xuICAgICAgICBvdXRbMF0gPSBhWzBdOyBvdXRbMV0gPSBhWzFdOyBvdXRbMl0gPSBhWzJdOyBvdXRbM10gPSBhWzNdO1xuICAgICAgICBvdXRbNF0gPSBhWzRdOyBvdXRbNV0gPSBhWzVdOyBvdXRbNl0gPSBhWzZdOyBvdXRbN10gPSBhWzddO1xuICAgICAgICBvdXRbOF0gPSBhWzhdOyBvdXRbOV0gPSBhWzldOyBvdXRbMTBdID0gYVsxMF07IG91dFsxMV0gPSBhWzExXTtcbiAgICB9XG5cbiAgICBhMCA9IFNJTUQuRmxvYXQzMng0Lm11bChhMCwgU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh2ZWMsIDAsIDAsIDAsIDApKTtcbiAgICBhMSA9IFNJTUQuRmxvYXQzMng0Lm11bChhMSwgU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh2ZWMsIDEsIDEsIDEsIDEpKTtcbiAgICBhMiA9IFNJTUQuRmxvYXQzMng0Lm11bChhMiwgU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh2ZWMsIDIsIDIsIDIsIDIpKTtcblxuICAgIHZhciB0MCA9IFNJTUQuRmxvYXQzMng0LmFkZChhMCwgU0lNRC5GbG9hdDMyeDQuYWRkKGExLCBTSU1ELkZsb2F0MzJ4NC5hZGQoYTIsIGEzKSkpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMTIsIHQwKTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiB2ZWN0b3IgdXNpbmcgU0lNRCBpZiBhdmFpbGFibGUgYW5kIGVuYWJsZWRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnRyYW5zbGF0ZSA9IGdsTWF0cml4LlVTRV9TSU1EID8gbWF0NC5TSU1ELnRyYW5zbGF0ZSA6IG1hdDQuc2NhbGFyLnRyYW5zbGF0ZTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzMgbm90IHVzaW5nIHZlY3Rvcml6YXRpb25cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7dmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKiovXG5tYXQ0LnNjYWxhci5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdO1xuXG4gICAgb3V0WzBdID0gYVswXSAqIHg7XG4gICAgb3V0WzFdID0gYVsxXSAqIHg7XG4gICAgb3V0WzJdID0gYVsyXSAqIHg7XG4gICAgb3V0WzNdID0gYVszXSAqIHg7XG4gICAgb3V0WzRdID0gYVs0XSAqIHk7XG4gICAgb3V0WzVdID0gYVs1XSAqIHk7XG4gICAgb3V0WzZdID0gYVs2XSAqIHk7XG4gICAgb3V0WzddID0gYVs3XSAqIHk7XG4gICAgb3V0WzhdID0gYVs4XSAqIHo7XG4gICAgb3V0WzldID0gYVs5XSAqIHo7XG4gICAgb3V0WzEwXSA9IGFbMTBdICogejtcbiAgICBvdXRbMTFdID0gYVsxMV0gKiB6O1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzMgdXNpbmcgdmVjdG9yaXphdGlvblxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHt2ZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqKi9cbm1hdDQuU0lNRC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCwgYTEsIGEyO1xuICAgIHZhciB2ZWMgPSBTSU1ELkZsb2F0MzJ4NCh2WzBdLCB2WzFdLCB2WzJdLCAwKTtcblxuICAgIGEwID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAwKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShcbiAgICAgICAgb3V0LCAwLCBTSU1ELkZsb2F0MzJ4NC5tdWwoYTAsIFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodmVjLCAwLCAwLCAwLCAwKSkpO1xuXG4gICAgYTEgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDQpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKFxuICAgICAgICBvdXQsIDQsIFNJTUQuRmxvYXQzMng0Lm11bChhMSwgU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh2ZWMsIDEsIDEsIDEsIDEpKSk7XG5cbiAgICBhMiA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgOCk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUoXG4gICAgICAgIG91dCwgOCwgU0lNRC5GbG9hdDMyeDQubXVsKGEyLCBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHZlYywgMiwgMiwgMiwgMikpKTtcblxuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzMgdXNpbmcgU0lNRCBpZiBhdmFpbGFibGUgYW5kIGVuYWJsZWRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7dmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc2NhbGUgPSBnbE1hdHJpeC5VU0VfU0lNRCA/IG1hdDQuU0lNRC5zY2FsZSA6IG1hdDQuc2NhbGFyLnNjYWxlO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIGdpdmVuIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQsIGF4aXMpIHtcbiAgICB2YXIgeCA9IGF4aXNbMF0sIHkgPSBheGlzWzFdLCB6ID0gYXhpc1syXSxcbiAgICAgICAgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeiksXG4gICAgICAgIHMsIGMsIHQsXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjMsXG4gICAgICAgIGIwMCwgYjAxLCBiMDIsXG4gICAgICAgIGIxMCwgYjExLCBiMTIsXG4gICAgICAgIGIyMCwgYjIxLCBiMjI7XG5cbiAgICBpZiAoTWF0aC5hYnMobGVuKSA8IGdsTWF0cml4LkVQU0lMT04pIHsgcmV0dXJuIG51bGw7IH1cblxuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeCAqPSBsZW47XG4gICAgeSAqPSBsZW47XG4gICAgeiAqPSBsZW47XG5cbiAgICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICB0ID0gMSAtIGM7XG5cbiAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gICAgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XG4gICAgYjAwID0geCAqIHggKiB0ICsgYzsgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7IGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xuICAgIGIxMCA9IHggKiB5ICogdCAtIHogKiBzOyBiMTEgPSB5ICogeSAqIHQgKyBjOyBiMTIgPSB6ICogeSAqIHQgKyB4ICogcztcbiAgICBiMjAgPSB4ICogeiAqIHQgKyB5ICogczsgYjIxID0geSAqIHogKiB0IC0geCAqIHM7IGIyMiA9IHogKiB6ICogdCArIGM7XG5cbiAgICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMjtcbiAgICBvdXRbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDI7XG4gICAgb3V0WzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xuICAgIG91dFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMjtcbiAgICBvdXRbNF0gPSBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTI7XG4gICAgb3V0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICAgIG91dFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMjtcbiAgICBvdXRbN10gPSBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTI7XG4gICAgb3V0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICAgIG91dFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMjtcbiAgICBvdXRbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyO1xuICAgIG91dFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXMgbm90IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnNjYWxhci5yb3RhdGVYID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSxcbiAgICAgICAgYTIxID0gYVs5XSxcbiAgICAgICAgYTIyID0gYVsxMF0sXG4gICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICAgIG91dFswXSAgPSBhWzBdO1xuICAgICAgICBvdXRbMV0gID0gYVsxXTtcbiAgICAgICAgb3V0WzJdICA9IGFbMl07XG4gICAgICAgIG91dFszXSAgPSBhWzNdO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFs0XSA9IGExMCAqIGMgKyBhMjAgKiBzO1xuICAgIG91dFs1XSA9IGExMSAqIGMgKyBhMjEgKiBzO1xuICAgIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICAgIG91dFs3XSA9IGExMyAqIGMgKyBhMjMgKiBzO1xuICAgIG91dFs4XSA9IGEyMCAqIGMgLSBhMTAgKiBzO1xuICAgIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICAgIG91dFsxMF0gPSBhMjIgKiBjIC0gYTEyICogcztcbiAgICBvdXRbMTFdID0gYTIzICogYyAtIGExMyAqIHM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXMgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuU0lNRC5yb3RhdGVYID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBTSU1ELkZsb2F0MzJ4NC5zcGxhdChNYXRoLnNpbihyYWQpKSxcbiAgICAgICAgYyA9IFNJTUQuRmxvYXQzMng0LnNwbGF0KE1hdGguY29zKHJhZCkpO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICBvdXRbMF0gID0gYVswXTtcbiAgICAgIG91dFsxXSAgPSBhWzFdO1xuICAgICAgb3V0WzJdICA9IGFbMl07XG4gICAgICBvdXRbM10gID0gYVszXTtcbiAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgdmFyIGFfMSA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgNCk7XG4gICAgdmFyIGFfMiA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgOCk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwoYV8xLCBjKSwgU0lNRC5GbG9hdDMyeDQubXVsKGFfMiwgcykpKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChhXzIsIGMpLCBTSU1ELkZsb2F0MzJ4NC5tdWwoYV8xLCBzKSkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzIHVzaW5nIFNJTUQgaWYgYXZhaWxhYmUgYW5kIGVuYWJsZWRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZVggPSBnbE1hdHJpeC5VU0VfU0lNRCA/IG1hdDQuU0lNRC5yb3RhdGVYIDogbWF0NC5zY2FsYXIucm90YXRlWDtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpcyBub3QgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc2NhbGFyLnJvdGF0ZVkgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdLFxuICAgICAgICBhMjAgPSBhWzhdLFxuICAgICAgICBhMjEgPSBhWzldLFxuICAgICAgICBhMjIgPSBhWzEwXSxcbiAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzRdICA9IGFbNF07XG4gICAgICAgIG91dFs1XSAgPSBhWzVdO1xuICAgICAgICBvdXRbNl0gID0gYVs2XTtcbiAgICAgICAgb3V0WzddICA9IGFbN107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYyAtIGEyMCAqIHM7XG4gICAgb3V0WzFdID0gYTAxICogYyAtIGEyMSAqIHM7XG4gICAgb3V0WzJdID0gYTAyICogYyAtIGEyMiAqIHM7XG4gICAgb3V0WzNdID0gYTAzICogYyAtIGEyMyAqIHM7XG4gICAgb3V0WzhdID0gYTAwICogcyArIGEyMCAqIGM7XG4gICAgb3V0WzldID0gYTAxICogcyArIGEyMSAqIGM7XG4gICAgb3V0WzEwXSA9IGEwMiAqIHMgKyBhMjIgKiBjO1xuICAgIG91dFsxMV0gPSBhMDMgKiBzICsgYTIzICogYztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpcyB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5TSU1ELnJvdGF0ZVkgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IFNJTUQuRmxvYXQzMng0LnNwbGF0KE1hdGguc2luKHJhZCkpLFxuICAgICAgICBjID0gU0lNRC5GbG9hdDMyeDQuc3BsYXQoTWF0aC5jb3MocmFkKSk7XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzRdICA9IGFbNF07XG4gICAgICAgIG91dFs1XSAgPSBhWzVdO1xuICAgICAgICBvdXRbNl0gID0gYVs2XTtcbiAgICAgICAgb3V0WzddICA9IGFbN107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgdmFyIGFfMCA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMCk7XG4gICAgdmFyIGFfMiA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgOCk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwoYV8wLCBjKSwgU0lNRC5GbG9hdDMyeDQubXVsKGFfMiwgcykpKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChhXzAsIHMpLCBTSU1ELkZsb2F0MzJ4NC5tdWwoYV8yLCBjKSkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzIGlmIFNJTUQgYXZhaWxhYmxlIGFuZCBlbmFibGVkXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuIG1hdDQucm90YXRlWSA9IGdsTWF0cml4LlVTRV9TSU1EID8gbWF0NC5TSU1ELnJvdGF0ZVkgOiBtYXQ0LnNjYWxhci5yb3RhdGVZO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzIG5vdCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zY2FsYXIucm90YXRlWiA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sXG4gICAgICAgIGExMSA9IGFbNV0sXG4gICAgICAgIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN107XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgICAgIG91dFs4XSAgPSBhWzhdO1xuICAgICAgICBvdXRbOV0gID0gYVs5XTtcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgICAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYyArIGExMCAqIHM7XG4gICAgb3V0WzFdID0gYTAxICogYyArIGExMSAqIHM7XG4gICAgb3V0WzJdID0gYTAyICogYyArIGExMiAqIHM7XG4gICAgb3V0WzNdID0gYTAzICogYyArIGExMyAqIHM7XG4gICAgb3V0WzRdID0gYTEwICogYyAtIGEwMCAqIHM7XG4gICAgb3V0WzVdID0gYTExICogYyAtIGEwMSAqIHM7XG4gICAgb3V0WzZdID0gYTEyICogYyAtIGEwMiAqIHM7XG4gICAgb3V0WzddID0gYTEzICogYyAtIGEwMyAqIHM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXMgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuU0lNRC5yb3RhdGVaID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBTSU1ELkZsb2F0MzJ4NC5zcGxhdChNYXRoLnNpbihyYWQpKSxcbiAgICAgICAgYyA9IFNJTUQuRmxvYXQzMng0LnNwbGF0KE1hdGguY29zKHJhZCkpO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgICAgICBvdXRbOF0gID0gYVs4XTtcbiAgICAgICAgb3V0WzldICA9IGFbOV07XG4gICAgICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICAgICAgb3V0WzExXSA9IGFbMTFdO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIHZhciBhXzAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDApO1xuICAgIHZhciBhXzEgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDQpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKGFfMCwgYyksIFNJTUQuRmxvYXQzMng0Lm11bChhXzEsIHMpKSk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwoYV8xLCBjKSwgU0lNRC5GbG9hdDMyeDQubXVsKGFfMCwgcykpKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpcyBpZiBTSU1EIGF2YWlsYWJsZSBhbmQgZW5hYmxlZFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbiBtYXQ0LnJvdGF0ZVogPSBnbE1hdHJpeC5VU0VfU0lNRCA/IG1hdDQuU0lNRC5yb3RhdGVaIDogbWF0NC5zY2FsYXIucm90YXRlWjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IHZbMF07XG4gICAgb3V0WzEzXSA9IHZbMV07XG4gICAgb3V0WzE0XSA9IHZbMl07XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjM30gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21TY2FsaW5nID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gdlswXTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IHZbMV07XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gdlsyXTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlIGFyb3VuZCBhIGdpdmVuIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCwgYXhpcyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQsIGF4aXMpIHtcbiAgICB2YXIgeCA9IGF4aXNbMF0sIHkgPSBheGlzWzFdLCB6ID0gYXhpc1syXSxcbiAgICAgICAgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeiksXG4gICAgICAgIHMsIGMsIHQ7XG5cbiAgICBpZiAoTWF0aC5hYnMobGVuKSA8IGdsTWF0cml4LkVQU0lMT04pIHsgcmV0dXJuIG51bGw7IH1cblxuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeCAqPSBsZW47XG4gICAgeSAqPSBsZW47XG4gICAgeiAqPSBsZW47XG5cbiAgICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICB0ID0gMSAtIGM7XG5cbiAgICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IHggKiB4ICogdCArIGM7XG4gICAgb3V0WzFdID0geSAqIHggKiB0ICsgeiAqIHM7XG4gICAgb3V0WzJdID0geiAqIHggKiB0IC0geSAqIHM7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4ICogeSAqIHQgLSB6ICogcztcbiAgICBvdXRbNV0gPSB5ICogeSAqIHQgKyBjO1xuICAgIG91dFs2XSA9IHogKiB5ICogdCArIHggKiBzO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geCAqIHogKiB0ICsgeSAqIHM7XG4gICAgb3V0WzldID0geSAqIHogKiB0IC0geCAqIHM7XG4gICAgb3V0WzEwXSA9IHogKiB6ICogdCArIGM7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVgoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21YUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdICA9IDE7XG4gICAgb3V0WzFdICA9IDA7XG4gICAgb3V0WzJdICA9IDA7XG4gICAgb3V0WzNdICA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSBjO1xuICAgIG91dFs2XSA9IHM7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IC1zO1xuICAgIG91dFsxMF0gPSBjO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGVZKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tWVJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSAgPSBjO1xuICAgIG91dFsxXSAgPSAwO1xuICAgIG91dFsyXSAgPSAtcztcbiAgICBvdXRbM10gID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHM7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gYztcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlWihkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVpSb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gID0gYztcbiAgICBvdXRbMV0gID0gcztcbiAgICBvdXRbMl0gID0gMDtcbiAgICBvdXRbM10gID0gMDtcbiAgICBvdXRbNF0gPSAtcztcbiAgICBvdXRbNV0gPSBjO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgdmFyIHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uID0gZnVuY3Rpb24gKG91dCwgcSwgdikge1xuICAgIC8vIFF1YXRlcm5pb24gbWF0aFxuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeHkgPSB4ICogeTIsXG4gICAgICAgIHh6ID0geCAqIHoyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgeXogPSB5ICogejIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtICh5eSArIHp6KTtcbiAgICBvdXRbMV0gPSB4eSArIHd6O1xuICAgIG91dFsyXSA9IHh6IC0gd3k7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4eSAtIHd6O1xuICAgIG91dFs1XSA9IDEgLSAoeHggKyB6eik7XG4gICAgb3V0WzZdID0geXogKyB3eDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHh6ICsgd3k7XG4gICAgb3V0WzldID0geXogLSB3eDtcbiAgICBvdXRbMTBdID0gMSAtICh4eCArIHl5KTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gdlswXTtcbiAgICBvdXRbMTNdID0gdlsxXTtcbiAgICBvdXRbMTRdID0gdlsyXTtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIHZlY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxuICogIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aCBmcm9tUm90YXRpb25UcmFuc2xhdGlvbixcbiAqICB0aGUgcmV0dXJuZWQgdmVjdG9yIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIHRyYW5zbGF0aW9uIHZlY3RvclxuICogIG9yaWdpbmFsbHkgc3VwcGxpZWQuXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgdHJhbnNsYXRpb24gY29tcG9uZW50XG4gKiBAcGFyYW0gIHttYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxuICogQHJldHVybiB7dmVjM30gb3V0XG4gKi9cbm1hdDQuZ2V0VHJhbnNsYXRpb24gPSBmdW5jdGlvbiAob3V0LCBtYXQpIHtcbiAgb3V0WzBdID0gbWF0WzEyXTtcbiAgb3V0WzFdID0gbWF0WzEzXTtcbiAgb3V0WzJdID0gbWF0WzE0XTtcblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIHJvdGF0aW9uYWwgY29tcG9uZW50XG4gKiAgb2YgYSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguIElmIGEgbWF0cml4IGlzIGJ1aWx0IHdpdGhcbiAqICBmcm9tUm90YXRpb25UcmFuc2xhdGlvbiwgdGhlIHJldHVybmVkIHF1YXRlcm5pb24gd2lsbCBiZSB0aGVcbiAqICBzYW1lIGFzIHRoZSBxdWF0ZXJuaW9uIG9yaWdpbmFsbHkgc3VwcGxpZWQuXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBRdWF0ZXJuaW9uIHRvIHJlY2VpdmUgdGhlIHJvdGF0aW9uIGNvbXBvbmVudFxuICogQHBhcmFtIHttYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxuICogQHJldHVybiB7cXVhdH0gb3V0XG4gKi9cbm1hdDQuZ2V0Um90YXRpb24gPSBmdW5jdGlvbiAob3V0LCBtYXQpIHtcbiAgLy8gQWxnb3JpdGhtIHRha2VuIGZyb20gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cbiAgdmFyIHRyYWNlID0gbWF0WzBdICsgbWF0WzVdICsgbWF0WzEwXTtcbiAgdmFyIFMgPSAwO1xuXG4gIGlmICh0cmFjZSA+IDApIHsgXG4gICAgUyA9IE1hdGguc3FydCh0cmFjZSArIDEuMCkgKiAyO1xuICAgIG91dFszXSA9IDAuMjUgKiBTO1xuICAgIG91dFswXSA9IChtYXRbNl0gLSBtYXRbOV0pIC8gUztcbiAgICBvdXRbMV0gPSAobWF0WzhdIC0gbWF0WzJdKSAvIFM7IFxuICAgIG91dFsyXSA9IChtYXRbMV0gLSBtYXRbNF0pIC8gUzsgXG4gIH0gZWxzZSBpZiAoKG1hdFswXSA+IG1hdFs1XSkmKG1hdFswXSA+IG1hdFsxMF0pKSB7IFxuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgbWF0WzBdIC0gbWF0WzVdIC0gbWF0WzEwXSkgKiAyO1xuICAgIG91dFszXSA9IChtYXRbNl0gLSBtYXRbOV0pIC8gUztcbiAgICBvdXRbMF0gPSAwLjI1ICogUztcbiAgICBvdXRbMV0gPSAobWF0WzFdICsgbWF0WzRdKSAvIFM7IFxuICAgIG91dFsyXSA9IChtYXRbOF0gKyBtYXRbMl0pIC8gUzsgXG4gIH0gZWxzZSBpZiAobWF0WzVdID4gbWF0WzEwXSkgeyBcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIG1hdFs1XSAtIG1hdFswXSAtIG1hdFsxMF0pICogMjtcbiAgICBvdXRbM10gPSAobWF0WzhdIC0gbWF0WzJdKSAvIFM7XG4gICAgb3V0WzBdID0gKG1hdFsxXSArIG1hdFs0XSkgLyBTOyBcbiAgICBvdXRbMV0gPSAwLjI1ICogUztcbiAgICBvdXRbMl0gPSAobWF0WzZdICsgbWF0WzldKSAvIFM7IFxuICB9IGVsc2UgeyBcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIG1hdFsxMF0gLSBtYXRbMF0gLSBtYXRbNV0pICogMjtcbiAgICBvdXRbM10gPSAobWF0WzFdIC0gbWF0WzRdKSAvIFM7XG4gICAgb3V0WzBdID0gKG1hdFs4XSArIG1hdFsyXSkgLyBTO1xuICAgIG91dFsxXSA9IChtYXRbNl0gKyBtYXRbOV0pIC8gUztcbiAgICBvdXRbMl0gPSAwLjI1ICogUztcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24sIHZlY3RvciB0cmFuc2xhdGlvbiBhbmQgdmVjdG9yIHNjYWxlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIHZhciBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBzIFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZSA9IGZ1bmN0aW9uIChvdXQsIHEsIHYsIHMpIHtcbiAgICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHh5ID0geCAqIHkyLFxuICAgICAgICB4eiA9IHggKiB6MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MixcbiAgICAgICAgc3ggPSBzWzBdLFxuICAgICAgICBzeSA9IHNbMV0sXG4gICAgICAgIHN6ID0gc1syXTtcblxuICAgIG91dFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICAgIG91dFsxXSA9ICh4eSArIHd6KSAqIHN4O1xuICAgIG91dFsyXSA9ICh4eiAtIHd5KSAqIHN4O1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gKHh5IC0gd3opICogc3k7XG4gICAgb3V0WzVdID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gICAgb3V0WzZdID0gKHl6ICsgd3gpICogc3k7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAoeHogKyB3eSkgKiBzejtcbiAgICBvdXRbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgICBvdXRbMTBdID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IHZbMF07XG4gICAgb3V0WzEzXSA9IHZbMV07XG4gICAgb3V0WzE0XSA9IHZbMl07XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLCB2ZWN0b3IgdHJhbnNsYXRpb24gYW5kIHZlY3RvciBzY2FsZSwgcm90YXRpbmcgYW5kIHNjYWxpbmcgYXJvdW5kIHRoZSBnaXZlbiBvcmlnaW5cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgb3JpZ2luKTtcbiAqICAgICB2YXIgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBzY2FsZSlcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBuZWdhdGl2ZU9yaWdpbik7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gbyBUaGUgb3JpZ2luIHZlY3RvciBhcm91bmQgd2hpY2ggdG8gc2NhbGUgYW5kIHJvdGF0ZVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVPcmlnaW4gPSBmdW5jdGlvbiAob3V0LCBxLCB2LCBzLCBvKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICB4MiA9IHggKyB4LFxuICAgICAgeTIgPSB5ICsgeSxcbiAgICAgIHoyID0geiArIHosXG5cbiAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgeHkgPSB4ICogeTIsXG4gICAgICB4eiA9IHggKiB6MixcbiAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgeXogPSB5ICogejIsXG4gICAgICB6eiA9IHogKiB6MixcbiAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgd3kgPSB3ICogeTIsXG4gICAgICB3eiA9IHcgKiB6MixcblxuICAgICAgc3ggPSBzWzBdLFxuICAgICAgc3kgPSBzWzFdLFxuICAgICAgc3ogPSBzWzJdLFxuXG4gICAgICBveCA9IG9bMF0sXG4gICAgICBveSA9IG9bMV0sXG4gICAgICBveiA9IG9bMl07XG5cbiAgb3V0WzBdID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gIG91dFsxXSA9ICh4eSArIHd6KSAqIHN4O1xuICBvdXRbMl0gPSAoeHogLSB3eSkgKiBzeDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gKHh5IC0gd3opICogc3k7XG4gIG91dFs1XSA9ICgxIC0gKHh4ICsgenopKSAqIHN5O1xuICBvdXRbNl0gPSAoeXogKyB3eCkgKiBzeTtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gKHh6ICsgd3kpICogc3o7XG4gIG91dFs5XSA9ICh5eiAtIHd4KSAqIHN6O1xuICBvdXRbMTBdID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXSArIG94IC0gKG91dFswXSAqIG94ICsgb3V0WzRdICogb3kgKyBvdXRbOF0gKiBveik7XG4gIG91dFsxM10gPSB2WzFdICsgb3kgLSAob3V0WzFdICogb3ggKyBvdXRbNV0gKiBveSArIG91dFs5XSAqIG96KTtcbiAgb3V0WzE0XSA9IHZbMl0gKyBveiAtIChvdXRbMl0gKiBveCArIG91dFs2XSAqIG95ICsgb3V0WzEwXSAqIG96KTtcbiAgb3V0WzE1XSA9IDE7XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBhIDR4NCBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gcSBRdWF0ZXJuaW9uIHRvIGNyZWF0ZSBtYXRyaXggZnJvbVxuICpcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tUXVhdCA9IGZ1bmN0aW9uIChvdXQsIHEpIHtcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHl4ID0geSAqIHgyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgenggPSB6ICogeDIsXG4gICAgICAgIHp5ID0geiAqIHkyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICAgIG91dFsxXSA9IHl4ICsgd3o7XG4gICAgb3V0WzJdID0genggLSB3eTtcbiAgICBvdXRbM10gPSAwO1xuXG4gICAgb3V0WzRdID0geXggLSB3ejtcbiAgICBvdXRbNV0gPSAxIC0geHggLSB6ejtcbiAgICBvdXRbNl0gPSB6eSArIHd4O1xuICAgIG91dFs3XSA9IDA7XG5cbiAgICBvdXRbOF0gPSB6eCArIHd5O1xuICAgIG91dFs5XSA9IHp5IC0gd3g7XG4gICAgb3V0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICAgIG91dFsxMV0gPSAwO1xuXG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBmcnVzdHVtIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcnVzdHVtID0gZnVuY3Rpb24gKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgcmwgPSAxIC8gKHJpZ2h0IC0gbGVmdCksXG4gICAgICAgIHRiID0gMSAvICh0b3AgLSBib3R0b20pLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gKG5lYXIgKiAyKSAqIHJsO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gKG5lYXIgKiAyKSAqIHRiO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAocmlnaHQgKyBsZWZ0KSAqIHJsO1xuICAgIG91dFs5XSA9ICh0b3AgKyBib3R0b20pICogdGI7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKGZhciAqIG5lYXIgKiAyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucGVyc3BlY3RpdmUgPSBmdW5jdGlvbiAob3V0LCBmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICAgIHZhciBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IGY7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzExXSA9IC0xO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAoMiAqIGZhciAqIG5lYXIpICogbmY7XG4gICAgb3V0WzE1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZmllbGQgb2Ygdmlldy5cbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWZ1bCBmb3IgZ2VuZXJhdGluZyBwcm9qZWN0aW9uIG1hdHJpY2VzIHRvIGJlIHVzZWRcbiAqIHdpdGggdGhlIHN0aWxsIGV4cGVyaWVtZW50YWwgV2ViVlIgQVBJLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBmb3YgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyB2YWx1ZXM6IHVwRGVncmVlcywgZG93bkRlZ3JlZXMsIGxlZnREZWdyZWVzLCByaWdodERlZ3JlZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcgPSBmdW5jdGlvbiAob3V0LCBmb3YsIG5lYXIsIGZhcikge1xuICAgIHZhciB1cFRhbiA9IE1hdGgudGFuKGZvdi51cERlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgZG93blRhbiA9IE1hdGgudGFuKGZvdi5kb3duRGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICBsZWZ0VGFuID0gTWF0aC50YW4oZm92LmxlZnREZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIHJpZ2h0VGFuID0gTWF0aC50YW4oZm92LnJpZ2h0RGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICB4U2NhbGUgPSAyLjAgLyAobGVmdFRhbiArIHJpZ2h0VGFuKSxcbiAgICAgICAgeVNjYWxlID0gMi4wIC8gKHVwVGFuICsgZG93blRhbik7XG5cbiAgICBvdXRbMF0gPSB4U2NhbGU7XG4gICAgb3V0WzFdID0gMC4wO1xuICAgIG91dFsyXSA9IDAuMDtcbiAgICBvdXRbM10gPSAwLjA7XG4gICAgb3V0WzRdID0gMC4wO1xuICAgIG91dFs1XSA9IHlTY2FsZTtcbiAgICBvdXRbNl0gPSAwLjA7XG4gICAgb3V0WzddID0gMC4wO1xuICAgIG91dFs4XSA9IC0oKGxlZnRUYW4gLSByaWdodFRhbikgKiB4U2NhbGUgKiAwLjUpO1xuICAgIG91dFs5XSA9ICgodXBUYW4gLSBkb3duVGFuKSAqIHlTY2FsZSAqIDAuNSk7XG4gICAgb3V0WzEwXSA9IGZhciAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTFdID0gLTEuMDtcbiAgICBvdXRbMTJdID0gMC4wO1xuICAgIG91dFsxM10gPSAwLjA7XG4gICAgb3V0WzE0XSA9IChmYXIgKiBuZWFyKSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTVdID0gMC4wO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5vcnRobyA9IGZ1bmN0aW9uIChvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpLFxuICAgICAgICBidCA9IDEgLyAoYm90dG9tIC0gdG9wKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IC0yICogbHI7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAtMiAqIGJ0O1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDIgKiBuZjtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgICBvdXRbMTNdID0gKHRvcCArIGJvdHRvbSkgKiBidDtcbiAgICBvdXRbMTRdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge3ZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcbiAqIEBwYXJhbSB7dmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lmxvb2tBdCA9IGZ1bmN0aW9uIChvdXQsIGV5ZSwgY2VudGVyLCB1cCkge1xuICAgIHZhciB4MCwgeDEsIHgyLCB5MCwgeTEsIHkyLCB6MCwgejEsIHoyLCBsZW4sXG4gICAgICAgIGV5ZXggPSBleWVbMF0sXG4gICAgICAgIGV5ZXkgPSBleWVbMV0sXG4gICAgICAgIGV5ZXogPSBleWVbMl0sXG4gICAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgICB1cHkgPSB1cFsxXSxcbiAgICAgICAgdXB6ID0gdXBbMl0sXG4gICAgICAgIGNlbnRlcnggPSBjZW50ZXJbMF0sXG4gICAgICAgIGNlbnRlcnkgPSBjZW50ZXJbMV0sXG4gICAgICAgIGNlbnRlcnogPSBjZW50ZXJbMl07XG5cbiAgICBpZiAoTWF0aC5hYnMoZXlleCAtIGNlbnRlcngpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJlxuICAgICAgICBNYXRoLmFicyhleWV5IC0gY2VudGVyeSkgPCBnbE1hdHJpeC5FUFNJTE9OICYmXG4gICAgICAgIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICAgICAgcmV0dXJuIG1hdDQuaWRlbnRpdHkob3V0KTtcbiAgICB9XG5cbiAgICB6MCA9IGV5ZXggLSBjZW50ZXJ4O1xuICAgIHoxID0gZXlleSAtIGNlbnRlcnk7XG4gICAgejIgPSBleWV6IC0gY2VudGVyejtcblxuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQoejAgKiB6MCArIHoxICogejEgKyB6MiAqIHoyKTtcbiAgICB6MCAqPSBsZW47XG4gICAgejEgKj0gbGVuO1xuICAgIHoyICo9IGxlbjtcblxuICAgIHgwID0gdXB5ICogejIgLSB1cHogKiB6MTtcbiAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejI7XG4gICAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICAgIGxlbiA9IE1hdGguc3FydCh4MCAqIHgwICsgeDEgKiB4MSArIHgyICogeDIpO1xuICAgIGlmICghbGVuKSB7XG4gICAgICAgIHgwID0gMDtcbiAgICAgICAgeDEgPSAwO1xuICAgICAgICB4MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gMSAvIGxlbjtcbiAgICAgICAgeDAgKj0gbGVuO1xuICAgICAgICB4MSAqPSBsZW47XG4gICAgICAgIHgyICo9IGxlbjtcbiAgICB9XG5cbiAgICB5MCA9IHoxICogeDIgLSB6MiAqIHgxO1xuICAgIHkxID0gejIgKiB4MCAtIHowICogeDI7XG4gICAgeTIgPSB6MCAqIHgxIC0gejEgKiB4MDtcblxuICAgIGxlbiA9IE1hdGguc3FydCh5MCAqIHkwICsgeTEgKiB5MSArIHkyICogeTIpO1xuICAgIGlmICghbGVuKSB7XG4gICAgICAgIHkwID0gMDtcbiAgICAgICAgeTEgPSAwO1xuICAgICAgICB5MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gMSAvIGxlbjtcbiAgICAgICAgeTAgKj0gbGVuO1xuICAgICAgICB5MSAqPSBsZW47XG4gICAgICAgIHkyICo9IGxlbjtcbiAgICB9XG5cbiAgICBvdXRbMF0gPSB4MDtcbiAgICBvdXRbMV0gPSB5MDtcbiAgICBvdXRbMl0gPSB6MDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHgxO1xuICAgIG91dFs1XSA9IHkxO1xuICAgIG91dFs2XSA9IHoxO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geDI7XG4gICAgb3V0WzldID0geTI7XG4gICAgb3V0WzEwXSA9IHoyO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAtKHgwICogZXlleCArIHgxICogZXlleSArIHgyICogZXlleik7XG4gICAgb3V0WzEzXSA9IC0oeTAgKiBleWV4ICsgeTEgKiBleWV5ICsgeTIgKiBleWV6KTtcbiAgICBvdXRbMTRdID0gLSh6MCAqIGV5ZXggKyB6MSAqIGV5ZXkgKyB6MiAqIGV5ZXopO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQ0LnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQ0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIGFbNF0gKyAnLCAnICsgYVs1XSArICcsICcgKyBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgYVs4XSArICcsICcgKyBhWzldICsgJywgJyArIGFbMTBdICsgJywgJyArIGFbMTFdICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIGFbMTJdICsgJywgJyArIGFbMTNdICsgJywgJyArIGFbMTRdICsgJywgJyArIGFbMTVdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0NC5mcm9iID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIE1hdGgucG93KGFbNl0sIDIpICsgTWF0aC5wb3coYVs3XSwgMikgKyBNYXRoLnBvdyhhWzhdLCAyKSArIE1hdGgucG93KGFbOV0sIDIpICsgTWF0aC5wb3coYVsxMF0sIDIpICsgTWF0aC5wb3coYVsxMV0sIDIpICsgTWF0aC5wb3coYVsxMl0sIDIpICsgTWF0aC5wb3coYVsxM10sIDIpICsgTWF0aC5wb3coYVsxNF0sIDIpICsgTWF0aC5wb3coYVsxNV0sIDIpICkpXG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDQnc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgICBvdXRbN10gPSBhWzddICsgYls3XTtcbiAgICBvdXRbOF0gPSBhWzhdICsgYls4XTtcbiAgICBvdXRbOV0gPSBhWzldICsgYls5XTtcbiAgICBvdXRbMTBdID0gYVsxMF0gKyBiWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV0gKyBiWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl0gKyBiWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM10gKyBiWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF0gKyBiWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV0gKyBiWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICAgIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICAgIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICAgIG91dFs2XSA9IGFbNl0gLSBiWzZdO1xuICAgIG91dFs3XSA9IGFbN10gLSBiWzddO1xuICAgIG91dFs4XSA9IGFbOF0gLSBiWzhdO1xuICAgIG91dFs5XSA9IGFbOV0gLSBiWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXSAtIGJbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXSAtIGJbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXSAtIGJbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXSAtIGJbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XSAtIGJbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XSAtIGJbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQ0LnN1YiA9IG1hdDQuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQubXVsdGlwbHlTY2FsYXIgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICBvdXRbM10gPSBhWzNdICogYjtcbiAgICBvdXRbNF0gPSBhWzRdICogYjtcbiAgICBvdXRbNV0gPSBhWzVdICogYjtcbiAgICBvdXRbNl0gPSBhWzZdICogYjtcbiAgICBvdXRbN10gPSBhWzddICogYjtcbiAgICBvdXRbOF0gPSBhWzhdICogYjtcbiAgICBvdXRbOV0gPSBhWzldICogYjtcbiAgICBvdXRbMTBdID0gYVsxMF0gKiBiO1xuICAgIG91dFsxMV0gPSBhWzExXSAqIGI7XG4gICAgb3V0WzEyXSA9IGFbMTJdICogYjtcbiAgICBvdXRbMTNdID0gYVsxM10gKiBiO1xuICAgIG91dFsxNF0gPSBhWzE0XSAqIGI7XG4gICAgb3V0WzE1XSA9IGFbMTVdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byBtYXQ0J3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lm11bHRpcGx5U2NhbGFyQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgICBvdXRbNF0gPSBhWzRdICsgKGJbNF0gKiBzY2FsZSk7XG4gICAgb3V0WzVdID0gYVs1XSArIChiWzVdICogc2NhbGUpO1xuICAgIG91dFs2XSA9IGFbNl0gKyAoYls2XSAqIHNjYWxlKTtcbiAgICBvdXRbN10gPSBhWzddICsgKGJbN10gKiBzY2FsZSk7XG4gICAgb3V0WzhdID0gYVs4XSArIChiWzhdICogc2NhbGUpO1xuICAgIG91dFs5XSA9IGFbOV0gKyAoYls5XSAqIHNjYWxlKTtcbiAgICBvdXRbMTBdID0gYVsxMF0gKyAoYlsxMF0gKiBzY2FsZSk7XG4gICAgb3V0WzExXSA9IGFbMTFdICsgKGJbMTFdICogc2NhbGUpO1xuICAgIG91dFsxMl0gPSBhWzEyXSArIChiWzEyXSAqIHNjYWxlKTtcbiAgICBvdXRbMTNdID0gYVsxM10gKyAoYlsxM10gKiBzY2FsZSk7XG4gICAgb3V0WzE0XSA9IGFbMTRdICsgKGJbMTRdICogc2NhbGUpO1xuICAgIG91dFsxNV0gPSBhWzE1XSArIChiWzE1XSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDR9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbm1hdDQuZXhhY3RFcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmIFxuICAgICAgICAgICBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddICYmIFxuICAgICAgICAgICBhWzhdID09PSBiWzhdICYmIGFbOV0gPT09IGJbOV0gJiYgYVsxMF0gPT09IGJbMTBdICYmIGFbMTFdID09PSBiWzExXSAmJlxuICAgICAgICAgICBhWzEyXSA9PT0gYlsxMl0gJiYgYVsxM10gPT09IGJbMTNdICYmIGFbMTRdID09PSBiWzE0XSAmJiBhWzE1XSA9PT0gYlsxNV07XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0NH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xubWF0NC5lcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBhMCAgPSBhWzBdLCAgYTEgID0gYVsxXSwgIGEyICA9IGFbMl0sICBhMyAgPSBhWzNdLFxuICAgICAgICBhNCAgPSBhWzRdLCAgYTUgID0gYVs1XSwgIGE2ICA9IGFbNl0sICBhNyAgPSBhWzddLCBcbiAgICAgICAgYTggID0gYVs4XSwgIGE5ICA9IGFbOV0sICBhMTAgPSBhWzEwXSwgYTExID0gYVsxMV0sIFxuICAgICAgICBhMTIgPSBhWzEyXSwgYTEzID0gYVsxM10sIGExNCA9IGFbMTRdLCBhMTUgPSBhWzE1XTtcblxuICAgIHZhciBiMCAgPSBiWzBdLCAgYjEgID0gYlsxXSwgIGIyICA9IGJbMl0sICBiMyAgPSBiWzNdLFxuICAgICAgICBiNCAgPSBiWzRdLCAgYjUgID0gYls1XSwgIGI2ICA9IGJbNl0sICBiNyAgPSBiWzddLCBcbiAgICAgICAgYjggID0gYls4XSwgIGI5ICA9IGJbOV0sICBiMTAgPSBiWzEwXSwgYjExID0gYlsxMV0sIFxuICAgICAgICBiMTIgPSBiWzEyXSwgYjEzID0gYlsxM10sIGIxNCA9IGJbMTRdLCBiMTUgPSBiWzE1XTtcblxuICAgIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTQgLSBiNCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE1KSwgTWF0aC5hYnMoYjUpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTYgLSBiNikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE2KSwgTWF0aC5hYnMoYjYpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTcgLSBiNykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE3KSwgTWF0aC5hYnMoYjcpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTggLSBiOCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE4KSwgTWF0aC5hYnMoYjgpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTkgLSBiOSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE5KSwgTWF0aC5hYnMoYjkpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTEwIC0gYjEwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEwKSwgTWF0aC5hYnMoYjEwKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExMSAtIGIxMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMSksIE1hdGguYWJzKGIxMSkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMTIgLSBiMTIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTIpLCBNYXRoLmFicyhiMTIpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTEzIC0gYjEzKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEzKSwgTWF0aC5hYnMoYjEzKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExNCAtIGIxNCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExNCksIE1hdGguYWJzKGIxNCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMTUgLSBiMTUpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTUpLCBNYXRoLmFicyhiMTUpKSk7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBtYXQ0O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xudmFyIG1hdDMgPSByZXF1aXJlKFwiLi9tYXQzLmpzXCIpO1xudmFyIHZlYzMgPSByZXF1aXJlKFwiLi92ZWMzLmpzXCIpO1xudmFyIHZlYzQgPSByZXF1aXJlKFwiLi92ZWM0LmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyBRdWF0ZXJuaW9uXG4gKiBAbmFtZSBxdWF0XG4gKi9cbnZhciBxdWF0ID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBxdWF0XG4gKlxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqL1xucXVhdC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXRzIGEgcXVhdGVybmlvbiB0byByZXByZXNlbnQgdGhlIHNob3J0ZXN0IHJvdGF0aW9uIGZyb20gb25lXG4gKiB2ZWN0b3IgdG8gYW5vdGhlci5cbiAqXG4gKiBCb3RoIHZlY3RvcnMgYXJlIGFzc3VtZWQgdG8gYmUgdW5pdCBsZW5ndGguXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uLlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBpbml0aWFsIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBkZXN0aW5hdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGlvblRvID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB0bXB2ZWMzID0gdmVjMy5jcmVhdGUoKTtcbiAgICB2YXIgeFVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDEsMCwwKTtcbiAgICB2YXIgeVVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDAsMSwwKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICAgICAgdmFyIGRvdCA9IHZlYzMuZG90KGEsIGIpO1xuICAgICAgICBpZiAoZG90IDwgLTAuOTk5OTk5KSB7XG4gICAgICAgICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIHhVbml0VmVjMywgYSk7XG4gICAgICAgICAgICBpZiAodmVjMy5sZW5ndGgodG1wdmVjMykgPCAwLjAwMDAwMSlcbiAgICAgICAgICAgICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIHlVbml0VmVjMywgYSk7XG4gICAgICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh0bXB2ZWMzLCB0bXB2ZWMzKTtcbiAgICAgICAgICAgIHF1YXQuc2V0QXhpc0FuZ2xlKG91dCwgdG1wdmVjMywgTWF0aC5QSSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9IGVsc2UgaWYgKGRvdCA+IDAuOTk5OTk5KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSAwO1xuICAgICAgICAgICAgb3V0WzFdID0gMDtcbiAgICAgICAgICAgIG91dFsyXSA9IDA7XG4gICAgICAgICAgICBvdXRbM10gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgYSwgYik7XG4gICAgICAgICAgICBvdXRbMF0gPSB0bXB2ZWMzWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdG1wdmVjM1sxXTtcbiAgICAgICAgICAgIG91dFsyXSA9IHRtcHZlYzNbMl07XG4gICAgICAgICAgICBvdXRbM10gPSAxICsgZG90O1xuICAgICAgICAgICAgcmV0dXJuIHF1YXQubm9ybWFsaXplKG91dCwgb3V0KTtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFNldHMgdGhlIHNwZWNpZmllZCBxdWF0ZXJuaW9uIHdpdGggdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuXG4gKiBheGVzLiBFYWNoIGF4aXMgaXMgYSB2ZWMzIGFuZCBpcyBleHBlY3RlZCB0byBiZSB1bml0IGxlbmd0aCBhbmRcbiAqIHBlcnBlbmRpY3VsYXIgdG8gYWxsIG90aGVyIHNwZWNpZmllZCBheGVzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gdmlldyAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIHZpZXdpbmcgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHJpZ2h0IHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBcInJpZ2h0XCIgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHVwICAgIHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBcInVwXCIgZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuc2V0QXhlcyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgbWF0ciA9IG1hdDMuY3JlYXRlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob3V0LCB2aWV3LCByaWdodCwgdXApIHtcbiAgICAgICAgbWF0clswXSA9IHJpZ2h0WzBdO1xuICAgICAgICBtYXRyWzNdID0gcmlnaHRbMV07XG4gICAgICAgIG1hdHJbNl0gPSByaWdodFsyXTtcblxuICAgICAgICBtYXRyWzFdID0gdXBbMF07XG4gICAgICAgIG1hdHJbNF0gPSB1cFsxXTtcbiAgICAgICAgbWF0cls3XSA9IHVwWzJdO1xuXG4gICAgICAgIG1hdHJbMl0gPSAtdmlld1swXTtcbiAgICAgICAgbWF0cls1XSA9IC12aWV3WzFdO1xuICAgICAgICBtYXRyWzhdID0gLXZpZXdbMl07XG5cbiAgICAgICAgcmV0dXJuIHF1YXQubm9ybWFsaXplKG91dCwgcXVhdC5mcm9tTWF0MyhvdXQsIG1hdHIpKTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXRlcm5pb24gdG8gY2xvbmVcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5jbG9uZSA9IHZlYzQuY2xvbmU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuZnJvbVZhbHVlcyA9IHZlYzQuZnJvbVZhbHVlcztcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgcXVhdCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIHNvdXJjZSBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5jb3B5ID0gdmVjNC5jb3B5O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHF1YXQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNldCA9IHZlYzQuc2V0O1xuXG4vKipcbiAqIFNldCBhIHF1YXQgdG8gdGhlIGlkZW50aXR5IHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0cyBhIHF1YXQgZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYW5kIHJvdGF0aW9uIGF4aXMsXG4gKiB0aGVuIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgYXJvdW5kIHdoaWNoIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgaW4gcmFkaWFuc1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICoqL1xucXVhdC5zZXRBeGlzQW5nbGUgPSBmdW5jdGlvbihvdXQsIGF4aXMsIHJhZCkge1xuICAgIHJhZCA9IHJhZCAqIDAuNTtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgb3V0WzBdID0gcyAqIGF4aXNbMF07XG4gICAgb3V0WzFdID0gcyAqIGF4aXNbMV07XG4gICAgb3V0WzJdID0gcyAqIGF4aXNbMl07XG4gICAgb3V0WzNdID0gTWF0aC5jb3MocmFkKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSByb3RhdGlvbiBheGlzIGFuZCBhbmdsZSBmb3IgYSBnaXZlblxuICogIHF1YXRlcm5pb24uIElmIGEgcXVhdGVybmlvbiBpcyBjcmVhdGVkIHdpdGhcbiAqICBzZXRBeGlzQW5nbGUsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHRoZSBzYW1lXG4gKiAgdmFsdWVzIGFzIHByb3ZpZGllZCBpbiB0aGUgb3JpZ2luYWwgcGFyYW1ldGVyIGxpc3RcbiAqICBPUiBmdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKiBFeGFtcGxlOiBUaGUgcXVhdGVybmlvbiBmb3JtZWQgYnkgYXhpcyBbMCwgMCwgMV0gYW5kXG4gKiAgYW5nbGUgLTkwIGlzIHRoZSBzYW1lIGFzIHRoZSBxdWF0ZXJuaW9uIGZvcm1lZCBieVxuICogIFswLCAwLCAxXSBhbmQgMjcwLiBUaGlzIG1ldGhvZCBmYXZvcnMgdGhlIGxhdHRlci5cbiAqIEBwYXJhbSAge3ZlYzN9IG91dF9heGlzICBWZWN0b3IgcmVjZWl2aW5nIHRoZSBheGlzIG9mIHJvdGF0aW9uXG4gKiBAcGFyYW0gIHtxdWF0fSBxICAgICBRdWF0ZXJuaW9uIHRvIGJlIGRlY29tcG9zZWRcbiAqIEByZXR1cm4ge051bWJlcn0gICAgIEFuZ2xlLCBpbiByYWRpYW5zLCBvZiB0aGUgcm90YXRpb25cbiAqL1xucXVhdC5nZXRBeGlzQW5nbGUgPSBmdW5jdGlvbihvdXRfYXhpcywgcSkge1xuICAgIHZhciByYWQgPSBNYXRoLmFjb3MocVszXSkgKiAyLjA7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQgLyAyLjApO1xuICAgIGlmIChzICE9IDAuMCkge1xuICAgICAgICBvdXRfYXhpc1swXSA9IHFbMF0gLyBzO1xuICAgICAgICBvdXRfYXhpc1sxXSA9IHFbMV0gLyBzO1xuICAgICAgICBvdXRfYXhpc1syXSA9IHFbMl0gLyBzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHMgaXMgemVybywgcmV0dXJuIGFueSBheGlzIChubyByb3RhdGlvbiAtIGF4aXMgZG9lcyBub3QgbWF0dGVyKVxuICAgICAgICBvdXRfYXhpc1swXSA9IDE7XG4gICAgICAgIG91dF9heGlzWzFdID0gMDtcbiAgICAgICAgb3V0X2F4aXNbMl0gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gcmFkO1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuYWRkID0gdmVjNC5hZGQ7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl0sIGJ3ID0gYlszXTtcblxuICAgIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubXVsID0gcXVhdC5tdWx0aXBseTtcblxuLyoqXG4gKiBTY2FsZXMgYSBxdWF0IGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNjYWxlID0gdmVjNC5zY2FsZTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFggYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRlWCA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHJhZCAqPSAwLjU7IFxuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnggPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieDtcbiAgICBvdXRbMV0gPSBheSAqIGJ3ICsgYXogKiBieDtcbiAgICBvdXRbMl0gPSBheiAqIGJ3IC0gYXkgKiBieDtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRlWSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHJhZCAqPSAwLjU7IFxuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnkgPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3IC0gYXogKiBieTtcbiAgICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieTtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXggKiBieTtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXkgKiBieTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFogYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRlWiA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHJhZCAqPSAwLjU7IFxuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnogPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXkgKiBiejtcbiAgICBvdXRbMV0gPSBheSAqIGJ3IC0gYXggKiBiejtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBiejtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXogKiBiejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBXIGNvbXBvbmVudCBvZiBhIHF1YXQgZnJvbSB0aGUgWCwgWSwgYW5kIFogY29tcG9uZW50cy5cbiAqIEFzc3VtZXMgdGhhdCBxdWF0ZXJuaW9uIGlzIDEgdW5pdCBpbiBsZW5ndGguXG4gKiBBbnkgZXhpc3RpbmcgVyBjb21wb25lbnQgd2lsbCBiZSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIFcgY29tcG9uZW50IG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuY2FsY3VsYXRlVyA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcblxuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIG91dFszXSA9IE1hdGguc3FydChNYXRoLmFicygxLjAgLSB4ICogeCAtIHkgKiB5IC0geiAqIHopKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5kb3QgPSB2ZWM0LmRvdDtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5sZXJwID0gdmVjNC5sZXJwO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnNsZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIC8vIGJlbmNobWFya3M6XG4gICAgLy8gICAgaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi1zbGVycC1pbXBsZW1lbnRhdGlvbnNcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl0sIGJ3ID0gYlszXTtcblxuICAgIHZhciAgICAgICAgb21lZ2EsIGNvc29tLCBzaW5vbSwgc2NhbGUwLCBzY2FsZTE7XG5cbiAgICAvLyBjYWxjIGNvc2luZVxuICAgIGNvc29tID0gYXggKiBieCArIGF5ICogYnkgKyBheiAqIGJ6ICsgYXcgKiBidztcbiAgICAvLyBhZGp1c3Qgc2lnbnMgKGlmIG5lY2Vzc2FyeSlcbiAgICBpZiAoIGNvc29tIDwgMC4wICkge1xuICAgICAgICBjb3NvbSA9IC1jb3NvbTtcbiAgICAgICAgYnggPSAtIGJ4O1xuICAgICAgICBieSA9IC0gYnk7XG4gICAgICAgIGJ6ID0gLSBiejtcbiAgICAgICAgYncgPSAtIGJ3O1xuICAgIH1cbiAgICAvLyBjYWxjdWxhdGUgY29lZmZpY2llbnRzXG4gICAgaWYgKCAoMS4wIC0gY29zb20pID4gMC4wMDAwMDEgKSB7XG4gICAgICAgIC8vIHN0YW5kYXJkIGNhc2UgKHNsZXJwKVxuICAgICAgICBvbWVnYSAgPSBNYXRoLmFjb3MoY29zb20pO1xuICAgICAgICBzaW5vbSAgPSBNYXRoLnNpbihvbWVnYSk7XG4gICAgICAgIHNjYWxlMCA9IE1hdGguc2luKCgxLjAgLSB0KSAqIG9tZWdhKSAvIHNpbm9tO1xuICAgICAgICBzY2FsZTEgPSBNYXRoLnNpbih0ICogb21lZ2EpIC8gc2lub207XG4gICAgfSBlbHNlIHsgICAgICAgIFxuICAgICAgICAvLyBcImZyb21cIiBhbmQgXCJ0b1wiIHF1YXRlcm5pb25zIGFyZSB2ZXJ5IGNsb3NlIFxuICAgICAgICAvLyAgLi4uIHNvIHdlIGNhbiBkbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICAgIHNjYWxlMCA9IDEuMCAtIHQ7XG4gICAgICAgIHNjYWxlMSA9IHQ7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZXNcbiAgICBvdXRbMF0gPSBzY2FsZTAgKiBheCArIHNjYWxlMSAqIGJ4O1xuICAgIG91dFsxXSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7XG4gICAgb3V0WzJdID0gc2NhbGUwICogYXogKyBzY2FsZTEgKiBiejtcbiAgICBvdXRbM10gPSBzY2FsZTAgKiBhdyArIHNjYWxlMSAqIGJ3O1xuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5zcWxlcnAgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgdGVtcDEgPSBxdWF0LmNyZWF0ZSgpO1xuICB2YXIgdGVtcDIgPSBxdWF0LmNyZWF0ZSgpO1xuICBcbiAgcmV0dXJuIGZ1bmN0aW9uIChvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgICBxdWF0LnNsZXJwKHRlbXAxLCBhLCBkLCB0KTtcbiAgICBxdWF0LnNsZXJwKHRlbXAyLCBiLCBjLCB0KTtcbiAgICBxdWF0LnNsZXJwKG91dCwgdGVtcDEsIHRlbXAyLCAyICogdCAqICgxIC0gdCkpO1xuICAgIFxuICAgIHJldHVybiBvdXQ7XG4gIH07XG59KCkpO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGludmVyc2Ugb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgaW52ZXJzZSBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG4gICAgICAgIGRvdCA9IGEwKmEwICsgYTEqYTEgKyBhMiphMiArIGEzKmEzLFxuICAgICAgICBpbnZEb3QgPSBkb3QgPyAxLjAvZG90IDogMDtcbiAgICBcbiAgICAvLyBUT0RPOiBXb3VsZCBiZSBmYXN0ZXIgdG8gcmV0dXJuIFswLDAsMCwwXSBpbW1lZGlhdGVseSBpZiBkb3QgPT0gMFxuXG4gICAgb3V0WzBdID0gLWEwKmludkRvdDtcbiAgICBvdXRbMV0gPSAtYTEqaW52RG90O1xuICAgIG91dFsyXSA9IC1hMippbnZEb3Q7XG4gICAgb3V0WzNdID0gYTMqaW52RG90O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGNvbmp1Z2F0ZSBvZiBhIHF1YXRcbiAqIElmIHRoZSBxdWF0ZXJuaW9uIGlzIG5vcm1hbGl6ZWQsIHRoaXMgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW4gcXVhdC5pbnZlcnNlIGFuZCBwcm9kdWNlcyB0aGUgc2FtZSByZXN1bHQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgY29uanVnYXRlIG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuY29uanVnYXRlID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0Lmxlbmd0aCA9IHZlYzQubGVuZ3RoO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5sZW4gPSBxdWF0Lmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuc3F1YXJlZExlbmd0aCA9IHZlYzQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNxckxlbiA9IHF1YXQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdGVybmlvbiB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0Lm5vcm1hbGl6ZSA9IHZlYzQubm9ybWFsaXplO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIDN4MyByb3RhdGlvbiBtYXRyaXguXG4gKlxuICogTk9URTogVGhlIHJlc3VsdGFudCBxdWF0ZXJuaW9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyB5b3Ugc2hvdWxkIGJlIHN1cmVcbiAqIHRvIHJlbm9ybWFsaXplIHRoZSBxdWF0ZXJuaW9uIHlvdXJzZWxmIHdoZXJlIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7bWF0M30gbSByb3RhdGlvbiBtYXRyaXhcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmZyb21NYXQzID0gZnVuY3Rpb24ob3V0LCBtKSB7XG4gICAgLy8gQWxnb3JpdGhtIGluIEtlbiBTaG9lbWFrZSdzIGFydGljbGUgaW4gMTk4NyBTSUdHUkFQSCBjb3Vyc2Ugbm90ZXNcbiAgICAvLyBhcnRpY2xlIFwiUXVhdGVybmlvbiBDYWxjdWx1cyBhbmQgRmFzdCBBbmltYXRpb25cIi5cbiAgICB2YXIgZlRyYWNlID0gbVswXSArIG1bNF0gKyBtWzhdO1xuICAgIHZhciBmUm9vdDtcblxuICAgIGlmICggZlRyYWNlID4gMC4wICkge1xuICAgICAgICAvLyB8d3wgPiAxLzIsIG1heSBhcyB3ZWxsIGNob29zZSB3ID4gMS8yXG4gICAgICAgIGZSb290ID0gTWF0aC5zcXJ0KGZUcmFjZSArIDEuMCk7ICAvLyAyd1xuICAgICAgICBvdXRbM10gPSAwLjUgKiBmUm9vdDtcbiAgICAgICAgZlJvb3QgPSAwLjUvZlJvb3Q7ICAvLyAxLyg0dylcbiAgICAgICAgb3V0WzBdID0gKG1bNV0tbVs3XSkqZlJvb3Q7XG4gICAgICAgIG91dFsxXSA9IChtWzZdLW1bMl0pKmZSb290O1xuICAgICAgICBvdXRbMl0gPSAobVsxXS1tWzNdKSpmUm9vdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB8d3wgPD0gMS8yXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgaWYgKCBtWzRdID4gbVswXSApXG4gICAgICAgICAgaSA9IDE7XG4gICAgICAgIGlmICggbVs4XSA+IG1baSozK2ldIClcbiAgICAgICAgICBpID0gMjtcbiAgICAgICAgdmFyIGogPSAoaSsxKSUzO1xuICAgICAgICB2YXIgayA9IChpKzIpJTM7XG4gICAgICAgIFxuICAgICAgICBmUm9vdCA9IE1hdGguc3FydChtW2kqMytpXS1tW2oqMytqXS1tW2sqMytrXSArIDEuMCk7XG4gICAgICAgIG91dFtpXSA9IDAuNSAqIGZSb290O1xuICAgICAgICBmUm9vdCA9IDAuNSAvIGZSb290O1xuICAgICAgICBvdXRbM10gPSAobVtqKjMra10gLSBtW2sqMytqXSkgKiBmUm9vdDtcbiAgICAgICAgb3V0W2pdID0gKG1baiozK2ldICsgbVtpKjMral0pICogZlJvb3Q7XG4gICAgICAgIG91dFtrXSA9IChtW2sqMytpXSArIG1baSozK2tdKSAqIGZSb290O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgcXVhdGVuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSB2ZWMgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcbiAqL1xucXVhdC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAncXVhdCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcXVhdGVybmlvbnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSBUaGUgZmlyc3QgcXVhdGVybmlvbi5cbiAqIEBwYXJhbSB7cXVhdH0gYiBUaGUgc2Vjb25kIHF1YXRlcm5pb24uXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xucXVhdC5leGFjdEVxdWFscyA9IHZlYzQuZXhhY3RFcXVhbHM7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcXVhdGVybmlvbnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHtxdWF0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnF1YXQuZXF1YWxzID0gdmVjNC5lcXVhbHM7XG5cbm1vZHVsZS5leHBvcnRzID0gcXVhdDtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgMiBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzJcbiAqL1xudmFyIHZlYzIgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXG4gKlxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSkge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zdWIgPSB2ZWMyLnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLm11bCA9IHZlYzIubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5kaXYgPSB2ZWMyLmRpdmlkZTtcblxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmNlaWwgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICAgIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuZmxvb3IgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5taW4gPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubWF4ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnJvdW5kID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzIncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzIuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuZGlzdCA9IHZlYzIuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMyLnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV07XG4gICAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLnNxckRpc3QgPSB2ZWMyLnNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWMyLmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5sZW4gPSB2ZWMyLmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWMyLnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zcXJMZW4gPSB2ZWMyLnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmludmVyc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeTtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjMi5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzIuY3Jvc3MgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgeiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gICAgb3V0WzBdID0gb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdO1xuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIucmFuZG9tID0gZnVuY3Rpb24gKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcbiAgICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHNjYWxlO1xuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogc2NhbGU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0Mn0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQyID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5O1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJkfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDJkID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQzXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0M30gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQzID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bM10gKiB5ICsgbVs2XTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNF0gKiB5ICsgbVs3XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQ0XG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcwJ1xuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzEyXTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVsxM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzJzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzIuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMycyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5mb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZWMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdO1xuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMyLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWMyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMyfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnZlYzIuZXhhY3RFcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV07XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMyfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnZlYzIuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV07XG4gICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdO1xuICAgIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZlYzI7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDMgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbmFtZSB2ZWMzXG4gKi9cbnZhciB2ZWMzID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjM1xuICpcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG52ZWMzLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG52ZWMzLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5LCB6KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuc3ViID0gdmVjMy5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5tdWwgPSB2ZWMzLm11bHRpcGx5O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZGl2ID0gdmVjMy5kaXZpZGU7XG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5jZWlsID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5mbG9vciA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICAgIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5mbG9vcihhWzJdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubWluID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm1heCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yb3VuZCA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMzIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMzLmRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZGlzdCA9IHZlYzMuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMzLnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuc3FyRGlzdCA9IHZlYzMuc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzMubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5sZW4gPSB2ZWMzLmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWMzLnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Kno7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuc3FyTGVuID0gdmVjMy5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubmVnYXRlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5pbnZlcnNlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICB2YXIgbGVuID0geCp4ICsgeSp5ICsgeip6O1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgICAgICAgb3V0WzJdID0gYVsyXSAqIGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG52ZWMzLmRvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5jcm9zcyA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdO1xuXG4gICAgb3V0WzBdID0gYXkgKiBieiAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXogKiBieCAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYng7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV0sXG4gICAgICAgIGF6ID0gYVsyXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGhlcm1pdGUgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmhlcm1pdGUgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBmYWN0b3JUaW1lczIgPSB0ICogdCxcbiAgICAgIGZhY3RvcjEgPSBmYWN0b3JUaW1lczIgKiAoMiAqIHQgLSAzKSArIDEsXG4gICAgICBmYWN0b3IyID0gZmFjdG9yVGltZXMyICogKHQgLSAyKSArIHQsXG4gICAgICBmYWN0b3IzID0gZmFjdG9yVGltZXMyICogKHQgLSAxKSxcbiAgICAgIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiAoMyAtIDIgKiB0KTtcbiAgXG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIFxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGJlemllciBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuYmV6aWVyID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgaW52ZXJzZUZhY3RvciA9IDEgLSB0LFxuICAgICAgaW52ZXJzZUZhY3RvclRpbWVzVHdvID0gaW52ZXJzZUZhY3RvciAqIGludmVyc2VGYWN0b3IsXG4gICAgICBmYWN0b3JUaW1lczIgPSB0ICogdCxcbiAgICAgIGZhY3RvcjEgPSBpbnZlcnNlRmFjdG9yVGltZXNUd28gKiBpbnZlcnNlRmFjdG9yLFxuICAgICAgZmFjdG9yMiA9IDMgKiB0ICogaW52ZXJzZUZhY3RvclRpbWVzVHdvLFxuICAgICAgZmFjdG9yMyA9IDMgKiBmYWN0b3JUaW1lczIgKiBpbnZlcnNlRmFjdG9yLFxuICAgICAgZmFjdG9yNCA9IGZhY3RvclRpbWVzMiAqIHQ7XG4gIFxuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICBcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yYW5kb20gPSBmdW5jdGlvbiAob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuXG4gICAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gICAgdmFyIHogPSAoZ2xNYXRyaXguUkFORE9NKCkgKiAyLjApIC0gMS4wO1xuICAgIHZhciB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wLXoqeikgKiBzY2FsZTtcblxuICAgIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlO1xuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlO1xuICAgIG91dFsyXSA9IHogKiBzY2FsZTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQ0LlxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdO1xuICAgIHcgPSB3IHx8IDEuMDtcbiAgICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gdztcbiAgICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gdztcbiAgICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy50cmFuc2Zvcm1NYXQzID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG4gICAgb3V0WzBdID0geCAqIG1bMF0gKyB5ICogbVszXSArIHogKiBtWzZdO1xuICAgIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XTtcbiAgICBvdXRbMl0gPSB4ICogbVsyXSArIHkgKiBtWzVdICsgeiAqIG1bOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtUXVhdCA9IGZ1bmN0aW9uKG91dCwgYSwgcSkge1xuICAgIC8vIGJlbmNobWFya3M6IGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tdHJhbnNmb3JtLXZlYzMtaW1wbGVtZW50YXRpb25zXG5cbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgcXggPSBxWzBdLCBxeSA9IHFbMV0sIHF6ID0gcVsyXSwgcXcgPSBxWzNdLFxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG4gICAgICAgIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5LFxuICAgICAgICBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogeixcbiAgICAgICAgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHgsXG4gICAgICAgIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICAgIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gICAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yb3RhdGVYID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcbiAgIHZhciBwID0gW10sIHI9W107XG5cdCAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXHQgIHBbMF0gPSBhWzBdIC0gYlswXTtcblx0ICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuXG5cdCAgLy9wZXJmb3JtIHJvdGF0aW9uXG5cdCAgclswXSA9IHBbMF07XG5cdCAgclsxXSA9IHBbMV0qTWF0aC5jb3MoYykgLSBwWzJdKk1hdGguc2luKGMpO1xuXHQgIHJbMl0gPSBwWzFdKk1hdGguc2luKGMpICsgcFsyXSpNYXRoLmNvcyhjKTtcblxuXHQgIC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblx0ICBvdXRbMF0gPSByWzBdICsgYlswXTtcblx0ICBvdXRbMV0gPSByWzFdICsgYlsxXTtcblx0ICBvdXRbMl0gPSByWzJdICsgYlsyXTtcblxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnJvdGF0ZVkgPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICBcdHZhciBwID0gW10sIHI9W107XG4gIFx0Ly9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBcdHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgXHRwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuICBcbiAgXHQvL3BlcmZvcm0gcm90YXRpb25cbiAgXHRyWzBdID0gcFsyXSpNYXRoLnNpbihjKSArIHBbMF0qTWF0aC5jb3MoYyk7XG4gIFx0clsxXSA9IHBbMV07XG4gIFx0clsyXSA9IHBbMl0qTWF0aC5jb3MoYykgLSBwWzBdKk1hdGguc2luKGMpO1xuICBcbiAgXHQvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIFx0b3V0WzBdID0gclswXSArIGJbMF07XG4gIFx0b3V0WzFdID0gclsxXSArIGJbMV07XG4gIFx0b3V0WzJdID0gclsyXSArIGJbMl07XG4gIFxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnJvdGF0ZVogPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICBcdHZhciBwID0gW10sIHI9W107XG4gIFx0Ly9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBcdHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgXHRwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuICBcbiAgXHQvL3BlcmZvcm0gcm90YXRpb25cbiAgXHRyWzBdID0gcFswXSpNYXRoLmNvcyhjKSAtIHBbMV0qTWF0aC5zaW4oYyk7XG4gIFx0clsxXSA9IHBbMF0qTWF0aC5zaW4oYykgKyBwWzFdKk1hdGguY29zKGMpO1xuICBcdHJbMl0gPSBwWzJdO1xuICBcbiAgXHQvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIFx0b3V0WzBdID0gclswXSArIGJbMF07XG4gIFx0b3V0WzFdID0gclsxXSArIGJbMV07XG4gIFx0b3V0WzJdID0gclsyXSArIGJbMl07XG4gIFxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMzcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMzLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjM3MgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVjID0gdmVjMy5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDM7XG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTsgdmVjWzJdID0gYVtpKzJdO1xuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07IGFbaSsyXSA9IHZlY1syXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBiZXR3ZWVuIHR3byAzRCB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cbnZlYzMuYW5nbGUgPSBmdW5jdGlvbihhLCBiKSB7XG4gICBcbiAgICB2YXIgdGVtcEEgPSB2ZWMzLmZyb21WYWx1ZXMoYVswXSwgYVsxXSwgYVsyXSk7XG4gICAgdmFyIHRlbXBCID0gdmVjMy5mcm9tVmFsdWVzKGJbMF0sIGJbMV0sIGJbMl0pO1xuIFxuICAgIHZlYzMubm9ybWFsaXplKHRlbXBBLCB0ZW1wQSk7XG4gICAgdmVjMy5ub3JtYWxpemUodGVtcEIsIHRlbXBCKTtcbiBcbiAgICB2YXIgY29zaW5lID0gdmVjMy5kb3QodGVtcEEsIHRlbXBCKTtcblxuICAgIGlmKGNvc2luZSA+IDEuMCl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoY29zaW5lKTtcbiAgICB9ICAgICBcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzMuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzMoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG52ZWMzLmV4YWN0RXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl07XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnZlYzMuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXTtcbiAgICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB2ZWMzO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyA0IERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjNFxuICovXG52YXIgdmVjNCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzRcbiAqXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbnZlYzQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG52ZWM0LmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG52ZWM0LmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB6LCB3KSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIG91dFszXSA9IHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zZXQgPSBmdW5jdGlvbihvdXQsIHgsIHksIHosIHcpIHtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LnN1YiA9IHZlYzQuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAqIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQubXVsID0gdmVjNC5tdWx0aXBseTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuZGl2aWRlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAvIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LmRpdiA9IHZlYzQuZGl2aWRlO1xuXG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuY2VpbCA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICAgIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKTtcbiAgICBvdXRbM10gPSBNYXRoLmNlaWwoYVszXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmZsb29yID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pO1xuICAgIG91dFszXSA9IE1hdGguZmxvb3IoYVszXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm1pbiA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICAgIG91dFszXSA9IE1hdGgubWluKGFbM10sIGJbM10pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5tYXggPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgICBvdXRbM10gPSBNYXRoLm1heChhWzNdLCBiWzNdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQucm91bmQgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gICAgb3V0WzNdID0gTWF0aC5yb3VuZChhWzNdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWM0IGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIG91dFszXSA9IGFbM10gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzQncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjNC5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXSxcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6ICsgdyp3KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuZGlzdCA9IHZlYzQuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWM0LnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXSxcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5zcXJEaXN0ID0gdmVjNC5zcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjNC5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeiArIHcqdyk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5sZW4gPSB2ZWM0Lmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWM0LnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LnNxckxlbiA9IHZlYzQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIG91dFszXSA9IC1hWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuaW52ZXJzZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICBvdXRbM10gPSAxLjAgLyBhWzNdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBhWzNdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSB4ICogbGVuO1xuICAgICAgICBvdXRbMV0gPSB5ICogbGVuO1xuICAgICAgICBvdXRbMl0gPSB6ICogbGVuO1xuICAgICAgICBvdXRbM10gPSB3ICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzQuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdICsgYVszXSAqIGJbM107XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl0sXG4gICAgICAgIGF3ID0gYVszXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgICBvdXRbM10gPSBhdyArIHQgKiAoYlszXSAtIGF3KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnJhbmRvbSA9IGZ1bmN0aW9uIChvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG5cbiAgICAvL1RPRE86IFRoaXMgaXMgYSBwcmV0dHkgYXdmdWwgd2F5IG9mIGRvaW5nIHRoaXMuIEZpbmQgc29tZXRoaW5nIGJldHRlci5cbiAgICBvdXRbMF0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICBvdXRbMV0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICBvdXRbMl0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICBvdXRbM10gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICB2ZWM0Lm5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgdmVjNC5zY2FsZShvdXQsIG91dCwgc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIG1hdDQuXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSwgdyA9IGFbM107XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0gKiB3O1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdICogdztcbiAgICBvdXRbMl0gPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0gKiB3O1xuICAgIG91dFszXSA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XSAqIHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQudHJhbnNmb3JtUXVhdCA9IGZ1bmN0aW9uKG91dCwgYSwgcSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICAgIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzQuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWM0cyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5mb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZWMgPSB2ZWM0LmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gNDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdOyB2ZWNbMl0gPSBhW2krMl07IHZlY1szXSA9IGFbaSszXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdOyBhW2krMl0gPSB2ZWNbMl07IGFbaSszXSA9IHZlY1szXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWM0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnZlYzQuZXhhY3RFcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjNH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG52ZWM0LmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICAgIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZlYzQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gR3JpZEluZGV4O1xuXG52YXIgTlVNX1BBUkFNUyA9IDM7XG5cbmZ1bmN0aW9uIEdyaWRJbmRleChleHRlbnQsIG4sIHBhZGRpbmcpIHtcbiAgICB2YXIgY2VsbHMgPSB0aGlzLmNlbGxzID0gW107XG5cbiAgICBpZiAoZXh0ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGV4dGVudDtcbiAgICAgICAgdmFyIGFycmF5ID0gbmV3IEludDMyQXJyYXkodGhpcy5hcnJheUJ1ZmZlcik7XG4gICAgICAgIGV4dGVudCA9IGFycmF5WzBdO1xuICAgICAgICBuID0gYXJyYXlbMV07XG4gICAgICAgIHBhZGRpbmcgPSBhcnJheVsyXTtcblxuICAgICAgICB0aGlzLmQgPSBuICsgMiAqIHBhZGRpbmc7XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5kICogdGhpcy5kOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGFycmF5W05VTV9QQVJBTVMgKyBrXTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBhcnJheVtOVU1fUEFSQU1TICsgayArIDFdO1xuICAgICAgICAgICAgY2VsbHMucHVzaChzdGFydCA9PT0gZW5kID9cbiAgICAgICAgICAgICAgICAgICAgbnVsbCA6XG4gICAgICAgICAgICAgICAgICAgIGFycmF5LnN1YmFycmF5KHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5c09mZnNldCA9IGFycmF5W05VTV9QQVJBTVMgKyBjZWxscy5sZW5ndGhdO1xuICAgICAgICB2YXIgYmJveGVzT2Zmc2V0ID0gYXJyYXlbTlVNX1BBUkFNUyArIGNlbGxzLmxlbmd0aCArIDFdO1xuICAgICAgICB0aGlzLmtleXMgPSBhcnJheS5zdWJhcnJheShrZXlzT2Zmc2V0LCBiYm94ZXNPZmZzZXQpO1xuICAgICAgICB0aGlzLmJib3hlcyA9IGFycmF5LnN1YmFycmF5KGJib3hlc09mZnNldCk7XG5cbiAgICAgICAgdGhpcy5pbnNlcnQgPSB0aGlzLl9pbnNlcnRSZWFkb25seTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZCA9IG4gKyAyICogcGFkZGluZztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmQgKiB0aGlzLmQ7IGkrKykge1xuICAgICAgICAgICAgY2VsbHMucHVzaChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXlzID0gW107XG4gICAgICAgIHRoaXMuYmJveGVzID0gW107XG4gICAgfVxuXG4gICAgdGhpcy5uID0gbjtcbiAgICB0aGlzLmV4dGVudCA9IGV4dGVudDtcbiAgICB0aGlzLnBhZGRpbmcgPSBwYWRkaW5nO1xuICAgIHRoaXMuc2NhbGUgPSBuIC8gZXh0ZW50O1xuICAgIHRoaXMudWlkID0gMDtcblxuICAgIHZhciBwID0gKHBhZGRpbmcgLyBuKSAqIGV4dGVudDtcbiAgICB0aGlzLm1pbiA9IC1wO1xuICAgIHRoaXMubWF4ID0gZXh0ZW50ICsgcDtcbn1cblxuXG5HcmlkSW5kZXgucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKGtleSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB0aGlzLl9mb3JFYWNoQ2VsbCh4MSwgeTEsIHgyLCB5MiwgdGhpcy5faW5zZXJ0Q2VsbCwgdGhpcy51aWQrKyk7XG4gICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcbiAgICB0aGlzLmJib3hlcy5wdXNoKHgxKTtcbiAgICB0aGlzLmJib3hlcy5wdXNoKHkxKTtcbiAgICB0aGlzLmJib3hlcy5wdXNoKHgyKTtcbiAgICB0aGlzLmJib3hlcy5wdXNoKHkyKTtcbn07XG5cbkdyaWRJbmRleC5wcm90b3R5cGUuX2luc2VydFJlYWRvbmx5ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgJ0Nhbm5vdCBpbnNlcnQgaW50byBhIEdyaWRJbmRleCBjcmVhdGVkIGZyb20gYW4gQXJyYXlCdWZmZXIuJztcbn07XG5cbkdyaWRJbmRleC5wcm90b3R5cGUuX2luc2VydENlbGwgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgY2VsbEluZGV4LCB1aWQpIHtcbiAgICB0aGlzLmNlbGxzW2NlbGxJbmRleF0ucHVzaCh1aWQpO1xufTtcblxuR3JpZEluZGV4LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIG1pbiA9IHRoaXMubWluO1xuICAgIHZhciBtYXggPSB0aGlzLm1heDtcbiAgICBpZiAoeDEgPD0gbWluICYmIHkxIDw9IG1pbiAmJiBtYXggPD0geDIgJiYgbWF4IDw9IHkyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXMuc2xpY2UoKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIHNlZW5VaWRzID0ge307XG4gICAgICAgIHRoaXMuX2ZvckVhY2hDZWxsKHgxLCB5MSwgeDIsIHkyLCB0aGlzLl9xdWVyeUNlbGwsIHJlc3VsdCwgc2VlblVpZHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5cbkdyaWRJbmRleC5wcm90b3R5cGUuX3F1ZXJ5Q2VsbCA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCBjZWxsSW5kZXgsIHJlc3VsdCwgc2VlblVpZHMpIHtcbiAgICB2YXIgY2VsbCA9IHRoaXMuY2VsbHNbY2VsbEluZGV4XTtcbiAgICBpZiAoY2VsbCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cztcbiAgICAgICAgdmFyIGJib3hlcyA9IHRoaXMuYmJveGVzO1xuICAgICAgICBmb3IgKHZhciB1ID0gMDsgdSA8IGNlbGwubGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgIHZhciB1aWQgPSBjZWxsW3VdO1xuICAgICAgICAgICAgaWYgKHNlZW5VaWRzW3VpZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSB1aWQgKiA0O1xuICAgICAgICAgICAgICAgIGlmICgoeDEgPD0gYmJveGVzW29mZnNldCArIDJdKSAmJlxuICAgICAgICAgICAgICAgICAgICAoeTEgPD0gYmJveGVzW29mZnNldCArIDNdKSAmJlxuICAgICAgICAgICAgICAgICAgICAoeDIgPj0gYmJveGVzW29mZnNldCArIDBdKSAmJlxuICAgICAgICAgICAgICAgICAgICAoeTIgPj0gYmJveGVzW29mZnNldCArIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWVuVWlkc1t1aWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goa2V5c1t1aWRdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWVuVWlkc1t1aWRdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuR3JpZEluZGV4LnByb3RvdHlwZS5fZm9yRWFjaENlbGwgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgZm4sIGFyZzEsIGFyZzIpIHtcbiAgICB2YXIgY3gxID0gdGhpcy5fY29udmVydFRvQ2VsbENvb3JkKHgxKTtcbiAgICB2YXIgY3kxID0gdGhpcy5fY29udmVydFRvQ2VsbENvb3JkKHkxKTtcbiAgICB2YXIgY3gyID0gdGhpcy5fY29udmVydFRvQ2VsbENvb3JkKHgyKTtcbiAgICB2YXIgY3kyID0gdGhpcy5fY29udmVydFRvQ2VsbENvb3JkKHkyKTtcbiAgICBmb3IgKHZhciB4ID0gY3gxOyB4IDw9IGN4MjsgeCsrKSB7XG4gICAgICAgIGZvciAodmFyIHkgPSBjeTE7IHkgPD0gY3kyOyB5KyspIHtcbiAgICAgICAgICAgIHZhciBjZWxsSW5kZXggPSB0aGlzLmQgKiB5ICsgeDtcbiAgICAgICAgICAgIGlmIChmbi5jYWxsKHRoaXMsIHgxLCB5MSwgeDIsIHkyLCBjZWxsSW5kZXgsIGFyZzEsIGFyZzIpKSByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5HcmlkSW5kZXgucHJvdG90eXBlLl9jb252ZXJ0VG9DZWxsQ29vcmQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuZCAtIDEsIE1hdGguZmxvb3IoeCAqIHRoaXMuc2NhbGUpICsgdGhpcy5wYWRkaW5nKSk7XG59O1xuXG5HcmlkSW5kZXgucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5hcnJheUJ1ZmZlcikgcmV0dXJuIHRoaXMuYXJyYXlCdWZmZXI7XG5cbiAgICB2YXIgY2VsbHMgPSB0aGlzLmNlbGxzO1xuXG4gICAgdmFyIG1ldGFkYXRhTGVuZ3RoID0gTlVNX1BBUkFNUyArIHRoaXMuY2VsbHMubGVuZ3RoICsgMSArIDE7XG4gICAgdmFyIHRvdGFsQ2VsbExlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRvdGFsQ2VsbExlbmd0aCArPSB0aGlzLmNlbGxzW2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgYXJyYXkgPSBuZXcgSW50MzJBcnJheShtZXRhZGF0YUxlbmd0aCArIHRvdGFsQ2VsbExlbmd0aCArIHRoaXMua2V5cy5sZW5ndGggKyB0aGlzLmJib3hlcy5sZW5ndGgpO1xuICAgIGFycmF5WzBdID0gdGhpcy5leHRlbnQ7XG4gICAgYXJyYXlbMV0gPSB0aGlzLm47XG4gICAgYXJyYXlbMl0gPSB0aGlzLnBhZGRpbmc7XG5cbiAgICB2YXIgb2Zmc2V0ID0gbWV0YWRhdGFMZW5ndGg7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBjZWxscy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgY2VsbCA9IGNlbGxzW2tdO1xuICAgICAgICBhcnJheVtOVU1fUEFSQU1TICsga10gPSBvZmZzZXQ7XG4gICAgICAgIGFycmF5LnNldChjZWxsLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gY2VsbC5sZW5ndGg7XG4gICAgfVxuXG4gICAgYXJyYXlbTlVNX1BBUkFNUyArIGNlbGxzLmxlbmd0aF0gPSBvZmZzZXQ7XG4gICAgYXJyYXkuc2V0KHRoaXMua2V5cywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gdGhpcy5rZXlzLmxlbmd0aDtcblxuICAgIGFycmF5W05VTV9QQVJBTVMgKyBjZWxscy5sZW5ndGggKyAxXSA9IG9mZnNldDtcbiAgICBhcnJheS5zZXQodGhpcy5iYm94ZXMsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IHRoaXMuYmJveGVzLmxlbmd0aDtcblxuICAgIHJldHVybiBhcnJheS5idWZmZXI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbihwYXJhbWV0ZXJzLCBkZWZhdWx0VHlwZSkge1xuICAgIHZhciBmdW47XG5cbiAgICBpZiAoIWlzRnVuY3Rpb25EZWZpbml0aW9uKHBhcmFtZXRlcnMpKSB7XG4gICAgICAgIGZ1biA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcGFyYW1ldGVyczsgfTtcbiAgICAgICAgZnVuLmlzRmVhdHVyZUNvbnN0YW50ID0gdHJ1ZTtcbiAgICAgICAgZnVuLmlzWm9vbUNvbnN0YW50ID0gdHJ1ZTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB6b29tQW5kRmVhdHVyZURlcGVuZGVudCA9IHR5cGVvZiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzBdID09PSAnb2JqZWN0JztcbiAgICAgICAgdmFyIGZlYXR1cmVEZXBlbmRlbnQgPSB6b29tQW5kRmVhdHVyZURlcGVuZGVudCB8fCBwYXJhbWV0ZXJzLnByb3BlcnR5ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciB6b29tRGVwZW5kZW50ID0gem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQgfHwgIWZlYXR1cmVEZXBlbmRlbnQ7XG4gICAgICAgIHZhciB0eXBlID0gcGFyYW1ldGVycy50eXBlIHx8IGRlZmF1bHRUeXBlIHx8ICdleHBvbmVudGlhbCc7XG5cbiAgICAgICAgdmFyIGlubmVyRnVuO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgICAgICAgICAgaW5uZXJGdW4gPSBldmFsdWF0ZUV4cG9uZW50aWFsRnVuY3Rpb247XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2ludGVydmFsJykge1xuICAgICAgICAgICAgaW5uZXJGdW4gPSBldmFsdWF0ZUludGVydmFsRnVuY3Rpb247XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NhdGVnb3JpY2FsJykge1xuICAgICAgICAgICAgaW5uZXJGdW4gPSBldmFsdWF0ZUNhdGVnb3JpY2FsRnVuY3Rpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZnVuY3Rpb24gdHlwZSBcIicgKyB0eXBlICsgJ1wiJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQpIHtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlRnVuY3Rpb25zID0ge307XG4gICAgICAgICAgICB2YXIgZmVhdHVyZUZ1bmN0aW9uU3RvcHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgcGFyYW1ldGVycy5zdG9wcy5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgICAgIHZhciBzdG9wID0gcGFyYW1ldGVycy5zdG9wc1tzXTtcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZUZ1bmN0aW9uc1tzdG9wWzBdLnpvb21dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUZ1bmN0aW9uc1tzdG9wWzBdLnpvb21dID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgem9vbTogc3RvcFswXS56b29tLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogcGFyYW1ldGVycy50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHBhcmFtZXRlcnMucHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wczogW11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmVhdHVyZUZ1bmN0aW9uc1tzdG9wWzBdLnpvb21dLnN0b3BzLnB1c2goW3N0b3BbMF0udmFsdWUsIHN0b3BbMV1dKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgeiBpbiBmZWF0dXJlRnVuY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZUZ1bmN0aW9uU3RvcHMucHVzaChbZmVhdHVyZUZ1bmN0aW9uc1t6XS56b29tLCBjcmVhdGVGdW5jdGlvbihmZWF0dXJlRnVuY3Rpb25zW3pdKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuID0gZnVuY3Rpb24oem9vbSwgZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBldmFsdWF0ZUV4cG9uZW50aWFsRnVuY3Rpb24oeyBzdG9wczogZmVhdHVyZUZ1bmN0aW9uU3RvcHMsIGJhc2U6IHBhcmFtZXRlcnMuYmFzZSB9LCB6b29tKSh6b29tLCBmZWF0dXJlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmdW4uaXNGZWF0dXJlQ29uc3RhbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZ1bi5pc1pvb21Db25zdGFudCA9IGZhbHNlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoem9vbURlcGVuZGVudCkge1xuICAgICAgICAgICAgZnVuID0gZnVuY3Rpb24oem9vbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lckZ1bihwYXJhbWV0ZXJzLCB6b29tKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmdW4uaXNGZWF0dXJlQ29uc3RhbnQgPSB0cnVlO1xuICAgICAgICAgICAgZnVuLmlzWm9vbUNvbnN0YW50ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmdW4gPSBmdW5jdGlvbih6b29tLCBmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyRnVuKHBhcmFtZXRlcnMsIGZlYXR1cmVbcGFyYW1ldGVycy5wcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZ1bi5pc0ZlYXR1cmVDb25zdGFudCA9IGZhbHNlO1xuICAgICAgICAgICAgZnVuLmlzWm9vbUNvbnN0YW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW47XG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlQ2F0ZWdvcmljYWxGdW5jdGlvbihwYXJhbWV0ZXJzLCBpbnB1dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1ldGVycy5zdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5wdXQgPT09IHBhcmFtZXRlcnMuc3RvcHNbaV1bMF0pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzW2ldWzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzFdO1xufVxuXG5mdW5jdGlvbiBldmFsdWF0ZUludGVydmFsRnVuY3Rpb24ocGFyYW1ldGVycywgaW5wdXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtZXRlcnMuc3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlucHV0IDwgcGFyYW1ldGVycy5zdG9wc1tpXVswXSkgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzW01hdGgubWF4KGkgLSAxLCAwKV1bMV07XG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlRXhwb25lbnRpYWxGdW5jdGlvbihwYXJhbWV0ZXJzLCBpbnB1dCkge1xuICAgIHZhciBiYXNlID0gcGFyYW1ldGVycy5iYXNlICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmJhc2UgOiAxO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChpID49IHBhcmFtZXRlcnMuc3RvcHMubGVuZ3RoKSBicmVhaztcbiAgICAgICAgZWxzZSBpZiAoaW5wdXQgPD0gcGFyYW1ldGVycy5zdG9wc1tpXVswXSkgYnJlYWs7XG4gICAgICAgIGVsc2UgaSsrO1xuICAgIH1cblxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzW2ldWzFdO1xuXG4gICAgfSBlbHNlIGlmIChpID09PSBwYXJhbWV0ZXJzLnN0b3BzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5zdG9wc1tpIC0gMV1bMV07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGUoXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGJhc2UsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnN0b3BzW2kgLSAxXVswXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuc3RvcHNbaV1bMF0sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnN0b3BzW2kgLSAxXVsxXSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuc3RvcHNbaV1bMV1cbiAgICAgICAgKTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoaW5wdXQsIGJhc2UsIGlucHV0TG93ZXIsIGlucHV0VXBwZXIsIG91dHB1dExvd2VyLCBvdXRwdXRVcHBlcikge1xuICAgIGlmICh0eXBlb2Ygb3V0cHV0TG93ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGV2YWx1YXRlZExvd2VyID0gb3V0cHV0TG93ZXIuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGV2YWx1YXRlZFVwcGVyID0gb3V0cHV0VXBwZXIuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlKGlucHV0LCBiYXNlLCBpbnB1dExvd2VyLCBpbnB1dFVwcGVyLCBldmFsdWF0ZWRMb3dlciwgZXZhbHVhdGVkVXBwZXIpO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAob3V0cHV0TG93ZXIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZUFycmF5KGlucHV0LCBiYXNlLCBpbnB1dExvd2VyLCBpbnB1dFVwcGVyLCBvdXRwdXRMb3dlciwgb3V0cHV0VXBwZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZU51bWJlcihpbnB1dCwgYmFzZSwgaW5wdXRMb3dlciwgaW5wdXRVcHBlciwgb3V0cHV0TG93ZXIsIG91dHB1dFVwcGVyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlTnVtYmVyKGlucHV0LCBiYXNlLCBpbnB1dExvd2VyLCBpbnB1dFVwcGVyLCBvdXRwdXRMb3dlciwgb3V0cHV0VXBwZXIpIHtcbiAgICB2YXIgZGlmZmVyZW5jZSA9ICBpbnB1dFVwcGVyIC0gaW5wdXRMb3dlcjtcbiAgICB2YXIgcHJvZ3Jlc3MgPSBpbnB1dCAtIGlucHV0TG93ZXI7XG5cbiAgICB2YXIgcmF0aW87XG4gICAgaWYgKGJhc2UgPT09IDEpIHtcbiAgICAgICAgcmF0aW8gPSBwcm9ncmVzcyAvIGRpZmZlcmVuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmF0aW8gPSAoTWF0aC5wb3coYmFzZSwgcHJvZ3Jlc3MpIC0gMSkgLyAoTWF0aC5wb3coYmFzZSwgZGlmZmVyZW5jZSkgLSAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKG91dHB1dExvd2VyICogKDEgLSByYXRpbykpICsgKG91dHB1dFVwcGVyICogcmF0aW8pO1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUFycmF5KGlucHV0LCBiYXNlLCBpbnB1dExvd2VyLCBpbnB1dFVwcGVyLCBvdXRwdXRMb3dlciwgb3V0cHV0VXBwZXIpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXRMb3dlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXRwdXRbaV0gPSBpbnRlcnBvbGF0ZU51bWJlcihpbnB1dCwgYmFzZSwgaW5wdXRMb3dlciwgaW5wdXRVcHBlciwgb3V0cHV0TG93ZXJbaV0sIG91dHB1dFVwcGVyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbkRlZmluaXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5zdG9wcztcbn1cblxuXG5tb2R1bGUuZXhwb3J0cy5pc0Z1bmN0aW9uRGVmaW5pdGlvbiA9IGlzRnVuY3Rpb25EZWZpbml0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cy5pbnRlcnBvbGF0ZWQgPSBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uKHBhcmFtZXRlcnMsICdleHBvbmVudGlhbCcpO1xufTtcblxubW9kdWxlLmV4cG9ydHNbJ3BpZWNld2lzZS1jb25zdGFudCddID0gZnVuY3Rpb24ocGFyYW1ldGVycykge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihwYXJhbWV0ZXJzLCAnaW50ZXJ2YWwnKTtcbn07XG4iLCJcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG4vLyByZWFkRmlsZVN5bmMgY2FsbHMgbXVzdCBiZSB3cml0dGVuIG91dCBsb25nLWZvcm0gZm9yIGJyZnMuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVidWc6IHtcbiAgICBmcmFnbWVudFNvdXJjZTogXCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZWxzZVxcbiNkZWZpbmUgbG93cFxcbiNkZWZpbmUgbWVkaXVtcFxcbiNkZWZpbmUgaGlnaHBcXG4jZW5kaWZcXG5cXG51bmlmb3JtIGxvd3AgdmVjNCB1X2NvbG9yO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdV9jb2xvcjtcXG59XFxuXCIsXG4gICAgdmVydGV4U291cmNlOiBcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZWxzZVxcbiNkZWZpbmUgbG93cFxcbiNkZWZpbmUgbWVkaXVtcFxcbiNkZWZpbmUgaGlnaHBcXG4jZW5kaWZcXG5cXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5cXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3Bvcywgc3RlcCgzMjc2Ny4wLCBhX3Bvcy54KSwgMSk7XFxufVxcblwiXG4gIH0sXG4gIGZpbGw6IHtcbiAgICBmcmFnbWVudFNvdXJjZTogXCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZWxzZVxcbiNkZWZpbmUgbG93cFxcbiNkZWZpbmUgbWVkaXVtcFxcbiNkZWZpbmUgaGlnaHBcXG4jZW5kaWZcXG5cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgdmVjNCBjb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICAjcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIHZlYzQgY29sb3JcXG4gICAgI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yICogb3BhY2l0eTtcXG5cXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XFxuXCIsXG4gICAgdmVydGV4U291cmNlOiBcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZWxzZVxcbiNkZWZpbmUgbG93cFxcbiNkZWZpbmUgbWVkaXVtcFxcbiNkZWZpbmUgaGlnaHBcXG4jZW5kaWZcXG5cXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5cXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxuXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgY29sb3JcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCB2ZWM0IGNvbG9yXFxuICAgICNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcblxcbiAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3BvcywgMCwgMSk7XFxufVxcblwiXG4gIH0sXG4gIGV4dHJ1c2lvbjoge1xuICAgICAgZnJhZ21lbnRTb3VyY2U6IFwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2Vsc2VcXG4jZGVmaW5lIGxvd3BcXG4jZGVmaW5lIG1lZGl1bXBcXG4jZGVmaW5lIGhpZ2hwXFxuI2VuZGlmXFxuXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuI2lmZGVmIE1BUEJPWF9HTF9KU1xcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBtaW5IXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG1heEhcXG4jZW5kaWZcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgdmVjNCBjb2xvclxcblxcbnZvaWQgbWFpbigpIHtcXG4jaWZkZWYgTUFQQk9YX0dMX0pTXFxuICAgICNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgbWluSFxcbiAgICAjcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG1heEhcXG4jZW5kaWZcXG4gICAgI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCB2ZWM0IGNvbG9yXFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZfY29sb3I7XFxufVxcblwiLFxuICAgICAgdmVydGV4U291cmNlOiBcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZWxzZVxcbiNkZWZpbmUgbG93cFxcbiNkZWZpbmUgbWVkaXVtcFxcbiNkZWZpbmUgaGlnaHBcXG4jZW5kaWZcXG5cXG5hdHRyaWJ1dGUgdmVjMyBhX3BvcztcXG5hdHRyaWJ1dGUgdmVjMyBhX25vcm1hbDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9lZGdlZGlzdGFuY2U7XFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gdmVjMyB1X2xpZ2h0ZGlyO1xcbnVuaWZvcm0gdmVjNCB1X3NoYWRvdztcXG51bmlmb3JtIGxvd3AgdmVjNCB1X291dGxpbmVfY29sb3I7XFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFxuI2lmbmRlZiBNQVBCT1hfR0xfSlNcXG5hdHRyaWJ1dGUgZmxvYXQgbWluSDtcXG5hdHRyaWJ1dGUgZmxvYXQgbWF4SDtcXG4jZWxzZVxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBtaW5IXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG1heEhcXG4jZW5kaWZcXG5cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgdmVjNCBjb2xvclxcblxcbnZvaWQgbWFpbigpIHtcXG4jaWZkZWYgTUFQQk9YX0dMX0pTXFxuICAgICNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgbWluSFxcbiAgICAjcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG1heEhcXG4jZW5kaWZcXG4gICAgI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCB2ZWM0IGNvbG9yXFxuXFxuICAgIGZsb2F0IGVkID0gYV9lZGdlZGlzdGFuY2U7IC8vIHVzZSBlYWNoIGF0dHJpYiBpbiBvcmRlciB0byBub3QgdHJpcCBhIFZBTyBhc3NlcnRcXG4gICAgZmxvYXQgdCA9IG1vZChhX25vcm1hbC54LCAyLjApO1xcbiAgICAvLzEuMOeahOivneWwseaYr+aMieeFpzNk55qE6L+b6KGM57uY5Yi277yMXFxuICAgIC8vLTEuMOeahOivneWwseaMieeFpzJk5Y+q6IO96KKr5bGe5oCn55WM6Z2i5ZKM5Zyw5Zu+Y29udHJvbOeVjOmdouS4iueahDJk77yMM2TliIfmjaLmjInpkq7mlLnlj5hcXG4gICAgLy8tMi4w55qE6K+d5oyJ54WnMmTvvIzkvYbmmK/lj6/ku6XooqvlsZ7mgKfnlYzpnaLlkozlnLDlm75jb250cm9s55WM6Z2i5LiK55qEMmTvvIwzZOWIh+aNouaMiemSruaUueWPmFxcblxcbiAgICBpZihtaW5IID49IDAuMCl7XFxuICAgICAgICBpZihhX3Bvcy56IDwgMC4wKXtcXG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3Bvcy54eSwgMy4wKm1heEgsIDEpO1xcbiAgICAgICAgfWVsc2V7XFxuICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoYV9wb3MsIDEpO1xcbiAgICAgICAgfVxcbiAgICB9ZWxzZXtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiB2ZWM0KGFfcG9zLnh5LCAwLjAxLCAxKTtcXG4gICAgfVxcblxcbiNpZmRlZiBPVVRMSU5FXFxuICAgICNpZmRlZiBERUZBVUxUX0NPTE9SXFxuICAgIHZfY29sb3IgPSBjb2xvcjtcXG4gICAgI2Vsc2VcXG4gICAgdl9jb2xvciA9IHVfb3V0bGluZV9jb2xvcjtcXG4gICAgI2VuZGlmXFxuI2Vsc2VcXG4gICAgdl9jb2xvciA9IGNvbG9yO1xcbiNlbmRpZlxcblxcbiAgICBmbG9hdCBkaXJlY3Rpb25hbCA9IGNsYW1wKGRvdChhX25vcm1hbCAvIDMyNzY4LjAsIHVfbGlnaHRkaXIpLCAwLjAsIDEuMCk7XFxuICAgIGZsb2F0IHNoYWRvdyA9IGNsYW1wKCgwLjMgLSBkaXJlY3Rpb25hbCkgLyA3LjAsIDAuMCwgMC4zKTtcXG4gICAgZGlyZWN0aW9uYWwgPSBtaXgoMC43LCAxLjAsIGRpcmVjdGlvbmFsICogMi4wICogKDAuMiArXFxuICAgICAgICBwb3codCAqIGNsYW1wKG1heEggLyAxNTAuMCwgMC4wLCAxLjApLCAwLjI1KVxcbiAgICApIC8gMS4yKTtcXG5cXG4gICAgdl9jb2xvci5yZ2IgKj0gZGlyZWN0aW9uYWw7XFxuXFxuICAgIHZfY29sb3IgKz0gc2hhZG93ICogdV9zaGFkb3c7XFxufVxcblwiXG4gIH0sXG4gIGV4dHJ1c2lvbnBhdHRlcm46IHtcbiAgICAgIGZyYWdtZW50U291cmNlOiBcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbHNlXFxuI2RlZmluZSBsb3dwXFxuI2RlZmluZSBtZWRpdW1wXFxuI2RlZmluZSBoaWdocFxcbiNlbmRpZlxcblxcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fdGxfYTtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX2JyX2E7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl90bF9iO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fYnJfYjtcXG51bmlmb3JtIGZsb2F0IHVfbWl4O1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxuXFxudmFyeWluZyB2ZWMyIHZfcG9zX2E7XFxudmFyeWluZyB2ZWMyIHZfcG9zX2I7XFxudmFyeWluZyB2ZWM0IHZfc2hhZG93O1xcbnZhcnlpbmcgZmxvYXQgdl9kaXJlY3Rpb25hbDtcXG5cXG4jaWZkZWYgTUFQQk9YX0dMX0pTXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG1pbkhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgbWF4SFxcbiNlbmRpZlxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCB2ZWM0IGNvbG9yXFxuXFxudm9pZCBtYWluKCkge1xcbiNpZmRlZiBNQVBCT1hfR0xfSlNcXG4gICAgI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBtaW5IXFxuICAgICNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgbWF4SFxcbiNlbmRpZlxcbiAgICAjcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIHZlYzQgY29sb3JcXG5cXG4gICAgdmVjMiBpbWFnZWNvb3JkID0gbW9kKHZfcG9zX2EsIDEuMCk7XFxuICAgIHZlYzIgcG9zID0gbWl4KHVfcGF0dGVybl90bF9hLCB1X3BhdHRlcm5fYnJfYSwgaW1hZ2Vjb29yZCk7XFxuICAgIHZlYzQgY29sb3IxID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHBvcyk7XFxuXFxuICAgIHZlYzIgaW1hZ2Vjb29yZF9iID0gbW9kKHZfcG9zX2IsIDEuMCk7XFxuICAgIHZlYzIgcG9zMiA9IG1peCh1X3BhdHRlcm5fdGxfYiwgdV9wYXR0ZXJuX2JyX2IsIGltYWdlY29vcmRfYik7XFxuICAgIHZlYzQgY29sb3IyID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHBvczIpO1xcblxcbiAgICB2ZWM0IG1peGVkQ29sb3IgPSBtaXgoY29sb3IxLCBjb2xvcjIsIHVfbWl4KTtcXG4gICAgbWl4ZWRDb2xvci5yZ2IgKj0gdl9kaXJlY3Rpb25hbDtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gKG1peGVkQ29sb3IgKyB2X3NoYWRvdyk7XFxuXFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVxcblwiLFxuICAgICAgdmVydGV4U291cmNlOiBcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZWxzZVxcbiNkZWZpbmUgbG93cFxcbiNkZWZpbmUgbWVkaXVtcFxcbiNkZWZpbmUgaGlnaHBcXG4jZW5kaWZcXG5cXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl9zaXplX2E7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl9zaXplX2I7XFxudW5pZm9ybSB2ZWMyIHVfcGl4ZWxfY29vcmRfdXBwZXI7XFxudW5pZm9ybSB2ZWMyIHVfcGl4ZWxfY29vcmRfbG93ZXI7XFxudW5pZm9ybSBmbG9hdCB1X3NjYWxlX2E7XFxudW5pZm9ybSBmbG9hdCB1X3NjYWxlX2I7XFxudW5pZm9ybSBmbG9hdCB1X3RpbGVfdW5pdHNfdG9fcGl4ZWxzO1xcbnVuaWZvcm0gZmxvYXQgdV9oZWlnaHRfZmFjdG9yO1xcblxcbnVuaWZvcm0gdmVjMyB1X2xpZ2h0ZGlyO1xcbnVuaWZvcm0gdmVjNCB1X3NoYWRvdztcXG5cXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5hdHRyaWJ1dGUgdmVjMyBhX25vcm1hbDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9lZGdlZGlzdGFuY2U7XFxuXFxudmFyeWluZyB2ZWMyIHZfcG9zX2E7XFxudmFyeWluZyB2ZWMyIHZfcG9zX2I7XFxudmFyeWluZyB2ZWM0IHZfc2hhZG93O1xcbnZhcnlpbmcgZmxvYXQgdl9kaXJlY3Rpb25hbDtcXG5cXG4jaWZuZGVmIE1BUEJPWF9HTF9KU1xcbmF0dHJpYnV0ZSBmbG9hdCBtaW5IO1xcbmF0dHJpYnV0ZSBmbG9hdCBtYXhIO1xcbiNlbHNlXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG1pbkhcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgbWF4SFxcbiNlbmRpZlxcblxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCB2ZWM0IGNvbG9yXFxuXFxudm9pZCBtYWluKCkge1xcbiNpZmRlZiBNQVBCT1hfR0xfSlNcXG4gICAgI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBtaW5IXFxuICAgICNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgbWF4SFxcbiNlbmRpZlxcbiAgICAjcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIHZlYzQgY29sb3JcXG5cXG4gICAgZmxvYXQgdCA9IG1vZChhX25vcm1hbC54LCAyLjApO1xcbiAgICBmbG9hdCB6ID0gdCA+IDAuMCA/IG1heEggOiBtaW5IO1xcblxcbiAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3BvcywgeiwgMSk7XFxuXFxuICAgIHZlYzIgc2NhbGVkX3NpemVfYSA9IHVfc2NhbGVfYSAqIHVfcGF0dGVybl9zaXplX2E7XFxuICAgIHZlYzIgc2NhbGVkX3NpemVfYiA9IHVfc2NhbGVfYiAqIHVfcGF0dGVybl9zaXplX2I7XFxuXFxuICAgIC8vIHRoZSBmb2xsb3dpbmcgb2Zmc2V0IGNhbGN1bGF0aW9uIGlzIGR1cGxpY2F0ZWQgZnJvbSB0aGUgcmVndWxhciBwYXR0ZXJuIHNoYWRlcjpcXG4gICAgdmVjMiBvZmZzZXRfYSA9IG1vZChtb2QobW9kKHVfcGl4ZWxfY29vcmRfdXBwZXIsIHNjYWxlZF9zaXplX2EpICogMjU2LjAsIHNjYWxlZF9zaXplX2EpICogMjU2LjAgKyB1X3BpeGVsX2Nvb3JkX2xvd2VyLCBzY2FsZWRfc2l6ZV9hKTtcXG4gICAgdmVjMiBvZmZzZXRfYiA9IG1vZChtb2QobW9kKHVfcGl4ZWxfY29vcmRfdXBwZXIsIHNjYWxlZF9zaXplX2IpICogMjU2LjAsIHNjYWxlZF9zaXplX2IpICogMjU2LjAgKyB1X3BpeGVsX2Nvb3JkX2xvd2VyLCBzY2FsZWRfc2l6ZV9iKTtcXG5cXG4gICAgaWYgKGFfbm9ybWFsLnggPT0gMS4wICYmIGFfbm9ybWFsLnkgPT0gMC4wICYmIGFfbm9ybWFsLnogPT0gMTYzODQuMCkge1xcbiAgICAgICAgLy8gZXh0cnVzaW9uIHRvcFxcbiAgICAgICAgdl9wb3NfYSA9ICh1X3RpbGVfdW5pdHNfdG9fcGl4ZWxzICogYV9wb3MgKyBvZmZzZXRfYSkgLyBzY2FsZWRfc2l6ZV9hO1xcbiAgICAgICAgdl9wb3NfYiA9ICh1X3RpbGVfdW5pdHNfdG9fcGl4ZWxzICogYV9wb3MgKyBvZmZzZXRfYikgLyBzY2FsZWRfc2l6ZV9iO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gZXh0cnVzaW9uIHNpZGVcXG4gICAgICAgIGZsb2F0IGhmID0geiAqIHVfaGVpZ2h0X2ZhY3RvcjtcXG5cXG4gICAgICAgIHZfcG9zX2EgPSAodV90aWxlX3VuaXRzX3RvX3BpeGVscyAqIHZlYzIoYV9lZGdlZGlzdGFuY2UsIGhmKSArIG9mZnNldF9hKSAvIHNjYWxlZF9zaXplX2E7XFxuICAgICAgICB2X3Bvc19iID0gKHVfdGlsZV91bml0c190b19waXhlbHMgKiB2ZWMyKGFfZWRnZWRpc3RhbmNlLCBoZikgKyBvZmZzZXRfYikgLyBzY2FsZWRfc2l6ZV9iO1xcbiAgICB9XFxuXFxuICAgIGZsb2F0IGRpcmVjdGlvbmFsID0gY2xhbXAoZG90KGFfbm9ybWFsIC8gMzI3NjguMCwgdV9saWdodGRpciksIDAuMCwgMS4wKTtcXG4gICAgZmxvYXQgc2hhZG93ID0gY2xhbXAoKDAuMyAtIGRpcmVjdGlvbmFsKSAvIDcuMCwgMC4wLCAwLjMpO1xcbiAgICBkaXJlY3Rpb25hbCA9IG1peCgwLjcsIDEuMCwgZGlyZWN0aW9uYWwgKiAyLjAgKiAoMC4yICsgdCkgLyAxLjIpO1xcblxcbiAgICB2X3NoYWRvdyA9IHNoYWRvdyAqIHVfc2hhZG93O1xcbiAgICB2X2RpcmVjdGlvbmFsID0gZGlyZWN0aW9uYWw7XFxufVxcblwiXG4gIH0sXG4gIGV4dHJ1c2lvbnRleHR1cmU6IHtcbiAgICAgIGZyYWdtZW50U291cmNlOiBcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbHNlXFxuI2RlZmluZSBsb3dwXFxuI2RlZmluZSBtZWRpdW1wXFxuI2RlZmluZSBoaWdocFxcbiNlbmRpZlxcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG51bmlmb3JtIGZsb2F0IHVfb3BhY2l0eTtcXG5cXG52YXJ5aW5nIHZlYzIgdl9wb3M7XFxuXFxuLy8gVE9ETyBoZXJlIHdlJ2xsIHByb2JhYmx5IHdhbnQgdG8gYWRkIGFiaWxpdHkgdG8gZmFkZSBpbi4uLlxcbi8vICNpZm5kZWYgTUFQQk9YX0dMX0pTXFxuLy8gdmFyeWluZyB2ZWMyIHZfcG9zO1xcbi8vICNlbHNlXFxuLy8gdW5pZm9ybSBmbG9hdCB1X29wYWNpdHkwO1xcbi8vIHVuaWZvcm0gZmxvYXQgdV9vcGFjaXR5MTtcXG4vLyB1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlMDtcXG4vLyB1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlMTtcXG4vLyB2YXJ5aW5nIHZlYzIgdl9wb3MwO1xcbi8vIHZhcnlpbmcgdmVjMiB2X3BvczE7XFxuLy8gI2VuZGlmXFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlLCB2X3BvcykgKiB1X29wYWNpdHk7XFxufVxcblwiLFxuICAgICAgdmVydGV4U291cmNlOiBcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZWxzZVxcbiNkZWZpbmUgbG93cFxcbiNkZWZpbmUgbWVkaXVtcFxcbiNkZWZpbmUgaGlnaHBcXG4jZW5kaWZcXG5cXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxudW5pZm9ybSBpbnQgdV94ZGltO1xcbnVuaWZvcm0gaW50IHVfeWRpbTtcXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG52YXJ5aW5nIHZlYzIgdl9wb3M7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3BvcywgMCwgMSk7XFxuXFxuICAgIHZfcG9zLnggPSBhX3Bvcy54IC8gZmxvYXQodV94ZGltKTtcXG4gICAgdl9wb3MueSA9IDEuMCAtIGFfcG9zLnkgLyBmbG9hdCh1X3lkaW0pO1xcbn1cXG5cIlxuICB9LFxuICBjaXJjbGU6IHtcbiAgICBmcmFnbWVudFNvdXJjZTogXCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZWxzZVxcbiNkZWZpbmUgbG93cFxcbiNkZWZpbmUgbWVkaXVtcFxcbiNkZWZpbmUgaGlnaHBcXG4jZW5kaWZcXG5cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgdmVjNCBjb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBibHVyXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG5cXG52YXJ5aW5nIHZlYzIgdl9leHRydWRlO1xcbnZhcnlpbmcgbG93cCBmbG9hdCB2X2FudGlhbGlhc2JsdXI7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICAjcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIHZlYzQgY29sb3JcXG4gICAgI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBibHVyXFxuICAgICNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgZmxvYXQgb3BhY2l0eVxcblxcbiAgICBmbG9hdCB0ID0gc21vb3Roc3RlcCgxLjAgLSBtYXgoYmx1ciwgdl9hbnRpYWxpYXNibHVyKSwgMS4wLCBsZW5ndGgodl9leHRydWRlKSk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yICogKDEuMCAtIHQpICogb3BhY2l0eTtcXG5cXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XFxuXCIsXG4gICAgdmVydGV4U291cmNlOiBcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZWxzZVxcbiNkZWZpbmUgbG93cFxcbiNkZWZpbmUgbWVkaXVtcFxcbiNkZWZpbmUgaGlnaHBcXG4jZW5kaWZcXG5cXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxudW5pZm9ybSBib29sIHVfc2NhbGVfd2l0aF9tYXA7XFxudW5pZm9ybSB2ZWMyIHVfZXh0cnVkZV9zY2FsZTtcXG51bmlmb3JtIGZsb2F0IHVfZGV2aWNlcGl4ZWxyYXRpbztcXG5cXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgdmVjNCBjb2xvclxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbWVkaXVtcCBmbG9hdCByYWRpdXNcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgYmx1clxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCBmbG9hdCBvcGFjaXR5XFxuXFxudmFyeWluZyB2ZWMyIHZfZXh0cnVkZTtcXG52YXJ5aW5nIGxvd3AgZmxvYXQgdl9hbnRpYWxpYXNibHVyO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgICNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgdmVjNCBjb2xvclxcbiAgICAjcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBtZWRpdW1wIGZsb2F0IHJhZGl1c1xcbiAgICAjcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IGJsdXJcXG4gICAgI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxuXFxuICAgIC8vIHVuZW5jb2RlIHRoZSBleHRydXNpb24gdmVjdG9yIHRoYXQgd2Ugc251Y2sgaW50byB0aGUgYV9wb3MgdmVjdG9yXFxuICAgIHZfZXh0cnVkZSA9IHZlYzIobW9kKGFfcG9zLCAyLjApICogMi4wIC0gMS4wKTtcXG5cXG4gICAgdmVjMiBleHRydWRlID0gdl9leHRydWRlICogcmFkaXVzICogdV9leHRydWRlX3NjYWxlO1xcbiAgICAvLyBtdWx0aXBseSBhX3BvcyBieSAwLjUsIHNpbmNlIHdlIGhhZCBpdCAqIDIgaW4gb3JkZXIgdG8gc25lYWtcXG4gICAgLy8gaW4gZXh0cnVzaW9uIGRhdGFcXG4gICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoZmxvb3IoYV9wb3MgKiAwLjUpLCAwLCAxKTtcXG5cXG4gICAgaWYgKHVfc2NhbGVfd2l0aF9tYXApIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uLnh5ICs9IGV4dHJ1ZGU7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBnbF9Qb3NpdGlvbi54eSArPSBleHRydWRlICogZ2xfUG9zaXRpb24udztcXG4gICAgfVxcblxcbiAgICAvLyBUaGlzIGlzIGEgbWluaW11bSBibHVyIGRpc3RhbmNlIHRoYXQgc2VydmVzIGFzIGEgZmF1eC1hbnRpYWxpYXNpbmcgZm9yXFxuICAgIC8vIHRoZSBjaXJjbGUuIHNpbmNlIGJsdXIgaXMgYSByYXRpbyBvZiB0aGUgY2lyY2xlJ3Mgc2l6ZSBhbmQgdGhlIGludGVudCBpc1xcbiAgICAvLyB0byBrZWVwIHRoZSBibHVyIGF0IHJvdWdobHkgMXB4LCB0aGUgdHdvIGFyZSBpbnZlcnNlbHkgcmVsYXRlZC5cXG4gICAgdl9hbnRpYWxpYXNibHVyID0gMS4wIC8gdV9kZXZpY2VwaXhlbHJhdGlvIC8gcmFkaXVzO1xcbn1cXG5cIlxuICB9LFxuICBsaW5lOiB7XG4gICAgZnJhZ21lbnRTb3VyY2U6IFwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2Vsc2VcXG4jZGVmaW5lIGxvd3BcXG4jZGVmaW5lIG1lZGl1bXBcXG4jZGVmaW5lIGhpZ2hwXFxuI2VuZGlmXFxuXFxudW5pZm9ybSBsb3dwIGZsb2F0IHVfb3BhY2l0eTtcXG51bmlmb3JtIGZsb2F0IHVfYmx1cjtcXG5cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgdmVjNCBjb2xvclxcblxcbnZhcnlpbmcgdmVjMiB2X2xpbmV3aWR0aDtcXG52YXJ5aW5nIHZlYzIgdl9ub3JtYWw7XFxudmFyeWluZyBmbG9hdCB2X2dhbW1hX3NjYWxlO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCB2ZWM0IGNvbG9yXFxuXFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2Ugb2YgdGhlIHBpeGVsIGZyb20gdGhlIGxpbmUgaW4gcGl4ZWxzLlxcbiAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKHZfbm9ybWFsKSAqIHZfbGluZXdpZHRoLnM7XFxuXFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgYW50aWFsaWFzaW5nIGZhZGUgZmFjdG9yLiBUaGlzIGlzIGVpdGhlciB3aGVuIGZhZGluZyBpblxcbiAgICAvLyB0aGUgbGluZSBpbiBjYXNlIG9mIGFuIG9mZnNldCBsaW5lICh2X2xpbmV3aWR0aC50KSBvciB3aGVuIGZhZGluZyBvdXRcXG4gICAgLy8gKHZfbGluZXdpZHRoLnMpXFxuICAgIGZsb2F0IGJsdXIgPSB1X2JsdXIgKiB2X2dhbW1hX3NjYWxlO1xcbiAgICBmbG9hdCBhbHBoYSA9IGNsYW1wKG1pbihkaXN0IC0gKHZfbGluZXdpZHRoLnQgLSBibHVyKSwgdl9saW5ld2lkdGgucyAtIGRpc3QpIC8gYmx1ciwgMC4wLCAxLjApO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvciAqIChhbHBoYSAqIHVfb3BhY2l0eSk7XFxuXFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVxcblwiLFxuICAgIHZlcnRleFNvdXJjZTogXCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2Vsc2VcXG4jZGVmaW5lIGxvd3BcXG4jZGVmaW5lIG1lZGl1bXBcXG4jZGVmaW5lIGhpZ2hwXFxuI2VuZGlmXFxuXFxuLy8gZmxvb3IoMTI3IC8gMikgPT0gNjMuMFxcbi8vIHRoZSBtYXhpbXVtIGFsbG93ZWQgbWl0ZXIgbGltaXQgaXMgMi4wIGF0IHRoZSBtb21lbnQuIHRoZSBleHRydWRlIG5vcm1hbCBpc1xcbi8vIHN0b3JlZCBpbiBhIGJ5dGUgKC0xMjguLjEyNykuIHdlIHNjYWxlIHJlZ3VsYXIgbm9ybWFscyB1cCB0byBsZW5ndGggNjMsIGJ1dFxcbi8vIHRoZXJlIGFyZSBhbHNvIFxcXCJzcGVjaWFsXFxcIiBub3JtYWxzIHRoYXQgaGF2ZSBhIGJpZ2dlciBsZW5ndGggKG9mIHVwIHRvIDEyNiBpblxcbi8vIHRoaXMgY2FzZSkuXFxuLy8gI2RlZmluZSBzY2FsZSA2My4wXFxuI2RlZmluZSBzY2FsZSAwLjAxNTg3MzAxNlxcblxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfZGF0YTtcXG5cXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfcmF0aW87XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfbGluZXdpZHRoO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X2dhcHdpZHRoO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X2FudGlhbGlhc2luZztcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9leHRyYTtcXG51bmlmb3JtIG1hdDIgdV9hbnRpYWxpYXNpbmdtYXRyaXg7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfb2Zmc2V0O1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X2JsdXI7XFxuXFxudmFyeWluZyB2ZWMyIHZfbm9ybWFsO1xcbnZhcnlpbmcgdmVjMiB2X2xpbmV3aWR0aDtcXG52YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7XFxuXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIHZlYzQgY29sb3JcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgICNwcmFnbWEgbWFwYm94OiBpbml0aWFsaXplIGxvd3AgdmVjNCBjb2xvclxcblxcbiAgICB2ZWMyIGFfZXh0cnVkZSA9IGFfZGF0YS54eSAtIDEyOC4wO1xcbiAgICBmbG9hdCBhX2RpcmVjdGlvbiA9IG1vZChhX2RhdGEueiwgNC4wKSAtIDEuMDtcXG5cXG4gICAgLy8gV2Ugc3RvcmUgdGhlIHRleHR1cmUgbm9ybWFscyBpbiB0aGUgbW9zdCBpbnNpZ25pZmljYW50IGJpdFxcbiAgICAvLyB0cmFuc2Zvcm0geSBzbyB0aGF0IDAgPT4gLTEgYW5kIDEgPT4gMVxcbiAgICAvLyBJbiB0aGUgdGV4dHVyZSBub3JtYWwsIHggaXMgMCBpZiB0aGUgbm9ybWFsIHBvaW50cyBzdHJhaWdodCB1cC9kb3duIGFuZCAxIGlmIGl0J3MgYSByb3VuZCBjYXBcXG4gICAgLy8geSBpcyAxIGlmIHRoZSBub3JtYWwgcG9pbnRzIHVwLCBhbmQgLTEgaWYgaXQgcG9pbnRzIGRvd25cXG4gICAgbWVkaXVtcCB2ZWMyIG5vcm1hbCA9IG1vZChhX3BvcywgMi4wKTtcXG4gICAgbm9ybWFsLnkgPSBzaWduKG5vcm1hbC55IC0gMC41KTtcXG4gICAgdl9ub3JtYWwgPSBub3JtYWw7XFxuXFxuICAgIGZsb2F0IGluc2V0ID0gdV9nYXB3aWR0aCArICh1X2dhcHdpZHRoID4gMC4wID8gdV9hbnRpYWxpYXNpbmcgOiAwLjApO1xcbiAgICBmbG9hdCBvdXRzZXQgPSB1X2dhcHdpZHRoICsgdV9saW5ld2lkdGggKiAodV9nYXB3aWR0aCA+IDAuMCA/IDIuMCA6IDEuMCkgKyB1X2FudGlhbGlhc2luZztcXG5cXG4gICAgLy8gU2NhbGUgdGhlIGV4dHJ1c2lvbiB2ZWN0b3IgZG93biB0byBhIG5vcm1hbCBhbmQgdGhlbiB1cCBieSB0aGUgbGluZSB3aWR0aFxcbiAgICAvLyBvZiB0aGlzIHZlcnRleC5cXG4gICAgbWVkaXVtcCB2ZWMyIGRpc3QgPSBvdXRzZXQgKiBhX2V4dHJ1ZGUgKiBzY2FsZTtcXG5cXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBvZmZzZXQgd2hlbiBkcmF3aW5nIGEgbGluZSB0aGF0IGlzIHRvIHRoZSBzaWRlIG9mIHRoZSBhY3R1YWwgbGluZS5cXG4gICAgLy8gV2UgZG8gdGhpcyBieSBjcmVhdGluZyBhIHZlY3RvciB0aGF0IHBvaW50cyB0b3dhcmRzIHRoZSBleHRydWRlLCBidXQgcm90YXRlXFxuICAgIC8vIGl0IHdoZW4gd2UncmUgZHJhd2luZyByb3VuZCBlbmQgcG9pbnRzIChhX2RpcmVjdGlvbiA9IC0xIG9yIDEpIHNpbmNlIHRoZWlyXFxuICAgIC8vIGV4dHJ1ZGUgdmVjdG9yIHBvaW50cyBpbiBhbm90aGVyIGRpcmVjdGlvbi5cXG4gICAgbWVkaXVtcCBmbG9hdCB1ID0gMC41ICogYV9kaXJlY3Rpb247XFxuICAgIG1lZGl1bXAgZmxvYXQgdCA9IDEuMCAtIGFicyh1KTtcXG4gICAgbWVkaXVtcCB2ZWMyIG9mZnNldCA9IHVfb2Zmc2V0ICogYV9leHRydWRlICogc2NhbGUgKiBub3JtYWwueSAqIG1hdDIodCwgLXUsIHUsIHQpO1xcblxcbiAgICAvLyBSZW1vdmUgdGhlIHRleHR1cmUgbm9ybWFsIGJpdCBvZiB0aGUgcG9zaXRpb24gYmVmb3JlIHNjYWxpbmcgaXQgd2l0aCB0aGVcXG4gICAgLy8gbW9kZWwvdmlldyBtYXRyaXguXFxuICAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiB2ZWM0KGZsb29yKGFfcG9zICogMC41KSArIChvZmZzZXQgKyBkaXN0KSAvIHVfcmF0aW8sIDAuMCwgMS4wKTtcXG5cXG4gICAgLy8gcG9zaXRpb24gb2YgeSBvbiB0aGUgc2NyZWVuXFxuICAgIGZsb2F0IHkgPSBnbF9Qb3NpdGlvbi55IC8gZ2xfUG9zaXRpb24udztcXG5cXG4gICAgLy8gaG93IG11Y2ggZmVhdHVyZXMgYXJlIHNxdWlzaGVkIGluIHRoZSB5IGRpcmVjdGlvbiBieSB0aGUgdGlsdFxcbiAgICBmbG9hdCBzcXVpc2hfc2NhbGUgPSBsZW5ndGgoYV9leHRydWRlKSAvIGxlbmd0aCh1X2FudGlhbGlhc2luZ21hdHJpeCAqIGFfZXh0cnVkZSk7XFxuXFxuICAgIC8vIGhvdyBtdWNoIGZlYXR1cmVzIGFyZSBzcXVpc2hlZCBpbiBhbGwgZGlyZWN0aW9ucyBieSB0aGUgcGVyc3BlY3RpdmVuZXNzXFxuICAgIGZsb2F0IHBlcnNwZWN0aXZlX3NjYWxlID0gMS4wIC8gKDEuMCAtIG1pbih5ICogdV9leHRyYSwgMC45KSk7XFxuXFxuICAgIHZfbGluZXdpZHRoID0gdmVjMihvdXRzZXQsIGluc2V0KTtcXG4gICAgdl9nYW1tYV9zY2FsZSA9IHBlcnNwZWN0aXZlX3NjYWxlICogc3F1aXNoX3NjYWxlO1xcbn1cXG5cIlxuICB9LFxuICBsaW5lcGF0dGVybjoge1xuICAgIGZyYWdtZW50U291cmNlOiBcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbHNlXFxuI2RlZmluZSBsb3dwXFxuI2RlZmluZSBtZWRpdW1wXFxuI2RlZmluZSBoaWdocFxcbiNlbmRpZlxcblxcbnVuaWZvcm0gZmxvYXQgdV9ibHVyO1xcblxcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fc2l6ZV9hO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fc2l6ZV9iO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fdGxfYTtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX2JyX2E7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl90bF9iO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fYnJfYjtcXG51bmlmb3JtIGZsb2F0IHVfZmFkZTtcXG51bmlmb3JtIGZsb2F0IHVfb3BhY2l0eTtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcblxcbnZhcnlpbmcgdmVjMiB2X25vcm1hbDtcXG52YXJ5aW5nIHZlYzIgdl9saW5ld2lkdGg7XFxudmFyeWluZyBmbG9hdCB2X2xpbmVzb2ZhcjtcXG52YXJ5aW5nIGZsb2F0IHZfZ2FtbWFfc2NhbGU7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIG9mIHRoZSBwaXhlbCBmcm9tIHRoZSBsaW5lIGluIHBpeGVscy5cXG4gICAgZmxvYXQgZGlzdCA9IGxlbmd0aCh2X25vcm1hbCkgKiB2X2xpbmV3aWR0aC5zO1xcblxcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGFudGlhbGlhc2luZyBmYWRlIGZhY3Rvci4gVGhpcyBpcyBlaXRoZXIgd2hlbiBmYWRpbmcgaW5cXG4gICAgLy8gdGhlIGxpbmUgaW4gY2FzZSBvZiBhbiBvZmZzZXQgbGluZSAodl9saW5ld2lkdGgudCkgb3Igd2hlbiBmYWRpbmcgb3V0XFxuICAgIC8vICh2X2xpbmV3aWR0aC5zKVxcbiAgICBmbG9hdCBibHVyID0gdV9ibHVyICogdl9nYW1tYV9zY2FsZTtcXG4gICAgZmxvYXQgYWxwaGEgPSBjbGFtcChtaW4oZGlzdCAtICh2X2xpbmV3aWR0aC50IC0gYmx1ciksIHZfbGluZXdpZHRoLnMgLSBkaXN0KSAvIGJsdXIsIDAuMCwgMS4wKTtcXG5cXG4gICAgZmxvYXQgeF9hID0gbW9kKHZfbGluZXNvZmFyIC8gdV9wYXR0ZXJuX3NpemVfYS54LCAxLjApO1xcbiAgICBmbG9hdCB4X2IgPSBtb2Qodl9saW5lc29mYXIgLyB1X3BhdHRlcm5fc2l6ZV9iLngsIDEuMCk7XFxuICAgIGZsb2F0IHlfYSA9IDAuNSArICh2X25vcm1hbC55ICogdl9saW5ld2lkdGgucyAvIHVfcGF0dGVybl9zaXplX2EueSk7XFxuICAgIGZsb2F0IHlfYiA9IDAuNSArICh2X25vcm1hbC55ICogdl9saW5ld2lkdGgucyAvIHVfcGF0dGVybl9zaXplX2IueSk7XFxuICAgIHZlYzIgcG9zX2EgPSBtaXgodV9wYXR0ZXJuX3RsX2EsIHVfcGF0dGVybl9icl9hLCB2ZWMyKHhfYSwgeV9hKSk7XFxuICAgIHZlYzIgcG9zX2IgPSBtaXgodV9wYXR0ZXJuX3RsX2IsIHVfcGF0dGVybl9icl9iLCB2ZWMyKHhfYiwgeV9iKSk7XFxuXFxuICAgIHZlYzQgY29sb3IgPSBtaXgodGV4dHVyZTJEKHVfaW1hZ2UsIHBvc19hKSwgdGV4dHVyZTJEKHVfaW1hZ2UsIHBvc19iKSwgdV9mYWRlKTtcXG5cXG4gICAgYWxwaGEgKj0gdV9vcGFjaXR5O1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvciAqIGFscGhhO1xcblxcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cXG5cIixcbiAgICB2ZXJ0ZXhTb3VyY2U6IFwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNlbHNlXFxuI2RlZmluZSBsb3dwXFxuI2RlZmluZSBtZWRpdW1wXFxuI2RlZmluZSBoaWdocFxcbiNlbmRpZlxcblxcbi8vIGZsb29yKDEyNyAvIDIpID09IDYzLjBcXG4vLyB0aGUgbWF4aW11bSBhbGxvd2VkIG1pdGVyIGxpbWl0IGlzIDIuMCBhdCB0aGUgbW9tZW50LiB0aGUgZXh0cnVkZSBub3JtYWwgaXNcXG4vLyBzdG9yZWQgaW4gYSBieXRlICgtMTI4Li4xMjcpLiB3ZSBzY2FsZSByZWd1bGFyIG5vcm1hbHMgdXAgdG8gbGVuZ3RoIDYzLCBidXRcXG4vLyB0aGVyZSBhcmUgYWxzbyBcXFwic3BlY2lhbFxcXCIgbm9ybWFscyB0aGF0IGhhdmUgYSBiaWdnZXIgbGVuZ3RoIChvZiB1cCB0byAxMjYgaW5cXG4vLyB0aGlzIGNhc2UpLlxcbi8vICNkZWZpbmUgc2NhbGUgNjMuMFxcbiNkZWZpbmUgc2NhbGUgMC4wMTU4NzMwMTZcXG5cXG4vLyBXZSBzY2FsZSB0aGUgZGlzdGFuY2UgYmVmb3JlIGFkZGluZyBpdCB0byB0aGUgYnVmZmVycyBzbyB0aGF0IHdlIGNhbiBzdG9yZVxcbi8vIGxvbmcgZGlzdGFuY2VzIGZvciBsb25nIHNlZ21lbnRzLiBVc2UgdGhpcyB2YWx1ZSB0byB1bnNjYWxlIHRoZSBkaXN0YW5jZS5cXG4jZGVmaW5lIExJTkVfRElTVEFOQ0VfU0NBTEUgMi4wXFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzQgYV9kYXRhO1xcblxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9yYXRpbztcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9saW5ld2lkdGg7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfZ2Fwd2lkdGg7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfYW50aWFsaWFzaW5nO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X2V4dHJhO1xcbnVuaWZvcm0gbWF0MiB1X2FudGlhbGlhc2luZ21hdHJpeDtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9vZmZzZXQ7XFxuXFxudmFyeWluZyB2ZWMyIHZfbm9ybWFsO1xcbnZhcnlpbmcgdmVjMiB2X2xpbmV3aWR0aDtcXG52YXJ5aW5nIGZsb2F0IHZfbGluZXNvZmFyO1xcbnZhcnlpbmcgZmxvYXQgdl9nYW1tYV9zY2FsZTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZlYzIgYV9leHRydWRlID0gYV9kYXRhLnh5IC0gMTI4LjA7XFxuICAgIGZsb2F0IGFfZGlyZWN0aW9uID0gbW9kKGFfZGF0YS56LCA0LjApIC0gMS4wO1xcbiAgICBmbG9hdCBhX2xpbmVzb2ZhciA9IChmbG9vcihhX2RhdGEueiAvIDQuMCkgKyBhX2RhdGEudyAqIDY0LjApICogTElORV9ESVNUQU5DRV9TQ0FMRTtcXG5cXG4gICAgLy8gV2Ugc3RvcmUgdGhlIHRleHR1cmUgbm9ybWFscyBpbiB0aGUgbW9zdCBpbnNpZ25pZmljYW50IGJpdFxcbiAgICAvLyB0cmFuc2Zvcm0geSBzbyB0aGF0IDAgPT4gLTEgYW5kIDEgPT4gMVxcbiAgICAvLyBJbiB0aGUgdGV4dHVyZSBub3JtYWwsIHggaXMgMCBpZiB0aGUgbm9ybWFsIHBvaW50cyBzdHJhaWdodCB1cC9kb3duIGFuZCAxIGlmIGl0J3MgYSByb3VuZCBjYXBcXG4gICAgLy8geSBpcyAxIGlmIHRoZSBub3JtYWwgcG9pbnRzIHVwLCBhbmQgLTEgaWYgaXQgcG9pbnRzIGRvd25cXG4gICAgbWVkaXVtcCB2ZWMyIG5vcm1hbCA9IG1vZChhX3BvcywgMi4wKTtcXG4gICAgbm9ybWFsLnkgPSBzaWduKG5vcm1hbC55IC0gMC41KTtcXG4gICAgdl9ub3JtYWwgPSBub3JtYWw7XFxuXFxuICAgIGZsb2F0IGluc2V0ID0gdV9nYXB3aWR0aCArICh1X2dhcHdpZHRoID4gMC4wID8gdV9hbnRpYWxpYXNpbmcgOiAwLjApO1xcbiAgICBmbG9hdCBvdXRzZXQgPSB1X2dhcHdpZHRoICsgdV9saW5ld2lkdGggKiAodV9nYXB3aWR0aCA+IDAuMCA/IDIuMCA6IDEuMCkgKyB1X2FudGlhbGlhc2luZztcXG5cXG4gICAgLy8gU2NhbGUgdGhlIGV4dHJ1c2lvbiB2ZWN0b3IgZG93biB0byBhIG5vcm1hbCBhbmQgdGhlbiB1cCBieSB0aGUgbGluZSB3aWR0aFxcbiAgICAvLyBvZiB0aGlzIHZlcnRleC5cXG4gICAgbWVkaXVtcCB2ZWMyIGRpc3QgPSBvdXRzZXQgKiBhX2V4dHJ1ZGUgKiBzY2FsZTtcXG5cXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBvZmZzZXQgd2hlbiBkcmF3aW5nIGEgbGluZSB0aGF0IGlzIHRvIHRoZSBzaWRlIG9mIHRoZSBhY3R1YWwgbGluZS5cXG4gICAgLy8gV2UgZG8gdGhpcyBieSBjcmVhdGluZyBhIHZlY3RvciB0aGF0IHBvaW50cyB0b3dhcmRzIHRoZSBleHRydWRlLCBidXQgcm90YXRlXFxuICAgIC8vIGl0IHdoZW4gd2UncmUgZHJhd2luZyByb3VuZCBlbmQgcG9pbnRzIChhX2RpcmVjdGlvbiA9IC0xIG9yIDEpIHNpbmNlIHRoZWlyXFxuICAgIC8vIGV4dHJ1ZGUgdmVjdG9yIHBvaW50cyBpbiBhbm90aGVyIGRpcmVjdGlvbi5cXG4gICAgbWVkaXVtcCBmbG9hdCB1ID0gMC41ICogYV9kaXJlY3Rpb247XFxuICAgIG1lZGl1bXAgZmxvYXQgdCA9IDEuMCAtIGFicyh1KTtcXG4gICAgbWVkaXVtcCB2ZWMyIG9mZnNldCA9IHVfb2Zmc2V0ICogYV9leHRydWRlICogc2NhbGUgKiBub3JtYWwueSAqIG1hdDIodCwgLXUsIHUsIHQpO1xcblxcbiAgICAvLyBSZW1vdmUgdGhlIHRleHR1cmUgbm9ybWFsIGJpdCBvZiB0aGUgcG9zaXRpb24gYmVmb3JlIHNjYWxpbmcgaXQgd2l0aCB0aGVcXG4gICAgLy8gbW9kZWwvdmlldyBtYXRyaXguXFxuICAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiB2ZWM0KGZsb29yKGFfcG9zICogMC41KSArIChvZmZzZXQgKyBkaXN0KSAvIHVfcmF0aW8sIDAuMCwgMS4wKTtcXG4gICAgdl9saW5lc29mYXIgPSBhX2xpbmVzb2ZhcjtcXG5cXG4gICAgLy8gcG9zaXRpb24gb2YgeSBvbiB0aGUgc2NyZWVuXFxuICAgIGZsb2F0IHkgPSBnbF9Qb3NpdGlvbi55IC8gZ2xfUG9zaXRpb24udztcXG5cXG4gICAgLy8gaG93IG11Y2ggZmVhdHVyZXMgYXJlIHNxdWlzaGVkIGluIHRoZSB5IGRpcmVjdGlvbiBieSB0aGUgdGlsdFxcbiAgICBmbG9hdCBzcXVpc2hfc2NhbGUgPSBsZW5ndGgoYV9leHRydWRlKSAvIGxlbmd0aCh1X2FudGlhbGlhc2luZ21hdHJpeCAqIGFfZXh0cnVkZSk7XFxuXFxuICAgIC8vIGhvdyBtdWNoIGZlYXR1cmVzIGFyZSBzcXVpc2hlZCBpbiBhbGwgZGlyZWN0aW9ucyBieSB0aGUgcGVyc3BlY3RpdmVuZXNzXFxuICAgIGZsb2F0IHBlcnNwZWN0aXZlX3NjYWxlID0gMS4wIC8gKDEuMCAtIG1pbih5ICogdV9leHRyYSwgMC45KSk7XFxuXFxuICAgIHZfbGluZXdpZHRoID0gdmVjMihvdXRzZXQsIGluc2V0KTtcXG4gICAgdl9nYW1tYV9zY2FsZSA9IHBlcnNwZWN0aXZlX3NjYWxlICogc3F1aXNoX3NjYWxlO1xcbn1cXG5cIlxuICB9LFxuICBsaW5lc2RmcGF0dGVybjoge1xuICAgIGZyYWdtZW50U291cmNlOiBcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbHNlXFxuI2RlZmluZSBsb3dwXFxuI2RlZmluZSBtZWRpdW1wXFxuI2RlZmluZSBoaWdocFxcbiNlbmRpZlxcblxcbnVuaWZvcm0gbG93cCBmbG9hdCB1X29wYWNpdHk7XFxuXFxudW5pZm9ybSBmbG9hdCB1X2JsdXI7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG51bmlmb3JtIGZsb2F0IHVfc2RmZ2FtbWE7XFxudW5pZm9ybSBmbG9hdCB1X21peDtcXG5cXG52YXJ5aW5nIHZlYzIgdl9ub3JtYWw7XFxudmFyeWluZyB2ZWMyIHZfbGluZXdpZHRoO1xcbnZhcnlpbmcgdmVjMiB2X3RleF9hO1xcbnZhcnlpbmcgdmVjMiB2X3RleF9iO1xcbnZhcnlpbmcgZmxvYXQgdl9nYW1tYV9zY2FsZTtcXG5cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgdmVjNCBjb2xvclxcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCB2ZWM0IGNvbG9yXFxuXFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2Ugb2YgdGhlIHBpeGVsIGZyb20gdGhlIGxpbmUgaW4gcGl4ZWxzLlxcbiAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKHZfbm9ybWFsKSAqIHZfbGluZXdpZHRoLnM7XFxuXFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgYW50aWFsaWFzaW5nIGZhZGUgZmFjdG9yLiBUaGlzIGlzIGVpdGhlciB3aGVuIGZhZGluZyBpblxcbiAgICAvLyB0aGUgbGluZSBpbiBjYXNlIG9mIGFuIG9mZnNldCBsaW5lICh2X2xpbmV3aWR0aC50KSBvciB3aGVuIGZhZGluZyBvdXRcXG4gICAgLy8gKHZfbGluZXdpZHRoLnMpXFxuICAgIGZsb2F0IGJsdXIgPSB1X2JsdXIgKiB2X2dhbW1hX3NjYWxlO1xcbiAgICBmbG9hdCBhbHBoYSA9IGNsYW1wKG1pbihkaXN0IC0gKHZfbGluZXdpZHRoLnQgLSBibHVyKSwgdl9saW5ld2lkdGgucyAtIGRpc3QpIC8gYmx1ciwgMC4wLCAxLjApO1xcblxcbiAgICBmbG9hdCBzZGZkaXN0X2EgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhfYSkuYTtcXG4gICAgZmxvYXQgc2RmZGlzdF9iID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4X2IpLmE7XFxuICAgIGZsb2F0IHNkZmRpc3QgPSBtaXgoc2RmZGlzdF9hLCBzZGZkaXN0X2IsIHVfbWl4KTtcXG4gICAgYWxwaGEgKj0gc21vb3Roc3RlcCgwLjUgLSB1X3NkZmdhbW1hLCAwLjUgKyB1X3NkZmdhbW1hLCBzZGZkaXN0KTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgKiAoYWxwaGEgKiB1X29wYWNpdHkpO1xcblxcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cXG5cIixcbiAgICB2ZXJ0ZXhTb3VyY2U6IFwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNlbHNlXFxuI2RlZmluZSBsb3dwXFxuI2RlZmluZSBtZWRpdW1wXFxuI2RlZmluZSBoaWdocFxcbiNlbmRpZlxcblxcbi8vIGZsb29yKDEyNyAvIDIpID09IDYzLjBcXG4vLyB0aGUgbWF4aW11bSBhbGxvd2VkIG1pdGVyIGxpbWl0IGlzIDIuMCBhdCB0aGUgbW9tZW50LiB0aGUgZXh0cnVkZSBub3JtYWwgaXNcXG4vLyBzdG9yZWQgaW4gYSBieXRlICgtMTI4Li4xMjcpLiB3ZSBzY2FsZSByZWd1bGFyIG5vcm1hbHMgdXAgdG8gbGVuZ3RoIDYzLCBidXRcXG4vLyB0aGVyZSBhcmUgYWxzbyBcXFwic3BlY2lhbFxcXCIgbm9ybWFscyB0aGF0IGhhdmUgYSBiaWdnZXIgbGVuZ3RoIChvZiB1cCB0byAxMjYgaW5cXG4vLyB0aGlzIGNhc2UpLlxcbi8vICNkZWZpbmUgc2NhbGUgNjMuMFxcbiNkZWZpbmUgc2NhbGUgMC4wMTU4NzMwMTZcXG5cXG4vLyBXZSBzY2FsZSB0aGUgZGlzdGFuY2UgYmVmb3JlIGFkZGluZyBpdCB0byB0aGUgYnVmZmVycyBzbyB0aGF0IHdlIGNhbiBzdG9yZVxcbi8vIGxvbmcgZGlzdGFuY2VzIGZvciBsb25nIHNlZ21lbnRzLiBVc2UgdGhpcyB2YWx1ZSB0byB1bnNjYWxlIHRoZSBkaXN0YW5jZS5cXG4jZGVmaW5lIExJTkVfRElTVEFOQ0VfU0NBTEUgMi4wXFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzQgYV9kYXRhO1xcblxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9yYXRpbztcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9saW5ld2lkdGg7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfZ2Fwd2lkdGg7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfYW50aWFsaWFzaW5nO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5zY2FsZV9hO1xcbnVuaWZvcm0gZmxvYXQgdV90ZXhfeV9hO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5zY2FsZV9iO1xcbnVuaWZvcm0gZmxvYXQgdV90ZXhfeV9iO1xcbnVuaWZvcm0gZmxvYXQgdV9leHRyYTtcXG51bmlmb3JtIG1hdDIgdV9hbnRpYWxpYXNpbmdtYXRyaXg7XFxudW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVfb2Zmc2V0O1xcblxcbnZhcnlpbmcgdmVjMiB2X25vcm1hbDtcXG52YXJ5aW5nIHZlYzIgdl9saW5ld2lkdGg7XFxudmFyeWluZyB2ZWMyIHZfdGV4X2E7XFxudmFyeWluZyB2ZWMyIHZfdGV4X2I7XFxudmFyeWluZyBmbG9hdCB2X2dhbW1hX3NjYWxlO1xcblxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCB2ZWM0IGNvbG9yXFxuXFxudm9pZCBtYWluKCkge1xcbiAgICAjcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIHZlYzQgY29sb3JcXG5cXG4gICAgdmVjMiBhX2V4dHJ1ZGUgPSBhX2RhdGEueHkgLSAxMjguMDtcXG4gICAgZmxvYXQgYV9kaXJlY3Rpb24gPSBtb2QoYV9kYXRhLnosIDQuMCkgLSAxLjA7XFxuICAgIGZsb2F0IGFfbGluZXNvZmFyID0gKGZsb29yKGFfZGF0YS56IC8gNC4wKSArIGFfZGF0YS53ICogNjQuMCkgKiBMSU5FX0RJU1RBTkNFX1NDQUxFO1xcblxcbiAgICAvLyBXZSBzdG9yZSB0aGUgdGV4dHVyZSBub3JtYWxzIGluIHRoZSBtb3N0IGluc2lnbmlmaWNhbnQgYml0XFxuICAgIC8vIHRyYW5zZm9ybSB5IHNvIHRoYXQgMCA9PiAtMSBhbmQgMSA9PiAxXFxuICAgIC8vIEluIHRoZSB0ZXh0dXJlIG5vcm1hbCwgeCBpcyAwIGlmIHRoZSBub3JtYWwgcG9pbnRzIHN0cmFpZ2h0IHVwL2Rvd24gYW5kIDEgaWYgaXQncyBhIHJvdW5kIGNhcFxcbiAgICAvLyB5IGlzIDEgaWYgdGhlIG5vcm1hbCBwb2ludHMgdXAsIGFuZCAtMSBpZiBpdCBwb2ludHMgZG93blxcbiAgICBtZWRpdW1wIHZlYzIgbm9ybWFsID0gbW9kKGFfcG9zLCAyLjApO1xcbiAgICBub3JtYWwueSA9IHNpZ24obm9ybWFsLnkgLSAwLjUpO1xcbiAgICB2X25vcm1hbCA9IG5vcm1hbDtcXG5cXG4gICAgZmxvYXQgaW5zZXQgPSB1X2dhcHdpZHRoICsgKHVfZ2Fwd2lkdGggPiAwLjAgPyB1X2FudGlhbGlhc2luZyA6IDAuMCk7XFxuICAgIGZsb2F0IG91dHNldCA9IHVfZ2Fwd2lkdGggKyB1X2xpbmV3aWR0aCAqICh1X2dhcHdpZHRoID4gMC4wID8gMi4wIDogMS4wKSArIHVfYW50aWFsaWFzaW5nO1xcblxcbiAgICAvLyBTY2FsZSB0aGUgZXh0cnVzaW9uIHZlY3RvciBkb3duIHRvIGEgbm9ybWFsIGFuZCB0aGVuIHVwIGJ5IHRoZSBsaW5lIHdpZHRoXFxuICAgIC8vIG9mIHRoaXMgdmVydGV4LlxcbiAgICBtZWRpdW1wIHZlYzIgZGlzdCA9IG91dHNldCAqIGFfZXh0cnVkZSAqIHNjYWxlO1xcblxcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG9mZnNldCB3aGVuIGRyYXdpbmcgYSBsaW5lIHRoYXQgaXMgdG8gdGhlIHNpZGUgb2YgdGhlIGFjdHVhbCBsaW5lLlxcbiAgICAvLyBXZSBkbyB0aGlzIGJ5IGNyZWF0aW5nIGEgdmVjdG9yIHRoYXQgcG9pbnRzIHRvd2FyZHMgdGhlIGV4dHJ1ZGUsIGJ1dCByb3RhdGVcXG4gICAgLy8gaXQgd2hlbiB3ZSdyZSBkcmF3aW5nIHJvdW5kIGVuZCBwb2ludHMgKGFfZGlyZWN0aW9uID0gLTEgb3IgMSkgc2luY2UgdGhlaXJcXG4gICAgLy8gZXh0cnVkZSB2ZWN0b3IgcG9pbnRzIGluIGFub3RoZXIgZGlyZWN0aW9uLlxcbiAgICBtZWRpdW1wIGZsb2F0IHUgPSAwLjUgKiBhX2RpcmVjdGlvbjtcXG4gICAgbWVkaXVtcCBmbG9hdCB0ID0gMS4wIC0gYWJzKHUpO1xcbiAgICBtZWRpdW1wIHZlYzIgb2Zmc2V0ID0gdV9vZmZzZXQgKiBhX2V4dHJ1ZGUgKiBzY2FsZSAqIG5vcm1hbC55ICogbWF0Mih0LCAtdSwgdSwgdCk7XFxuXFxuICAgIC8vIFJlbW92ZSB0aGUgdGV4dHVyZSBub3JtYWwgYml0IG9mIHRoZSBwb3NpdGlvbiBiZWZvcmUgc2NhbGluZyBpdCB3aXRoIHRoZVxcbiAgICAvLyBtb2RlbC92aWV3IG1hdHJpeC5cXG4gICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoZmxvb3IoYV9wb3MgKiAwLjUpICsgKG9mZnNldCArIGRpc3QpIC8gdV9yYXRpbywgMC4wLCAxLjApO1xcblxcbiAgICB2X3RleF9hID0gdmVjMihhX2xpbmVzb2ZhciAqIHVfcGF0dGVybnNjYWxlX2EueCwgbm9ybWFsLnkgKiB1X3BhdHRlcm5zY2FsZV9hLnkgKyB1X3RleF95X2EpO1xcbiAgICB2X3RleF9iID0gdmVjMihhX2xpbmVzb2ZhciAqIHVfcGF0dGVybnNjYWxlX2IueCwgbm9ybWFsLnkgKiB1X3BhdHRlcm5zY2FsZV9iLnkgKyB1X3RleF95X2IpO1xcblxcbiAgICAvLyBwb3NpdGlvbiBvZiB5IG9uIHRoZSBzY3JlZW5cXG4gICAgZmxvYXQgeSA9IGdsX1Bvc2l0aW9uLnkgLyBnbF9Qb3NpdGlvbi53O1xcblxcbiAgICAvLyBob3cgbXVjaCBmZWF0dXJlcyBhcmUgc3F1aXNoZWQgaW4gdGhlIHkgZGlyZWN0aW9uIGJ5IHRoZSB0aWx0XFxuICAgIGZsb2F0IHNxdWlzaF9zY2FsZSA9IGxlbmd0aChhX2V4dHJ1ZGUpIC8gbGVuZ3RoKHVfYW50aWFsaWFzaW5nbWF0cml4ICogYV9leHRydWRlKTtcXG5cXG4gICAgLy8gaG93IG11Y2ggZmVhdHVyZXMgYXJlIHNxdWlzaGVkIGluIGFsbCBkaXJlY3Rpb25zIGJ5IHRoZSBwZXJzcGVjdGl2ZW5lc3NcXG4gICAgZmxvYXQgcGVyc3BlY3RpdmVfc2NhbGUgPSAxLjAgLyAoMS4wIC0gbWluKHkgKiB1X2V4dHJhLCAwLjkpKTtcXG5cXG4gICAgdl9saW5ld2lkdGggPSB2ZWMyKG91dHNldCwgaW5zZXQpO1xcbiAgICB2X2dhbW1hX3NjYWxlID0gcGVyc3BlY3RpdmVfc2NhbGUgKiBzcXVpc2hfc2NhbGU7XFxufVxcblwiXG4gIH0sXG4gIG91dGxpbmU6IHtcbiAgICBmcmFnbWVudFNvdXJjZTogXCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZWxzZVxcbiNkZWZpbmUgbG93cFxcbiNkZWZpbmUgbWVkaXVtcFxcbiNkZWZpbmUgaGlnaHBcXG4jZW5kaWZcXG5cXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgdmVjNCBvdXRsaW5lX2NvbG9yXFxuI3ByYWdtYSBtYXBib3g6IGRlZmluZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG5cXG52YXJ5aW5nIHZlYzIgdl9wb3M7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICAjcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIHZlYzQgb3V0bGluZV9jb2xvclxcbiAgICAjcHJhZ21hIG1hcGJveDogaW5pdGlhbGl6ZSBsb3dwIGZsb2F0IG9wYWNpdHlcXG5cXG4gICAgZmxvYXQgZGlzdCA9IGxlbmd0aCh2X3BvcyAtIGdsX0ZyYWdDb29yZC54eSk7XFxuICAgIGZsb2F0IGFscGhhID0gc21vb3Roc3RlcCgxLjAsIDAuMCwgZGlzdCk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IG91dGxpbmVfY29sb3IgKiAoYWxwaGEgKiBvcGFjaXR5KTtcXG5cXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XFxuXCIsXG4gICAgdmVydGV4U291cmNlOiBcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZWxzZVxcbiNkZWZpbmUgbG93cFxcbiNkZWZpbmUgbWVkaXVtcFxcbiNkZWZpbmUgaGlnaHBcXG4jZW5kaWZcXG5cXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5cXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHVfd29ybGQ7XFxuXFxudmFyeWluZyB2ZWMyIHZfcG9zO1xcblxcbiNwcmFnbWEgbWFwYm94OiBkZWZpbmUgbG93cCB2ZWM0IG91dGxpbmVfY29sb3JcXG4jcHJhZ21hIG1hcGJveDogZGVmaW5lIGxvd3AgZmxvYXQgb3BhY2l0eVxcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCB2ZWM0IG91dGxpbmVfY29sb3JcXG4gICAgI3ByYWdtYSBtYXBib3g6IGluaXRpYWxpemUgbG93cCBmbG9hdCBvcGFjaXR5XFxuXFxuICAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiB2ZWM0KGFfcG9zLCAwLCAxKTtcXG4gICAgdl9wb3MgPSAoZ2xfUG9zaXRpb24ueHkgLyBnbF9Qb3NpdGlvbi53ICsgMS4wKSAvIDIuMCAqIHVfd29ybGQ7XFxufVxcblwiXG4gIH0sXG4gIG91dGxpbmVwYXR0ZXJuOiB7XG4gICAgZnJhZ21lbnRTb3VyY2U6IFwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2Vsc2VcXG4jZGVmaW5lIGxvd3BcXG4jZGVmaW5lIG1lZGl1bXBcXG4jZGVmaW5lIGhpZ2hwXFxuI2VuZGlmXFxuXFxudW5pZm9ybSBmbG9hdCB1X29wYWNpdHk7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl90bF9hO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fYnJfYTtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX3RsX2I7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl9icl9iO1xcbnVuaWZvcm0gZmxvYXQgdV9taXg7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG5cXG52YXJ5aW5nIHZlYzIgdl9wb3NfYTtcXG52YXJ5aW5nIHZlYzIgdl9wb3NfYjtcXG52YXJ5aW5nIHZlYzIgdl9wb3M7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWMyIGltYWdlY29vcmQgPSBtb2Qodl9wb3NfYSwgMS4wKTtcXG4gICAgdmVjMiBwb3MgPSBtaXgodV9wYXR0ZXJuX3RsX2EsIHVfcGF0dGVybl9icl9hLCBpbWFnZWNvb3JkKTtcXG4gICAgdmVjNCBjb2xvcjEgPSB0ZXh0dXJlMkQodV9pbWFnZSwgcG9zKTtcXG5cXG4gICAgdmVjMiBpbWFnZWNvb3JkX2IgPSBtb2Qodl9wb3NfYiwgMS4wKTtcXG4gICAgdmVjMiBwb3MyID0gbWl4KHVfcGF0dGVybl90bF9iLCB1X3BhdHRlcm5fYnJfYiwgaW1hZ2Vjb29yZF9iKTtcXG4gICAgdmVjNCBjb2xvcjIgPSB0ZXh0dXJlMkQodV9pbWFnZSwgcG9zMik7XFxuXFxuICAgIC8vIGZpbmQgZGlzdGFuY2UgdG8gb3V0bGluZSBmb3IgYWxwaGEgaW50ZXJwb2xhdGlvblxcblxcbiAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKHZfcG9zIC0gZ2xfRnJhZ0Nvb3JkLnh5KTtcXG4gICAgZmxvYXQgYWxwaGEgPSBzbW9vdGhzdGVwKDEuMCwgMC4wLCBkaXN0KTtcXG4gICAgXFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IG1peChjb2xvcjEsIGNvbG9yMiwgdV9taXgpICogYWxwaGEgKiB1X29wYWNpdHk7XFxuXFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVxcblwiLFxuICAgIHZlcnRleFNvdXJjZTogXCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2Vsc2VcXG4jZGVmaW5lIGxvd3BcXG4jZGVmaW5lIG1lZGl1bXBcXG4jZGVmaW5lIGhpZ2hwXFxuI2VuZGlmXFxuXFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl9zaXplX2E7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl9zaXplX2I7XFxudW5pZm9ybSB2ZWMyIHVfcGl4ZWxfY29vcmRfdXBwZXI7XFxudW5pZm9ybSB2ZWMyIHVfcGl4ZWxfY29vcmRfbG93ZXI7XFxudW5pZm9ybSBmbG9hdCB1X3NjYWxlX2E7XFxudW5pZm9ybSBmbG9hdCB1X3NjYWxlX2I7XFxudW5pZm9ybSBmbG9hdCB1X3RpbGVfdW5pdHNfdG9fcGl4ZWxzO1xcblxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcblxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIHZlYzIgdV93b3JsZDtcXG5cXG52YXJ5aW5nIHZlYzIgdl9wb3NfYTtcXG52YXJ5aW5nIHZlYzIgdl9wb3NfYjtcXG52YXJ5aW5nIHZlYzIgdl9wb3M7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3BvcywgMCwgMSk7XFxuICAgIHZlYzIgc2NhbGVkX3NpemVfYSA9IHVfc2NhbGVfYSAqIHVfcGF0dGVybl9zaXplX2E7XFxuICAgIHZlYzIgc2NhbGVkX3NpemVfYiA9IHVfc2NhbGVfYiAqIHVfcGF0dGVybl9zaXplX2I7XFxuXFxuICAgIC8vIHRoZSBjb3JyZWN0IG9mZnNldCBuZWVkcyB0byBiZSBjYWxjdWxhdGVkLlxcbiAgICAvL1xcbiAgICAvLyBUaGUgb2Zmc2V0IGRlcGVuZHMgb24gaG93IG1hbnkgcGl4ZWxzIGFyZSBiZXR3ZWVuIHRoZSB3b3JsZCBvcmlnaW4gYW5kXFxuICAgIC8vIHRoZSBlZGdlIG9mIHRoZSB0aWxlOlxcbiAgICAvLyB2ZWMyIG9mZnNldCA9IG1vZChwaXhlbF9jb29yZCwgc2l6ZSlcXG4gICAgLy9cXG4gICAgLy8gQXQgaGlnaCB6b29tIGxldmVscyB0aGVyZSBhcmUgYSB0b24gb2YgcGl4ZWxzIGJldHdlZW4gdGhlIHdvcmxkIG9yaWdpblxcbiAgICAvLyBhbmQgdGhlIGVkZ2Ugb2YgdGhlIHRpbGUuIFRoZSBnbHNsIHNwZWMgb25seSBndWFyYW50ZWVzIDE2IGJpdHMgb2ZcXG4gICAgLy8gcHJlY2lzaW9uIGZvciBoaWdocCBmbG9hdHMuIFdlIG5lZWQgbW9yZSB0aGFuIHRoYXQuXFxuICAgIC8vXFxuICAgIC8vIFRoZSBwaXhlbF9jb29yZCBpcyBwYXNzZWQgaW4gYXMgdHdvIDE2IGJpdCB2YWx1ZXM6XFxuICAgIC8vIHBpeGVsX2Nvb3JkX3VwcGVyID0gZmxvb3IocGl4ZWxfY29vcmQgLyAyXjE2KVxcbiAgICAvLyBwaXhlbF9jb29yZF9sb3dlciA9IG1vZChwaXhlbF9jb29yZCwgMl4xNilcXG4gICAgLy9cXG4gICAgLy8gVGhlIG9mZnNldCBpcyBjYWxjdWxhdGVkIGluIGEgc2VyaWVzIG9mIHN0ZXBzIHRoYXQgc2hvdWxkIHByZXNlcnZlIHRoaXMgcHJlY2lzaW9uOlxcbiAgICB2ZWMyIG9mZnNldF9hID0gbW9kKG1vZChtb2QodV9waXhlbF9jb29yZF91cHBlciwgc2NhbGVkX3NpemVfYSkgKiAyNTYuMCwgc2NhbGVkX3NpemVfYSkgKiAyNTYuMCArIHVfcGl4ZWxfY29vcmRfbG93ZXIsIHNjYWxlZF9zaXplX2EpO1xcbiAgICB2ZWMyIG9mZnNldF9iID0gbW9kKG1vZChtb2QodV9waXhlbF9jb29yZF91cHBlciwgc2NhbGVkX3NpemVfYikgKiAyNTYuMCwgc2NhbGVkX3NpemVfYikgKiAyNTYuMCArIHVfcGl4ZWxfY29vcmRfbG93ZXIsIHNjYWxlZF9zaXplX2IpO1xcblxcbiAgICB2X3Bvc19hID0gKHVfdGlsZV91bml0c190b19waXhlbHMgKiBhX3BvcyArIG9mZnNldF9hKSAvIHNjYWxlZF9zaXplX2E7XFxuICAgIHZfcG9zX2IgPSAodV90aWxlX3VuaXRzX3RvX3BpeGVscyAqIGFfcG9zICsgb2Zmc2V0X2IpIC8gc2NhbGVkX3NpemVfYjtcXG5cXG4gICAgdl9wb3MgPSAoZ2xfUG9zaXRpb24ueHkgLyBnbF9Qb3NpdGlvbi53ICsgMS4wKSAvIDIuMCAqIHVfd29ybGQ7XFxufVxcblwiXG4gIH0sXG4gIHBhdHRlcm46IHtcbiAgICBmcmFnbWVudFNvdXJjZTogXCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZWxzZVxcbiNkZWZpbmUgbG93cFxcbiNkZWZpbmUgbWVkaXVtcFxcbiNkZWZpbmUgaGlnaHBcXG4jZW5kaWZcXG5cXG51bmlmb3JtIGZsb2F0IHVfb3BhY2l0eTtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX3RsX2E7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl9icl9hO1xcbnVuaWZvcm0gdmVjMiB1X3BhdHRlcm5fdGxfYjtcXG51bmlmb3JtIHZlYzIgdV9wYXR0ZXJuX2JyX2I7XFxudW5pZm9ybSBmbG9hdCB1X21peDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcblxcbnZhcnlpbmcgdmVjMiB2X3Bvc19hO1xcbnZhcnlpbmcgdmVjMiB2X3Bvc19iO1xcblxcbnZvaWQgbWFpbigpIHtcXG5cXG4gICAgdmVjMiBpbWFnZWNvb3JkID0gbW9kKHZfcG9zX2EsIDEuMCk7XFxuICAgIHZlYzIgcG9zID0gbWl4KHVfcGF0dGVybl90bF9hLCB1X3BhdHRlcm5fYnJfYSwgaW1hZ2Vjb29yZCk7XFxuICAgIHZlYzQgY29sb3IxID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHBvcyk7XFxuXFxuICAgIHZlYzIgaW1hZ2Vjb29yZF9iID0gbW9kKHZfcG9zX2IsIDEuMCk7XFxuICAgIHZlYzIgcG9zMiA9IG1peCh1X3BhdHRlcm5fdGxfYiwgdV9wYXR0ZXJuX2JyX2IsIGltYWdlY29vcmRfYik7XFxuICAgIHZlYzQgY29sb3IyID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHBvczIpO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSBtaXgoY29sb3IxLCBjb2xvcjIsIHVfbWl4KSAqIHVfb3BhY2l0eTtcXG5cXG4jaWZkZWYgT1ZFUkRSQVdfSU5TUEVDVE9SXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wKTtcXG4jZW5kaWZcXG59XFxuXCIsXG4gICAgdmVydGV4U291cmNlOiBcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZWxzZVxcbiNkZWZpbmUgbG93cFxcbiNkZWZpbmUgbWVkaXVtcFxcbiNkZWZpbmUgaGlnaHBcXG4jZW5kaWZcXG5cXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl9zaXplX2E7XFxudW5pZm9ybSB2ZWMyIHVfcGF0dGVybl9zaXplX2I7XFxudW5pZm9ybSB2ZWMyIHVfcGl4ZWxfY29vcmRfdXBwZXI7XFxudW5pZm9ybSB2ZWMyIHVfcGl4ZWxfY29vcmRfbG93ZXI7XFxudW5pZm9ybSBmbG9hdCB1X3NjYWxlX2E7XFxudW5pZm9ybSBmbG9hdCB1X3NjYWxlX2I7XFxudW5pZm9ybSBmbG9hdCB1X3RpbGVfdW5pdHNfdG9fcGl4ZWxzO1xcblxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zO1xcblxcbnZhcnlpbmcgdmVjMiB2X3Bvc19hO1xcbnZhcnlpbmcgdmVjMiB2X3Bvc19iO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoYV9wb3MsIDAsIDEpO1xcbiAgICB2ZWMyIHNjYWxlZF9zaXplX2EgPSB1X3NjYWxlX2EgKiB1X3BhdHRlcm5fc2l6ZV9hO1xcbiAgICB2ZWMyIHNjYWxlZF9zaXplX2IgPSB1X3NjYWxlX2IgKiB1X3BhdHRlcm5fc2l6ZV9iO1xcblxcbiAgICAvLyB0aGUgY29ycmVjdCBvZmZzZXQgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZC5cXG4gICAgLy9cXG4gICAgLy8gVGhlIG9mZnNldCBkZXBlbmRzIG9uIGhvdyBtYW55IHBpeGVscyBhcmUgYmV0d2VlbiB0aGUgd29ybGQgb3JpZ2luIGFuZFxcbiAgICAvLyB0aGUgZWRnZSBvZiB0aGUgdGlsZTpcXG4gICAgLy8gdmVjMiBvZmZzZXQgPSBtb2QocGl4ZWxfY29vcmQsIHNpemUpXFxuICAgIC8vXFxuICAgIC8vIEF0IGhpZ2ggem9vbSBsZXZlbHMgdGhlcmUgYXJlIGEgdG9uIG9mIHBpeGVscyBiZXR3ZWVuIHRoZSB3b3JsZCBvcmlnaW5cXG4gICAgLy8gYW5kIHRoZSBlZGdlIG9mIHRoZSB0aWxlLiBUaGUgZ2xzbCBzcGVjIG9ubHkgZ3VhcmFudGVlcyAxNiBiaXRzIG9mXFxuICAgIC8vIHByZWNpc2lvbiBmb3IgaGlnaHAgZmxvYXRzLiBXZSBuZWVkIG1vcmUgdGhhbiB0aGF0LlxcbiAgICAvL1xcbiAgICAvLyBUaGUgcGl4ZWxfY29vcmQgaXMgcGFzc2VkIGluIGFzIHR3byAxNiBiaXQgdmFsdWVzOlxcbiAgICAvLyBwaXhlbF9jb29yZF91cHBlciA9IGZsb29yKHBpeGVsX2Nvb3JkIC8gMl4xNilcXG4gICAgLy8gcGl4ZWxfY29vcmRfbG93ZXIgPSBtb2QocGl4ZWxfY29vcmQsIDJeMTYpXFxuICAgIC8vXFxuICAgIC8vIFRoZSBvZmZzZXQgaXMgY2FsY3VsYXRlZCBpbiBhIHNlcmllcyBvZiBzdGVwcyB0aGF0IHNob3VsZCBwcmVzZXJ2ZSB0aGlzIHByZWNpc2lvbjpcXG4gICAgdmVjMiBvZmZzZXRfYSA9IG1vZChtb2QobW9kKHVfcGl4ZWxfY29vcmRfdXBwZXIsIHNjYWxlZF9zaXplX2EpICogMjU2LjAsIHNjYWxlZF9zaXplX2EpICogMjU2LjAgKyB1X3BpeGVsX2Nvb3JkX2xvd2VyLCBzY2FsZWRfc2l6ZV9hKTtcXG4gICAgdmVjMiBvZmZzZXRfYiA9IG1vZChtb2QobW9kKHVfcGl4ZWxfY29vcmRfdXBwZXIsIHNjYWxlZF9zaXplX2IpICogMjU2LjAsIHNjYWxlZF9zaXplX2IpICogMjU2LjAgKyB1X3BpeGVsX2Nvb3JkX2xvd2VyLCBzY2FsZWRfc2l6ZV9iKTtcXG5cXG4gICAgdl9wb3NfYSA9ICh1X3RpbGVfdW5pdHNfdG9fcGl4ZWxzICogYV9wb3MgKyBvZmZzZXRfYSkgLyBzY2FsZWRfc2l6ZV9hO1xcbiAgICB2X3Bvc19iID0gKHVfdGlsZV91bml0c190b19waXhlbHMgKiBhX3BvcyArIG9mZnNldF9iKSAvIHNjYWxlZF9zaXplX2I7XFxufVxcblwiXG4gIH0sXG4gIHJhc3Rlcjoge1xuICAgIGZyYWdtZW50U291cmNlOiBcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbHNlXFxuI2RlZmluZSBsb3dwXFxuI2RlZmluZSBtZWRpdW1wXFxuI2RlZmluZSBoaWdocFxcbiNlbmRpZlxcblxcbnVuaWZvcm0gZmxvYXQgdV9vcGFjaXR5MDtcXG51bmlmb3JtIGZsb2F0IHVfb3BhY2l0eTE7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTA7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTE7XFxudmFyeWluZyB2ZWMyIHZfcG9zMDtcXG52YXJ5aW5nIHZlYzIgdl9wb3MxO1xcblxcbnVuaWZvcm0gZmxvYXQgdV9icmlnaHRuZXNzX2xvdztcXG51bmlmb3JtIGZsb2F0IHVfYnJpZ2h0bmVzc19oaWdoO1xcblxcbnVuaWZvcm0gZmxvYXQgdV9zYXR1cmF0aW9uX2ZhY3RvcjtcXG51bmlmb3JtIGZsb2F0IHVfY29udHJhc3RfZmFjdG9yO1xcbnVuaWZvcm0gdmVjMyB1X3NwaW5fd2VpZ2h0cztcXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuICAgIC8vIHJlYWQgYW5kIGNyb3NzLWZhZGUgY29sb3JzIGZyb20gdGhlIG1haW4gYW5kIHBhcmVudCB0aWxlc1xcbiAgICB2ZWM0IGNvbG9yMCA9IHRleHR1cmUyRCh1X2ltYWdlMCwgdl9wb3MwKTtcXG4gICAgdmVjNCBjb2xvcjEgPSB0ZXh0dXJlMkQodV9pbWFnZTEsIHZfcG9zMSk7XFxuICAgIHZlYzQgY29sb3IgPSBjb2xvcjAgKiB1X29wYWNpdHkwICsgY29sb3IxICogdV9vcGFjaXR5MTtcXG4gICAgdmVjMyByZ2IgPSBjb2xvci5yZ2I7XFxuXFxuICAgIC8vIHNwaW5cXG4gICAgcmdiID0gdmVjMyhcXG4gICAgICAgIGRvdChyZ2IsIHVfc3Bpbl93ZWlnaHRzLnh5eiksXFxuICAgICAgICBkb3QocmdiLCB1X3NwaW5fd2VpZ2h0cy56eHkpLFxcbiAgICAgICAgZG90KHJnYiwgdV9zcGluX3dlaWdodHMueXp4KSk7XFxuXFxuICAgIC8vIHNhdHVyYXRpb25cXG4gICAgZmxvYXQgYXZlcmFnZSA9IChjb2xvci5yICsgY29sb3IuZyArIGNvbG9yLmIpIC8gMy4wO1xcbiAgICByZ2IgKz0gKGF2ZXJhZ2UgLSByZ2IpICogdV9zYXR1cmF0aW9uX2ZhY3RvcjtcXG5cXG4gICAgLy8gY29udHJhc3RcXG4gICAgcmdiID0gKHJnYiAtIDAuNSkgKiB1X2NvbnRyYXN0X2ZhY3RvciArIDAuNTtcXG5cXG4gICAgLy8gYnJpZ2h0bmVzc1xcbiAgICB2ZWMzIHVfaGlnaF92ZWMgPSB2ZWMzKHVfYnJpZ2h0bmVzc19sb3csIHVfYnJpZ2h0bmVzc19sb3csIHVfYnJpZ2h0bmVzc19sb3cpO1xcbiAgICB2ZWMzIHVfbG93X3ZlYyA9IHZlYzModV9icmlnaHRuZXNzX2hpZ2gsIHVfYnJpZ2h0bmVzc19oaWdoLCB1X2JyaWdodG5lc3NfaGlnaCk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQobWl4KHVfaGlnaF92ZWMsIHVfbG93X3ZlYywgcmdiKSwgY29sb3IuYSk7XFxuXFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVxcblwiLFxuICAgIHZlcnRleFNvdXJjZTogXCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2Vsc2VcXG4jZGVmaW5lIGxvd3BcXG4jZGVmaW5lIG1lZGl1bXBcXG4jZGVmaW5lIGhpZ2hwXFxuI2VuZGlmXFxuXFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcbnVuaWZvcm0gdmVjMiB1X3RsX3BhcmVudDtcXG51bmlmb3JtIGZsb2F0IHVfc2NhbGVfcGFyZW50O1xcbnVuaWZvcm0gZmxvYXQgdV9idWZmZXJfc2NhbGU7XFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzIgYV90ZXh0dXJlX3BvcztcXG5cXG52YXJ5aW5nIHZlYzIgdl9wb3MwO1xcbnZhcnlpbmcgdmVjMiB2X3BvczE7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3BvcywgMCwgMSk7XFxuICAgIHZfcG9zMCA9ICgoKGFfdGV4dHVyZV9wb3MgLyAzMjc2Ny4wKSAtIDAuNSkgLyB1X2J1ZmZlcl9zY2FsZSApICsgMC41O1xcbiAgICB2X3BvczEgPSAodl9wb3MwICogdV9zY2FsZV9wYXJlbnQpICsgdV90bF9wYXJlbnQ7XFxufVxcblwiXG4gIH0sXG4gIGljb246IHtcbiAgICBmcmFnbWVudFNvdXJjZTogXCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZWxzZVxcbiNkZWZpbmUgbG93cFxcbiNkZWZpbmUgbWVkaXVtcFxcbiNkZWZpbmUgaGlnaHBcXG4jZW5kaWZcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9mYWRldGV4dHVyZTtcXG51bmlmb3JtIGxvd3AgZmxvYXQgdV9vcGFjaXR5O1xcblxcbnZhcnlpbmcgdmVjMiB2X3RleDtcXG52YXJ5aW5nIHZlYzIgdl9mYWRlX3RleDtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGxvd3AgZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodV9mYWRldGV4dHVyZSwgdl9mYWRlX3RleCkuYSAqIHVfb3BhY2l0eTtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl90ZXgpICogYWxwaGE7XFxuXFxuI2lmZGVmIE9WRVJEUkFXX0lOU1BFQ1RPUlxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCk7XFxuI2VuZGlmXFxufVxcblwiLFxuICAgIHZlcnRleFNvdXJjZTogXCIjaWZkZWYgR0xfRVNcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2Vsc2VcXG4jZGVmaW5lIGxvd3BcXG4jZGVmaW5lIG1lZGl1bXBcXG4jZGVmaW5lIGhpZ2hwXFxuI2VuZGlmXFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzIgYV9vZmZzZXQ7XFxuYXR0cmlidXRlIHZlYzIgYV90ZXh0dXJlX3BvcztcXG5hdHRyaWJ1dGUgdmVjNCBhX2RhdGE7XFxuXFxuXFxuLy8gbWF0cml4IGlzIGZvciB0aGUgdmVydGV4IHBvc2l0aW9uLlxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG5cXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV96b29tO1xcbnVuaWZvcm0gYm9vbCB1X3JvdGF0ZV93aXRoX21hcDtcXG51bmlmb3JtIHZlYzIgdV9leHRydWRlX3NjYWxlO1xcblxcbnVuaWZvcm0gdmVjMiB1X3RleHNpemU7XFxuXFxudmFyeWluZyB2ZWMyIHZfdGV4O1xcbnZhcnlpbmcgdmVjMiB2X2ZhZGVfdGV4O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjMiBhX3RleCA9IGFfdGV4dHVyZV9wb3MueHk7XFxuICAgIG1lZGl1bXAgZmxvYXQgYV9sYWJlbG1pbnpvb20gPSBhX2RhdGFbMF07XFxuICAgIG1lZGl1bXAgdmVjMiBhX3pvb20gPSBhX2RhdGEucHE7XFxuICAgIG1lZGl1bXAgZmxvYXQgYV9taW56b29tID0gYV96b29tWzBdO1xcbiAgICBtZWRpdW1wIGZsb2F0IGFfbWF4em9vbSA9IGFfem9vbVsxXTtcXG5cXG4gICAgLy8gdV96b29tIGlzIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgYWRqdXN0ZWQgZm9yIHRoZSBjaGFuZ2UgaW4gZm9udCBzaXplXFxuICAgIG1lZGl1bXAgZmxvYXQgeiA9IDIuMCAtIHN0ZXAoYV9taW56b29tLCB1X3pvb20pIC0gKDEuMCAtIHN0ZXAoYV9tYXh6b29tLCB1X3pvb20pKTtcXG5cXG4gICAgdmVjMiBleHRydWRlID0gdV9leHRydWRlX3NjYWxlICogKGFfb2Zmc2V0IC8gNjQuMCk7XFxuICAgIGlmICh1X3JvdGF0ZV93aXRoX21hcCkge1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoYV9wb3MgKyBleHRydWRlLCAwLCAxKTtcXG4gICAgICAgIGdsX1Bvc2l0aW9uLnogKz0geiAqIGdsX1Bvc2l0aW9uLnc7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3BvcywgMCwgMSkgKyB2ZWM0KGV4dHJ1ZGUsIDAsIDApO1xcbiAgICB9XFxuXFxuICAgIHZfdGV4ID0gYV90ZXggLyB1X3RleHNpemU7XFxuICAgIHZfZmFkZV90ZXggPSB2ZWMyKGFfbGFiZWxtaW56b29tIC8gMjU1LjAsIDAuMCk7XFxufVxcblwiXG4gIH0sXG4gIHNkZjoge1xuICAgIGZyYWdtZW50U291cmNlOiBcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNlbHNlXFxuI2RlZmluZSBsb3dwXFxuI2RlZmluZSBtZWRpdW1wXFxuI2RlZmluZSBoaWdocFxcbiNlbmRpZlxcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ZhZGV0ZXh0dXJlO1xcbnVuaWZvcm0gbG93cCB2ZWM0IHVfY29sb3I7XFxudW5pZm9ybSBsb3dwIGZsb2F0IHVfb3BhY2l0eTtcXG51bmlmb3JtIGxvd3AgZmxvYXQgdV9idWZmZXI7XFxudW5pZm9ybSBsb3dwIGZsb2F0IHVfZ2FtbWE7XFxuXFxudmFyeWluZyB2ZWMyIHZfdGV4O1xcbnZhcnlpbmcgdmVjMiB2X2ZhZGVfdGV4O1xcbnZhcnlpbmcgZmxvYXQgdl9nYW1tYV9zY2FsZTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGxvd3AgZmxvYXQgZGlzdCA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHZfdGV4KS5hO1xcbiAgICBsb3dwIGZsb2F0IGZhZGVfYWxwaGEgPSB0ZXh0dXJlMkQodV9mYWRldGV4dHVyZSwgdl9mYWRlX3RleCkuYTtcXG4gICAgbG93cCBmbG9hdCBnYW1tYSA9IHVfZ2FtbWEgKiB2X2dhbW1hX3NjYWxlO1xcbiAgICBsb3dwIGZsb2F0IGFscGhhID0gc21vb3Roc3RlcCh1X2J1ZmZlciAtIGdhbW1hLCB1X2J1ZmZlciArIGdhbW1hLCBkaXN0KSAqIGZhZGVfYWxwaGE7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHVfY29sb3IgKiAoYWxwaGEgKiB1X29wYWNpdHkpO1xcblxcbiNpZmRlZiBPVkVSRFJBV19JTlNQRUNUT1JcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjApO1xcbiNlbmRpZlxcbn1cXG5cIixcbiAgICB2ZXJ0ZXhTb3VyY2U6IFwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNlbHNlXFxuI2RlZmluZSBsb3dwXFxuI2RlZmluZSBtZWRpdW1wXFxuI2RlZmluZSBoaWdocFxcbiNlbmRpZlxcblxcbmNvbnN0IGZsb2F0IFBJID0gMy4xNDE1OTI2NTM1ODk3OTM7XFxuXFxuYXR0cmlidXRlIHZlYzIgYV9wb3M7XFxuYXR0cmlidXRlIHZlYzIgYV9vZmZzZXQ7XFxuYXR0cmlidXRlIHZlYzIgYV90ZXh0dXJlX3BvcztcXG5hdHRyaWJ1dGUgdmVjNCBhX2RhdGE7XFxuXFxuXFxuLy8gbWF0cml4IGlzIGZvciB0aGUgdmVydGV4IHBvc2l0aW9uLlxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG5cXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV96b29tO1xcbnVuaWZvcm0gYm9vbCB1X3JvdGF0ZV93aXRoX21hcDtcXG51bmlmb3JtIGJvb2wgdV9waXRjaF93aXRoX21hcDtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9waXRjaDtcXG51bmlmb3JtIG1lZGl1bXAgZmxvYXQgdV9iZWFyaW5nO1xcbnVuaWZvcm0gbWVkaXVtcCBmbG9hdCB1X2FzcGVjdF9yYXRpbztcXG51bmlmb3JtIHZlYzIgdV9leHRydWRlX3NjYWxlO1xcblxcbnVuaWZvcm0gdmVjMiB1X3RleHNpemU7XFxuXFxudmFyeWluZyB2ZWMyIHZfdGV4O1xcbnZhcnlpbmcgdmVjMiB2X2ZhZGVfdGV4O1xcbnZhcnlpbmcgZmxvYXQgdl9nYW1tYV9zY2FsZTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZlYzIgYV90ZXggPSBhX3RleHR1cmVfcG9zLnh5O1xcbiAgICBtZWRpdW1wIGZsb2F0IGFfbGFiZWxtaW56b29tID0gYV9kYXRhWzBdO1xcbiAgICBtZWRpdW1wIHZlYzIgYV96b29tID0gYV9kYXRhLnBxO1xcbiAgICBtZWRpdW1wIGZsb2F0IGFfbWluem9vbSA9IGFfem9vbVswXTtcXG4gICAgbWVkaXVtcCBmbG9hdCBhX21heHpvb20gPSBhX3pvb21bMV07XFxuXFxuICAgIC8vIHVfem9vbSBpcyB0aGUgY3VycmVudCB6b29tIGxldmVsIGFkanVzdGVkIGZvciB0aGUgY2hhbmdlIGluIGZvbnQgc2l6ZVxcbiAgICBtZWRpdW1wIGZsb2F0IHogPSAyLjAgLSBzdGVwKGFfbWluem9vbSwgdV96b29tKSAtICgxLjAgLSBzdGVwKGFfbWF4em9vbSwgdV96b29tKSk7XFxuXFxuICAgIC8vIHBpdGNoLWFsaWdubWVudDogbWFwXFxuICAgIC8vIHJvdGF0aW9uLWFsaWdubWVudDogbWFwIHwgdmlld3BvcnRcXG4gICAgaWYgKHVfcGl0Y2hfd2l0aF9tYXApIHtcXG4gICAgICAgIGxvd3AgZmxvYXQgYW5nbGUgPSB1X3JvdGF0ZV93aXRoX21hcCA/IChhX2RhdGFbMV0gLyAyNTYuMCAqIDIuMCAqIFBJKSA6IHVfYmVhcmluZztcXG4gICAgICAgIGxvd3AgZmxvYXQgYXNpbiA9IHNpbihhbmdsZSk7XFxuICAgICAgICBsb3dwIGZsb2F0IGFjb3MgPSBjb3MoYW5nbGUpO1xcbiAgICAgICAgbWF0MiBSb3RhdGlvbk1hdHJpeCA9IG1hdDIoYWNvcywgYXNpbiwgLTEuMCAqIGFzaW4sIGFjb3MpO1xcbiAgICAgICAgdmVjMiBvZmZzZXQgPSBSb3RhdGlvbk1hdHJpeCAqIGFfb2Zmc2V0O1xcbiAgICAgICAgdmVjMiBleHRydWRlID0gdV9leHRydWRlX3NjYWxlICogKG9mZnNldCAvIDY0LjApO1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIHZlYzQoYV9wb3MgKyBleHRydWRlLCAwLCAxKTtcXG4gICAgICAgIGdsX1Bvc2l0aW9uLnogKz0geiAqIGdsX1Bvc2l0aW9uLnc7XFxuICAgIC8vIHBpdGNoLWFsaWdubWVudDogdmlld3BvcnRcXG4gICAgLy8gcm90YXRpb24tYWxpZ25tZW50OiBtYXBcXG4gICAgfSBlbHNlIGlmICh1X3JvdGF0ZV93aXRoX21hcCkge1xcbiAgICAgICAgLy8gZm9yZXNob3J0ZW5pbmcgZmFjdG9yIHRvIGFwcGx5IG9uIHBpdGNoZWQgbWFwc1xcbiAgICAgICAgLy8gYXMgYSBsYWJlbCBnb2VzIGZyb20gaG9yaXpvbnRhbCA8PT4gdmVydGljYWwgaW4gYW5nbGVcXG4gICAgICAgIC8vIGl0IGdvZXMgZnJvbSAwJSBmb3Jlc2hvcnRlbmluZyB0byB1cCB0byBhcm91bmQgNzAlIGZvcmVzaG9ydGVuaW5nXFxuICAgICAgICBsb3dwIGZsb2F0IHBpdGNoZmFjdG9yID0gMS4wIC0gY29zKHVfcGl0Y2ggKiBzaW4odV9waXRjaCAqIDAuNzUpKTtcXG5cXG4gICAgICAgIGxvd3AgZmxvYXQgbGluZWFuZ2xlID0gYV9kYXRhWzFdIC8gMjU2LjAgKiAyLjAgKiBQSTtcXG5cXG4gICAgICAgIC8vIHVzZSB0aGUgbGluZWFuZ2xlIHRvIHBvc2l0aW9uIHBvaW50cyBhLGIgYWxvbmcgdGhlIGxpbmVcXG4gICAgICAgIC8vIHByb2plY3QgdGhlIHBvaW50cyBhbmQgY2FsY3VsYXRlIHRoZSBsYWJlbCBhbmdsZSBpbiBwcm9qZWN0ZWQgc3BhY2VcXG4gICAgICAgIC8vIHRoaXMgY2FsY3VsYXRpb24gYWxsb3dzIGxhYmVscyB0byBiZSByZW5kZXJlZCB1bnNrZXdlZCBvbiBwaXRjaGVkIG1hcHNcXG4gICAgICAgIHZlYzQgYSA9IHVfbWF0cml4ICogdmVjNChhX3BvcywgMCwgMSk7XFxuICAgICAgICB2ZWM0IGIgPSB1X21hdHJpeCAqIHZlYzQoYV9wb3MgKyB2ZWMyKGNvcyhsaW5lYW5nbGUpLHNpbihsaW5lYW5nbGUpKSwgMCwgMSk7XFxuICAgICAgICBsb3dwIGZsb2F0IGFuZ2xlID0gYXRhbigoYlsxXS9iWzNdIC0gYVsxXS9hWzNdKS91X2FzcGVjdF9yYXRpbywgYlswXS9iWzNdIC0gYVswXS9hWzNdKTtcXG4gICAgICAgIGxvd3AgZmxvYXQgYXNpbiA9IHNpbihhbmdsZSk7XFxuICAgICAgICBsb3dwIGZsb2F0IGFjb3MgPSBjb3MoYW5nbGUpO1xcbiAgICAgICAgbWF0MiBSb3RhdGlvbk1hdHJpeCA9IG1hdDIoYWNvcywgLTEuMCAqIGFzaW4sIGFzaW4sIGFjb3MpO1xcblxcbiAgICAgICAgdmVjMiBvZmZzZXQgPSBSb3RhdGlvbk1hdHJpeCAqICh2ZWMyKCgxLjAtcGl0Y2hmYWN0b3IpKyhwaXRjaGZhY3Rvcipjb3MoYW5nbGUqMi4wKSksIDEuMCkgKiBhX29mZnNldCk7XFxuICAgICAgICB2ZWMyIGV4dHJ1ZGUgPSB1X2V4dHJ1ZGVfc2NhbGUgKiAob2Zmc2V0IC8gNjQuMCk7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogdmVjNChhX3BvcywgMCwgMSkgKyB2ZWM0KGV4dHJ1ZGUsIDAsIDApO1xcbiAgICAgICAgZ2xfUG9zaXRpb24ueiArPSB6ICogZ2xfUG9zaXRpb24udztcXG4gICAgLy8gcGl0Y2gtYWxpZ25tZW50OiB2aWV3cG9ydFxcbiAgICAvLyByb3RhdGlvbi1hbGlnbm1lbnQ6IHZpZXdwb3J0XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICB2ZWMyIGV4dHJ1ZGUgPSB1X2V4dHJ1ZGVfc2NhbGUgKiAoYV9vZmZzZXQgLyA2NC4wKTtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiB2ZWM0KGFfcG9zLCAwLCAxKSArIHZlYzQoZXh0cnVkZSwgMCwgMCk7XFxuICAgIH1cXG5cXG4gICAgdl9nYW1tYV9zY2FsZSA9IChnbF9Qb3NpdGlvbi53IC0gMC41KTtcXG5cXG4gICAgdl90ZXggPSBhX3RleCAvIHVfdGV4c2l6ZTtcXG4gICAgdl9mYWRlX3RleCA9IHZlYzIoYV9sYWJlbG1pbnpvb20gLyAyNTUuMCwgMC4wKTtcXG59XFxuXCJcbiAgfSxcbiAgY29sbGlzaW9uYm94OiB7XG4gICAgZnJhZ21lbnRTb3VyY2U6IFwiI2lmZGVmIEdMX0VTXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2Vsc2VcXG4jZGVmaW5lIGxvd3BcXG4jZGVmaW5lIG1lZGl1bXBcXG4jZGVmaW5lIGhpZ2hwXFxuI2VuZGlmXFxuXFxudW5pZm9ybSBmbG9hdCB1X3pvb207XFxudW5pZm9ybSBmbG9hdCB1X21heHpvb207XFxuXFxudmFyeWluZyBmbG9hdCB2X21heF96b29tO1xcbnZhcnlpbmcgZmxvYXQgdl9wbGFjZW1lbnRfem9vbTtcXG5cXG52b2lkIG1haW4oKSB7XFxuXFxuICAgIGZsb2F0IGFscGhhID0gMC41O1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMS4wLCAwLjAsIDEuMCkgKiBhbHBoYTtcXG5cXG4gICAgaWYgKHZfcGxhY2VtZW50X3pvb20gPiB1X3pvb20pIHtcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgMS4wKSAqIGFscGhhO1xcbiAgICB9XFxuXFxuICAgIGlmICh1X3pvb20gPj0gdl9tYXhfem9vbSkge1xcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApICogYWxwaGEgKiAwLjI1O1xcbiAgICB9XFxuXFxuICAgIGlmICh2X3BsYWNlbWVudF96b29tID49IHVfbWF4em9vbSkge1xcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMS4wLCAxLjApICogYWxwaGEgKiAwLjI7XFxuICAgIH1cXG59XFxuXCIsXG4gICAgdmVydGV4U291cmNlOiBcIiNpZmRlZiBHTF9FU1xcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZWxzZVxcbiNkZWZpbmUgbG93cFxcbiNkZWZpbmUgbWVkaXVtcFxcbiNkZWZpbmUgaGlnaHBcXG4jZW5kaWZcXG5cXG5hdHRyaWJ1dGUgdmVjMiBhX3BvcztcXG5hdHRyaWJ1dGUgdmVjMiBhX2V4dHJ1ZGU7XFxuYXR0cmlidXRlIHZlYzIgYV9kYXRhO1xcblxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfc2NhbGU7XFxuXFxudmFyeWluZyBmbG9hdCB2X21heF96b29tO1xcbnZhcnlpbmcgZmxvYXQgdl9wbGFjZW1lbnRfem9vbTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiB2ZWM0KGFfcG9zICsgYV9leHRydWRlIC8gdV9zY2FsZSwgMC4wLCAxLjApO1xcblxcbiAgICB2X21heF96b29tID0gYV9kYXRhLng7XFxuICAgIHZfcGxhY2VtZW50X3pvb20gPSBhX2RhdGEueTtcXG59XFxuXCJcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMudXRpbCA9IFwiZmxvYXQgZXZhbHVhdGVfem9vbV9mdW5jdGlvbl8xKGNvbnN0IHZlYzQgdmFsdWVzLCBjb25zdCBmbG9hdCB0KSB7XFxuICAgIGlmICh0IDwgMS4wKSB7XFxuICAgICAgICByZXR1cm4gbWl4KHZhbHVlc1swXSwgdmFsdWVzWzFdLCB0KTtcXG4gICAgfSBlbHNlIGlmICh0IDwgMi4wKSB7XFxuICAgICAgICByZXR1cm4gbWl4KHZhbHVlc1sxXSwgdmFsdWVzWzJdLCB0IC0gMS4wKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBtaXgodmFsdWVzWzJdLCB2YWx1ZXNbM10sIHQgLSAyLjApO1xcbiAgICB9XFxufVxcbnZlYzQgZXZhbHVhdGVfem9vbV9mdW5jdGlvbl80KGNvbnN0IHZlYzQgdmFsdWUwLCBjb25zdCB2ZWM0IHZhbHVlMSwgY29uc3QgdmVjNCB2YWx1ZTIsIGNvbnN0IHZlYzQgdmFsdWUzLCBjb25zdCBmbG9hdCB0KSB7XFxuICAgIGlmICh0IDwgMS4wKSB7XFxuICAgICAgICByZXR1cm4gbWl4KHZhbHVlMCwgdmFsdWUxLCB0KTtcXG4gICAgfSBlbHNlIGlmICh0IDwgMi4wKSB7XFxuICAgICAgICByZXR1cm4gbWl4KHZhbHVlMSwgdmFsdWUyLCB0IC0gMS4wKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBtaXgodmFsdWUyLCB2YWx1ZTMsIHQgLSAyLjApO1xcbiAgICB9XFxufVxcblwiO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9ybWF0ID0gcmVxdWlyZSgndXRpbCcpLmZvcm1hdDtcblxuZnVuY3Rpb24gVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUgLyosIG1lc3NhZ2UsIC4uLiovKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gKFxuICAgICAgICAoa2V5ID8ga2V5ICsgJzogJyA6ICcnKSArXG4gICAgICAgIGZvcm1hdC5hcHBseShmb3JtYXQsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpXG4gICAgKTtcblxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLl9fbGluZV9fKSB7XG4gICAgICAgIHRoaXMubGluZSA9IHZhbHVlLl9fbGluZV9fO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWYWxpZGF0aW9uRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG91dHB1dCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBpbnB1dCkge1xuICAgICAgICAgICAgb3V0cHV0W2tdID0gaW5wdXRba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0VHlwZSh2YWwpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgICAgIHJldHVybiAnYm9vbGVhbic7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbDtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUdXJuIGpzb25saW50LWxpbmVzLXByaW1pdGl2ZXMgb2JqZWN0cyBpbnRvIHByaW1pdGl2ZSBvYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHVuYnVuZGxlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nIHx8IHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgICByZXR1cm4gdmFsdWUudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xudmFyIGdldFR5cGUgPSByZXF1aXJlKCcuLi91dGlsL2dldF90eXBlJyk7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi4vdXRpbC9leHRlbmQnKTtcblxuLy8gTWFpbiByZWN1cnNpdmUgdmFsaWRhdGlvbiBmdW5jdGlvbi4gVHJhY2tzOlxuLy9cbi8vIC0ga2V5OiBzdHJpbmcgcmVwcmVzZW50aW5nIGxvY2F0aW9uIG9mIHZhbGlkYXRpb24gaW4gc3R5bGUgdHJlZS4gVXNlZCBvbmx5XG4vLyAgIGZvciBtb3JlIGluZm9ybWF0aXZlIGVycm9yIHJlcG9ydGluZy5cbi8vIC0gdmFsdWU6IGN1cnJlbnQgdmFsdWUgZnJvbSBzdHlsZSBiZWluZyBldmFsdWF0ZWQuIE1heSBiZSBhbnl0aGluZyBmcm9tIGFcbi8vICAgaGlnaCBsZXZlbCBvYmplY3QgdGhhdCBuZWVkcyB0byBiZSBkZXNjZW5kZWQgaW50byBkZWVwZXIgb3IgYSBzaW1wbGVcbi8vICAgc2NhbGFyIHZhbHVlLlxuLy8gLSB2YWx1ZVNwZWM6IGN1cnJlbnQgc3BlYyBiZWluZyBldmFsdWF0ZWQuIFRyYWNrcyB2YWx1ZS5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZShvcHRpb25zKSB7XG5cbiAgICB2YXIgdmFsaWRhdGVGdW5jdGlvbiA9IHJlcXVpcmUoJy4vdmFsaWRhdGVfZnVuY3Rpb24nKTtcbiAgICB2YXIgdmFsaWRhdGVPYmplY3QgPSByZXF1aXJlKCcuL3ZhbGlkYXRlX29iamVjdCcpO1xuICAgIHZhciBWQUxJREFUT1JTID0ge1xuICAgICAgICAnKic6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9LFxuICAgICAgICAnYXJyYXknOiByZXF1aXJlKCcuL3ZhbGlkYXRlX2FycmF5JyksXG4gICAgICAgICdib29sZWFuJzogcmVxdWlyZSgnLi92YWxpZGF0ZV9ib29sZWFuJyksXG4gICAgICAgICdudW1iZXInOiByZXF1aXJlKCcuL3ZhbGlkYXRlX251bWJlcicpLFxuICAgICAgICAnY29sb3InOiByZXF1aXJlKCcuL3ZhbGlkYXRlX2NvbG9yJyksXG4gICAgICAgICdjb25zdGFudHMnOiByZXF1aXJlKCcuL3ZhbGlkYXRlX2NvbnN0YW50cycpLFxuICAgICAgICAnZW51bSc6IHJlcXVpcmUoJy4vdmFsaWRhdGVfZW51bScpLFxuICAgICAgICAnZmlsdGVyJzogcmVxdWlyZSgnLi92YWxpZGF0ZV9maWx0ZXInKSxcbiAgICAgICAgJ2Z1bmN0aW9uJzogcmVxdWlyZSgnLi92YWxpZGF0ZV9mdW5jdGlvbicpLFxuICAgICAgICAnbGF5ZXInOiByZXF1aXJlKCcuL3ZhbGlkYXRlX2xheWVyJyksXG4gICAgICAgICdvYmplY3QnOiByZXF1aXJlKCcuL3ZhbGlkYXRlX29iamVjdCcpLFxuICAgICAgICAnc291cmNlJzogcmVxdWlyZSgnLi92YWxpZGF0ZV9zb3VyY2UnKSxcbiAgICAgICAgJ3N0cmluZyc6IHJlcXVpcmUoJy4vdmFsaWRhdGVfc3RyaW5nJylcbiAgICB9O1xuXG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIgdmFsdWVTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWM7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuXG4gICAgaWYgKGdldFR5cGUodmFsdWUpID09PSAnc3RyaW5nJyAmJiB2YWx1ZVswXSA9PT0gJ0AnKSB7XG4gICAgICAgIGlmIChzdHlsZVNwZWMuJHZlcnNpb24gPiA3KSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2NvbnN0YW50cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2OCcpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISh2YWx1ZSBpbiBzdHlsZS5jb25zdGFudHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2NvbnN0YW50IFwiJXNcIiBub3QgZm91bmQnLCB2YWx1ZSldO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMsIHsgdmFsdWU6IHN0eWxlLmNvbnN0YW50c1t2YWx1ZV0gfSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlU3BlYy5mdW5jdGlvbiAmJiBnZXRUeXBlKHZhbHVlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlRnVuY3Rpb24ob3B0aW9ucyk7XG5cbiAgICB9IGVsc2UgaWYgKHZhbHVlU3BlYy50eXBlICYmIFZBTElEQVRPUlNbdmFsdWVTcGVjLnR5cGVdKSB7XG4gICAgICAgIHJldHVybiBWQUxJREFUT1JTW3ZhbHVlU3BlYy50eXBlXShvcHRpb25zKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdChleHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIHZhbHVlU3BlYzogdmFsdWVTcGVjLnR5cGUgPyBzdHlsZVNwZWNbdmFsdWVTcGVjLnR5cGVdIDogdmFsdWVTcGVjXG4gICAgICAgIH0pKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0VHlwZSA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0X3R5cGUnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vdmFsaWRhdGUnKTtcbnZhciBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGVBcnJheShvcHRpb25zKSB7XG4gICAgdmFyIGFycmF5ID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIgYXJyYXlTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWM7XG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciB2YWxpZGF0ZUFycmF5RWxlbWVudCA9IG9wdGlvbnMuYXJyYXlFbGVtZW50VmFsaWRhdG9yIHx8IHZhbGlkYXRlO1xuXG4gICAgaWYgKGdldFR5cGUoYXJyYXkpICE9PSAnYXJyYXknKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGFycmF5LCAnYXJyYXkgZXhwZWN0ZWQsICVzIGZvdW5kJywgZ2V0VHlwZShhcnJheSkpXTtcbiAgICB9XG5cbiAgICBpZiAoYXJyYXlTcGVjLmxlbmd0aCAmJiBhcnJheS5sZW5ndGggIT09IGFycmF5U3BlYy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgYXJyYXksICdhcnJheSBsZW5ndGggJWQgZXhwZWN0ZWQsIGxlbmd0aCAlZCBmb3VuZCcsIGFycmF5U3BlYy5sZW5ndGgsIGFycmF5Lmxlbmd0aCldO1xuICAgIH1cblxuICAgIGlmIChhcnJheVNwZWNbJ21pbi1sZW5ndGgnXSAmJiBhcnJheS5sZW5ndGggPCBhcnJheVNwZWNbJ21pbi1sZW5ndGgnXSkge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBhcnJheSwgJ2FycmF5IGxlbmd0aCBhdCBsZWFzdCAlZCBleHBlY3RlZCwgbGVuZ3RoICVkIGZvdW5kJywgYXJyYXlTcGVjWydtaW4tbGVuZ3RoJ10sIGFycmF5Lmxlbmd0aCldO1xuICAgIH1cblxuICAgIHZhciBhcnJheUVsZW1lbnRTcGVjID0ge1xuICAgICAgICBcInR5cGVcIjogYXJyYXlTcGVjLnZhbHVlXG4gICAgfTtcblxuICAgIGlmIChzdHlsZVNwZWMuJHZlcnNpb24gPCA3KSB7XG4gICAgICAgIGFycmF5RWxlbWVudFNwZWMuZnVuY3Rpb24gPSBhcnJheVNwZWMuZnVuY3Rpb247XG4gICAgfVxuXG4gICAgaWYgKGdldFR5cGUoYXJyYXlTcGVjLnZhbHVlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYXJyYXlFbGVtZW50U3BlYyA9IGFycmF5U3BlYy52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlQXJyYXlFbGVtZW50KHtcbiAgICAgICAgICAgIGFycmF5OiBhcnJheSxcbiAgICAgICAgICAgIGFycmF5SW5kZXg6IGksXG4gICAgICAgICAgICB2YWx1ZTogYXJyYXlbaV0sXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IGFycmF5RWxlbWVudFNwZWMsXG4gICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlYyxcbiAgICAgICAgICAgIGtleToga2V5ICsgJ1snICsgaSArICddJ1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0VHlwZSA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0X3R5cGUnKTtcbnZhciBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGVCb29sZWFuKG9wdGlvbnMpIHtcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgdHlwZSA9IGdldFR5cGUodmFsdWUpO1xuXG4gICAgaWYgKHR5cGUgIT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2Jvb2xlYW4gZXhwZWN0ZWQsICVzIGZvdW5kJywgdHlwZSldO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG52YXIgZ2V0VHlwZSA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0X3R5cGUnKTtcbnZhciBwYXJzZUNTU0NvbG9yID0gcmVxdWlyZSgnY3NzY29sb3JwYXJzZXInKS5wYXJzZUNTU0NvbG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlQ29sb3Iob3B0aW9ucykge1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciB0eXBlID0gZ2V0VHlwZSh2YWx1ZSk7XG5cbiAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdjb2xvciBleHBlY3RlZCwgJXMgZm91bmQnLCB0eXBlKV07XG4gICAgfVxuXG4gICAgaWYgKHBhcnNlQ1NTQ29sb3IodmFsdWUpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnY29sb3IgZXhwZWN0ZWQsIFwiJXNcIiBmb3VuZCcsIHZhbHVlKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL3ZhbGlkYXRpb25fZXJyb3InKTtcbnZhciBnZXRUeXBlID0gcmVxdWlyZSgnLi4vdXRpbC9nZXRfdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlQ29uc3RhbnRzKG9wdGlvbnMpIHtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIGNvbnN0YW50cyA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuXG4gICAgaWYgKHN0eWxlU3BlYy4kdmVyc2lvbiA+IDcpIHtcbiAgICAgICAgaWYgKGNvbnN0YW50cykge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgY29uc3RhbnRzLCAnY29uc3RhbnRzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFzIG9mIHY4JyldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRUeXBlKGNvbnN0YW50cyk7XG4gICAgICAgIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgY29uc3RhbnRzLCAnb2JqZWN0IGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgY29uc3RhbnROYW1lIGluIGNvbnN0YW50cykge1xuICAgICAgICAgICAgaWYgKGNvbnN0YW50TmFtZVswXSAhPT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXkgKyAnLicgKyBjb25zdGFudE5hbWUsIGNvbnN0YW50c1tjb25zdGFudE5hbWVdLCAnY29uc3RhbnRzIG11c3Qgc3RhcnQgd2l0aCBcIkBcIicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH1cblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL3ZhbGlkYXRpb25fZXJyb3InKTtcbnZhciB1bmJ1bmRsZSA9IHJlcXVpcmUoJy4uL3V0aWwvdW5idW5kbGVfanNvbmxpbnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZUVudW0ob3B0aW9ucykge1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciB2YWx1ZVNwZWMgPSBvcHRpb25zLnZhbHVlU3BlYztcbiAgICB2YXIgZXJyb3JzID0gW107XG5cbiAgICBpZiAodmFsdWVTcGVjLnZhbHVlcy5pbmRleE9mKHVuYnVuZGxlKHZhbHVlKSkgPT09IC0xKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2V4cGVjdGVkIG9uZSBvZiBbJXNdLCAlcyBmb3VuZCcsIHZhbHVlU3BlYy52YWx1ZXMuam9pbignLCAnKSwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG52YXIgdmFsaWRhdGVFbnVtID0gcmVxdWlyZSgnLi92YWxpZGF0ZV9lbnVtJyk7XG52YXIgZ2V0VHlwZSA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0X3R5cGUnKTtcbnZhciB1bmJ1bmRsZSA9IHJlcXVpcmUoJy4uL3V0aWwvdW5idW5kbGVfanNvbmxpbnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZUZpbHRlcihvcHRpb25zKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIHZhciB0eXBlO1xuXG4gICAgdmFyIGVycm9ycyA9IFtdO1xuXG4gICAgaWYgKGdldFR5cGUodmFsdWUpICE9PSAnYXJyYXknKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnYXJyYXkgZXhwZWN0ZWQsICVzIGZvdW5kJywgZ2V0VHlwZSh2YWx1ZSkpXTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUubGVuZ3RoIDwgMSkge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2ZpbHRlciBhcnJheSBtdXN0IGhhdmUgYXQgbGVhc3QgMSBlbGVtZW50JyldO1xuICAgIH1cblxuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVFbnVtKHtcbiAgICAgICAga2V5OiBrZXkgKyAnWzBdJyxcbiAgICAgICAgdmFsdWU6IHZhbHVlWzBdLFxuICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5maWx0ZXJfb3BlcmF0b3IsXG4gICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjXG4gICAgfSkpO1xuXG4gICAgc3dpdGNoICh1bmJ1bmRsZSh2YWx1ZVswXSkpIHtcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gMiAmJiB2YWx1ZVsxXSA9PSAnJHR5cGUnKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnXCIkdHlwZVwiIGNhbm5vdCBiZSB1c2Ugd2l0aCBvcGVyYXRvciBcIiVzXCInLCB2YWx1ZVswXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPSAzKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnZmlsdGVyIGFycmF5IGZvciBvcGVyYXRvciBcIiVzXCIgbXVzdCBoYXZlIDMgZWxlbWVudHMnLCB2YWx1ZVswXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ2luJzpcbiAgICAgICAgY2FzZSAnIWluJzpcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBnZXRUeXBlKHZhbHVlWzFdKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXkgKyAnWzFdJywgdmFsdWVbMV0sICdzdHJpbmcgZXhwZWN0ZWQsICVzIGZvdW5kJywgdHlwZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVbMV1bMF0gPT09ICdAJykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSArICdbMV0nLCB2YWx1ZVsxXSwgJ2ZpbHRlciBrZXkgY2Fubm90IGJlIGEgY29uc3RhbnQnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBnZXRUeXBlKHZhbHVlW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbMV0gPT0gJyR0eXBlJykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlRW51bSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSArICdbJyArIGkgKyAnXScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5nZW9tZXRyeV90eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbHVlW2ldWzBdID09PSAnQCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXkgKyAnWycgKyBpICsgJ10nLCB2YWx1ZVtpXSwgJ2ZpbHRlciB2YWx1ZSBjYW5ub3QgYmUgYSBjb25zdGFudCcpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdzdHJpbmcnICYmIHR5cGUgIT09ICdudW1iZXInICYmIHR5cGUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSArICdbJyArIGkgKyAnXScsIHZhbHVlW2ldLCAnc3RyaW5nLCBudW1iZXIsIG9yIGJvb2xlYW4gZXhwZWN0ZWQsICVzIGZvdW5kJywgdHlwZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2FueSc6XG4gICAgICAgIGNhc2UgJ2FsbCc6XG4gICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUZpbHRlcih7XG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5ICsgJ1snICsgaSArICddJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlW2ldLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlY1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2hhcyc6XG4gICAgICAgIGNhc2UgJyFoYXMnOlxuICAgICAgICAgICAgdHlwZSA9IGdldFR5cGUodmFsdWVbMV0pO1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ2ZpbHRlciBhcnJheSBmb3IgXCIlc1wiIG9wZXJhdG9yIG11c3QgaGF2ZSAyIGVsZW1lbnRzJywgdmFsdWVbMF0pKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSArICdbMV0nLCB2YWx1ZVsxXSwgJ3N0cmluZyBleHBlY3RlZCwgJXMgZm91bmQnLCB0eXBlKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlWzFdWzBdID09PSAnQCcpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSArICdbMV0nLCB2YWx1ZVsxXSwgJ2ZpbHRlciBrZXkgY2Fubm90IGJlIGEgY29uc3RhbnQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgIH1cblxuICAgIHJldHVybiBlcnJvcnM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xudmFyIGdldFR5cGUgPSByZXF1aXJlKCcuLi91dGlsL2dldF90eXBlJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL3ZhbGlkYXRlJyk7XG52YXIgdmFsaWRhdGVPYmplY3QgPSByZXF1aXJlKCcuL3ZhbGlkYXRlX29iamVjdCcpO1xudmFyIHZhbGlkYXRlQXJyYXkgPSByZXF1aXJlKCcuL3ZhbGlkYXRlX2FycmF5Jyk7XG52YXIgdmFsaWRhdGVOdW1iZXIgPSByZXF1aXJlKCcuL3ZhbGlkYXRlX251bWJlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBmdW5jdGlvblZhbHVlU3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjO1xuICAgIHZhciBzdG9wS2V5VHlwZTtcblxuICAgIHZhciBpc1Byb3BlcnR5RnVuY3Rpb24gPSBvcHRpb25zLnZhbHVlLnByb3BlcnR5ICE9PSB1bmRlZmluZWQgfHwgc3RvcEtleVR5cGUgPT09ICdvYmplY3QnO1xuICAgIHZhciBpc1pvb21GdW5jdGlvbiA9IG9wdGlvbnMudmFsdWUucHJvcGVydHkgPT09IHVuZGVmaW5lZCB8fCBzdG9wS2V5VHlwZSA9PT0gJ29iamVjdCc7XG5cbiAgICB2YXIgZXJyb3JzID0gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgICB2YWx1ZTogb3B0aW9ucy52YWx1ZSxcbiAgICAgICAgdmFsdWVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYy5mdW5jdGlvbixcbiAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMsXG4gICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7IHN0b3BzOiB2YWxpZGF0ZUZ1bmN0aW9uU3RvcHMgfVxuICAgIH0pO1xuXG4gICAgaWYgKG9wdGlvbnMuc3R5bGVTcGVjLiR2ZXJzaW9uID49IDgpIHtcbiAgICAgICBpZiAoaXNQcm9wZXJ0eUZ1bmN0aW9uICYmICFvcHRpb25zLnZhbHVlU3BlY1sncHJvcGVydHktZnVuY3Rpb24nXSkge1xuICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAncHJvcGVydHkgZnVuY3Rpb25zIG5vdCBzdXBwb3J0ZWQnKSk7XG4gICAgICAgfSBlbHNlIGlmIChpc1pvb21GdW5jdGlvbiAmJiAhb3B0aW9ucy52YWx1ZVNwZWNbJ3pvb20tZnVuY3Rpb24nXSkge1xuICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnem9vbSBmdW5jdGlvbnMgbm90IHN1cHBvcnRlZCcpKTtcbiAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVycm9ycztcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25TdG9wcyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcblxuICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlQXJyYXkoe1xuICAgICAgICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogb3B0aW9ucy52YWx1ZVNwZWMsXG4gICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMsXG4gICAgICAgICAgICBhcnJheUVsZW1lbnRWYWxpZGF0b3I6IHZhbGlkYXRlRnVuY3Rpb25TdG9wXG4gICAgICAgIH0pKTtcblxuICAgICAgICBpZiAoZ2V0VHlwZSh2YWx1ZSkgPT09ICdhcnJheScgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCB2YWx1ZSwgJ2FycmF5IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgc3RvcCcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvblN0b3Aob3B0aW9ucykge1xuICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcblxuICAgICAgICBpZiAoZ2V0VHlwZSh2YWx1ZSkgIT09ICdhcnJheScpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnYXJyYXkgZXhwZWN0ZWQsICVzIGZvdW5kJywgZ2V0VHlwZSh2YWx1ZSkpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnYXJyYXkgbGVuZ3RoICVkIGV4cGVjdGVkLCBsZW5ndGggJWQgZm91bmQnLCAyLCB2YWx1ZS5sZW5ndGgpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0eXBlID0gZ2V0VHlwZSh2YWx1ZVswXSk7XG4gICAgICAgIGlmICghc3RvcEtleVR5cGUpIHN0b3BLZXlUeXBlID0gdHlwZTtcbiAgICAgICAgaWYgKHR5cGUgIT09IHN0b3BLZXlUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJyVzIHN0b3Aga2V5IHR5cGUgbXVzdCBtYXRjaCBwcmV2aW91cyBzdG9wIGtleSB0eXBlICVzJywgdHlwZSwgc3RvcEtleVR5cGUpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKHZhbHVlWzBdLnpvb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnb2JqZWN0IHN0b3Aga2V5IG11c3QgaGF2ZSB6b29tJyldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlWzBdLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ29iamVjdCBzdG9wIGtleSBtdXN0IGhhdmUgdmFsdWUnKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSArICdbMF0nLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHsgem9vbToge30gfSxcbiAgICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7IHpvb206IHZhbGlkYXRlTnVtYmVyLCB2YWx1ZTogdmFsaWRhdGVWYWx1ZSB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KChpc1pvb21GdW5jdGlvbiA/IHZhbGlkYXRlTnVtYmVyIDogdmFsaWRhdGVWYWx1ZSkoe1xuICAgICAgICAgICAgICAgIGtleToga2V5ICsgJ1swXScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIHZhbHVlU3BlYzoge30sXG4gICAgICAgICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlY1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZSh7XG4gICAgICAgICAgICBrZXk6IGtleSArICdbMV0nLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlWzFdLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBmdW5jdGlvblZhbHVlU3BlYyxcbiAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlY1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgaWYgKGdldFR5cGUodmFsdWVbMF0pID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uVmFsdWVTcGVjLmZ1bmN0aW9uID09PSAncGllY2V3aXNlLWNvbnN0YW50JyAmJiB2YWx1ZVswXSAlIDEgIT09IDApIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSArICdbMF0nLCB2YWx1ZVswXSwgJ3pvb20gbGV2ZWwgZm9yIHBpZWNld2lzZS1jb25zdGFudCBmdW5jdGlvbnMgbXVzdCBiZSBhbiBpbnRlZ2VyJykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheUluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlWzBdIDwgb3B0aW9ucy5hcnJheVtvcHRpb25zLmFycmF5SW5kZXggLSAxXVswXSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSArICdbMF0nLCB2YWx1ZVswXSwgJ2FycmF5IHN0b3BzIG11c3QgYXBwZWFyIGluIGFzY2VuZGluZyBvcmRlcicpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlVmFsdWUob3B0aW9ucykge1xuICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgIHZhciB0eXBlID0gZ2V0VHlwZShvcHRpb25zLnZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgIT09ICdudW1iZXInICYmIHR5cGUgIT09ICdzdHJpbmcnICYmIHR5cGUgIT09ICdhcnJheScpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdwcm9wZXJ0eSB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyLCBzdHJpbmcgb3IgYXJyYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICB9XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG52YXIgdmFsaWRhdGVTdHJpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlX3N0cmluZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcblxuICAgIHZhciBlcnJvcnMgPSB2YWxpZGF0ZVN0cmluZyhvcHRpb25zKTtcbiAgICBpZiAoZXJyb3JzLmxlbmd0aCkgcmV0dXJuIGVycm9ycztcblxuICAgIGlmICh2YWx1ZS5pbmRleE9mKCd7Zm9udHN0YWNrfScpID09PSAtMSkge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdcImdseXBoc1wiIHVybCBtdXN0IGluY2x1ZGUgYSBcIntmb250c3RhY2t9XCIgdG9rZW4nKSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLmluZGV4T2YoJ3tyYW5nZX0nKSA9PT0gLTEpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnXCJnbHlwaHNcIiB1cmwgbXVzdCBpbmNsdWRlIGEgXCJ7cmFuZ2V9XCIgdG9rZW4nKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVycm9ycztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uX2Vycm9yJyk7XG52YXIgdW5idW5kbGUgPSByZXF1aXJlKCcuLi91dGlsL3VuYnVuZGxlX2pzb25saW50Jyk7XG52YXIgdmFsaWRhdGVPYmplY3QgPSByZXF1aXJlKCcuL3ZhbGlkYXRlX29iamVjdCcpO1xudmFyIHZhbGlkYXRlRmlsdGVyID0gcmVxdWlyZSgnLi92YWxpZGF0ZV9maWx0ZXInKTtcbnZhciB2YWxpZGF0ZVBhaW50UHJvcGVydHkgPSByZXF1aXJlKCcuL3ZhbGlkYXRlX3BhaW50X3Byb3BlcnR5Jyk7XG52YXIgdmFsaWRhdGVMYXlvdXRQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vdmFsaWRhdGVfbGF5b3V0X3Byb3BlcnR5Jyk7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi4vdXRpbC9leHRlbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZUxheWVyKG9wdGlvbnMpIHtcbiAgICB2YXIgZXJyb3JzID0gW107XG5cbiAgICB2YXIgbGF5ZXIgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcblxuICAgIGlmICghbGF5ZXIudHlwZSAmJiAhbGF5ZXIucmVmKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllciwgJ2VpdGhlciBcInR5cGVcIiBvciBcInJlZlwiIGlzIHJlcXVpcmVkJykpO1xuICAgIH1cbiAgICB2YXIgdHlwZSA9IHVuYnVuZGxlKGxheWVyLnR5cGUpO1xuICAgIHZhciByZWYgPSB1bmJ1bmRsZShsYXllci5yZWYpO1xuXG4gICAgaWYgKGxheWVyLmlkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5hcnJheUluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvdGhlckxheWVyID0gc3R5bGUubGF5ZXJzW2ldO1xuICAgICAgICAgICAgaWYgKHVuYnVuZGxlKG90aGVyTGF5ZXIuaWQpID09PSB1bmJ1bmRsZShsYXllci5pZCkpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIuaWQsICdkdXBsaWNhdGUgbGF5ZXIgaWQgXCIlc1wiLCBwcmV2aW91c2x5IHVzZWQgYXQgbGluZSAlZCcsIGxheWVyLmlkLCBvdGhlckxheWVyLmlkLl9fbGluZV9fKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJ3JlZicgaW4gbGF5ZXIpIHtcbiAgICAgICAgWyd0eXBlJywgJ3NvdXJjZScsICdzb3VyY2UtbGF5ZXInLCAnZmlsdGVyJywgJ2xheW91dCddLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIGlmIChwIGluIGxheWVyKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyW3BdLCAnXCIlc1wiIGlzIHByb2hpYml0ZWQgZm9yIHJlZiBsYXllcnMnLCBwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBwYXJlbnQ7XG5cbiAgICAgICAgc3R5bGUubGF5ZXJzLmZvckVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgIGlmIChsYXllci5pZCA9PSByZWYpIHBhcmVudCA9IGxheWVyO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnJlZiwgJ3JlZiBsYXllciBcIiVzXCIgbm90IGZvdW5kJywgcmVmKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyZW50LnJlZikge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnJlZiwgJ3JlZiBjYW5ub3QgcmVmZXJlbmNlIGFub3RoZXIgcmVmIGxheWVyJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHlwZSA9IHVuYnVuZGxlKHBhcmVudC50eXBlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gJ2JhY2tncm91bmQnKSB7XG4gICAgICAgIGlmICghbGF5ZXIuc291cmNlKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIsICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IFwic291cmNlXCInKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gc3R5bGUuc291cmNlcyAmJiBzdHlsZS5zb3VyY2VzW2xheWVyLnNvdXJjZV07XG4gICAgICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllci5zb3VyY2UsICdzb3VyY2UgXCIlc1wiIG5vdCBmb3VuZCcsIGxheWVyLnNvdXJjZSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UudHlwZSA9PSAndmVjdG9yJyAmJiB0eXBlID09ICdyYXN0ZXInKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnNvdXJjZSwgJ2xheWVyIFwiJXNcIiByZXF1aXJlcyBhIHJhc3RlciBzb3VyY2UnLCBsYXllci5pZCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UudHlwZSA9PSAncmFzdGVyJyAmJiB0eXBlICE9ICdyYXN0ZXInKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnNvdXJjZSwgJ2xheWVyIFwiJXNcIiByZXF1aXJlcyBhIHZlY3RvciBzb3VyY2UnLCBsYXllci5pZCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UudHlwZSA9PSAndmVjdG9yJyAmJiAhbGF5ZXJbJ3NvdXJjZS1sYXllciddKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLCAnbGF5ZXIgXCIlc1wiIG11c3Qgc3BlY2lmeSBhIFwic291cmNlLWxheWVyXCInLCBsYXllci5pZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZTogbGF5ZXIsXG4gICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLmxheWVyLFxuICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYyxcbiAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgICAgICAgIGZpbHRlcjogdmFsaWRhdGVGaWx0ZXIsXG4gICAgICAgICAgICBsYXlvdXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgICBsYXllcjogbGF5ZXIsXG4gICAgICAgICAgICAgICAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYyxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICcqJzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZUxheW91dFByb3BlcnR5KGV4dGVuZCh7bGF5ZXJUeXBlOiB0eXBlfSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFpbnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgICBsYXllcjogbGF5ZXIsXG4gICAgICAgICAgICAgICAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYyxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICcqJzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZVBhaW50UHJvcGVydHkoZXh0ZW5kKHtsYXllclR5cGU6IHR5cGV9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJldHVybiBlcnJvcnM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL3ZhbGlkYXRlJyk7XG52YXIgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlTGF5b3V0UHJvcGVydHkob3B0aW9ucykge1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciBwcm9wZXJ0eUtleSA9IG9wdGlvbnMub2JqZWN0S2V5O1xuICAgIHZhciBsYXllclNwZWMgPSBzdHlsZVNwZWNbJ2xheW91dF8nICsgb3B0aW9ucy5sYXllclR5cGVdO1xuXG4gICAgaWYgKG9wdGlvbnMudmFsdWVTcGVjIHx8IGxheWVyU3BlY1twcm9wZXJ0eUtleV0pIHtcbiAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmxheWVyVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eUtleSA9PT0gJ2ljb24taW1hZ2UnICYmIHN0eWxlICYmICFzdHlsZS5zcHJpdGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICd1c2Ugb2YgXCJpY29uLWltYWdlXCIgcmVxdWlyZXMgYSBzdHlsZSBcInNwcml0ZVwiIHByb3BlcnR5JykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUtleSA9PT0gJ3RleHQtZmllbGQnICYmIHN0eWxlICYmICFzdHlsZS5nbHlwaHMpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICd1c2Ugb2YgXCJ0ZXh0LWZpZWxkXCIgcmVxdWlyZXMgYSBzdHlsZSBcImdseXBoc1wiIHByb3BlcnR5JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVycm9ycy5jb25jYXQodmFsaWRhdGUoe1xuICAgICAgICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogb3B0aW9ucy52YWx1ZVNwZWMgfHwgbGF5ZXJTcGVjW3Byb3BlcnR5S2V5XSxcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICAgIH0pKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAndW5rbm93biBwcm9wZXJ0eSBcIiVzXCInLCBwcm9wZXJ0eUtleSldO1xuICAgIH1cblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdldFR5cGUgPSByZXF1aXJlKCcuLi91dGlsL2dldF90eXBlJyk7XG52YXIgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyKG9wdGlvbnMpIHtcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIgdmFsdWVTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWM7XG4gICAgdmFyIHR5cGUgPSBnZXRUeXBlKHZhbHVlKTtcblxuICAgIGlmICh0eXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ251bWJlciBleHBlY3RlZCwgJXMgZm91bmQnLCB0eXBlKV07XG4gICAgfVxuXG4gICAgaWYgKCdtaW5pbXVtJyBpbiB2YWx1ZVNwZWMgJiYgdmFsdWUgPCB2YWx1ZVNwZWMubWluaW11bSkge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJyVzIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSB2YWx1ZSAlcycsIHZhbHVlLCB2YWx1ZVNwZWMubWluaW11bSldO1xuICAgIH1cblxuICAgIGlmICgnbWF4aW11bScgaW4gdmFsdWVTcGVjICYmIHZhbHVlID4gdmFsdWVTcGVjLm1heGltdW0pIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICclcyBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gdmFsdWUgJXMnLCB2YWx1ZSwgdmFsdWVTcGVjLm1heGltdW0pXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xudmFyIGdldFR5cGUgPSByZXF1aXJlKCcuLi91dGlsL2dldF90eXBlJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL3ZhbGlkYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob3B0aW9ucykge1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgb2JqZWN0ID0gb3B0aW9ucy52YWx1ZTtcbiAgICB2YXIgdmFsdWVTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWM7XG4gICAgdmFyIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzID0gb3B0aW9ucy5vYmplY3RFbGVtZW50VmFsaWRhdG9ycyB8fCB7fTtcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICB2YXIgZXJyb3JzID0gW107XG5cbiAgICB2YXIgdHlwZSA9IGdldFR5cGUob2JqZWN0KTtcbiAgICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgb2JqZWN0LCAnb2JqZWN0IGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBvYmplY3RLZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIHZhciB2YWx1ZVNwZWNLZXkgPSBvYmplY3RLZXkuc3BsaXQoJy4nKVswXTsgLy8gdHJlYXQgJ3BhaW50LionIGFzICdwYWludCdcbiAgICAgICAgdmFyIG9iamVjdEVsZW1lbnRTcGVjID0gdmFsdWVTcGVjICYmICh2YWx1ZVNwZWNbdmFsdWVTcGVjS2V5XSB8fCB2YWx1ZVNwZWNbJyonXSk7XG4gICAgICAgIHZhciBvYmplY3RFbGVtZW50VmFsaWRhdG9yID0gb2JqZWN0RWxlbWVudFZhbGlkYXRvcnNbdmFsdWVTcGVjS2V5XSB8fCBvYmplY3RFbGVtZW50VmFsaWRhdG9yc1snKiddO1xuXG4gICAgICAgIGlmIChvYmplY3RFbGVtZW50U3BlYyB8fCBvYmplY3RFbGVtZW50VmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KChvYmplY3RFbGVtZW50VmFsaWRhdG9yIHx8IHZhbGlkYXRlKSh7XG4gICAgICAgICAgICAgICAga2V5OiAoa2V5ID8ga2V5ICsgJy4nIDoga2V5KSArIG9iamVjdEtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogb2JqZWN0W29iamVjdEtleV0sXG4gICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBvYmplY3RFbGVtZW50U3BlYyxcbiAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMsXG4gICAgICAgICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgICAgICAgb2JqZWN0S2V5OiBvYmplY3RLZXlcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAvLyB0b2xlcmF0ZSByb290LWxldmVsIGV4dHJhIGtleXMgJiBhcmJpdHJhcnkgbGF5ZXIgcHJvcGVydGllc1xuICAgICAgICAvLyBUT0RPIHJlbW92ZSB0aGlzIGxheWVyLXNwZWNpZmljIGxvZ2ljXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ICE9PSAnJyAmJiBrZXkuc3BsaXQoJy4nKS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBvYmplY3Rbb2JqZWN0S2V5XSwgJ3Vua25vd24gcHJvcGVydHkgXCIlc1wiJywgb2JqZWN0S2V5KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhbHVlU3BlY0tleSBpbiB2YWx1ZVNwZWMpIHtcbiAgICAgICAgaWYgKHZhbHVlU3BlY1t2YWx1ZVNwZWNLZXldLnJlcXVpcmVkICYmIHZhbHVlU3BlY1t2YWx1ZVNwZWNLZXldWydkZWZhdWx0J10gPT09IHVuZGVmaW5lZCAmJiBvYmplY3RbdmFsdWVTcGVjS2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgb2JqZWN0LCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcIiVzXCInLCB2YWx1ZVNwZWNLZXkpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlcnJvcnM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL3ZhbGlkYXRlJyk7XG52YXIgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlUGFpbnRQcm9wZXJ0eShvcHRpb25zKSB7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG4gICAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIHByb3BlcnR5S2V5ID0gb3B0aW9ucy5vYmplY3RLZXk7XG4gICAgdmFyIGxheWVyU3BlYyA9IHN0eWxlU3BlY1sncGFpbnRfJyArIG9wdGlvbnMubGF5ZXJUeXBlXTtcblxuICAgIHZhciB0cmFuc2l0aW9uTWF0Y2ggPSBwcm9wZXJ0eUtleS5tYXRjaCgvXiguKiktdHJhbnNpdGlvbiQvKTtcblxuICAgIGlmICh0cmFuc2l0aW9uTWF0Y2ggJiYgbGF5ZXJTcGVjW3RyYW5zaXRpb25NYXRjaFsxXV0gJiYgbGF5ZXJTcGVjW3RyYW5zaXRpb25NYXRjaFsxXV0udHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUoe1xuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy50cmFuc2l0aW9uLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgICAgfSk7XG5cbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMudmFsdWVTcGVjIHx8IGxheWVyU3BlY1twcm9wZXJ0eUtleV0pIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHtcbiAgICAgICAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB2YWx1ZVNwZWM6IG9wdGlvbnMudmFsdWVTcGVjIHx8IGxheWVyU3BlY1twcm9wZXJ0eUtleV0sXG4gICAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICB9KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAndW5rbm93biBwcm9wZXJ0eSBcIiVzXCInLCBwcm9wZXJ0eUtleSldO1xuICAgIH1cblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL3ZhbGlkYXRpb25fZXJyb3InKTtcbnZhciB1bmJ1bmRsZSA9IHJlcXVpcmUoJy4uL3V0aWwvdW5idW5kbGVfanNvbmxpbnQnKTtcbnZhciB2YWxpZGF0ZU9iamVjdCA9IHJlcXVpcmUoJy4vdmFsaWRhdGVfb2JqZWN0Jyk7XG52YXIgdmFsaWRhdGVFbnVtID0gcmVxdWlyZSgnLi92YWxpZGF0ZV9lbnVtJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdmFsaWRhdGVTb3VyY2Uob3B0aW9ucykge1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuXG4gICAgaWYgKCF2YWx1ZS50eXBlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnXCJ0eXBlXCIgaXMgcmVxdWlyZWQnKV07XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSB1bmJ1bmRsZSh2YWx1ZS50eXBlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAndmVjdG9yJzpcbiAgICAgICAgY2FzZSAncmFzdGVyJzpcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5zb3VyY2VfdGlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKCd1cmwnIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoWyd0eXBlJywgJ3VybCcsICd0aWxlU2l6ZSddLmluZGV4T2YocHJvcCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSArICcuJyArIHByb3AsIHZhbHVlW3Byb3BdLCAnYSBzb3VyY2Ugd2l0aCBhIFwidXJsXCIgcHJvcGVydHkgbWF5IG5vdCBpbmNsdWRlIGEgXCIlc1wiIHByb3BlcnR5JywgcHJvcCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcblxuICAgICAgICBjYXNlICdnZW9qc29uJzpcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLnNvdXJjZV9nZW9qc29uLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMuc291cmNlX3ZpZGVvLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMuc291cmNlX2ltYWdlLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZUVudW0oe1xuICAgICAgICAgICAgICAgIGtleToga2V5ICsgJy50eXBlJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUudHlwZSxcbiAgICAgICAgICAgICAgICB2YWx1ZVNwZWM6IHt2YWx1ZXM6IFsndmVjdG9yJywgJ3Jhc3RlcicsICdnZW9qc29uJywgJ3ZpZGVvJywgJ2ltYWdlJ119LFxuICAgICAgICAgICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgICAgICAgfSk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdldFR5cGUgPSByZXF1aXJlKCcuLi91dGlsL2dldF90eXBlJyk7XG52YXIgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvdmFsaWRhdGlvbl9lcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICB2YXIgdHlwZSA9IGdldFR5cGUodmFsdWUpO1xuXG4gICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnc3RyaW5nIGV4cGVjdGVkLCAlcyBmb3VuZCcsIHR5cGUpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdmFsaWRhdGVDb25zdGFudHMgPSByZXF1aXJlKCcuL3ZhbGlkYXRlL3ZhbGlkYXRlX2NvbnN0YW50cycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi92YWxpZGF0ZS92YWxpZGF0ZScpO1xudmFyIGxhdGVzdFN0eWxlU3BlYyA9IHJlcXVpcmUoJy4uL3JlZmVyZW5jZS9sYXRlc3QubWluJyk7XG52YXIgdmFsaWRhdGVHbHlwaHNVUkwgPSByZXF1aXJlKCcuL3ZhbGlkYXRlL3ZhbGlkYXRlX2dseXBoc191cmwnKTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBhIE1hcGJveCBHTCBzdHlsZSBhZ2FpbnN0IHRoZSBzdHlsZSBzcGVjaWZpY2F0aW9uLiBUaGlzIGVudHJ5cG9pbnQsXG4gKiBgbWFwYm94LWdsLXN0eWxlLXNwZWMvbGliL3ZhbGlkYXRlX3N0eWxlLm1pbmAsIGlzIGRlc2lnbmVkIHRvIHByb2R1Y2UgYXNcbiAqIHNtYWxsIGEgYnJvd3NlcmlmeSBidW5kbGUgYXMgcG9zc2libGUgYnkgb21pdHRpbmcgdW5uZWNlc3NhcnkgZnVuY3Rpb25hbGl0eVxuICogYW5kIGxlZ2FjeSBzdHlsZSBzcGVjaWZpY2F0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGUgVGhlIHN0eWxlIHRvIGJlIHZhbGlkYXRlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVTcGVjXSBUaGUgc3R5bGUgc3BlY2lmaWNhdGlvbiB0byB2YWxpZGF0ZSBhZ2FpbnN0LlxuICogICAgIElmIG9taXR0ZWQsIHRoZSBsYXRlc3Qgc3R5bGUgc3BlYyBpcyB1c2VkLlxuICogQHJldHVybnMge0FycmF5PFZhbGlkYXRpb25FcnJvcj59XG4gKiBAZXhhbXBsZVxuICogICB2YXIgdmFsaWRhdGUgPSByZXF1aXJlKCdtYXBib3gtZ2wtc3R5bGUtc3BlYy9saWIvdmFsaWRhdGVfc3R5bGUubWluJyk7XG4gKiAgIHZhciBlcnJvcnMgPSB2YWxpZGF0ZShzdHlsZSk7XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU3R5bGVNaW4oc3R5bGUsIHN0eWxlU3BlYykge1xuICAgIHN0eWxlU3BlYyA9IHN0eWxlU3BlYyB8fCBsYXRlc3RTdHlsZVNwZWM7XG5cbiAgICB2YXIgZXJyb3JzID0gW107XG5cbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlKHtcbiAgICAgICAga2V5OiAnJyxcbiAgICAgICAgdmFsdWU6IHN0eWxlLFxuICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy4kcm9vdCxcbiAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMsXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgICAgICAgIGdseXBoczogdmFsaWRhdGVHbHlwaHNVUkxcbiAgICAgICAgfVxuICAgIH0pKTtcblxuICAgIGlmIChzdHlsZVNwZWMuJHZlcnNpb24gPiA3ICYmIHN0eWxlLmNvbnN0YW50cykge1xuICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlQ29uc3RhbnRzKHtcbiAgICAgICAgICAgIGtleTogJ2NvbnN0YW50cycsXG4gICAgICAgICAgICB2YWx1ZTogc3R5bGUuY29uc3RhbnRzLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBzb3J0RXJyb3JzKGVycm9ycyk7XG59XG5cbnZhbGlkYXRlU3R5bGVNaW4uc291cmNlID0gd3JhcENsZWFuRXJyb3JzKHJlcXVpcmUoJy4vdmFsaWRhdGUvdmFsaWRhdGVfc291cmNlJykpO1xudmFsaWRhdGVTdHlsZU1pbi5sYXllciA9IHdyYXBDbGVhbkVycm9ycyhyZXF1aXJlKCcuL3ZhbGlkYXRlL3ZhbGlkYXRlX2xheWVyJykpO1xudmFsaWRhdGVTdHlsZU1pbi5maWx0ZXIgPSB3cmFwQ2xlYW5FcnJvcnMocmVxdWlyZSgnLi92YWxpZGF0ZS92YWxpZGF0ZV9maWx0ZXInKSk7XG52YWxpZGF0ZVN0eWxlTWluLnBhaW50UHJvcGVydHkgPSB3cmFwQ2xlYW5FcnJvcnMocmVxdWlyZSgnLi92YWxpZGF0ZS92YWxpZGF0ZV9wYWludF9wcm9wZXJ0eScpKTtcbnZhbGlkYXRlU3R5bGVNaW4ubGF5b3V0UHJvcGVydHkgPSB3cmFwQ2xlYW5FcnJvcnMocmVxdWlyZSgnLi92YWxpZGF0ZS92YWxpZGF0ZV9sYXlvdXRfcHJvcGVydHknKSk7XG5cbmZ1bmN0aW9uIHNvcnRFcnJvcnMoZXJyb3JzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChlcnJvcnMpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEubGluZSAtIGIubGluZTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gd3JhcENsZWFuRXJyb3JzKGlubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc29ydEVycm9ycyhpbm5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkYXRlU3R5bGVNaW47XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vdjgubWluLmpzb24nKTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcInNvdXJjZXNcIjp7XCIqXCI6e1widHlwZVwiOlwic291cmNlXCIsXCJkb2NcIjpcIlNwZWNpZmljYXRpb24gb2YgYSBkYXRhIHNvdXJjZS4gRm9yIHZlY3RvciBhbmQgcmFzdGVyIHNvdXJjZXMsIGVpdGhlciBUaWxlSlNPTiBvciBhIFVSTCB0byBhIFRpbGVKU09OIG11c3QgYmUgcHJvdmlkZWQuIEZvciBHZW9KU09OIGFuZCB2aWRlbyBzb3VyY2VzLCBhIFVSTCBtdXN0IGJlIHByb3ZpZGVkLlwifX0sXCJ0cmFuc2l0aW9uXCI6e1wiZHVyYXRpb25cIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjozMDAsXCJtaW5pbXVtXCI6MCxcInVuaXRzXCI6XCJtaWxsaXNlY29uZHNcIixcImRvY1wiOlwiVGltZSBhbGxvdHRlZCBmb3IgdHJhbnNpdGlvbnMgdG8gY29tcGxldGUuXCJ9LFwiZGVsYXlcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwibWluaW11bVwiOjAsXCJ1bml0c1wiOlwibWlsbGlzZWNvbmRzXCIsXCJkb2NcIjpcIkxlbmd0aCBvZiB0aW1lIGJlZm9yZSBhIHRyYW5zaXRpb24gYmVnaW5zLlwifX0sXCIkdmVyc2lvblwiOjgsXCJzb3VyY2VcIjpbXCJzb3VyY2VfdGlsZVwiLFwic291cmNlX2dlb2pzb25cIixcInNvdXJjZV92aWRlb1wiLFwic291cmNlX2ltYWdlXCJdLFwic291cmNlX3RpbGVcIjp7XCJ0eXBlXCI6e1wicmVxdWlyZWRcIjp0cnVlLFwidHlwZVwiOlwiZW51bVwiLFwidmFsdWVzXCI6W1widmVjdG9yXCIsXCJyYXN0ZXJcIl0sXCJkb2NcIjpcIlRoZSBkYXRhIHR5cGUgb2YgdGhlIHRpbGUgc291cmNlLlwifSxcInVybFwiOntcInR5cGVcIjpcInN0cmluZ1wiLFwiZG9jXCI6XCJBIFVSTCB0byBhIFRpbGVKU09OIHJlc291cmNlLiBTdXBwb3J0ZWQgcHJvdG9jb2xzIGFyZSBgaHR0cDpgLCBgaHR0cHM6YCwgYW5kIGBtYXBib3g6Ly88bWFwaWQ+YC5cIn0sXCJ0aWxlc1wiOntcInR5cGVcIjpcImFycmF5XCIsXCJ2YWx1ZVwiOlwic3RyaW5nXCIsXCJkb2NcIjpcIkFuIGFycmF5IG9mIG9uZSBvciBtb3JlIHRpbGUgc291cmNlIFVSTHMsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLlwifSxcIm1pbnpvb21cIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwiZG9jXCI6XCJNaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLlwifSxcIm1heHpvb21cIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjoyMixcImRvY1wiOlwiTWF4aW11bSB6b29tIGxldmVsIGZvciB3aGljaCB0aWxlcyBhcmUgYXZhaWxhYmxlLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy4gRGF0YSBmcm9tIHRpbGVzIGF0IHRoZSBtYXh6b29tIGFyZSB1c2VkIHdoZW4gZGlzcGxheWluZyB0aGUgbWFwIGF0IGhpZ2hlciB6b29tIGxldmVscy5cIn0sXCJ0aWxlU2l6ZVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjUxMixcInVuaXRzXCI6XCJwaXhlbHNcIixcImRvY1wiOlwiVGhlIG1pbmltdW0gdmlzdWFsIHNpemUgdG8gZGlzcGxheSB0aWxlcyBmb3IgdGhpcyBsYXllci4gT25seSBjb25maWd1cmFibGUgZm9yIHJhc3RlciBsYXllcnMuXCJ9LFwiKlwiOntcInR5cGVcIjpcIipcIixcImRvY1wiOlwiT3RoZXIga2V5cyB0byBjb25maWd1cmUgdGhlIGRhdGEgc291cmNlLlwifX0sXCJzb3VyY2VfZ2VvanNvblwiOntcInR5cGVcIjp7XCJyZXF1aXJlZFwiOnRydWUsXCJ0eXBlXCI6XCJlbnVtXCIsXCJ2YWx1ZXNcIjpbXCJnZW9qc29uXCJdLFwiZG9jXCI6XCJUaGUgZGF0YSB0eXBlIG9mIHRoZSBHZW9KU09OIHNvdXJjZS5cIn0sXCJkYXRhXCI6e1widHlwZVwiOlwiKlwiLFwiZG9jXCI6XCJBIFVSTCB0byBhIEdlb0pTT04gZmlsZSwgb3IgaW5saW5lIEdlb0pTT04uXCJ9LFwibWF4em9vbVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjE0LFwiZG9jXCI6XCJNYXhpbXVtIHpvb20gbGV2ZWwgYXQgd2hpY2ggdG8gY3JlYXRlIHZlY3RvciB0aWxlcyAoaGlnaGVyIG1lYW5zIGdyZWF0ZXIgZGV0YWlsIGF0IGhpZ2ggem9vbSBsZXZlbHMpLlwifSxcImJ1ZmZlclwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjY0LFwiZG9jXCI6XCJUaWxlIGJ1ZmZlciBzaXplIG9uIGVhY2ggc2lkZSAoaGlnaGVyIG1lYW5zIGZld2VyIHJlbmRlcmluZyBhcnRpZmFjdHMgbmVhciB0aWxlIGVkZ2VzIGJ1dCBzbG93ZXIgcGVyZm9ybWFuY2UpLlwifSxcInRvbGVyYW5jZVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjMsXCJkb2NcIjpcIkRvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbiB0b2xlcmFuY2UgKGhpZ2hlciBtZWFucyBzaW1wbGVyIGdlb21ldHJpZXMgYW5kIGZhc3RlciBwZXJmb3JtYW5jZSkuXCJ9LFwiY2x1c3RlclwiOntcInR5cGVcIjpcImJvb2xlYW5cIixcImRlZmF1bHRcIjpmYWxzZSxcImRvY1wiOlwiSWYgdGhlIGRhdGEgaXMgYSBjb2xsZWN0aW9uIG9mIHBvaW50IGZlYXR1cmVzLCBzZXR0aW5nIHRoaXMgdG8gdHJ1ZSBjbHVzdGVycyB0aGUgcG9pbnRzIGJ5IHJhZGl1cyBpbnRvIGdyb3Vwcy5cIn0sXCJjbHVzdGVyUmFkaXVzXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6NDAwLFwiZG9jXCI6XCJSYWRpdXMgb2YgZWFjaCBjbHVzdGVyIHdoZW4gY2x1c3RlcmluZyBwb2ludHMsIHJlbGF0aXZlIHRvIDQwOTYgdGlsZS5cIn0sXCJjbHVzdGVyTWF4Wm9vbVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZG9jXCI6XCJNYXggem9vbSB0byBjbHVzdGVyIHBvaW50cyBvbi4gRGVmYXVsdHMgdG8gb25lIHpvb20gbGVzcyB0aGFuIG1heHpvb20gKHNvIHRoYXQgbGFzdCB6b29tIGZlYXR1cmVzIGFyZSBub3QgY2x1c3RlcmVkKS5cIn19LFwic291cmNlX3ZpZGVvXCI6e1widHlwZVwiOntcInJlcXVpcmVkXCI6dHJ1ZSxcInR5cGVcIjpcImVudW1cIixcInZhbHVlc1wiOltcInZpZGVvXCJdLFwiZG9jXCI6XCJUaGUgZGF0YSB0eXBlIG9mIHRoZSB2aWRlbyBzb3VyY2UuXCJ9LFwidXJsc1wiOntcInJlcXVpcmVkXCI6dHJ1ZSxcInR5cGVcIjpcImFycmF5XCIsXCJ2YWx1ZVwiOlwic3RyaW5nXCIsXCJkb2NcIjpcIlVSTHMgdG8gdmlkZW8gY29udGVudCBpbiBvcmRlciBvZiBwcmVmZXJyZWQgZm9ybWF0LlwifSxcImNvb3JkaW5hdGVzXCI6e1wicmVxdWlyZWRcIjp0cnVlLFwiZG9jXCI6XCJDb3JuZXJzIG9mIHZpZGVvIHNwZWNpZmllZCBpbiBsb25naXR1ZGUsIGxhdGl0dWRlIHBhaXJzLlwiLFwidHlwZVwiOlwiYXJyYXlcIixcImxlbmd0aFwiOjQsXCJ2YWx1ZVwiOntcInR5cGVcIjpcImFycmF5XCIsXCJsZW5ndGhcIjoyLFwidmFsdWVcIjpcIm51bWJlclwiLFwiZG9jXCI6XCJBIHNpbmdsZSBsb25naXR1ZGUsIGxhdGl0dWRlIHBhaXIuXCJ9fX0sXCJzb3VyY2VfaW1hZ2VcIjp7XCJ0eXBlXCI6e1wicmVxdWlyZWRcIjp0cnVlLFwidHlwZVwiOlwiZW51bVwiLFwidmFsdWVzXCI6W1wiaW1hZ2VcIl0sXCJkb2NcIjpcIlRoZSBkYXRhIHR5cGUgb2YgdGhlIGltYWdlIHNvdXJjZS5cIn0sXCJ1cmxcIjp7XCJyZXF1aXJlZFwiOnRydWUsXCJ0eXBlXCI6XCJzdHJpbmdcIixcImRvY1wiOlwiVVJMIHRoYXQgcG9pbnRzIHRvIGFuIGltYWdlXCJ9LFwiY29vcmRpbmF0ZXNcIjp7XCJyZXF1aXJlZFwiOnRydWUsXCJkb2NcIjpcIkNvcm5lcnMgb2YgaW1hZ2Ugc3BlY2lmaWVkIGluIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcGFpcnMuXCIsXCJ0eXBlXCI6XCJhcnJheVwiLFwibGVuZ3RoXCI6NCxcInZhbHVlXCI6e1widHlwZVwiOlwiYXJyYXlcIixcImxlbmd0aFwiOjIsXCJ2YWx1ZVwiOlwibnVtYmVyXCIsXCJkb2NcIjpcIkEgc2luZ2xlIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcGFpci5cIn19fSxcImxheWVyXCI6e1wiaWRcIjp7XCJ0eXBlXCI6XCJzdHJpbmdcIixcImRvY1wiOlwiVW5pcXVlIGxheWVyIG5hbWUuXCIsXCJyZXF1aXJlZFwiOnRydWV9LFwidHlwZVwiOntcInR5cGVcIjpcImVudW1cIixcInZhbHVlc1wiOltcImZpbGxcIixcImxpbmVcIixcInN5bWJvbFwiLFwiY2lyY2xlXCIsXCJyYXN0ZXJcIixcImJhY2tncm91bmRcIixcImV4dHJ1c2lvblwiXSxcImRvY1wiOlwiUmVuZGVyaW5nIHR5cGUgb2YgdGhpcyBsYXllci5cIn0sXCJtZXRhZGF0YVwiOntcInR5cGVcIjpcIipcIixcImRvY1wiOlwiQXJiaXRyYXJ5IHByb3BlcnRpZXMgdXNlZnVsIHRvIHRyYWNrIHdpdGggdGhlIGxheWVyLCBidXQgZG8gbm90IGluZmx1ZW5jZSByZW5kZXJpbmcuIFByb3BlcnRpZXMgc2hvdWxkIGJlIHByZWZpeGVkIHRvIGF2b2lkIGNvbGxpc2lvbnMsIGxpa2UgJ21hcGJveDonLlwifSxcInJlZlwiOntcInR5cGVcIjpcInN0cmluZ1wiLFwiZG9jXCI6XCJSZWZlcmVuY2VzIGFub3RoZXIgbGF5ZXIgdG8gY29weSBgdHlwZWAsIGBzb3VyY2VgLCBgc291cmNlLWxheWVyYCwgYG1pbnpvb21gLCBgbWF4em9vbWAsIGBmaWx0ZXJgLCBhbmQgYGxheW91dGAgcHJvcGVydGllcyBmcm9tLiBUaGlzIGFsbG93cyB0aGUgbGF5ZXJzIHRvIHNoYXJlIHByb2Nlc3NpbmcgYW5kIGJlIG1vcmUgZWZmaWNpZW50LlwifSxcInNvdXJjZVwiOntcInR5cGVcIjpcInN0cmluZ1wiLFwiZG9jXCI6XCJOYW1lIG9mIGEgc291cmNlIGRlc2NyaXB0aW9uIHRvIGJlIHVzZWQgZm9yIHRoaXMgbGF5ZXIuXCJ9LFwic291cmNlLWxheWVyXCI6e1widHlwZVwiOlwic3RyaW5nXCIsXCJkb2NcIjpcIkxheWVyIHRvIHVzZSBmcm9tIGEgdmVjdG9yIHRpbGUgc291cmNlLiBSZXF1aXJlZCBpZiB0aGUgc291cmNlIHN1cHBvcnRzIG11bHRpcGxlIGxheWVycy5cIn0sXCJtaW56b29tXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJtaW5pbXVtXCI6MCxcIm1heGltdW1cIjoyMixcImRvY1wiOlwiVGhlIG1pbmltdW0gem9vbSBsZXZlbCBvbiB3aGljaCB0aGUgbGF5ZXIgZ2V0cyBwYXJzZWQgYW5kIGFwcGVhcnMgb24uXCJ9LFwibWF4em9vbVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwibWluaW11bVwiOjAsXCJtYXhpbXVtXCI6MjIsXCJkb2NcIjpcIlRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgb24gd2hpY2ggdGhlIGxheWVyIGdldHMgcGFyc2VkIGFuZCBhcHBlYXJzIG9uLlwifSxcImludGVyYWN0aXZlXCI6e1widHlwZVwiOlwiYm9vbGVhblwiLFwiZG9jXCI6XCJFbmFibGUgcXVlcnlpbmcgb2YgZmVhdHVyZSBkYXRhIGZyb20gdGhpcyBsYXllciBmb3IgaW50ZXJhY3Rpdml0eS5cIixcImRlZmF1bHRcIjpmYWxzZX0sXCJmaWx0ZXJcIjp7XCJ0eXBlXCI6XCJmaWx0ZXJcIixcImRvY1wiOlwiQSBleHByZXNzaW9uIHNwZWNpZnlpbmcgY29uZGl0aW9ucyBvbiBzb3VyY2UgZmVhdHVyZXMuIE9ubHkgZmVhdHVyZXMgdGhhdCBtYXRjaCB0aGUgZmlsdGVyIGFyZSBkaXNwbGF5ZWQuXCJ9LFwibGF5b3V0XCI6e1widHlwZVwiOlwibGF5b3V0XCIsXCJkb2NcIjpcIkxheW91dCBwcm9wZXJ0aWVzIGZvciB0aGUgbGF5ZXIuXCJ9LFwicGFpbnRcIjp7XCJ0eXBlXCI6XCJwYWludFwiLFwiZG9jXCI6XCJEZWZhdWx0IHBhaW50IHByb3BlcnRpZXMgZm9yIHRoaXMgbGF5ZXIuXCJ9LFwicGFpbnQuKlwiOntcInR5cGVcIjpcInBhaW50XCIsXCJkb2NcIjpcIkNsYXNzLXNwZWNpZmljIHBhaW50IHByb3BlcnRpZXMgZm9yIHRoaXMgbGF5ZXIuIFRoZSBjbGFzcyBuYW1lIGlzIHRoZSBwYXJ0IGFmdGVyIHRoZSBmaXJzdCBkb3QuXCJ9fSxcImxheW91dFwiOltcImxheW91dF9maWxsXCIsXCJsYXlvdXRfbGluZVwiLFwibGF5b3V0X2NpcmNsZVwiLFwibGF5b3V0X3N5bWJvbFwiLFwibGF5b3V0X3Jhc3RlclwiLFwibGF5b3V0X2JhY2tncm91bmRcIixcImxheW91dF9leHRydXNpb25cIl0sXCJsYXlvdXRfYmFja2dyb3VuZFwiOntcInZpc2liaWxpdHlcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInZhbHVlc1wiOltcInZpc2libGVcIixcIm5vbmVcIl0sXCJkZWZhdWx0XCI6XCJ2aXNpYmxlXCIsXCJkb2NcIjpcIlRoZSBkaXNwbGF5IG9mIHRoaXMgbGF5ZXIuIGBub25lYCBoaWRlcyB0aGlzIGxheWVyLlwiLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX19LFwibGF5b3V0X2ZpbGxcIjp7XCJ2aXNpYmlsaXR5XCI6e1widHlwZVwiOlwiZW51bVwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJ2YWx1ZXNcIjpbXCJ2aXNpYmxlXCIsXCJub25lXCJdLFwiZGVmYXVsdFwiOlwidmlzaWJsZVwiLFwiZG9jXCI6XCJUaGUgZGlzcGxheSBvZiB0aGlzIGxheWVyLiBgbm9uZWAgaGlkZXMgdGhpcyBsYXllci5cIixcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifX19fSxcImxheW91dF9leHRydXNpb25cIjp7XCJ2aXNpYmlsaXR5XCI6e1widHlwZVwiOlwiZW51bVwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJ2YWx1ZXNcIjpbXCJ2aXNpYmxlXCIsXCJub25lXCJdLFwiZGVmYXVsdFwiOlwidmlzaWJsZVwiLFwiZG9jXCI6XCJUaGUgZGlzcGxheSBvZiB0aGlzIGxheWVyLiBgbm9uZWAgaGlkZXMgdGhpcyBsYXllci5cIn19LFwibGF5b3V0X2NpcmNsZVwiOntcInZpc2liaWxpdHlcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInZhbHVlc1wiOltcInZpc2libGVcIixcIm5vbmVcIl0sXCJkZWZhdWx0XCI6XCJ2aXNpYmxlXCIsXCJkb2NcIjpcIlRoZSBkaXNwbGF5IG9mIHRoaXMgbGF5ZXIuIGBub25lYCBoaWRlcyB0aGlzIGxheWVyLlwiLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX19LFwibGF5b3V0X2xpbmVcIjp7XCJsaW5lLWNhcFwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwidmFsdWVzXCI6W1wiYnV0dFwiLFwicm91bmRcIixcInNxdWFyZVwiXSxcImRlZmF1bHRcIjpcImJ1dHRcIixcImRvY1wiOlwiVGhlIGRpc3BsYXkgb2YgbGluZSBlbmRpbmdzLlwiLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX0sXCJsaW5lLWpvaW5cIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcInZhbHVlc1wiOltcImJldmVsXCIsXCJyb3VuZFwiLFwibWl0ZXJcIl0sXCJkZWZhdWx0XCI6XCJtaXRlclwiLFwiZG9jXCI6XCJUaGUgZGlzcGxheSBvZiBsaW5lcyB3aGVuIGpvaW5pbmcuXCIsXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcImxpbmUtbWl0ZXItbGltaXRcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjoyLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJwcm9wZXJ0eS1mdW5jdGlvblwiOnRydWUsXCJkb2NcIjpcIlVzZWQgdG8gYXV0b21hdGljYWxseSBjb252ZXJ0IG1pdGVyIGpvaW5zIHRvIGJldmVsIGpvaW5zIGZvciBzaGFycCBhbmdsZXMuXCIsXCJyZXF1aXJlc1wiOlt7XCJsaW5lLWpvaW5cIjpcIm1pdGVyXCJ9XSxcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifX19LFwibGluZS1yb3VuZC1saW1pdFwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjEuMDUsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcImRvY1wiOlwiVXNlZCB0byBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgcm91bmQgam9pbnMgdG8gbWl0ZXIgam9pbnMgZm9yIHNoYWxsb3cgYW5nbGVzLlwiLFwicmVxdWlyZXNcIjpbe1wibGluZS1qb2luXCI6XCJyb3VuZFwifV0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcInZpc2liaWxpdHlcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInZhbHVlc1wiOltcInZpc2libGVcIixcIm5vbmVcIl0sXCJkZWZhdWx0XCI6XCJ2aXNpYmxlXCIsXCJkb2NcIjpcIlRoZSBkaXNwbGF5IG9mIHRoaXMgbGF5ZXIuIGBub25lYCBoaWRlcyB0aGlzIGxheWVyLlwiLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX19LFwibGF5b3V0X3N5bWJvbFwiOntcInN5bWJvbC1wbGFjZW1lbnRcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcInZhbHVlc1wiOltcInBvaW50XCIsXCJsaW5lXCJdLFwiZGVmYXVsdFwiOlwicG9pbnRcIixcImRvY1wiOlwiTGFiZWwgcGxhY2VtZW50IHJlbGF0aXZlIHRvIGl0cyBnZW9tZXRyeS4gYGxpbmVgIGNhbiBvbmx5IGJlIHVzZWQgb24gTGluZVN0cmluZ3MgYW5kIFBvbHlnb25zLlwiLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX0sXCJzeW1ib2wtc3BhY2luZ1wiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjI1MCxcIm1pbmltdW1cIjoxLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJwcm9wZXJ0eS1mdW5jdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCIsXCJkb2NcIjpcIkRpc3RhbmNlIGJldHdlZW4gdHdvIHN5bWJvbCBhbmNob3JzLlwiLFwicmVxdWlyZXNcIjpbe1wic3ltYm9sLXBsYWNlbWVudFwiOlwibGluZVwifV0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcInN5bWJvbC1hdm9pZC1lZGdlc1wiOntcInR5cGVcIjpcImJvb2xlYW5cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwiZGVmYXVsdFwiOmZhbHNlLFwiZG9jXCI6XCJJZiB0cnVlLCB0aGUgc3ltYm9scyB3aWxsIG5vdCBjcm9zcyB0aWxlIGVkZ2VzIHRvIGF2b2lkIG11dHVhbCBjb2xsaXNpb25zLiBSZWNvbW1lbmRlZCBpbiBsYXllcnMgdGhhdCBkb24ndCBoYXZlIGVub3VnaCBwYWRkaW5nIGluIHRoZSB2ZWN0b3IgdGlsZSB0byBwcmV2ZW50IGNvbGxpc2lvbnMsIG9yIGlmIGl0IGlzIGEgcG9pbnQgc3ltYm9sIGxheWVyIHBsYWNlZCBhZnRlciBhIGxpbmUgc3ltYm9sIGxheWVyLlwiLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX0sXCJpY29uLWFsbG93LW92ZXJsYXBcIjp7XCJ0eXBlXCI6XCJib29sZWFuXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcImRlZmF1bHRcIjpmYWxzZSxcImRvY1wiOlwiSWYgdHJ1ZSwgdGhlIGljb24gd2lsbCBiZSB2aXNpYmxlIGV2ZW4gaWYgaXQgY29sbGlkZXMgd2l0aCBvdGhlciBwcmV2aW91c2x5IGRyYXduIHN5bWJvbHMuXCIsXCJyZXF1aXJlc1wiOltcImljb24taW1hZ2VcIl0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcImljb24taWdub3JlLXBsYWNlbWVudFwiOntcInR5cGVcIjpcImJvb2xlYW5cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwiZGVmYXVsdFwiOmZhbHNlLFwiZG9jXCI6XCJJZiB0cnVlLCBvdGhlciBzeW1ib2xzIGNhbiBiZSB2aXNpYmxlIGV2ZW4gaWYgdGhleSBjb2xsaWRlIHdpdGggdGhlIGljb24uXCIsXCJyZXF1aXJlc1wiOltcImljb24taW1hZ2VcIl0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcImljb24tb3B0aW9uYWxcIjp7XCJ0eXBlXCI6XCJib29sZWFuXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcImRlZmF1bHRcIjpmYWxzZSxcImRvY1wiOlwiSWYgdHJ1ZSwgdGV4dCB3aWxsIGRpc3BsYXkgd2l0aG91dCB0aGVpciBjb3JyZXNwb25kaW5nIGljb25zIHdoZW4gdGhlIGljb24gY29sbGlkZXMgd2l0aCBvdGhlciBzeW1ib2xzIGFuZCB0aGUgdGV4dCBkb2VzIG5vdC5cIixcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiLFwidGV4dC1maWVsZFwiXSxcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifX19LFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcInZhbHVlc1wiOltcIm1hcFwiLFwidmlld3BvcnRcIl0sXCJkZWZhdWx0XCI6XCJ2aWV3cG9ydFwiLFwiZG9jXCI6XCJPcmllbnRhdGlvbiBvZiBpY29uIHdoZW4gbWFwIGlzIHJvdGF0ZWQuXCIsXCJyZXF1aXJlc1wiOltcImljb24taW1hZ2VcIl0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcImljb24tc2l6ZVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjEsXCJtaW5pbXVtXCI6MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwiZG9jXCI6XCJTY2FsZSBmYWN0b3IgZm9yIGljb24uIDEgaXMgb3JpZ2luYWwgc2l6ZSwgMyB0cmlwbGVzIHRoZSBzaXplLlwiLFwicmVxdWlyZXNcIjpbXCJpY29uLWltYWdlXCJdLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX0sXCJpY29uLXRleHQtZml0XCI6e1widHlwZVwiOlwiZW51bVwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJwcm9wZXJ0eS1mdW5jdGlvblwiOmZhbHNlLFwidmFsdWVzXCI6W1wibm9uZVwiLFwiYm90aFwiLFwid2lkdGhcIixcImhlaWdodFwiXSxcImRlZmF1bHRcIjpcIm5vbmVcIixcImRvY1wiOlwiUG9zaXRpb24gYW5kIHNjYWxlIGFuIGljb24gYnkgdGhlIGl0cyBjb3JyZXNwb25kaW5nIHRleHQuXCIsXCJyZXF1aXJlc1wiOltcImljb24taW1hZ2VcIixcInRleHQtZmllbGRcIl0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMjEuMFwifX19LFwiaWNvbi10ZXh0LWZpdC1wYWRkaW5nXCI6e1widHlwZVwiOlwiYXJyYXlcIixcInZhbHVlXCI6XCJudW1iZXJcIixcImxlbmd0aFwiOjQsXCJkZWZhdWx0XCI6WzAsMCwwLDBdLFwidW5pdHNcIjpcInBpeGVsc1wiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJwcm9wZXJ0eS1mdW5jdGlvblwiOnRydWUsXCJkb2NcIjpcIlNpemUgb2YgcGFkZGluZyBhcmVhIGFyb3VuZCB0aGUgdGV4dC1maXQgc2l6ZSBpbiBjbG9ja3dpc2Ugb3JkZXI6IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdC5cIixcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiLFwiaWNvbi10ZXh0LWZpdFwiLFwidGV4dC1maWVsZFwiXSxcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4yMS4wXCJ9fX0sXCJpY29uLWltYWdlXCI6e1widHlwZVwiOlwic3RyaW5nXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcImRvY1wiOlwiQSBzdHJpbmcgd2l0aCB7dG9rZW5zfSByZXBsYWNlZCwgcmVmZXJlbmNpbmcgdGhlIGRhdGEgcHJvcGVydHkgdG8gcHVsbCBmcm9tLlwiLFwidG9rZW5zXCI6dHJ1ZSxcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifX19LFwiaWNvbi1yb3RhdGVcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwicGVyaW9kXCI6MzYwLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJwcm9wZXJ0eS1mdW5jdGlvblwiOnRydWUsXCJ1bml0c1wiOlwiZGVncmVlc1wiLFwiZG9jXCI6XCJSb3RhdGVzIHRoZSBpY29uIGNsb2Nrd2lzZS5cIixcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiXSxcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6e1wianNcIjpcIjAuMjEuMFwifX19LFwiaWNvbi1wYWRkaW5nXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MixcIm1pbmltdW1cIjowLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJwcm9wZXJ0eS1mdW5jdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCIsXCJkb2NcIjpcIlNpemUgb2YgdGhlIGFkZGl0aW9uYWwgYXJlYSBhcm91bmQgdGhlIGljb24gYm91bmRpbmcgYm94IHVzZWQgZm9yIGRldGVjdGluZyBzeW1ib2wgY29sbGlzaW9ucy5cIixcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiXSxcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifX19LFwiaWNvbi1rZWVwLXVwcmlnaHRcIjp7XCJ0eXBlXCI6XCJib29sZWFuXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcImRlZmF1bHRcIjpmYWxzZSxcImRvY1wiOlwiSWYgdHJ1ZSwgdGhlIGljb24gbWF5IGJlIGZsaXBwZWQgdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIHJlbmRlcmVkIHVwc2lkZS1kb3duLlwiLFwicmVxdWlyZXNcIjpbXCJpY29uLWltYWdlXCIse1wiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIjpcIm1hcFwifSx7XCJzeW1ib2wtcGxhY2VtZW50XCI6XCJsaW5lXCJ9XSxcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifX19LFwiaWNvbi1vZmZzZXRcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwidmFsdWVcIjpcIm51bWJlclwiLFwibGVuZ3RoXCI6MixcImRlZmF1bHRcIjpbMCwwXSxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwiZG9jXCI6XCJPZmZzZXQgZGlzdGFuY2Ugb2YgaWNvbiBmcm9tIGl0cyBhbmNob3IuIFBvc2l0aXZlIHZhbHVlcyBpbmRpY2F0ZSByaWdodCBhbmQgZG93biwgd2hpbGUgbmVnYXRpdmUgdmFsdWVzIGluZGljYXRlIGxlZnQgYW5kIHVwLlwiLFwicmVxdWlyZXNcIjpbXCJpY29uLWltYWdlXCJdLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX0sXCJ0ZXh0LXBpdGNoLWFsaWdubWVudFwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwidmFsdWVzXCI6W1wibWFwXCIsXCJ2aWV3cG9ydFwiXSxcImRvY1wiOlwiQWxpZ25zIHRleHQgdG8gdGhlIHBsYW5lIG9mIHRoZSBgdmlld3BvcnRgIG9yIHRoZSBgbWFwYCB3aGVuIHRoZSBtYXAgaXMgcGl0Y2hlZC4gTWF0Y2hlcyBgdGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRgIGlmIHVuc3BlY2lmaWVkLlwiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjIxLjBcIn19fSxcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCI6e1widHlwZVwiOlwiZW51bVwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJwcm9wZXJ0eS1mdW5jdGlvblwiOnRydWUsXCJ2YWx1ZXNcIjpbXCJtYXBcIixcInZpZXdwb3J0XCJdLFwiZGVmYXVsdFwiOlwidmlld3BvcnRcIixcImRvY1wiOlwiT3JpZW50YXRpb24gb2YgdGV4dCB3aGVuIG1hcCBpcyByb3RhdGVkLlwiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX0sXCJ0ZXh0LWZpZWxkXCI6e1widHlwZVwiOlwic3RyaW5nXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcImRlZmF1bHRcIjpcIlwiLFwidG9rZW5zXCI6dHJ1ZSxcImRvY1wiOlwiVmFsdWUgdG8gdXNlIGZvciBhIHRleHQgbGFiZWwuIEZlYXR1cmUgcHJvcGVydGllcyBhcmUgc3BlY2lmaWVkIHVzaW5nIHRva2VucyBsaWtlIHtmaWVsZF9uYW1lfS5cIixcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifX19LFwidGV4dC1mb250XCI6e1widHlwZVwiOlwiYXJyYXlcIixcInZhbHVlXCI6XCJzdHJpbmdcIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwiZGVmYXVsdFwiOltcIk9wZW4gU2FucyBSZWd1bGFyXCIsXCJBcmlhbCBVbmljb2RlIE1TIFJlZ3VsYXJcIl0sXCJkb2NcIjpcIkZvbnQgc3RhY2sgdG8gdXNlIGZvciBkaXNwbGF5aW5nIHRleHQuXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcInRleHQtc2l6ZVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjE2LFwibWluaW11bVwiOjAsXCJ1bml0c1wiOlwicGl4ZWxzXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcImRvY1wiOlwiRm9udCBzaXplLlwiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX0sXCJ0ZXh0LW1heC13aWR0aFwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjEwLFwibWluaW11bVwiOjAsXCJ1bml0c1wiOlwiZW1cIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwiZG9jXCI6XCJUaGUgbWF4aW11bSBsaW5lIHdpZHRoIGZvciB0ZXh0IHdyYXBwaW5nLlwiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX0sXCJ0ZXh0LWxpbmUtaGVpZ2h0XCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MS4yLFwidW5pdHNcIjpcImVtXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcImRvY1wiOlwiVGV4dCBsZWFkaW5nIHZhbHVlIGZvciBtdWx0aS1saW5lIHRleHQuXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcInRleHQtbGV0dGVyLXNwYWNpbmdcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwidW5pdHNcIjpcImVtXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcImRvY1wiOlwiVGV4dCB0cmFja2luZyBhbW91bnQuXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcInRleHQtanVzdGlmeVwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwidmFsdWVzXCI6W1wibGVmdFwiLFwiY2VudGVyXCIsXCJyaWdodFwiXSxcImRlZmF1bHRcIjpcImNlbnRlclwiLFwiZG9jXCI6XCJUZXh0IGp1c3RpZmljYXRpb24gb3B0aW9ucy5cIixcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXSxcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifX19LFwidGV4dC1hbmNob3JcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcInZhbHVlc1wiOltcImNlbnRlclwiLFwibGVmdFwiLFwicmlnaHRcIixcInRvcFwiLFwiYm90dG9tXCIsXCJ0b3AtbGVmdFwiLFwidG9wLXJpZ2h0XCIsXCJib3R0b20tbGVmdFwiLFwiYm90dG9tLXJpZ2h0XCJdLFwiZGVmYXVsdFwiOlwiY2VudGVyXCIsXCJkb2NcIjpcIlBhcnQgb2YgdGhlIHRleHQgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIixcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXSxcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifX19LFwidGV4dC1tYXgtYW5nbGVcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjo0NSxcInVuaXRzXCI6XCJkZWdyZWVzXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcImRvY1wiOlwiTWF4aW11bSBhbmdsZSBjaGFuZ2UgYmV0d2VlbiBhZGphY2VudCBjaGFyYWN0ZXJzLlwiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCIse1wic3ltYm9sLXBsYWNlbWVudFwiOlwibGluZVwifV0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcInRleHQtcm90YXRlXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcInBlcmlvZFwiOjM2MCxcInVuaXRzXCI6XCJkZWdyZWVzXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcImRvY1wiOlwiUm90YXRlcyB0aGUgdGV4dCBjbG9ja3dpc2UuXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcInRleHQtcGFkZGluZ1wiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjIsXCJtaW5pbXVtXCI6MCxcInVuaXRzXCI6XCJwaXhlbHNcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwiZG9jXCI6XCJTaXplIG9mIHRoZSBhZGRpdGlvbmFsIGFyZWEgYXJvdW5kIHRoZSB0ZXh0IGJvdW5kaW5nIGJveCB1c2VkIGZvciBkZXRlY3Rpbmcgc3ltYm9sIGNvbGxpc2lvbnMuXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcInRleHQta2VlcC11cHJpZ2h0XCI6e1widHlwZVwiOlwiYm9vbGVhblwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJwcm9wZXJ0eS1mdW5jdGlvblwiOnRydWUsXCJkZWZhdWx0XCI6dHJ1ZSxcImRvY1wiOlwiSWYgdHJ1ZSwgdGhlIHRleHQgbWF5IGJlIGZsaXBwZWQgdmVydGljYWxseSB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVuZGVyZWQgdXBzaWRlLWRvd24uXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIix7XCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiOlwibWFwXCJ9LHtcInN5bWJvbC1wbGFjZW1lbnRcIjpcImxpbmVcIn1dLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX0sXCJ0ZXh0LXRyYW5zZm9ybVwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwidmFsdWVzXCI6W1wibm9uZVwiLFwidXBwZXJjYXNlXCIsXCJsb3dlcmNhc2VcIl0sXCJkZWZhdWx0XCI6XCJub25lXCIsXCJkb2NcIjpcIlNwZWNpZmllcyBob3cgdG8gY2FwaXRhbGl6ZSB0ZXh0LCBzaW1pbGFyIHRvIHRoZSBDU1MgYHRleHQtdHJhbnNmb3JtYCBwcm9wZXJ0eS5cIixcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXSxcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifX19LFwidGV4dC1vZmZzZXRcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwiZG9jXCI6XCJPZmZzZXQgZGlzdGFuY2Ugb2YgdGV4dCBmcm9tIGl0cyBhbmNob3IuIFBvc2l0aXZlIHZhbHVlcyBpbmRpY2F0ZSByaWdodCBhbmQgZG93biwgd2hpbGUgbmVnYXRpdmUgdmFsdWVzIGluZGljYXRlIGxlZnQgYW5kIHVwLlwiLFwidmFsdWVcIjpcIm51bWJlclwiLFwidW5pdHNcIjpcImVtc1wiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJwcm9wZXJ0eS1mdW5jdGlvblwiOnRydWUsXCJsZW5ndGhcIjoyLFwiZGVmYXVsdFwiOlswLDBdLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX0sXCJ0ZXh0LWFsbG93LW92ZXJsYXBcIjp7XCJ0eXBlXCI6XCJib29sZWFuXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcImRlZmF1bHRcIjpmYWxzZSxcImRvY1wiOlwiSWYgdHJ1ZSwgdGhlIHRleHQgd2lsbCBiZSB2aXNpYmxlIGV2ZW4gaWYgaXQgY29sbGlkZXMgd2l0aCBvdGhlciBwcmV2aW91c2x5IGRyYXduIHN5bWJvbHMuXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcInRleHQtaWdub3JlLXBsYWNlbWVudFwiOntcInR5cGVcIjpcImJvb2xlYW5cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwiZGVmYXVsdFwiOmZhbHNlLFwiZG9jXCI6XCJJZiB0cnVlLCBvdGhlciBzeW1ib2xzIGNhbiBiZSB2aXNpYmxlIGV2ZW4gaWYgdGhleSBjb2xsaWRlIHdpdGggdGhlIHRleHQuXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcInRleHQtb3B0aW9uYWxcIjp7XCJ0eXBlXCI6XCJib29sZWFuXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcImRlZmF1bHRcIjpmYWxzZSxcImRvY1wiOlwiSWYgdHJ1ZSwgaWNvbnMgd2lsbCBkaXNwbGF5IHdpdGhvdXQgdGhlaXIgY29ycmVzcG9uZGluZyB0ZXh0IHdoZW4gdGhlIHRleHQgY29sbGlkZXMgd2l0aCBvdGhlciBzeW1ib2xzIGFuZCB0aGUgaWNvbiBkb2VzIG5vdC5cIixcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiLFwiaWNvbi1pbWFnZVwiXSxcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifX19LFwidmlzaWJpbGl0eVwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwidmFsdWVzXCI6W1widmlzaWJsZVwiLFwibm9uZVwiXSxcImRlZmF1bHRcIjpcInZpc2libGVcIixcImRvY1wiOlwiVGhlIGRpc3BsYXkgb2YgdGhpcyBsYXllci4gYG5vbmVgIGhpZGVzIHRoaXMgbGF5ZXIuXCIsXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fX0sXCIkcm9vdFwiOntcInZlcnNpb25cIjp7XCJyZXF1aXJlZFwiOnRydWUsXCJ0eXBlXCI6XCJlbnVtXCIsXCJ2YWx1ZXNcIjpbOF0sXCJkb2NcIjpcIlN0eWxlIHNwZWNpZmljYXRpb24gdmVyc2lvbiBudW1iZXIuIE11c3QgYmUgOC5cIixcImV4YW1wbGVcIjo4fSxcIm5hbWVcIjp7XCJ0eXBlXCI6XCJzdHJpbmdcIixcImRvY1wiOlwiQSBodW1hbi1yZWFkYWJsZSBuYW1lIGZvciB0aGUgc3R5bGUuXCIsXCJleGFtcGxlXCI6XCJCcmlnaHRcIn0sXCJtZXRhZGF0YVwiOntcInR5cGVcIjpcIipcIixcImRvY1wiOlwiQXJiaXRyYXJ5IHByb3BlcnRpZXMgdXNlZnVsIHRvIHRyYWNrIHdpdGggdGhlIHN0eWxlc2hlZXQsIGJ1dCBkbyBub3QgaW5mbHVlbmNlIHJlbmRlcmluZy4gUHJvcGVydGllcyBzaG91bGQgYmUgcHJlZml4ZWQgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSAnbWFwYm94OicuXCJ9LFwiY2VudGVyXCI6e1widHlwZVwiOlwiYXJyYXlcIixcInZhbHVlXCI6XCJudW1iZXJcIixcImRvY1wiOlwiRGVmYXVsdCBtYXAgY2VudGVyIGluIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUuICBUaGUgc3R5bGUgY2VudGVyIHdpbGwgYmUgdXNlZCBvbmx5IGlmIHRoZSBtYXAgaGFzIG5vdCBiZWVuIHBvc2l0aW9uZWQgYnkgb3RoZXIgbWVhbnMgKGUuZy4gbWFwIG9wdGlvbnMgb3IgdXNlciBpbnRlcmFjdGlvbikuXCIsXCJleGFtcGxlXCI6Wy03My45NzQ5LDQwLjc3MzZdfSxcInpvb21cIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRvY1wiOlwiRGVmYXVsdCB6b29tIGxldmVsLiAgVGhlIHN0eWxlIHpvb20gd2lsbCBiZSB1c2VkIG9ubHkgaWYgdGhlIG1hcCBoYXMgbm90IGJlZW4gcG9zaXRpb25lZCBieSBvdGhlciBtZWFucyAoZS5nLiBtYXAgb3B0aW9ucyBvciB1c2VyIGludGVyYWN0aW9uKS5cIixcImV4YW1wbGVcIjoxMi41fSxcImJlYXJpbmdcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwicGVyaW9kXCI6MzYwLFwidW5pdHNcIjpcImRlZ3JlZXNcIixcImRvY1wiOlwiRGVmYXVsdCBiZWFyaW5nLCBpbiBkZWdyZWVzLiAgVGhlIHN0eWxlIGJlYXJpbmcgd2lsbCBiZSB1c2VkIG9ubHkgaWYgdGhlIG1hcCBoYXMgbm90IGJlZW4gcG9zaXRpb25lZCBieSBvdGhlciBtZWFucyAoZS5nLiBtYXAgb3B0aW9ucyBvciB1c2VyIGludGVyYWN0aW9uKS5cIixcImV4YW1wbGVcIjoyOX0sXCJwaXRjaFwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjAsXCJ1bml0c1wiOlwiZGVncmVlc1wiLFwiZG9jXCI6XCJEZWZhdWx0IHBpdGNoLCBpbiBkZWdyZWVzLiBaZXJvIGlzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIHN1cmZhY2UuICBUaGUgc3R5bGUgcGl0Y2ggd2lsbCBiZSB1c2VkIG9ubHkgaWYgdGhlIG1hcCBoYXMgbm90IGJlZW4gcG9zaXRpb25lZCBieSBvdGhlciBtZWFucyAoZS5nLiBtYXAgb3B0aW9ucyBvciB1c2VyIGludGVyYWN0aW9uKS5cIixcImV4YW1wbGVcIjo1MH0sXCJsaWdodFwiOntcImxpZ2h0LWFuY2hvclwiOntcInR5cGVcIjpcImVudW1cIixcImRlZmF1bHRcIjpcInZpZXdwb3J0XCIsXCJ2YWx1ZXNcIjpbXCJtYXBcIixcInZpZXdwb3J0XCJdLFwiZG9jXCI6XCJXaGV0aGVyIGV4dHJ1c2lvbnMgYXJlIGxpdCByZWxhdGl2ZSB0byBtYXAgb3Igdmlld3BvcnQuIFRoZSBsaWdodC1hbmNob3IgcHJvcGVydHkgd2lsbCBvbmx5IGJlIHVzZWQgaWYgaXQgaGFzIG5vdCBiZWVuIHNldCBieSBtYXAgb3B0aW9ucyB1cG9uIGluaXRpYWxpemF0aW9uLlwiLFwiZXhhbXBsZVwiOlwibWFwXCJ9LFwibGlnaHQtZGlyZWN0aW9uXCI6e1widHlwZVwiOlwiYXJyYXlcIixcInZhbHVlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjpbLTAuNSwtMC4zLDFdLFwiZG9jXCI6XCJMaWdodCBkaXJlY3Rpb24gZm9yIGxpZ2h0aW5nIGV4dHJ1c2lvbnMgIyNUT0RPIyMuIFRoZSBsaWdodC1kaXJlY3Rpb24gcHJvcGVydHkgd2lsbCBvbmx5IGJlIHVzZWQgaWYgaXQgaGFzIG5vdCBiZWVuIHNldCBieSBtYXAgb3B0aW9ucyB1cG9uIGluaXRpYWxpemF0aW9uLlwiLFwiZXhhbXBsZVwiOlswLjUsLTAuMiwxXX0sXCJsaWdodC1jb2xvclwiOntcInR5cGVcIjpcImNvbG9yXCIsXCJkZWZhdWx0XCI6XCJyZ2JhKDEsMSwxLDAuNzUpXCIsXCJkb2NcIjpcIkNvbG9yIHRpbnQgZm9yIGxpZ2h0aW5nIGV4dHJ1c2lvbnMuIFRoZSBsaWdodC1jb2xvciBwcm9wZXJ0eSB3aWxsIG9ubHkgYmUgdXNlZCBpZiBpdCBoYXMgbm90IGJlZW4gc2V0IGJ5IG1hcCBvcHRpb25zIHVwb24gaW5pdGlhbGl6YXRpb24uXCIsXCJleGFtcGxlXCI6XCIjIyBUT0RPIEBuaWNraWRsdWdhc2ggd2hhdCdzIGEgZ29vZCBsaWdodCBjb2xvcj9cIn19LFwic291cmNlc1wiOntcInJlcXVpcmVkXCI6dHJ1ZSxcInR5cGVcIjpcInNvdXJjZXNcIixcImRvY1wiOlwiRGF0YSBzb3VyY2Ugc3BlY2lmaWNhdGlvbnMuXCIsXCJleGFtcGxlXCI6e1wibWFwYm94LXN0cmVldHNcIjp7XCJ0eXBlXCI6XCJ2ZWN0b3JcIixcInVybFwiOlwibWFwYm94Oi8vbWFwYm94Lm1hcGJveC1zdHJlZXRzLXY2XCJ9fX0sXCJzcHJpdGVcIjp7XCJ0eXBlXCI6XCJzdHJpbmdcIixcImRvY1wiOlwiQSBiYXNlIFVSTCBmb3IgcmV0cmlldmluZyB0aGUgc3ByaXRlIGltYWdlIGFuZCBtZXRhZGF0YS4gVGhlIGV4dGVuc2lvbnMgYC5wbmdgLCBgLmpzb25gIGFuZCBzY2FsZSBmYWN0b3IgYEAyeC5wbmdgIHdpbGwgYmUgYXV0b21hdGljYWxseSBhcHBlbmRlZC4gVGhpcyBwcm9wZXJ0eSBpcyByZXF1aXJlZCBpZiBhbnkgbGF5ZXIgdXNlcyB0aGUgJ3Nwcml0ZS1pbWFnZScgbGF5b3V0IHByb3BlcnR5LlwiLFwiZXhhbXBsZVwiOlwibWFwYm94Oi8vc3ByaXRlcy9tYXBib3gvYnJpZ2h0LXY4XCJ9LFwiZ2x5cGhzXCI6e1widHlwZVwiOlwic3RyaW5nXCIsXCJkb2NcIjpcIkEgVVJMIHRlbXBsYXRlIGZvciBsb2FkaW5nIHNpZ25lZC1kaXN0YW5jZS1maWVsZCBnbHlwaCBzZXRzIGluIFBCRiBmb3JtYXQuIFRoZSBVUkwgbXVzdCBpbmNsdWRlIGB7Zm9udHN0YWNrfWAgYW5kIGB7cmFuZ2V9YCB0b2tlbnMuIFRoaXMgcHJvcGVydHkgaXMgcmVxdWlyZWQgaWYgYW55IGxheWVyIHVzZXMgdGhlICd0ZXh0LWZpZWxkJyBsYXlvdXQgcHJvcGVydHkuXCIsXCJleGFtcGxlXCI6XCJtYXBib3g6Ly9mb250cy9tYXBib3gve2ZvbnRzdGFja30ve3JhbmdlfS5wYmZcIn0sXCJ0cmFuc2l0aW9uXCI6e1widHlwZVwiOlwidHJhbnNpdGlvblwiLFwiZG9jXCI6XCJBIGdsb2JhbCB0cmFuc2l0aW9uIGRlZmluaXRpb24gdG8gdXNlIGFzIGEgZGVmYXVsdCBhY3Jvc3MgcHJvcGVydGllcy5cIixcImV4YW1wbGVcIjp7XCJkdXJhdGlvblwiOjMwMCxcImRlbGF5XCI6MH19LFwibGF5ZXJzXCI6e1wicmVxdWlyZWRcIjp0cnVlLFwidHlwZVwiOlwiYXJyYXlcIixcInZhbHVlXCI6XCJsYXllclwiLFwiZG9jXCI6XCJMYXllcnMgd2lsbCBiZSBkcmF3biBpbiB0aGUgb3JkZXIgb2YgdGhpcyBhcnJheS5cIixcImV4YW1wbGVcIjpbe1wiaWRcIjpcIndhdGVyXCIsXCJzb3VyY2VcIjpcIm1hcGJveC1zdHJlZXRzXCIsXCJzb3VyY2UtbGF5ZXJcIjpcIndhdGVyXCIsXCJ0eXBlXCI6XCJmaWxsXCIsXCJwYWludFwiOntcImZpbGwtY29sb3JcIjpcIiMwMGZmZmZcIn19XX19LFwiZmlsdGVyXCI6e1widHlwZVwiOlwiYXJyYXlcIixcInZhbHVlXCI6XCIqXCIsXCJkb2NcIjpcIkEgZmlsdGVyIHNlbGVjdHMgc3BlY2lmaWMgZmVhdHVyZXMgZnJvbSBhIGxheWVyLlwifSxcImZpbHRlcl9vcGVyYXRvclwiOntcInR5cGVcIjpcImVudW1cIixcInZhbHVlc1wiOltcIj09XCIsXCIhPVwiLFwiPlwiLFwiPj1cIixcIjxcIixcIjw9XCIsXCJpblwiLFwiIWluXCIsXCJhbGxcIixcImFueVwiLFwibm9uZVwiLFwiaGFzXCIsXCIhaGFzXCJdLFwiZG9jXCI6XCJUaGUgZmlsdGVyIG9wZXJhdG9yLlwifSxcImdlb21ldHJ5X3R5cGVcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJ2YWx1ZXNcIjpbXCJQb2ludFwiLFwiTGluZVN0cmluZ1wiLFwiUG9seWdvblwiXSxcImRvY1wiOlwiVGhlIGdlb21ldHJ5IHR5cGUgZm9yIHRoZSBmaWx0ZXIgdG8gc2VsZWN0LlwifSxcImNvbG9yX29wZXJhdGlvblwiOntcInR5cGVcIjpcImVudW1cIixcInZhbHVlc1wiOltcImxpZ2h0ZW5cIixcInNhdHVyYXRlXCIsXCJzcGluXCIsXCJmYWRlXCIsXCJtaXhcIl0sXCJkb2NcIjpcIkEgY29sb3Igb3BlcmF0aW9uIHRvIGFwcGx5LlwifSxcImZ1bmN0aW9uXCI6e1wic3RvcHNcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwicmVxdWlyZWRcIjp0cnVlLFwiZG9jXCI6XCJBbiBhcnJheSBvZiBzdG9wcy5cIixcInZhbHVlXCI6XCJmdW5jdGlvbl9zdG9wXCJ9LFwiYmFzZVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjEsXCJtaW5pbXVtXCI6MCxcImRvY1wiOlwiVGhlIGV4cG9uZW50aWFsIGJhc2Ugb2YgdGhlIGludGVycG9sYXRpb24gY3VydmUuIEl0IGNvbnRyb2xzIHRoZSByYXRlIGF0IHdoaWNoIHRoZSByZXN1bHQgaW5jcmVhc2VzLiBIaWdoZXIgdmFsdWVzIG1ha2UgdGhlIHJlc3VsdCBpbmNyZWFzZSBtb3JlIHRvd2FyZHMgdGhlIGhpZ2ggZW5kIG9mIHRoZSByYW5nZS4gV2l0aCBgMWAgdGhlIHN0b3BzIGFyZSBpbnRlcnBvbGF0ZWQgbGluZWFybHkuXCJ9LFwicHJvcGVydHlcIjp7XCJ0eXBlXCI6XCJzdHJpbmdcIixcImRvY1wiOlwiVGhlIG5hbWUgb2YgYSBnbG9iYWwgcHJvcGVydHkgb3IgZmVhdHVyZSBwcm9wZXJ0eSB0byB1c2UgYXMgdGhlIGZ1bmN0aW9uIGlucHV0LlwiLFwiZGVmYXVsdFwiOlwiJHpvb21cIn0sXCJ0eXBlXCI6e1widHlwZVwiOlwiZW51bVwiLFwidmFsdWVzXCI6W1wiZXhwb25lbnRpYWxcIixcImludGVydmFsXCIsXCJjYXRlZ29yaWNhbFwiXSxcImRvY1wiOlwiVGhlIGludGVycG9sYXRpb24gc3RyYXRlZ3kgdG8gdXNlIGluIGZ1bmN0aW9uIGV2YWx1YXRpb24uXCIsXCJkZWZhdWx0XCI6XCJleHBvbmVudGlhbFwifX0sXCJmdW5jdGlvbl9zdG9wXCI6e1widHlwZVwiOlwiYXJyYXlcIixcIm1pbmltdW1cIjowLFwibWF4aW11bVwiOjIyLFwidmFsdWVcIjpbXCJudW1iZXJcIixcImNvbG9yXCJdLFwibGVuZ3RoXCI6MixcImRvY1wiOlwiWm9vbSBsZXZlbCBhbmQgdmFsdWUgcGFpci5cIn0sXCJwYWludFwiOltcInBhaW50X2ZpbGxcIixcInBhaW50X2V4dHJ1c2lvblwiLFwicGFpbnRfbGluZVwiLFwicGFpbnRfY2lyY2xlXCIsXCJwYWludF9zeW1ib2xcIixcInBhaW50X3Jhc3RlclwiLFwicGFpbnRfYmFja2dyb3VuZFwiXSxcInBhaW50X2ZpbGxcIjp7XCJmaWxsLWFudGlhbGlhc1wiOntcInR5cGVcIjpcImJvb2xlYW5cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwiZGVmYXVsdFwiOnRydWUsXCJkb2NcIjpcIldoZXRoZXIgb3Igbm90IHRoZSBmaWxsIHNob3VsZCBiZSBhbnRpYWxpYXNlZC5cIixcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifX19LFwiZmlsbC1vcGFjaXR5XCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcImRlZmF1bHRcIjoxLFwibWluaW11bVwiOjAsXCJtYXhpbXVtXCI6MSxcImRvY1wiOlwiVGhlIG9wYWNpdHkgb2YgdGhlIGVudGlyZSBmaWxsIGxheWVyLiBJbiBjb250cmFzdCB0byB0aGUgZmlsbC1jb2xvciwgdGhpcyB2YWx1ZSB3aWxsIGFsc28gYWZmZWN0IHRoZSAxcHggc3Ryb2tlIGFyb3VuZCB0aGUgZmlsbCwgaWYgdGhlIHN0cm9rZSBpcyB1c2VkLlwiLFwidHJhbnNpdGlvblwiOnRydWUsXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn0sXCJwcm9wZXJ0eS1mdW5jdGlvblwiOntcImpzXCI6XCIwLjIxLjBcIn19fSxcImZpbGwtY29sb3JcIjp7XCJ0eXBlXCI6XCJjb2xvclwiLFwiZGVmYXVsdFwiOlwiIzAwMDAwMFwiLFwiZG9jXCI6XCJUaGUgY29sb3Igb2YgdGhlIGZpbGxlZCBwYXJ0IG9mIHRoaXMgbGF5ZXIuIFRoaXMgY29sb3IgY2FuIGJlIHNwZWNpZmllZCBhcyByZ2JhIHdpdGggYW4gYWxwaGEgY29tcG9uZW50IGFuZCB0aGUgY29sb3IncyBvcGFjaXR5IHdpbGwgbm90IGFmZmVjdCB0aGUgb3BhY2l0eSBvZiB0aGUgMXB4IHN0cm9rZSwgaWYgaXQgaXMgdXNlZC5cIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwidHJhbnNpdGlvblwiOnRydWUsXCJyZXF1aXJlc1wiOlt7XCIhXCI6XCJmaWxsLXBhdHRlcm5cIn1dLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9LFwicHJvcGVydHktZnVuY3Rpb25cIjp7XCJqc1wiOlwiMC4xOS4wXCJ9fX0sXCJmaWxsLW91dGxpbmUtY29sb3JcIjp7XCJ0eXBlXCI6XCJjb2xvclwiLFwiZG9jXCI6XCJUaGUgb3V0bGluZSBjb2xvciBvZiB0aGUgZmlsbC4gTWF0Y2hlcyB0aGUgdmFsdWUgb2YgYGZpbGwtY29sb3JgIGlmIHVuc3BlY2lmaWVkLlwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJwcm9wZXJ0eS1mdW5jdGlvblwiOnRydWUsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInJlcXVpcmVzXCI6W3tcIiFcIjpcImZpbGwtcGF0dGVyblwifSx7XCJmaWxsLWFudGlhbGlhc1wiOnRydWV9XSxcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6e1wianNcIjpcIjAuMTkuMFwifX19LFwiZmlsbC10cmFuc2xhdGVcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwidmFsdWVcIjpcIm51bWJlclwiLFwibGVuZ3RoXCI6MixcImRlZmF1bHRcIjpbMCwwXSxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCIsXCJkb2NcIjpcIlRoZSBnZW9tZXRyeSdzIG9mZnNldC4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwLCByZXNwZWN0aXZlbHkuXCIsXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcImZpbGwtdHJhbnNsYXRlLWFuY2hvclwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwidmFsdWVzXCI6W1wibWFwXCIsXCJ2aWV3cG9ydFwiXSxcImRvY1wiOlwiQ29udHJvbCB3aGV0aGVyIHRoZSB0cmFuc2xhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgbWFwIChub3J0aCkgb3Igdmlld3BvcnQgKHNjcmVlbilcIixcImRlZmF1bHRcIjpcIm1hcFwiLFwicmVxdWlyZXNcIjpbXCJmaWxsLXRyYW5zbGF0ZVwiXSxcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifX19LFwiZmlsbC1wYXR0ZXJuXCI6e1widHlwZVwiOlwic3RyaW5nXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcInRyYW5zaXRpb25cIjp0cnVlLFwiZG9jXCI6XCJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgaW1hZ2UgZmlsbHMuIEZvciBzZWFtbGVzcyBwYXR0ZXJucywgaW1hZ2Ugd2lkdGggYW5kIGhlaWdodCBtdXN0IGJlIGEgZmFjdG9yIG9mIHR3byAoMiwgNCwgOCwgLi4uLCA1MTIpLlwiLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX19LFwicGFpbnRfZXh0cnVzaW9uXCI6e1wiZXh0cnVzaW9uLWFudGlhbGlhc1wiOntcInR5cGVcIjpcImJvb2xlYW5cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjpmYWxzZSxcImRlZmF1bHRcIjp0cnVlLFwiZG9jXCI6XCJUT0RPIFdoZXRoZXIgb3Igbm90IHRoZSBleHRydXNpb24gc2hvdWxkIGJlIGFudGlhbGlhc2VkLlwifSxcImV4dHJ1c2lvbi1sYXllci1vcGFjaXR5XCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6ZmFsc2UsXCJkZWZhdWx0XCI6MSxcIm1pbmltdW1cIjowLFwibWF4aW11bVwiOjEsXCJkb2NcIjpcIlRoZSBvcGFjaXR5IG9mIHRoZSBlbnRpcmUgZXh0cnVzaW9uIGxheWVyLiBJbiBjb250cmFzdCB0byB0aGUgZXh0cnVzaW9uLWNvbG9yLCB0aGlzIHZhbHVlIHdpbGwgYWxzbyBhZmZlY3QgdGhlIDFweCBzdHJva2UgYXJvdW5kIHRoZSBleHRydXNpb24sIGlmIHRoZSBzdHJva2UgaXMgdXNlZC5cIixcInRyYW5zaXRpb25cIjp0cnVlfSxcImV4dHJ1c2lvbi1oZWlnaHRcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwiZGVmYXVsdFwiOjMsXCJtaW5pbXVtXCI6MCxcImRvY1wiOlwiVGhlIGhlaWdodCAoaW4gIyNVTklUUyMjKSB3aXRoIHdoaWNoIHRvIGV4dHJ1ZGUgdGhpcyBsYXllci5cIixcInRyYW5zaXRpb25cIjp0cnVlfSxcImV4dHJ1c2lvbi1taW4taGVpZ2h0XCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcImRlZmF1bHRcIjowLFwibWluaW11bVwiOjAsXCJkb2NcIjpcIlRoZSBoZWlnaHQgKGluICMjVU5JVFMjIykgd2l0aCB3aGljaCB0byBleHRydWRlIHRoaXMgbGF5ZXIuXCIsXCJ0cmFuc2l0aW9uXCI6dHJ1ZX0sXCJleHRydXNpb24tY29sb3JcIjp7XCJ0eXBlXCI6XCJjb2xvclwiLFwiZGVmYXVsdFwiOlwiIzAwMDAwMFwiLFwiZG9jXCI6XCJUaGUgY29sb3Igb2YgdGhlIGV4dHJ1ZGVkIHBhcnQgb2YgdGhpcyBsYXllci4gVGhpcyBjb2xvciBjYW4gYmUgc3BlY2lmaWVkIGFzIHJnYmEgd2l0aCBhbiBhbHBoYSBjb21wb25lbnQgYW5kIHRoZSBjb2xvcidzIG9wYWNpdHkgd2lsbCBub3QgYWZmZWN0IHRoZSBvcGFjaXR5IG9mIHRoZSAxcHggc3Ryb2tlLCBpZiBpdCBpcyB1c2VkLlwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJwcm9wZXJ0eS1mdW5jdGlvblwiOnRydWUsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInJlcXVpcmVzXCI6W3tcIiFcIjpcImV4dHJ1c2lvbi1wYXR0ZXJuXCJ9XX0sXCJleHRydXNpb24tb3V0bGluZS1jb2xvclwiOntcInR5cGVcIjpcImNvbG9yXCIsXCJkb2NcIjpcIlRoZSBvdXRsaW5lIGNvbG9yIG9mIHRoZSBleHRydXNpb24uIE1hdGNoZXMgdGhlIHZhbHVlIG9mIGBleHRydXNpb24tY29sb3JgIGlmIHVuc3BlY2lmaWVkLlwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJwcm9wZXJ0eS1mdW5jdGlvblwiOnRydWUsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInJlcXVpcmVzXCI6W3tcIiFcIjpcImV4dHJ1c2lvbi1wYXR0ZXJuXCJ9LHtcImV4dHJ1c2lvbi1hbnRpYWxpYXNcIjp0cnVlfV19LFwiZXh0cnVzaW9uLXRyYW5zbGF0ZVwiOntcInR5cGVcIjpcImFycmF5XCIsXCJ2YWx1ZVwiOlwibnVtYmVyXCIsXCJsZW5ndGhcIjoyLFwiZGVmYXVsdFwiOlswLDBdLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJwcm9wZXJ0eS1mdW5jdGlvblwiOnRydWUsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInVuaXRzXCI6XCJwaXhlbHNcIixcImRvY1wiOlwiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIn0sXCJleHRydXNpb24tdHJhbnNsYXRlLWFuY2hvclwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwidmFsdWVzXCI6W1wibWFwXCIsXCJ2aWV3cG9ydFwiXSxcImRvY1wiOlwiQ29udHJvbCB3aGV0aGVyIHRoZSB0cmFuc2xhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgbWFwIChub3J0aCkgb3Igdmlld3BvcnQgKHNjcmVlbilcIixcImRlZmF1bHRcIjpcIm1hcFwiLFwicmVxdWlyZXNcIjpbXCJleHRydXNpb24tdHJhbnNsYXRlXCJdfSxcImV4dHJ1c2lvbi1wYXR0ZXJuXCI6e1widHlwZVwiOlwic3RyaW5nXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcInRyYW5zaXRpb25cIjp0cnVlLFwiZG9jXCI6XCJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgaW1hZ2UgZXh0cnVzaW9ucy4gRm9yIHNlYW1sZXNzIHBhdHRlcm5zLCBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0IG11c3QgYmUgYSBmYWN0b3Igb2YgdHdvICgyLCA0LCA4LCAuLi4sIDUxMikuXCJ9fSxcInBhaW50X2xpbmVcIjp7XCJsaW5lLW9wYWNpdHlcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRvY1wiOlwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGxpbmUgd2lsbCBiZSBkcmF3bi5cIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwiZGVmYXVsdFwiOjEsXCJtaW5pbXVtXCI6MCxcIm1heGltdW1cIjoxLFwidHJhbnNpdGlvblwiOnRydWUsXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcImxpbmUtY29sb3JcIjp7XCJ0eXBlXCI6XCJjb2xvclwiLFwiZG9jXCI6XCJUaGUgY29sb3Igd2l0aCB3aGljaCB0aGUgbGluZSB3aWxsIGJlIGRyYXduLlwiLFwiZGVmYXVsdFwiOlwiIzAwMDAwMFwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJwcm9wZXJ0eS1mdW5jdGlvblwiOnRydWUsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInJlcXVpcmVzXCI6W3tcIiFcIjpcImxpbmUtcGF0dGVyblwifV0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcImxpbmUtdHJhbnNsYXRlXCI6e1widHlwZVwiOlwiYXJyYXlcIixcInZhbHVlXCI6XCJudW1iZXJcIixcImxlbmd0aFwiOjIsXCJkZWZhdWx0XCI6WzAsMF0sXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wiLFwiZG9jXCI6XCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX0sXCJsaW5lLXRyYW5zbGF0ZS1hbmNob3JcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcInZhbHVlc1wiOltcIm1hcFwiLFwidmlld3BvcnRcIl0sXCJkb2NcIjpcIkNvbnRyb2wgd2hldGhlciB0aGUgdHJhbnNsYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIG1hcCAobm9ydGgpIG9yIHZpZXdwb3J0IChzY3JlZW4pXCIsXCJkZWZhdWx0XCI6XCJtYXBcIixcInJlcXVpcmVzXCI6W1wibGluZS10cmFuc2xhdGVcIl0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcImxpbmUtd2lkdGhcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjoxLFwibWluaW11bVwiOjAsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wiLFwiZG9jXCI6XCJTdHJva2UgdGhpY2tuZXNzLlwiLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX0sXCJsaW5lLWdhcC13aWR0aFwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjAsXCJtaW5pbXVtXCI6MCxcImRvY1wiOlwiRHJhd3MgYSBsaW5lIGNhc2luZyBvdXRzaWRlIG9mIGEgbGluZSdzIGFjdHVhbCBwYXRoLiBWYWx1ZSBpbmRpY2F0ZXMgdGhlIHdpZHRoIG9mIHRoZSBpbm5lciBnYXAuXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wiLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX0sXCJsaW5lLW9mZnNldFwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjAsXCJkb2NcIjpcIlRoZSBsaW5lJ3Mgb2Zmc2V0LiBGb3IgbGluZWFyIGZlYXR1cmVzLCBhIHBvc2l0aXZlIHZhbHVlIG9mZnNldHMgdGhlIGxpbmUgdG8gdGhlIHJpZ2h0LCByZWxhdGl2ZSB0byB0aGUgZGlyZWN0aW9uIG9mIHRoZSBsaW5lLCBhbmQgYSBuZWdhdGl2ZSB2YWx1ZSB0byB0aGUgbGVmdC4gRm9yIHBvbHlnb24gZmVhdHVyZXMsIGEgcG9zaXRpdmUgdmFsdWUgcmVzdWx0cyBpbiBhbiBpbnNldCwgYW5kIGEgbmVnYXRpdmUgdmFsdWUgcmVzdWx0cyBpbiBhbiBvdXRzZXQuXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wiLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEyLjFcIixcImlvc1wiOlwiMy4xLjBcIixcImFuZHJvaWRcIjpcIjMuMC4wXCJ9fX0sXCJsaW5lLWJsdXJcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwibWluaW11bVwiOjAsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wiLFwiZG9jXCI6XCJCbHVyIGFwcGxpZWQgdG8gdGhlIGxpbmUsIGluIHBpeGVscy5cIixcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifX19LFwibGluZS1kYXNoYXJyYXlcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwidmFsdWVcIjpcIm51bWJlclwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJwcm9wZXJ0eS1mdW5jdGlvblwiOnRydWUsXCJkb2NcIjpcIlNwZWNpZmllcyB0aGUgbGVuZ3RocyBvZiB0aGUgYWx0ZXJuYXRpbmcgZGFzaGVzIGFuZCBnYXBzIHRoYXQgZm9ybSB0aGUgZGFzaCBwYXR0ZXJuLiBUaGUgbGVuZ3RocyBhcmUgbGF0ZXIgc2NhbGVkIGJ5IHRoZSBsaW5lIHdpZHRoLiBUbyBjb252ZXJ0IGEgZGFzaCBsZW5ndGggdG8gcGl4ZWxzLCBtdWx0aXBseSB0aGUgbGVuZ3RoIGJ5IHRoZSBjdXJyZW50IGxpbmUgd2lkdGguXCIsXCJtaW5pbXVtXCI6MCxcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcImxpbmUgd2lkdGhzXCIsXCJyZXF1aXJlc1wiOlt7XCIhXCI6XCJsaW5lLXBhdHRlcm5cIn1dLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX0sXCJsaW5lLXBhdHRlcm5cIjp7XCJ0eXBlXCI6XCJzdHJpbmdcIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwidHJhbnNpdGlvblwiOnRydWUsXCJkb2NcIjpcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBpbWFnZSBsaW5lcy4gRm9yIHNlYW1sZXNzIHBhdHRlcm5zLCBpbWFnZSB3aWR0aCBtdXN0IGJlIGEgZmFjdG9yIG9mIHR3byAoMiwgNCwgOCwgLi4uLCA1MTIpLlwiLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX19LFwicGFpbnRfY2lyY2xlXCI6e1wiY2lyY2xlLXJhZGl1c1wiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjUsXCJtaW5pbXVtXCI6MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCIsXCJkb2NcIjpcIkNpcmNsZSByYWRpdXMuXCIsXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn0sXCJwcm9wZXJ0eS1mdW5jdGlvblwiOntcImpzXCI6XCIwLjE4LjBcIn19fSxcImNpcmNsZS1jb2xvclwiOntcInR5cGVcIjpcImNvbG9yXCIsXCJkZWZhdWx0XCI6XCIjMDAwMDAwXCIsXCJkb2NcIjpcIlRoZSBjb2xvciBvZiB0aGUgY2lyY2xlLlwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJwcm9wZXJ0eS1mdW5jdGlvblwiOnRydWUsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6e1wianNcIjpcIjAuMTguMFwifX19LFwiY2lyY2xlLWJsdXJcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwiZG9jXCI6XCJBbW91bnQgdG8gYmx1ciB0aGUgY2lyY2xlLiAxIGJsdXJzIHRoZSBjaXJjbGUgc3VjaCB0aGF0IG9ubHkgdGhlIGNlbnRlcnBvaW50IGlzIGZ1bGwgb3BhY2l0eS5cIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwidHJhbnNpdGlvblwiOnRydWUsXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn0sXCJwcm9wZXJ0eS1mdW5jdGlvblwiOntcImpzXCI6XCIwLjIwLjBcIn19fSxcImNpcmNsZS1vcGFjaXR5XCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkb2NcIjpcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBjaXJjbGUgd2lsbCBiZSBkcmF3bi5cIixcImRlZmF1bHRcIjoxLFwibWluaW11bVwiOjAsXCJtYXhpbXVtXCI6MSxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwidHJhbnNpdGlvblwiOnRydWUsXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn0sXCJwcm9wZXJ0eS1mdW5jdGlvblwiOntcImpzXCI6XCIwLjIwLjBcIn19fSxcImNpcmNsZS10cmFuc2xhdGVcIjp7XCJ0eXBlXCI6XCJhcnJheVwiLFwidmFsdWVcIjpcIm51bWJlclwiLFwibGVuZ3RoXCI6MixcImRlZmF1bHRcIjpbMCwwXSxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCIsXCJkb2NcIjpcIlRoZSBnZW9tZXRyeSdzIG9mZnNldC4gVmFsdWVzIGFyZSBbeCwgeV0gd2hlcmUgbmVnYXRpdmVzIGluZGljYXRlIGxlZnQgYW5kIHVwLCByZXNwZWN0aXZlbHkuXCIsXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcImNpcmNsZS10cmFuc2xhdGUtYW5jaG9yXCI6e1widHlwZVwiOlwiZW51bVwiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJwcm9wZXJ0eS1mdW5jdGlvblwiOnRydWUsXCJ2YWx1ZXNcIjpbXCJtYXBcIixcInZpZXdwb3J0XCJdLFwiZG9jXCI6XCJDb250cm9sIHdoZXRoZXIgdGhlIHRyYW5zbGF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBtYXAgKG5vcnRoKSBvciB2aWV3cG9ydCAoc2NyZWVuKVwiLFwiZGVmYXVsdFwiOlwibWFwXCIsXCJyZXF1aXJlc1wiOltcImNpcmNsZS10cmFuc2xhdGVcIl0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcImNpcmNsZS1waXRjaC1zY2FsZVwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwidmFsdWVzXCI6W1wibWFwXCIsXCJ2aWV3cG9ydFwiXSxcImRlZmF1bHRcIjpcIm1hcFwiLFwiZG9jXCI6XCJDb250cm9scyB0aGUgc2NhbGluZyBiZWhhdmlvciBvZiB0aGUgY2lyY2xlIHdoZW4gdGhlIG1hcCBpcyBwaXRjaGVkLiBUaGUgdmFsdWUgYG1hcGAgc2NhbGVzIGNpcmNsZXMgYWNjb3JkaW5nIHRvIHRoZWlyIGFwcGFyZW50IGRpc3RhbmNlIHRvIHRoZSBjYW1lcmEuIFRoZSB2YWx1ZSBgdmlld3BvcnRgIHJlc3VsdHMgaW4gbm8gcGl0Y2gtcmVsYXRlZCBzY2FsaW5nLlwiLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjIxLjBcIn19fX0sXCJwYWludF9zeW1ib2xcIjp7XCJpY29uLW9wYWNpdHlcIjp7XCJkb2NcIjpcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBpY29uIHdpbGwgYmUgZHJhd24uXCIsXCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjoxLFwibWluaW11bVwiOjAsXCJtYXhpbXVtXCI6MSxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwidHJhbnNpdGlvblwiOnRydWUsXCJyZXF1aXJlc1wiOltcImljb24taW1hZ2VcIl0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcImljb24tY29sb3JcIjp7XCJ0eXBlXCI6XCJjb2xvclwiLFwiZGVmYXVsdFwiOlwiIzAwMDAwMFwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJwcm9wZXJ0eS1mdW5jdGlvblwiOnRydWUsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcImRvY1wiOlwiVGhlIGNvbG9yIG9mIHRoZSBpY29uLiBUaGlzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBzZGYgaWNvbnMuXCIsXCJyZXF1aXJlc1wiOltcImljb24taW1hZ2VcIl0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcImljb24taGFsby1jb2xvclwiOntcInR5cGVcIjpcImNvbG9yXCIsXCJkZWZhdWx0XCI6XCJyZ2JhKDAsIDAsIDAsIDApXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcInRyYW5zaXRpb25cIjp0cnVlLFwiZG9jXCI6XCJUaGUgY29sb3Igb2YgdGhlIGljb24ncyBoYWxvLiBJY29uIGhhbG9zIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBzZGYgaWNvbnMuXCIsXCJyZXF1aXJlc1wiOltcImljb24taW1hZ2VcIl0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcImljb24taGFsby13aWR0aFwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZGVmYXVsdFwiOjAsXCJtaW5pbXVtXCI6MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwicGl4ZWxzXCIsXCJkb2NcIjpcIkRpc3RhbmNlIG9mIGhhbG8gdG8gdGhlIGljb24gb3V0bGluZS5cIixcInJlcXVpcmVzXCI6W1wiaWNvbi1pbWFnZVwiXSxcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifX19LFwiaWNvbi1oYWxvLWJsdXJcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwibWluaW11bVwiOjAsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wiLFwiZG9jXCI6XCJGYWRlIG91dCB0aGUgaGFsbyB0b3dhcmRzIHRoZSBvdXRzaWRlLlwiLFwicmVxdWlyZXNcIjpbXCJpY29uLWltYWdlXCJdLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX0sXCJpY29uLXRyYW5zbGF0ZVwiOntcInR5cGVcIjpcImFycmF5XCIsXCJ2YWx1ZVwiOlwibnVtYmVyXCIsXCJsZW5ndGhcIjoyLFwiZGVmYXVsdFwiOlswLDBdLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJwcm9wZXJ0eS1mdW5jdGlvblwiOnRydWUsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInVuaXRzXCI6XCJwaXhlbHNcIixcImRvY1wiOlwiRGlzdGFuY2UgdGhhdCB0aGUgaWNvbidzIGFuY2hvciBpcyBtb3ZlZCBmcm9tIGl0cyBvcmlnaW5hbCBwbGFjZW1lbnQuIFBvc2l0aXZlIHZhbHVlcyBpbmRpY2F0ZSByaWdodCBhbmQgZG93biwgd2hpbGUgbmVnYXRpdmUgdmFsdWVzIGluZGljYXRlIGxlZnQgYW5kIHVwLlwiLFwicmVxdWlyZXNcIjpbXCJpY29uLWltYWdlXCJdLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX0sXCJpY29uLXRyYW5zbGF0ZS1hbmNob3JcIjp7XCJ0eXBlXCI6XCJlbnVtXCIsXCJmdW5jdGlvblwiOlwicGllY2V3aXNlLWNvbnN0YW50XCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcInZhbHVlc1wiOltcIm1hcFwiLFwidmlld3BvcnRcIl0sXCJkb2NcIjpcIkNvbnRyb2wgd2hldGhlciB0aGUgdHJhbnNsYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIG1hcCAobm9ydGgpIG9yIHZpZXdwb3J0IChzY3JlZW4pLlwiLFwiZGVmYXVsdFwiOlwibWFwXCIsXCJyZXF1aXJlc1wiOltcImljb24taW1hZ2VcIixcImljb24tdHJhbnNsYXRlXCJdLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX0sXCJ0ZXh0LW9wYWNpdHlcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRvY1wiOlwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIHRleHQgd2lsbCBiZSBkcmF3bi5cIixcImRlZmF1bHRcIjoxLFwibWluaW11bVwiOjAsXCJtYXhpbXVtXCI6MSxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwidHJhbnNpdGlvblwiOnRydWUsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcInRleHQtY29sb3JcIjp7XCJ0eXBlXCI6XCJjb2xvclwiLFwiZG9jXCI6XCJUaGUgY29sb3Igd2l0aCB3aGljaCB0aGUgdGV4dCB3aWxsIGJlIGRyYXduLlwiLFwiZGVmYXVsdFwiOlwiIzAwMDAwMFwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJwcm9wZXJ0eS1mdW5jdGlvblwiOnRydWUsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiXSxcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifX19LFwidGV4dC1oYWxvLWNvbG9yXCI6e1widHlwZVwiOlwiY29sb3JcIixcImRlZmF1bHRcIjpcInJnYmEoMCwgMCwgMCwgMClcIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwidHJhbnNpdGlvblwiOnRydWUsXCJkb2NcIjpcIlRoZSBjb2xvciBvZiB0aGUgdGV4dCdzIGhhbG8sIHdoaWNoIGhlbHBzIGl0IHN0YW5kIG91dCBmcm9tIGJhY2tncm91bmRzLlwiLFwicmVxdWlyZXNcIjpbXCJ0ZXh0LWZpZWxkXCJdLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX0sXCJ0ZXh0LWhhbG8td2lkdGhcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjowLFwibWluaW11bVwiOjAsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wiLFwiZG9jXCI6XCJEaXN0YW5jZSBvZiBoYWxvIHRvIHRoZSBmb250IG91dGxpbmUuIE1heCB0ZXh0IGhhbG8gd2lkdGggaXMgMS80IG9mIHRoZSBmb250LXNpemUuXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcInRleHQtaGFsby1ibHVyXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcIm1pbmltdW1cIjowLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJwcm9wZXJ0eS1mdW5jdGlvblwiOnRydWUsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInVuaXRzXCI6XCJwaXhlbHNcIixcImRvY1wiOlwiVGhlIGhhbG8ncyBmYWRlb3V0IGRpc3RhbmNlIHRvd2FyZHMgdGhlIG91dHNpZGUuXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcInRleHQtdHJhbnNsYXRlXCI6e1widHlwZVwiOlwiYXJyYXlcIixcInZhbHVlXCI6XCJudW1iZXJcIixcImxlbmd0aFwiOjIsXCJkZWZhdWx0XCI6WzAsMF0sXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInByb3BlcnR5LWZ1bmN0aW9uXCI6dHJ1ZSxcInRyYW5zaXRpb25cIjp0cnVlLFwidW5pdHNcIjpcInBpeGVsc1wiLFwiZG9jXCI6XCJEaXN0YW5jZSB0aGF0IHRoZSB0ZXh0J3MgYW5jaG9yIGlzIG1vdmVkIGZyb20gaXRzIG9yaWdpbmFsIHBsYWNlbWVudC4gUG9zaXRpdmUgdmFsdWVzIGluZGljYXRlIHJpZ2h0IGFuZCBkb3duLCB3aGlsZSBuZWdhdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAuXCIsXCJyZXF1aXJlc1wiOltcInRleHQtZmllbGRcIl0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcInRleHQtdHJhbnNsYXRlLWFuY2hvclwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwicHJvcGVydHktZnVuY3Rpb25cIjp0cnVlLFwidmFsdWVzXCI6W1wibWFwXCIsXCJ2aWV3cG9ydFwiXSxcImRvY1wiOlwiQ29udHJvbCB3aGV0aGVyIHRoZSB0cmFuc2xhdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgbWFwIChub3J0aCkgb3Igdmlld3BvcnQgKHNjcmVlbikuXCIsXCJkZWZhdWx0XCI6XCJtYXBcIixcInJlcXVpcmVzXCI6W1widGV4dC1maWVsZFwiLFwidGV4dC10cmFuc2xhdGVcIl0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fX0sXCJwYWludF9yYXN0ZXJcIjp7XCJyYXN0ZXItb3BhY2l0eVwiOntcInR5cGVcIjpcIm51bWJlclwiLFwiZG9jXCI6XCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgaW1hZ2Ugd2lsbCBiZSBkcmF3bi5cIixcImRlZmF1bHRcIjoxLFwibWluaW11bVwiOjAsXCJtYXhpbXVtXCI6MSxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwidHJhbnNpdGlvblwiOnRydWUsXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcInJhc3Rlci1odWUtcm90YXRlXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJkZWZhdWx0XCI6MCxcInBlcmlvZFwiOjM2MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwiZGVncmVlc1wiLFwiZG9jXCI6XCJSb3RhdGVzIGh1ZXMgYXJvdW5kIHRoZSBjb2xvciB3aGVlbC5cIixcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifX19LFwicmFzdGVyLWJyaWdodG5lc3MtbWluXCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcImRvY1wiOlwiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBicmlnaHRuZXNzIG9mIHRoZSBpbWFnZS4gVGhlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIGJyaWdodG5lc3MuXCIsXCJkZWZhdWx0XCI6MCxcIm1pbmltdW1cIjowLFwibWF4aW11bVwiOjEsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifX19LFwicmFzdGVyLWJyaWdodG5lc3MtbWF4XCI6e1widHlwZVwiOlwibnVtYmVyXCIsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcImRvY1wiOlwiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBicmlnaHRuZXNzIG9mIHRoZSBpbWFnZS4gVGhlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIGJyaWdodG5lc3MuXCIsXCJkZWZhdWx0XCI6MSxcIm1pbmltdW1cIjowLFwibWF4aW11bVwiOjEsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifX19LFwicmFzdGVyLXNhdHVyYXRpb25cIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRvY1wiOlwiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBzYXR1cmF0aW9uIG9mIHRoZSBpbWFnZS5cIixcImRlZmF1bHRcIjowLFwibWluaW11bVwiOi0xLFwibWF4aW11bVwiOjEsXCJmdW5jdGlvblwiOlwiaW50ZXJwb2xhdGVkXCIsXCJ6b29tLWZ1bmN0aW9uXCI6dHJ1ZSxcInRyYW5zaXRpb25cIjp0cnVlLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX0sXCJyYXN0ZXItY29udHJhc3RcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRvY1wiOlwiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBjb250cmFzdCBvZiB0aGUgaW1hZ2UuXCIsXCJkZWZhdWx0XCI6MCxcIm1pbmltdW1cIjotMSxcIm1heGltdW1cIjoxLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInNkay1zdXBwb3J0XCI6e1wiYmFzaWNcIjp7XCJqc1wiOlwiMC4xMC4wXCIsXCJpb3NcIjpcIjIuMC4wXCIsXCJhbmRyb2lkXCI6XCIyLjAuMVwifX19LFwicmFzdGVyLWZhZGUtZHVyYXRpb25cIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjozMDAsXCJtaW5pbXVtXCI6MCxcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwidHJhbnNpdGlvblwiOnRydWUsXCJ1bml0c1wiOlwibWlsbGlzZWNvbmRzXCIsXCJkb2NcIjpcIkZhZGUgZHVyYXRpb24gd2hlbiBhIG5ldyB0aWxlIGlzIGFkZGVkLlwiLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX19LFwicGFpbnRfYmFja2dyb3VuZFwiOntcImJhY2tncm91bmQtY29sb3JcIjp7XCJ0eXBlXCI6XCJjb2xvclwiLFwiZGVmYXVsdFwiOlwiIzAwMDAwMFwiLFwiZG9jXCI6XCJUaGUgY29sb3Igd2l0aCB3aGljaCB0aGUgYmFja2dyb3VuZCB3aWxsIGJlIGRyYXduLlwiLFwiZnVuY3Rpb25cIjpcImludGVycG9sYXRlZFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcInJlcXVpcmVzXCI6W3tcIiFcIjpcImJhY2tncm91bmQtcGF0dGVyblwifV0sXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fSxcImJhY2tncm91bmQtcGF0dGVyblwiOntcInR5cGVcIjpcInN0cmluZ1wiLFwiZnVuY3Rpb25cIjpcInBpZWNld2lzZS1jb25zdGFudFwiLFwiem9vbS1mdW5jdGlvblwiOnRydWUsXCJ0cmFuc2l0aW9uXCI6dHJ1ZSxcImRvY1wiOlwiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGFuIGltYWdlIGJhY2tncm91bmQuIEZvciBzZWFtbGVzcyBwYXR0ZXJucywgaW1hZ2Ugd2lkdGggYW5kIGhlaWdodCBtdXN0IGJlIGEgZmFjdG9yIG9mIHR3byAoMiwgNCwgOCwgLi4uLCA1MTIpLlwiLFwic2RrLXN1cHBvcnRcIjp7XCJiYXNpY1wiOntcImpzXCI6XCIwLjEwLjBcIixcImlvc1wiOlwiMi4wLjBcIixcImFuZHJvaWRcIjpcIjIuMC4xXCJ9fX0sXCJiYWNrZ3JvdW5kLW9wYWNpdHlcIjp7XCJ0eXBlXCI6XCJudW1iZXJcIixcImRlZmF1bHRcIjoxLFwibWluaW11bVwiOjAsXCJtYXhpbXVtXCI6MSxcImRvY1wiOlwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGJhY2tncm91bmQgd2lsbCBiZSBkcmF3bi5cIixcImZ1bmN0aW9uXCI6XCJpbnRlcnBvbGF0ZWRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwidHJhbnNpdGlvblwiOnRydWUsXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fX0sXCJsYXlvdXRfcmFzdGVyXCI6e1widmlzaWJpbGl0eVwiOntcInR5cGVcIjpcImVudW1cIixcImZ1bmN0aW9uXCI6XCJwaWVjZXdpc2UtY29uc3RhbnRcIixcInpvb20tZnVuY3Rpb25cIjp0cnVlLFwidmFsdWVzXCI6W1widmlzaWJsZVwiLFwibm9uZVwiXSxcImRlZmF1bHRcIjpcInZpc2libGVcIixcImRvY1wiOlwiVGhlIGRpc3BsYXkgb2YgdGhpcyBsYXllci4gYG5vbmVgIGhpZGVzIHRoaXMgbGF5ZXIuXCIsXCJzZGstc3VwcG9ydFwiOntcImJhc2ljXCI6e1wianNcIjpcIjAuMTAuMFwiLFwiaW9zXCI6XCIyLjAuMFwiLFwiYW5kcm9pZFwiOlwiMi4wLjFcIn19fX19XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gaXNTdXBwb3J0ZWQ7XG59IGVsc2UgaWYgKHdpbmRvdykge1xuICAgIHdpbmRvdy5tYXBib3hnbCA9IHdpbmRvdy5tYXBib3hnbCB8fCB7fTtcbiAgICB3aW5kb3cubWFwYm94Z2wuc3VwcG9ydGVkID0gaXNTdXBwb3J0ZWQ7XG59XG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgc3VwcG9ydHMgTWFwYm94IEdMIEpTXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0PWZhbHNlXSBSZXR1cm4gYGZhbHNlYFxuICogICBpZiB0aGUgcGVyZm9ybWFuY2Ugb2YgTWFwYm94IEdMIEpTIHdvdWxkIGJlIGRyYW1hdGljYWxseSB3b3JzZSB0aGFuXG4gKiAgIGV4cGVjdGVkIChpLmUuIGEgc29mdHdhcmUgcmVuZGVyZXIgaXMgd291bGQgYmUgdXNlZClcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU3VwcG9ydGVkKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gISEoXG4gICAgICAgIGlzQnJvd3NlcigpICYmXG4gICAgICAgIGlzQXJyYXlTdXBwb3J0ZWQoKSAmJlxuICAgICAgICBpc0Z1bmN0aW9uU3VwcG9ydGVkKCkgJiZcbiAgICAgICAgaXNPYmplY3RTdXBwb3J0ZWQoKSAmJlxuICAgICAgICBpc0pTT05TdXBwb3J0ZWQoKSAmJlxuICAgICAgICBpc1dvcmtlclN1cHBvcnRlZCgpICYmXG4gICAgICAgIGlzVWludDhDbGFtcGVkQXJyYXlTdXBwb3J0ZWQoKSAmJlxuICAgICAgICBpc1dlYkdMU3VwcG9ydGVkQ2FjaGVkKG9wdGlvbnMgJiYgb3B0aW9ucy5mYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0KVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGlzQnJvd3NlcigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbn1cblxuZnVuY3Rpb24gaXNBcnJheVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICBBcnJheS5wcm90b3R5cGUgJiZcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmV2ZXJ5ICYmXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5maWx0ZXIgJiZcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggJiZcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgJiZcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mICYmXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5tYXAgJiZcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnNvbWUgJiZcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnJlZHVjZSAmJlxuICAgICAgICBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHQgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb25TdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZSAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZDtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3RTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgT2JqZWN0LmtleXMgJiZcbiAgICAgICAgT2JqZWN0LmNyZWF0ZSAmJlxuICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiZcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgJiZcbiAgICAgICAgT2JqZWN0LmlzU2VhbGVkICYmXG4gICAgICAgIE9iamVjdC5pc0Zyb3plbiAmJlxuICAgICAgICBPYmplY3QuaXNFeHRlbnNpYmxlICYmXG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiZcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzICYmXG4gICAgICAgIE9iamVjdC5zZWFsICYmXG4gICAgICAgIE9iamVjdC5mcmVlemUgJiZcbiAgICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gaXNKU09OU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAnSlNPTicgaW4gd2luZG93ICYmICdwYXJzZScgaW4gSlNPTiAmJiAnc3RyaW5naWZ5JyBpbiBKU09OO1xufVxuXG5mdW5jdGlvbiBpc1dvcmtlclN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gJ1dvcmtlcicgaW4gd2luZG93O1xufVxuXG4vLyBJRTExIG9ubHkgc3VwcG9ydHMgYFVpbnQ4Q2xhbXBlZEFycmF5YCBhcyBvZiB2ZXJzaW9uXG4vLyBbS0IyOTI5NDM3XShodHRwczovL3N1cHBvcnQubWljcm9zb2Z0LmNvbS9lbi11cy9rYi8yOTI5NDM3KVxuZnVuY3Rpb24gaXNVaW50OENsYW1wZWRBcnJheVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gJ1VpbnQ4Q2xhbXBlZEFycmF5JyBpbiB3aW5kb3c7XG59XG5cbnZhciBpc1dlYkdMU3VwcG9ydGVkQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzV2ViR0xTdXBwb3J0ZWRDYWNoZWQoZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCkge1xuXG4gICAgaWYgKGlzV2ViR0xTdXBwb3J0ZWRDYWNoZVtmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlzV2ViR0xTdXBwb3J0ZWRDYWNoZVtmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0XSA9IGlzV2ViR0xTdXBwb3J0ZWQoZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzV2ViR0xTdXBwb3J0ZWRDYWNoZVtmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0XTtcbn1cblxuaXNTdXBwb3J0ZWQud2ViR0xDb250ZXh0QXR0cmlidXRlcyA9IHtcbiAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgIGFscGhhOiB0cnVlLFxuICAgIHN0ZW5jaWw6IHRydWUsXG4gICAgZGVwdGg6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzV2ViR0xTdXBwb3J0ZWQoZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCkge1xuXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBPYmplY3QuY3JlYXRlKGlzU3VwcG9ydGVkLndlYkdMQ29udGV4dEF0dHJpYnV0ZXMpO1xuICAgIGF0dHJpYnV0ZXMuZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCA9IGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ7XG5cbiAgICBpZiAoY2FudmFzLnByb2JhYmx5U3VwcG9ydHNDb250ZXh0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjYW52YXMucHJvYmFibHlTdXBwb3J0c0NvbnRleHQoJ3dlYmdsJywgYXR0cmlidXRlcykgfHxcbiAgICAgICAgICAgIGNhbnZhcy5wcm9iYWJseVN1cHBvcnRzQ29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgYXR0cmlidXRlcylcbiAgICAgICAgKTtcblxuICAgIH0gZWxzZSBpZiAoY2FudmFzLnN1cHBvcnRzQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgY2FudmFzLnN1cHBvcnRzQ29udGV4dCgnd2ViZ2wnLCBhdHRyaWJ1dGVzKSB8fFxuICAgICAgICAgICAgY2FudmFzLnN1cHBvcnRzQ29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgYXR0cmlidXRlcylcbiAgICAgICAgKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBhdHRyaWJ1dGVzKSB8fFxuICAgICAgICAgICAgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGF0dHJpYnV0ZXMpXG4gICAgICAgICk7XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBsaWdodHdlaWdodCBCdWZmZXIgc2hpbSBmb3IgcGJmIGJyb3dzZXIgYnVpbGRcbi8vIGJhc2VkIG9uIGNvZGUgZnJvbSBnaXRodWIuY29tL2Zlcm9zcy9idWZmZXIgKE1JVC1saWNlbnNlZClcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXI7XG5cbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpO1xuXG52YXIgQnVmZmVyTWV0aG9kcztcblxuZnVuY3Rpb24gQnVmZmVyKGxlbmd0aCkge1xuICAgIHZhciBhcnI7XG4gICAgaWYgKGxlbmd0aCAmJiBsZW5ndGgubGVuZ3RoKSB7XG4gICAgICAgIGFyciA9IGxlbmd0aDtcbiAgICAgICAgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCB8fCAwKTtcbiAgICBpZiAoYXJyKSBidWYuc2V0KGFycik7XG5cbiAgICBidWYucmVhZFVJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy5yZWFkVUludDMyTEU7XG4gICAgYnVmLndyaXRlVUludDMyTEUgPSBCdWZmZXJNZXRob2RzLndyaXRlVUludDMyTEU7XG4gICAgYnVmLnJlYWRJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy5yZWFkSW50MzJMRTtcbiAgICBidWYud3JpdGVJbnQzMkxFID0gQnVmZmVyTWV0aG9kcy53cml0ZUludDMyTEU7XG4gICAgYnVmLnJlYWRGbG9hdExFID0gQnVmZmVyTWV0aG9kcy5yZWFkRmxvYXRMRTtcbiAgICBidWYud3JpdGVGbG9hdExFID0gQnVmZmVyTWV0aG9kcy53cml0ZUZsb2F0TEU7XG4gICAgYnVmLnJlYWREb3VibGVMRSA9IEJ1ZmZlck1ldGhvZHMucmVhZERvdWJsZUxFO1xuICAgIGJ1Zi53cml0ZURvdWJsZUxFID0gQnVmZmVyTWV0aG9kcy53cml0ZURvdWJsZUxFO1xuICAgIGJ1Zi50b1N0cmluZyA9IEJ1ZmZlck1ldGhvZHMudG9TdHJpbmc7XG4gICAgYnVmLndyaXRlID0gQnVmZmVyTWV0aG9kcy53cml0ZTtcbiAgICBidWYuc2xpY2UgPSBCdWZmZXJNZXRob2RzLnNsaWNlO1xuICAgIGJ1Zi5jb3B5ID0gQnVmZmVyTWV0aG9kcy5jb3B5O1xuXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWU7XG4gICAgcmV0dXJuIGJ1Zjtcbn1cblxudmFyIGxhc3RTdHIsIGxhc3RTdHJFbmNvZGVkO1xuXG5CdWZmZXJNZXRob2RzID0ge1xuICAgIHJlYWRVSW50MzJMRTogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXNbcG9zXSkgfFxuICAgICAgICAgICAgKHRoaXNbcG9zICsgMV0gPDwgOCkgfFxuICAgICAgICAgICAgKHRoaXNbcG9zICsgMl0gPDwgMTYpKSArXG4gICAgICAgICAgICAodGhpc1twb3MgKyAzXSAqIDB4MTAwMDAwMCk7XG4gICAgfSxcblxuICAgIHdyaXRlVUludDMyTEU6IGZ1bmN0aW9uKHZhbCwgcG9zKSB7XG4gICAgICAgIHRoaXNbcG9zXSA9IHZhbDtcbiAgICAgICAgdGhpc1twb3MgKyAxXSA9ICh2YWwgPj4+IDgpO1xuICAgICAgICB0aGlzW3BvcyArIDJdID0gKHZhbCA+Pj4gMTYpO1xuICAgICAgICB0aGlzW3BvcyArIDNdID0gKHZhbCA+Pj4gMjQpO1xuICAgIH0sXG5cbiAgICByZWFkSW50MzJMRTogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXNbcG9zXSkgfFxuICAgICAgICAgICAgKHRoaXNbcG9zICsgMV0gPDwgOCkgfFxuICAgICAgICAgICAgKHRoaXNbcG9zICsgMl0gPDwgMTYpKSArXG4gICAgICAgICAgICAodGhpc1twb3MgKyAzXSA8PCAyNCk7XG4gICAgfSxcblxuICAgIHJlYWRGbG9hdExFOiAgZnVuY3Rpb24ocG9zKSB7IHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgcG9zLCB0cnVlLCAyMywgNCk7IH0sXG4gICAgcmVhZERvdWJsZUxFOiBmdW5jdGlvbihwb3MpIHsgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBwb3MsIHRydWUsIDUyLCA4KTsgfSxcblxuICAgIHdyaXRlRmxvYXRMRTogIGZ1bmN0aW9uKHZhbCwgcG9zKSB7IHJldHVybiBpZWVlNzU0LndyaXRlKHRoaXMsIHZhbCwgcG9zLCB0cnVlLCAyMywgNCk7IH0sXG4gICAgd3JpdGVEb3VibGVMRTogZnVuY3Rpb24odmFsLCBwb3MpIHsgcmV0dXJuIGllZWU3NTQud3JpdGUodGhpcywgdmFsLCBwb3MsIHRydWUsIDUyLCA4KTsgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgc3RyID0gJycsXG4gICAgICAgICAgICB0bXAgPSAnJztcblxuICAgICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgICAgIGVuZCA9IE1hdGgubWluKHRoaXMubGVuZ3RoLCBlbmQgfHwgdGhpcy5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSB0aGlzW2ldO1xuICAgICAgICAgICAgaWYgKGNoIDw9IDB4N0YpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gZGVjb2RlVVJJQ29tcG9uZW50KHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgICAgICAgICB0bXAgPSAnJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG1wICs9ICclJyArIGNoLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciArPSBkZWNvZGVVUklDb21wb25lbnQodG1wKTtcblxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cbiAgICB3cml0ZTogZnVuY3Rpb24oc3RyLCBwb3MpIHtcbiAgICAgICAgdmFyIGJ5dGVzID0gc3RyID09PSBsYXN0U3RyID8gbGFzdFN0ckVuY29kZWQgOiBlbmNvZGVTdHJpbmcoc3RyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpc1twb3MgKyBpXSA9IGJ5dGVzW2ldO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNsaWNlOiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpO1xuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbihidWYsIHBvcykge1xuICAgICAgICBwb3MgPSBwb3MgfHwgMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBidWZbcG9zICsgaV0gPSB0aGlzW2ldO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuQnVmZmVyTWV0aG9kcy53cml0ZUludDMyTEUgPSBCdWZmZXJNZXRob2RzLndyaXRlVUludDMyTEU7XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgbGFzdFN0ciA9IHN0cjtcbiAgICBsYXN0U3RyRW5jb2RlZCA9IGVuY29kZVN0cmluZyhzdHIpO1xuICAgIHJldHVybiBsYXN0U3RyRW5jb2RlZC5sZW5ndGg7XG59O1xuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbihidWYpIHtcbiAgICByZXR1cm4gISEoYnVmICYmIGJ1Zi5faXNCdWZmZXIpO1xufTtcblxuZnVuY3Rpb24gZW5jb2RlU3RyaW5nKHN0cikge1xuICAgIHZhciBsZW5ndGggPSBzdHIubGVuZ3RoLFxuICAgICAgICBieXRlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGMsIGxlYWQ7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7IC8vIGNvZGUgcG9pbnRcblxuICAgICAgICBpZiAoYyA+IDB4RDdGRiAmJiBjIDwgMHhFMDAwKSB7XG5cbiAgICAgICAgICAgIGlmIChsZWFkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPCAweERDMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICAgICAgICAgICAgbGVhZCA9IGM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYyA9IGxlYWQgLSAweEQ4MDAgPDwgMTAgfCBjIC0gMHhEQzAwIHwgMHgxMDAwMDtcbiAgICAgICAgICAgICAgICAgICAgbGVhZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjID4gMHhEQkZGIHx8IChpICsgMSA9PT0gbGVuZ3RoKSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICAgICAgICBlbHNlIGxlYWQgPSBjO1xuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChsZWFkKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgICAgbGVhZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4ODApIGJ5dGVzLnB1c2goYyk7XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkgYnl0ZXMucHVzaChjID4+IDB4NiB8IDB4QzAsIGMgJiAweDNGIHwgMHg4MCk7XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDEwMDAwKSBieXRlcy5wdXNoKGMgPj4gMHhDIHwgMHhFMCwgYyA+PiAweDYgJiAweDNGIHwgMHg4MCwgYyAmIDB4M0YgfCAweDgwKTtcbiAgICAgICAgZWxzZSBieXRlcy5wdXNoKGMgPj4gMHgxMiB8IDB4RjAsIGMgPj4gMHhDICYgMHgzRiB8IDB4ODAsIGMgPj4gMHg2ICYgMHgzRiB8IDB4ODAsIGMgJiAweDNGIHwgMHg4MCk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYmY7XG5cbnZhciBCdWZmZXIgPSBnbG9iYWwuQnVmZmVyIHx8IHJlcXVpcmUoJy4vYnVmZmVyJyk7XG5cbmZ1bmN0aW9uIFBiZihidWYpIHtcbiAgICB0aGlzLmJ1ZiA9ICFCdWZmZXIuaXNCdWZmZXIoYnVmKSA/IG5ldyBCdWZmZXIoYnVmIHx8IDApIDogYnVmO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMuYnVmLmxlbmd0aDtcbn1cblxuUGJmLlZhcmludCAgPSAwOyAvLyB2YXJpbnQ6IGludDMyLCBpbnQ2NCwgdWludDMyLCB1aW50NjQsIHNpbnQzMiwgc2ludDY0LCBib29sLCBlbnVtXG5QYmYuRml4ZWQ2NCA9IDE7IC8vIDY0LWJpdDogZG91YmxlLCBmaXhlZDY0LCBzZml4ZWQ2NFxuUGJmLkJ5dGVzICAgPSAyOyAvLyBsZW5ndGgtZGVsaW1pdGVkOiBzdHJpbmcsIGJ5dGVzLCBlbWJlZGRlZCBtZXNzYWdlcywgcGFja2VkIHJlcGVhdGVkIGZpZWxkc1xuUGJmLkZpeGVkMzIgPSA1OyAvLyAzMi1iaXQ6IGZsb2F0LCBmaXhlZDMyLCBzZml4ZWQzMlxuXG52YXIgU0hJRlRfTEVGVF8zMiA9ICgxIDw8IDE2KSAqICgxIDw8IDE2KSxcbiAgICBTSElGVF9SSUdIVF8zMiA9IDEgLyBTSElGVF9MRUZUXzMyLFxuICAgIFBPV18yXzYzID0gTWF0aC5wb3coMiwgNjMpO1xuXG5QYmYucHJvdG90eXBlID0ge1xuXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYnVmID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLy8gPT09IFJFQURJTkcgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIHJlYWRGaWVsZHM6IGZ1bmN0aW9uKHJlYWRGaWVsZCwgcmVzdWx0LCBlbmQpIHtcbiAgICAgICAgZW5kID0gZW5kIHx8IHRoaXMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMucmVhZFZhcmludCgpLFxuICAgICAgICAgICAgICAgIHRhZyA9IHZhbCA+PiAzLFxuICAgICAgICAgICAgICAgIHN0YXJ0UG9zID0gdGhpcy5wb3M7XG5cbiAgICAgICAgICAgIHJlYWRGaWVsZCh0YWcsIHJlc3VsdCwgdGhpcyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gc3RhcnRQb3MpIHRoaXMuc2tpcCh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIHJlYWRNZXNzYWdlOiBmdW5jdGlvbihyZWFkRmllbGQsIHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkRmllbGRzKHJlYWRGaWVsZCwgcmVzdWx0LCB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zKTtcbiAgICB9LFxuXG4gICAgcmVhZEZpeGVkMzI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuXG4gICAgcmVhZFNGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRJbnQzMkxFKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuXG4gICAgLy8gNjQtYml0IGludCBoYW5kbGluZyBpcyBiYXNlZCBvbiBnaXRodWIuY29tL2Rwdy9ub2RlLWJ1ZmZlci1tb3JlLWludHMgKE1JVC1saWNlbnNlZClcblxuICAgIHJlYWRGaXhlZDY0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLnBvcykgKyB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MgKyA0KSAqIFNISUZUX0xFRlRfMzI7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRTRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5wb3MpICsgdGhpcy5idWYucmVhZEludDMyTEUodGhpcy5wb3MgKyA0KSAqIFNISUZUX0xFRlRfMzI7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWRGbG9hdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmJ1Zi5yZWFkRmxvYXRMRSh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIHJlYWREb3VibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5idWYucmVhZERvdWJsZUxFKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuXG4gICAgcmVhZFZhcmludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBidWYgPSB0aGlzLmJ1ZixcbiAgICAgICAgICAgIHZhbCwgYjtcblxuICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgID0gIGIgJiAweDdmOyAgICAgICAgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgfD0gKGIgJiAweDdmKSA8PCA3OyAgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgfD0gKGIgJiAweDdmKSA8PCAxNDsgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuICAgICAgICBiID0gYnVmW3RoaXMucG9zKytdOyB2YWwgfD0gKGIgJiAweDdmKSA8PCAyMTsgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuXG4gICAgICAgIHJldHVybiByZWFkVmFyaW50UmVtYWluZGVyKHZhbCwgdGhpcyk7XG4gICAgfSxcblxuICAgIHJlYWRWYXJpbnQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydFBvcyA9IHRoaXMucG9zLFxuICAgICAgICAgICAgdmFsID0gdGhpcy5yZWFkVmFyaW50KCk7XG5cbiAgICAgICAgaWYgKHZhbCA8IFBPV18yXzYzKSByZXR1cm4gdmFsO1xuXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnBvcyAtIDI7XG4gICAgICAgIHdoaWxlICh0aGlzLmJ1Zltwb3NdID09PSAweGZmKSBwb3MtLTtcbiAgICAgICAgaWYgKHBvcyA8IHN0YXJ0UG9zKSBwb3MgPSBzdGFydFBvcztcblxuICAgICAgICB2YWwgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvcyAtIHN0YXJ0UG9zICsgMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYiA9IH50aGlzLmJ1ZltzdGFydFBvcyArIGldICYgMHg3ZjtcbiAgICAgICAgICAgIHZhbCArPSBpIDwgNCA/IGIgPDwgaSAqIDcgOiBiICogTWF0aC5wb3coMiwgaSAqIDcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC12YWwgLSAxO1xuICAgIH0sXG5cbiAgICByZWFkU1ZhcmludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBudW0gPSB0aGlzLnJlYWRWYXJpbnQoKTtcbiAgICAgICAgcmV0dXJuIG51bSAlIDIgPT09IDEgPyAobnVtICsgMSkgLyAtMiA6IG51bSAvIDI7IC8vIHppZ3phZyBlbmNvZGluZ1xuICAgIH0sXG5cbiAgICByZWFkQm9vbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMucmVhZFZhcmludCgpKTtcbiAgICB9LFxuXG4gICAgcmVhZFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgICAgc3RyID0gdGhpcy5idWYudG9TdHJpbmcoJ3V0ZjgnLCB0aGlzLnBvcywgZW5kKTtcbiAgICAgICAgdGhpcy5wb3MgPSBlbmQ7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuICAgIHJlYWRCeXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLFxuICAgICAgICAgICAgYnVmZmVyID0gdGhpcy5idWYuc2xpY2UodGhpcy5wb3MsIGVuZCk7XG4gICAgICAgIHRoaXMucG9zID0gZW5kO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH0sXG5cbiAgICAvLyB2ZXJib3NlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOyBkb2Vzbid0IGFmZmVjdCBnemlwcGVkIHNpemVcblxuICAgIHJlYWRQYWNrZWRWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkVmFyaW50KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNWYXJpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU1ZhcmludCgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRCb29sZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEJvb2xlYW4oKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRmxvYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkRmxvYXQoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRG91YmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZERvdWJsZSgpKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlYWRQYWNrZWRGaXhlZDMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZEZpeGVkMzIoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkU0ZpeGVkMzI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcywgYXJyID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnBvcyA8IGVuZCkgYXJyLnB1c2godGhpcy5yZWFkU0ZpeGVkMzIoKSk7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWFkUGFja2VkRml4ZWQ2NDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnJlYWRWYXJpbnQoKSArIHRoaXMucG9zLCBhcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zIDwgZW5kKSBhcnIucHVzaCh0aGlzLnJlYWRGaXhlZDY0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgcmVhZFBhY2tlZFNGaXhlZDY0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucmVhZFZhcmludCgpICsgdGhpcy5wb3MsIGFyciA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5wb3MgPCBlbmQpIGFyci5wdXNoKHRoaXMucmVhZFNGaXhlZDY0KCkpO1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG5cbiAgICBza2lwOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB2YWwgJiAweDc7XG4gICAgICAgIGlmICh0eXBlID09PSBQYmYuVmFyaW50KSB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gPiAweDdmKSB7fVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSBQYmYuQnl0ZXMpIHRoaXMucG9zID0gdGhpcy5yZWFkVmFyaW50KCkgKyB0aGlzLnBvcztcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gUGJmLkZpeGVkMzIpIHRoaXMucG9zICs9IDQ7XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFBiZi5GaXhlZDY0KSB0aGlzLnBvcyArPSA4O1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVW5pbXBsZW1lbnRlZCB0eXBlOiAnICsgdHlwZSk7XG4gICAgfSxcblxuICAgIC8vID09PSBXUklUSU5HID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICB3cml0ZVRhZzogZnVuY3Rpb24odGFnLCB0eXBlKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoKHRhZyA8PCAzKSB8IHR5cGUpO1xuICAgIH0sXG5cbiAgICByZWFsbG9jOiBmdW5jdGlvbihtaW4pIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDE2O1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGggPCB0aGlzLnBvcyArIG1pbikgbGVuZ3RoICo9IDI7XG5cbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKGxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmJ1Zi5jb3B5KGJ1Zik7XG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKDAsIHRoaXMubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgd3JpdGVGaXhlZDMyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZVVJbnQzMkxFKHZhbCwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgIH0sXG5cbiAgICB3cml0ZVNGaXhlZDMyOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUodmFsLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgfSxcblxuICAgIHdyaXRlRml4ZWQ2NDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMucmVhbGxvYyg4KTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVJbnQzMkxFKHZhbCAmIC0xLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlVUludDMyTEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIHRoaXMucG9zICsgNCk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlU0ZpeGVkNjQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoOCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgdGhpcy5wb3MpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZUludDMyTEUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIHRoaXMucG9zICsgNCk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlVmFyaW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFsID0gK3ZhbDtcblxuICAgICAgICBpZiAodmFsID4gMHhmZmZmZmZmKSB7XG4gICAgICAgICAgICB3cml0ZUJpZ1ZhcmludCh2YWwsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWFsbG9jKDQpO1xuXG4gICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gICAgICAgICAgIHZhbCAmIDB4N2YgIHwgKHZhbCA+IDB4N2YgPyAweDgwIDogMCk7IGlmICh2YWwgPD0gMHg3ZikgcmV0dXJuO1xuICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvcysrXSA9ICgodmFsID4+Pj0gNykgJiAweDdmKSB8ICh2YWwgPiAweDdmID8gMHg4MCA6IDApOyBpZiAodmFsIDw9IDB4N2YpIHJldHVybjtcbiAgICAgICAgdGhpcy5idWZbdGhpcy5wb3MrK10gPSAoKHZhbCA+Pj49IDcpICYgMHg3ZikgfCAodmFsID4gMHg3ZiA/IDB4ODAgOiAwKTsgaWYgKHZhbCA8PSAweDdmKSByZXR1cm47XG4gICAgICAgIHRoaXMuYnVmW3RoaXMucG9zKytdID0gICAodmFsID4+PiA3KSAmIDB4N2Y7XG4gICAgfSxcblxuICAgIHdyaXRlU1ZhcmludDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQodmFsIDwgMCA/IC12YWwgKiAyIC0gMSA6IHZhbCAqIDIpO1xuICAgIH0sXG5cbiAgICB3cml0ZUJvb2xlYW46IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50KEJvb2xlYW4odmFsKSk7XG4gICAgfSxcblxuICAgIHdyaXRlU3RyaW5nOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgICAgIHZhciBieXRlcyA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN0cik7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQoYnl0ZXMpO1xuICAgICAgICB0aGlzLnJlYWxsb2MoYnl0ZXMpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZShzdHIsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gYnl0ZXM7XG4gICAgfSxcblxuICAgIHdyaXRlRmxvYXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoNCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlRmxvYXRMRSh2YWwsIHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICB9LFxuXG4gICAgd3JpdGVEb3VibGU6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB0aGlzLnJlYWxsb2MoOCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlRG91YmxlTEUodmFsLCB0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgfSxcblxuICAgIHdyaXRlQnl0ZXM6IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICB2YXIgbGVuID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgdGhpcy53cml0ZVZhcmludChsZW4pO1xuICAgICAgICB0aGlzLnJlYWxsb2MobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgdGhpcy5idWZbdGhpcy5wb3MrK10gPSBidWZmZXJbaV07XG4gICAgfSxcblxuICAgIHdyaXRlUmF3TWVzc2FnZTogZnVuY3Rpb24oZm4sIG9iaikge1xuICAgICAgICB0aGlzLnBvcysrOyAvLyByZXNlcnZlIDEgYnl0ZSBmb3Igc2hvcnQgbWVzc2FnZSBsZW5ndGhcblxuICAgICAgICAvLyB3cml0ZSB0aGUgbWVzc2FnZSBkaXJlY3RseSB0byB0aGUgYnVmZmVyIGFuZCBzZWUgaG93IG11Y2ggd2FzIHdyaXR0ZW5cbiAgICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5wb3M7XG4gICAgICAgIGZuKG9iaiwgdGhpcyk7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLnBvcyAtIHN0YXJ0UG9zO1xuXG4gICAgICAgIGlmIChsZW4gPj0gMHg4MCkgcmVhbGxvY0ZvclJhd01lc3NhZ2Uoc3RhcnRQb3MsIGxlbiwgdGhpcyk7XG5cbiAgICAgICAgLy8gZmluYWxseSwgd3JpdGUgdGhlIG1lc3NhZ2UgbGVuZ3RoIGluIHRoZSByZXNlcnZlZCBwbGFjZSBhbmQgcmVzdG9yZSB0aGUgcG9zaXRpb25cbiAgICAgICAgdGhpcy5wb3MgPSBzdGFydFBvcyAtIDE7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQobGVuKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gbGVuO1xuICAgIH0sXG5cbiAgICB3cml0ZU1lc3NhZ2U6IGZ1bmN0aW9uKHRhZywgZm4sIG9iaikge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkJ5dGVzKTtcbiAgICAgICAgdGhpcy53cml0ZVJhd01lc3NhZ2UoZm4sIG9iaik7XG4gICAgfSxcblxuICAgIHdyaXRlUGFja2VkVmFyaW50OiAgIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRWYXJpbnQsIGFycik7ICAgfSxcbiAgICB3cml0ZVBhY2tlZFNWYXJpbnQ6ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkU1ZhcmludCwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRCb29sZWFuOiAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEJvb2xlYW4sIGFycik7ICB9LFxuICAgIHdyaXRlUGFja2VkRmxvYXQ6ICAgIGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRGbG9hdCwgYXJyKTsgICAgfSxcbiAgICB3cml0ZVBhY2tlZERvdWJsZTogICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRG91YmxlLCBhcnIpOyAgIH0sXG4gICAgd3JpdGVQYWNrZWRGaXhlZDMyOiAgZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZEZpeGVkMzIsIGFycik7ICB9LFxuICAgIHdyaXRlUGFja2VkU0ZpeGVkMzI6IGZ1bmN0aW9uKHRhZywgYXJyKSB7IHRoaXMud3JpdGVNZXNzYWdlKHRhZywgd3JpdGVQYWNrZWRTRml4ZWQzMiwgYXJyKTsgfSxcbiAgICB3cml0ZVBhY2tlZEZpeGVkNjQ6ICBmdW5jdGlvbih0YWcsIGFycikgeyB0aGlzLndyaXRlTWVzc2FnZSh0YWcsIHdyaXRlUGFja2VkRml4ZWQ2NCwgYXJyKTsgIH0sXG4gICAgd3JpdGVQYWNrZWRTRml4ZWQ2NDogZnVuY3Rpb24odGFnLCBhcnIpIHsgdGhpcy53cml0ZU1lc3NhZ2UodGFnLCB3cml0ZVBhY2tlZFNGaXhlZDY0LCBhcnIpOyB9LFxuXG4gICAgd3JpdGVCeXRlc0ZpZWxkOiBmdW5jdGlvbih0YWcsIGJ1ZmZlcikge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkJ5dGVzKTtcbiAgICAgICAgdGhpcy53cml0ZUJ5dGVzKGJ1ZmZlcik7XG4gICAgfSxcbiAgICB3cml0ZUZpeGVkMzJGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDMyKTtcbiAgICAgICAgdGhpcy53cml0ZUZpeGVkMzIodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlU0ZpeGVkMzJGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDMyKTtcbiAgICAgICAgdGhpcy53cml0ZVNGaXhlZDMyKHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZUZpeGVkNjRGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDY0KTtcbiAgICAgICAgdGhpcy53cml0ZUZpeGVkNjQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlU0ZpeGVkNjRGaWVsZDogZnVuY3Rpb24odGFnLCB2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVRhZyh0YWcsIFBiZi5GaXhlZDY0KTtcbiAgICAgICAgdGhpcy53cml0ZVNGaXhlZDY0KHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZVZhcmludEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLlZhcmludCk7XG4gICAgICAgIHRoaXMud3JpdGVWYXJpbnQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlU1ZhcmludEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLlZhcmludCk7XG4gICAgICAgIHRoaXMud3JpdGVTVmFyaW50KHZhbCk7XG4gICAgfSxcbiAgICB3cml0ZVN0cmluZ0ZpZWxkOiBmdW5jdGlvbih0YWcsIHN0cikge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkJ5dGVzKTtcbiAgICAgICAgdGhpcy53cml0ZVN0cmluZyhzdHIpO1xuICAgIH0sXG4gICAgd3JpdGVGbG9hdEZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVGFnKHRhZywgUGJmLkZpeGVkMzIpO1xuICAgICAgICB0aGlzLndyaXRlRmxvYXQodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlRG91YmxlRmllbGQ6IGZ1bmN0aW9uKHRhZywgdmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVUYWcodGFnLCBQYmYuRml4ZWQ2NCk7XG4gICAgICAgIHRoaXMud3JpdGVEb3VibGUodmFsKTtcbiAgICB9LFxuICAgIHdyaXRlQm9vbGVhbkZpZWxkOiBmdW5jdGlvbih0YWcsIHZhbCkge1xuICAgICAgICB0aGlzLndyaXRlVmFyaW50RmllbGQodGFnLCBCb29sZWFuKHZhbCkpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHJlYWRWYXJpbnRSZW1haW5kZXIodmFsLCBwYmYpIHtcbiAgICB2YXIgYnVmID0gcGJmLmJ1ZiwgYjtcblxuICAgIGIgPSBidWZbcGJmLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDEwMDAwMDAwOyAgICAgICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICBiID0gYnVmW3BiZi5wb3MrK107IHZhbCArPSAoYiAmIDB4N2YpICogMHg4MDAwMDAwMDA7ICAgICAgICBpZiAoYiA8IDB4ODApIHJldHVybiB2YWw7XG4gICAgYiA9IGJ1ZltwYmYucG9zKytdOyB2YWwgKz0gKGIgJiAweDdmKSAqIDB4NDAwMDAwMDAwMDA7ICAgICAgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuICAgIGIgPSBidWZbcGJmLnBvcysrXTsgdmFsICs9IChiICYgMHg3ZikgKiAweDIwMDAwMDAwMDAwMDA7ICAgIGlmIChiIDwgMHg4MCkgcmV0dXJuIHZhbDtcbiAgICBiID0gYnVmW3BiZi5wb3MrK107IHZhbCArPSAoYiAmIDB4N2YpICogMHgxMDAwMDAwMDAwMDAwMDA7ICBpZiAoYiA8IDB4ODApIHJldHVybiB2YWw7XG4gICAgYiA9IGJ1ZltwYmYucG9zKytdOyB2YWwgKz0gKGIgJiAweDdmKSAqIDB4ODAwMDAwMDAwMDAwMDAwMDsgaWYgKGIgPCAweDgwKSByZXR1cm4gdmFsO1xuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YXJpbnQgbm90IG1vcmUgdGhhbiAxMCBieXRlcycpO1xufVxuXG5mdW5jdGlvbiB3cml0ZUJpZ1ZhcmludCh2YWwsIHBiZikge1xuICAgIHBiZi5yZWFsbG9jKDEwKTtcblxuICAgIHZhciBtYXhQb3MgPSBwYmYucG9zICsgMTA7XG5cbiAgICB3aGlsZSAodmFsID49IDEpIHtcbiAgICAgICAgaWYgKHBiZi5wb3MgPj0gbWF4UG9zKSB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIHZhcmludCBkb2VzblxcJ3QgZml0IGludG8gMTAgYnl0ZXMnKTtcbiAgICAgICAgdmFyIGIgPSB2YWwgJiAweGZmO1xuICAgICAgICBwYmYuYnVmW3BiZi5wb3MrK10gPSBiIHwgKHZhbCA+PSAweDgwID8gMHg4MCA6IDApO1xuICAgICAgICB2YWwgLz0gMHg4MDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlYWxsb2NGb3JSYXdNZXNzYWdlKHN0YXJ0UG9zLCBsZW4sIHBiZikge1xuICAgIHZhciBleHRyYUxlbiA9XG4gICAgICAgIGxlbiA8PSAweDNmZmYgPyAxIDpcbiAgICAgICAgbGVuIDw9IDB4MWZmZmZmID8gMiA6XG4gICAgICAgIGxlbiA8PSAweGZmZmZmZmYgPyAzIDogTWF0aC5jZWlsKE1hdGgubG9nKGxlbikgLyAoTWF0aC5MTjIgKiA3KSk7XG5cbiAgICAvLyBpZiAxIGJ5dGUgaXNuJ3QgZW5vdWdoIGZvciBlbmNvZGluZyBtZXNzYWdlIGxlbmd0aCwgc2hpZnQgdGhlIGRhdGEgdG8gdGhlIHJpZ2h0XG4gICAgcGJmLnJlYWxsb2MoZXh0cmFMZW4pO1xuICAgIGZvciAodmFyIGkgPSBwYmYucG9zIC0gMTsgaSA+PSBzdGFydFBvczsgaS0tKSBwYmYuYnVmW2kgKyBleHRyYUxlbl0gPSBwYmYuYnVmW2ldO1xufVxuXG5mdW5jdGlvbiB3cml0ZVBhY2tlZFZhcmludChhcnIsIHBiZikgICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVWYXJpbnQoYXJyW2ldKTsgICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZFNWYXJpbnQoYXJyLCBwYmYpICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVTVmFyaW50KGFycltpXSk7ICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZEZsb2F0KGFyciwgcGJmKSAgICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVGbG9hdChhcnJbaV0pOyAgICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZERvdWJsZShhcnIsIHBiZikgICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVEb3VibGUoYXJyW2ldKTsgICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZEJvb2xlYW4oYXJyLCBwYmYpICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVCb29sZWFuKGFycltpXSk7ICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZEZpeGVkMzIoYXJyLCBwYmYpICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVGaXhlZDMyKGFycltpXSk7ICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZFNGaXhlZDMyKGFyciwgcGJmKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVTRml4ZWQzMihhcnJbaV0pOyB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZEZpeGVkNjQoYXJyLCBwYmYpICB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVGaXhlZDY0KGFycltpXSk7ICB9XG5mdW5jdGlvbiB3cml0ZVBhY2tlZFNGaXhlZDY0KGFyciwgcGJmKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVTRml4ZWQ2NChhcnJbaV0pOyB9XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxuZnVuY3Rpb24gUG9pbnQoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbn1cblxuUG9pbnQucHJvdG90eXBlID0ge1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7IH0sXG5cbiAgICBhZGQ6ICAgICBmdW5jdGlvbihwKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX2FkZChwKTsgICAgIH0sXG4gICAgc3ViOiAgICAgZnVuY3Rpb24ocCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9zdWIocCk7ICAgICB9LFxuICAgIG11bHQ6ICAgIGZ1bmN0aW9uKGspIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fbXVsdChrKTsgICAgfSxcbiAgICBkaXY6ICAgICBmdW5jdGlvbihrKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX2RpdihrKTsgICAgIH0sXG4gICAgcm90YXRlOiAgZnVuY3Rpb24oYSkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3RhdGUoYSk7ICB9LFxuICAgIG1hdE11bHQ6IGZ1bmN0aW9uKG0pIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fbWF0TXVsdChtKTsgfSxcbiAgICB1bml0OiAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY2xvbmUoKS5fdW5pdCgpOyB9LFxuICAgIHBlcnA6ICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jbG9uZSgpLl9wZXJwKCk7IH0sXG4gICAgcm91bmQ6ICAgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNsb25lKCkuX3JvdW5kKCk7IH0sXG5cbiAgICBtYWc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gdGhpcy54ID09PSBwLnggJiZcbiAgICAgICAgICAgICAgIHRoaXMueSA9PT0gcC55O1xuICAgIH0sXG5cbiAgICBkaXN0OiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0U3FyKHApKTtcbiAgICB9LFxuXG4gICAgZGlzdFNxcjogZnVuY3Rpb24ocCkge1xuICAgICAgICB2YXIgZHggPSBwLnggLSB0aGlzLngsXG4gICAgICAgICAgICBkeSA9IHAueSAtIHRoaXMueTtcbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuICAgIH0sXG5cbiAgICBhbmdsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcbiAgICB9LFxuXG4gICAgYW5nbGVUbzogZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnkgLSBiLnksIHRoaXMueCAtIGIueCk7XG4gICAgfSxcblxuICAgIGFuZ2xlV2l0aDogZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmdsZVdpdGhTZXAoYi54LCBiLnkpO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIHRoZSBhbmdsZSBvZiB0aGUgdHdvIHZlY3RvcnMsIHNvbHZpbmcgdGhlIGZvcm11bGEgZm9yIHRoZSBjcm9zcyBwcm9kdWN0IGEgeCBiID0gfGF8fGJ8c2luKM64KSBmb3IgzrguXG4gICAgYW5nbGVXaXRoU2VwOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKFxuICAgICAgICAgICAgdGhpcy54ICogeSAtIHRoaXMueSAqIHgsXG4gICAgICAgICAgICB0aGlzLnggKiB4ICsgdGhpcy55ICogeSk7XG4gICAgfSxcblxuICAgIF9tYXRNdWx0OiBmdW5jdGlvbihtKSB7XG4gICAgICAgIHZhciB4ID0gbVswXSAqIHRoaXMueCArIG1bMV0gKiB0aGlzLnksXG4gICAgICAgICAgICB5ID0gbVsyXSAqIHRoaXMueCArIG1bM10gKiB0aGlzLnk7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfYWRkOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHRoaXMueCArPSBwLng7XG4gICAgICAgIHRoaXMueSArPSBwLnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfc3ViOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHRoaXMueCAtPSBwLng7XG4gICAgICAgIHRoaXMueSAtPSBwLnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfbXVsdDogZnVuY3Rpb24oaykge1xuICAgICAgICB0aGlzLnggKj0gaztcbiAgICAgICAgdGhpcy55ICo9IGs7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfZGl2OiBmdW5jdGlvbihrKSB7XG4gICAgICAgIHRoaXMueCAvPSBrO1xuICAgICAgICB0aGlzLnkgLz0gaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF91bml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fZGl2KHRoaXMubWFnKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3BlcnA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgeSA9IHRoaXMueTtcbiAgICAgICAgdGhpcy55ID0gdGhpcy54O1xuICAgICAgICB0aGlzLnggPSAteTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9yb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICB4ID0gY29zICogdGhpcy54IC0gc2luICogdGhpcy55LFxuICAgICAgICAgICAgeSA9IHNpbiAqIHRoaXMueCArIGNvcyAqIHRoaXMueTtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9yb3VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcbiAgICAgICAgdGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RzIFBvaW50IGZyb20gYW4gYXJyYXkgaWYgbmVjZXNzYXJ5XG5Qb2ludC5jb252ZXJ0ID0gZnVuY3Rpb24gKGEpIHtcbiAgICBpZiAoYSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KGFbMF0sIGFbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFydGlhbFNvcnQ7XG5cbi8vIEZsb3lkLVJpdmVzdCBzZWxlY3Rpb24gYWxnb3JpdGhtOlxuLy8gUmVhcnJhbmdlIGl0ZW1zIHNvIHRoYXQgYWxsIGl0ZW1zIGluIHRoZSBbbGVmdCwga10gcmFuZ2UgYXJlIHNtYWxsZXIgdGhhbiBhbGwgaXRlbXMgaW4gKGssIHJpZ2h0XTtcbi8vIFRoZSBrLXRoIGVsZW1lbnQgd2lsbCBoYXZlIHRoZSAoayAtIGxlZnQgKyAxKXRoIHNtYWxsZXN0IHZhbHVlIGluIFtsZWZ0LCByaWdodF1cblxuZnVuY3Rpb24gcGFydGlhbFNvcnQoYXJyLCBrLCBsZWZ0LCByaWdodCwgY29tcGFyZSkge1xuICAgIGxlZnQgPSBsZWZ0IHx8IDA7XG4gICAgcmlnaHQgPSByaWdodCB8fCAoYXJyLmxlbmd0aCAtIDEpO1xuICAgIGNvbXBhcmUgPSBjb21wYXJlIHx8IGRlZmF1bHRDb21wYXJlO1xuXG4gICAgd2hpbGUgKHJpZ2h0ID4gbGVmdCkge1xuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0ID4gNjAwKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHJpZ2h0IC0gbGVmdCArIDE7XG4gICAgICAgICAgICB2YXIgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciB6ID0gTWF0aC5sb2cobik7XG4gICAgICAgICAgICB2YXIgcyA9IDAuNSAqIE1hdGguZXhwKDIgKiB6IC8gMyk7XG4gICAgICAgICAgICB2YXIgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbikgKiAobSAtIG4gLyAyIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICB2YXIgbmV3TGVmdCA9IE1hdGgubWF4KGxlZnQsIE1hdGguZmxvb3IoayAtIG0gKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICB2YXIgbmV3UmlnaHQgPSBNYXRoLm1pbihyaWdodCwgTWF0aC5mbG9vcihrICsgKG4gLSBtKSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIHBhcnRpYWxTb3J0KGFyciwgaywgbmV3TGVmdCwgbmV3UmlnaHQsIGNvbXBhcmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQgPSBhcnJba107XG4gICAgICAgIHZhciBpID0gbGVmdDtcbiAgICAgICAgdmFyIGogPSByaWdodDtcblxuICAgICAgICBzd2FwKGFyciwgbGVmdCwgayk7XG4gICAgICAgIGlmIChjb21wYXJlKGFycltyaWdodF0sIHQpID4gMCkgc3dhcChhcnIsIGxlZnQsIHJpZ2h0KTtcblxuICAgICAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgICAgICAgIHN3YXAoYXJyLCBpLCBqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGFycltpXSwgdCkgPCAwKSBpKys7XG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbal0sIHQpID4gMCkgai0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW2xlZnRdLCB0KSA9PT0gMCkgc3dhcChhcnIsIGxlZnQsIGopO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIHN3YXAoYXJyLCBqLCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA8PSBrKSBsZWZ0ID0gaiArIDE7XG4gICAgICAgIGlmIChrIDw9IGopIHJpZ2h0ID0gaiAtIDE7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzd2FwKGFyciwgaSwgaikge1xuICAgIHZhciB0bXAgPSBhcnJbaV07XG4gICAgYXJyW2ldID0gYXJyW2pdO1xuICAgIGFycltqXSA9IHRtcDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUoYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDE0IFNpbW9uIEx5ZGVsbFxyXG4vLyBYMTEgKOKAnE1JVOKAnSkgTGljZW5zZWQuIChTZWUgTElDRU5TRS4pXHJcblxyXG52b2lkIChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoZmFjdG9yeSlcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKVxyXG4gIH0gZWxzZSB7XHJcbiAgICByb290LnJlc29sdmVVcmwgPSBmYWN0b3J5KClcclxuICB9XHJcbn0odGhpcywgZnVuY3Rpb24oKSB7XHJcblxyXG4gIGZ1bmN0aW9uIHJlc29sdmVVcmwoLyogLi4udXJscyAqLykge1xyXG4gICAgdmFyIG51bVVybHMgPSBhcmd1bWVudHMubGVuZ3RoXHJcblxyXG4gICAgaWYgKG51bVVybHMgPT09IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVzb2x2ZVVybCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQ7IGdvdCBub25lLlwiKVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBiYXNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJhc2VcIilcclxuICAgIGJhc2UuaHJlZiA9IGFyZ3VtZW50c1swXVxyXG5cclxuICAgIGlmIChudW1VcmxzID09PSAxKSB7XHJcbiAgICAgIHJldHVybiBiYXNlLmhyZWZcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXVxyXG4gICAgaGVhZC5pbnNlcnRCZWZvcmUoYmFzZSwgaGVhZC5maXJzdENoaWxkKVxyXG5cclxuICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIilcclxuICAgIHZhciByZXNvbHZlZFxyXG5cclxuICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBudW1VcmxzOyBpbmRleCsrKSB7XHJcbiAgICAgIGEuaHJlZiA9IGFyZ3VtZW50c1tpbmRleF1cclxuICAgICAgcmVzb2x2ZWQgPSBhLmhyZWZcclxuICAgICAgYmFzZS5ocmVmID0gcmVzb2x2ZWRcclxuICAgIH1cclxuXHJcbiAgICBoZWFkLnJlbW92ZUNoaWxkKGJhc2UpXHJcblxyXG4gICAgcmV0dXJuIHJlc29sdmVkXHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzb2x2ZVVybFxyXG5cclxufSkpO1xyXG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gU2hlbGZQYWNrO1xuXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFNoZWxmUGFjayBiaW4gYWxsb2NhdG9yLlxuICpcbiAqIFVzZXMgdGhlIFNoZWxmIEJlc3QgSGVpZ2h0IEZpdCBhbGdvcml0aG0gZnJvbVxuICogaHR0cDovL2NsYi5kZW1vbi5maS9maWxlcy9SZWN0YW5nbGVCaW5QYWNrLnBkZlxuICpcbiAqIEBjbGFzcyAgU2hlbGZQYWNrXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBbdz02NF0gIEluaXRpYWwgd2lkdGggb2YgdGhlIHNwcml0ZVxuICogQHBhcmFtICB7bnVtYmVyfSAgW2g9NjRdICBJbml0aWFsIHdpZHRoIG9mIHRoZSBzcHJpdGVcbiAqIEBwYXJhbSAge09iamVjdH0gIFtvcHRpb25zXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuYXV0b1Jlc2l6ZT1mYWxzZV0gIElmIGB0cnVlYCwgdGhlIHNwcml0ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZ3Jvd1xuICogQGV4YW1wbGVcbiAqIHZhciBzcHJpdGUgPSBuZXcgU2hlbGZQYWNrKDY0LCA2NCwgeyBhdXRvUmVzaXplOiBmYWxzZSB9KTtcbiAqL1xuZnVuY3Rpb24gU2hlbGZQYWNrKHcsIGgsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLncgPSB3IHx8IDY0O1xuICAgIHRoaXMuaCA9IGggfHwgNjQ7XG4gICAgdGhpcy5hdXRvUmVzaXplID0gISFvcHRpb25zLmF1dG9SZXNpemU7XG4gICAgdGhpcy5zaGVsdmVzID0gW107XG4gICAgdGhpcy5zdGF0cyA9IHt9O1xuICAgIHRoaXMuY291bnQgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgIHRoaXMuc3RhdHNbaF0gPSAodGhpcy5zdGF0c1toXSB8IDApICsgMTtcbiAgICB9O1xufVxuXG4vKipcbiAqIEJhdGNoIHBhY2sgbXVsdGlwbGUgYmlucyBpbnRvIHRoZSBzcHJpdGUuXG4gKlxuICogQHBhcmFtICAge0FycmF5fSAgIGJpbnMgQXJyYXkgb2YgcmVxdWVzdGVkIGJpbnMgLSBlYWNoIG9iamVjdCBzaG91bGQgaGF2ZSBgd2lkdGhgLCBgaGVpZ2h0YCAob3IgYHdgLCBgaGApIHByb3BlcnRpZXNcbiAqIEBwYXJhbSAgIHtPYmplY3R9ICBbb3B0aW9uc11cbiAqIEBwYXJhbSAgIHtib29sZWFufSBbb3B0aW9ucy5pblBsYWNlPWZhbHNlXSBJZiBgdHJ1ZWAsIHRoZSBzdXBwbGllZCBiaW4gb2JqZWN0cyB3aWxsIGJlIHVwZGF0ZWQgaW5wbGFjZSB3aXRoIGB4YCBhbmQgYHlgIHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIHtBcnJheX0gICBBcnJheSBvZiBhbGxvY2F0ZWQgYmlucyAtIGVhY2ggYmluIGlzIGFuIG9iamVjdCB3aXRoIGB4YCwgYHlgLCBgd2AsIGBoYCBwcm9wZXJ0aWVzXG4gKiBAZXhhbXBsZVxuICogdmFyIGJpbnMgPSBbXG4gKiAgICAgeyBpZDogJ2EnLCB3aWR0aDogMTIsIGhlaWdodDogMTIgfSxcbiAqICAgICB7IGlkOiAnYicsIHdpZHRoOiAxMiwgaGVpZ2h0OiAxNiB9LFxuICogICAgIHsgaWQ6ICdjJywgd2lkdGg6IDEyLCBoZWlnaHQ6IDI0IH1cbiAqIF07XG4gKiB2YXIgcmVzdWx0cyA9IHNwcml0ZS5wYWNrKGJpbnMsIHsgaW5QbGFjZTogZmFsc2UgfSk7XG4gKi9cblNoZWxmUGFjay5wcm90b3R5cGUucGFjayA9IGZ1bmN0aW9uKGJpbnMsIG9wdGlvbnMpIHtcbiAgICBiaW5zID0gW10uY29uY2F0KGJpbnMpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgdywgaCwgYWxsb2NhdGlvbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmlucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB3ID0gYmluc1tpXS53IHx8IGJpbnNbaV0ud2lkdGg7XG4gICAgICAgIGggPSBiaW5zW2ldLmggfHwgYmluc1tpXS5oZWlnaHQ7XG4gICAgICAgIGlmICh3ICYmIGgpIHtcbiAgICAgICAgICAgIGFsbG9jYXRpb24gPSB0aGlzLnBhY2tPbmUodywgaCk7XG4gICAgICAgICAgICBpZiAoIWFsbG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmluUGxhY2UpIHtcbiAgICAgICAgICAgICAgICBiaW5zW2ldLnggPSBhbGxvY2F0aW9uLng7XG4gICAgICAgICAgICAgICAgYmluc1tpXS55ID0gYWxsb2NhdGlvbi55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGFsbG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFBhY2sgYSBzaW5nbGUgYmluIGludG8gdGhlIHNwcml0ZS5cbiAqXG4gKiBAcGFyYW0gICB7bnVtYmVyfSAgdyAgIFdpZHRoIG9mIHRoZSBiaW4gdG8gYWxsb2NhdGVcbiAqIEBwYXJhbSAgIHtudW1iZXJ9ICBoICAgSGVpZ2h0IG9mIHRoZSBiaW4gdG8gYWxsb2NhdGVcbiAqIEByZXR1cm5zIHtPYmplY3R9ICBBbGxvY2F0ZWQgYmluIG9iamVjdCB3aXRoIGB4YCwgYHlgLCBgd2AsIGBoYCBwcm9wZXJ0aWVzLCBvciBgbnVsbGAgaWYgYWxsb2NhdGlvbiBmYWlsZWRcbiAqIEBleGFtcGxlXG4gKiB2YXIgcmVzdWx0cyA9IHNwcml0ZS5wYWNrT25lKDEyLCAxNik7XG4gKi9cblNoZWxmUGFjay5wcm90b3R5cGUucGFja09uZSA9IGZ1bmN0aW9uKHcsIGgpIHtcbiAgICB2YXIgeSA9IDAsXG4gICAgICAgIGJlc3QgPSB7IHNoZWxmOiAtMSwgd2FzdGU6IEluZmluaXR5IH0sXG4gICAgICAgIHNoZWxmLCB3YXN0ZTtcblxuICAgIC8vIGZpbmQgdGhlIGJlc3Qgc2hlbGZcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2hlbHZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzaGVsZiA9IHRoaXMuc2hlbHZlc1tpXTtcbiAgICAgICAgeSArPSBzaGVsZi5oO1xuXG4gICAgICAgIC8vIGV4YWN0bHkgdGhlIHJpZ2h0IGhlaWdodCB3aXRoIHdpZHRoIHRvIHNwYXJlLCBwYWNrIGl0Li5cbiAgICAgICAgaWYgKGggPT09IHNoZWxmLmggJiYgdyA8PSBzaGVsZi5mcmVlKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50KGgpO1xuICAgICAgICAgICAgcmV0dXJuIHNoZWxmLmFsbG9jKHcsIGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdCBlbm91Z2ggaGVpZ2h0IG9yIHdpZHRoLCBza2lwIGl0Li5cbiAgICAgICAgaWYgKGggPiBzaGVsZi5oIHx8IHcgPiBzaGVsZi5mcmVlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYXliZSBlbm91Z2ggaGVpZ2h0IG9yIHdpZHRoLCBtaW5pbWl6ZSB3YXN0ZS4uXG4gICAgICAgIGlmIChoIDwgc2hlbGYuaCAmJiB3IDw9IHNoZWxmLmZyZWUpIHtcbiAgICAgICAgICAgIHdhc3RlID0gc2hlbGYuaCAtIGg7XG4gICAgICAgICAgICBpZiAod2FzdGUgPCBiZXN0Lndhc3RlKSB7XG4gICAgICAgICAgICAgICAgYmVzdC53YXN0ZSA9IHdhc3RlO1xuICAgICAgICAgICAgICAgIGJlc3Quc2hlbGYgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJlc3Quc2hlbGYgIT09IC0xKSB7XG4gICAgICAgIHNoZWxmID0gdGhpcy5zaGVsdmVzW2Jlc3Quc2hlbGZdO1xuICAgICAgICB0aGlzLmNvdW50KGgpO1xuICAgICAgICByZXR1cm4gc2hlbGYuYWxsb2ModywgaCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIHNoZWxmLi5cbiAgICBpZiAoaCA8PSAodGhpcy5oIC0geSkgJiYgdyA8PSB0aGlzLncpIHtcbiAgICAgICAgc2hlbGYgPSBuZXcgU2hlbGYoeSwgdGhpcy53LCBoKTtcbiAgICAgICAgdGhpcy5zaGVsdmVzLnB1c2goc2hlbGYpO1xuICAgICAgICB0aGlzLmNvdW50KGgpO1xuICAgICAgICByZXR1cm4gc2hlbGYuYWxsb2ModywgaCk7XG4gICAgfVxuXG4gICAgLy8gbm8gbW9yZSBzcGFjZS4uXG4gICAgLy8gSWYgYGF1dG9SZXNpemVgIG9wdGlvbiBpcyBzZXQsIGdyb3cgdGhlIHNwcml0ZSBhcyBmb2xsb3dzOlxuICAgIC8vICAqIGRvdWJsZSB3aGljaGV2ZXIgc3ByaXRlIGRpbWVuc2lvbiBpcyBzbWFsbGVyIChgdzFgIG9yIGBoMWApXG4gICAgLy8gICogaWYgc3ByaXRlIGRpbWVuc2lvbnMgYXJlIGVxdWFsLCBncm93IHdpZHRoIGJlZm9yZSBoZWlnaHRcbiAgICAvLyAgKiBhY2NvbW9kYXRlIHZlcnkgbGFyZ2UgYmluIHJlcXVlc3RzIChiaWcgYHdgIG9yIGBoYClcbiAgICBpZiAodGhpcy5hdXRvUmVzaXplKSB7XG4gICAgICAgIHZhciBoMSwgaDIsIHcxLCB3MjtcblxuICAgICAgICBoMSA9IGgyID0gdGhpcy5oO1xuICAgICAgICB3MSA9IHcyID0gdGhpcy53O1xuXG4gICAgICAgIGlmICh3MSA8PSBoMSB8fCB3ID4gdzEpIHsgICAvLyBncm93IHdpZHRoLi5cbiAgICAgICAgICAgIHcyID0gTWF0aC5tYXgodywgdzEpICogMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaDEgPCB3MSB8fCBoID4gaDEpIHsgICAgLy8gZ3JvdyBoZWlnaHQuLlxuICAgICAgICAgICAgaDIgPSBNYXRoLm1heChoLCBoMSkgKiAyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXNpemUodzIsIGgyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFja09uZSh3LCBoKTsgIC8vIHJldHJ5XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENsZWFyIHRoZSBzcHJpdGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIHNwcml0ZS5jbGVhcigpO1xuICovXG5TaGVsZlBhY2sucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zaGVsdmVzID0gW107XG4gICAgdGhpcy5zdGF0cyA9IHt9O1xufTtcblxuLyoqXG4gKiBSZXNpemUgdGhlIHNwcml0ZS5cbiAqIFRoZSByZXNpemUgd2lsbCBmYWlsIGlmIHRoZSByZXF1ZXN0ZWQgZGltZW5zaW9ucyBhcmUgc21hbGxlciB0aGFuIHRoZSBjdXJyZW50IHNwcml0ZSBkaW1lbnNpb25zLlxuICpcbiAqIEBwYXJhbSAgIHtudW1iZXJ9ICB3ICBSZXF1ZXN0ZWQgbmV3IHNwcml0ZSB3aWR0aFxuICogQHBhcmFtICAge251bWJlcn0gIGggIFJlcXVlc3RlZCBuZXcgc3ByaXRlIGhlaWdodFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNpemUgc3VjY2VlZGVkLCBgZmFsc2VgIGlmIGZhaWxlZFxuICogQGV4YW1wbGVcbiAqIHNwcml0ZS5yZXNpemUoMjU2LCAyNTYpO1xuICovXG5TaGVsZlBhY2sucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHcsIGgpIHtcbiAgICBpZiAodyA8IHRoaXMudyB8fCBoIDwgdGhpcy5oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLncgPSB3O1xuICAgIHRoaXMuaCA9IGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNoZWx2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5zaGVsdmVzW2ldLnJlc2l6ZSh3KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgU2hlbGYuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjbGFzcyAgU2hlbGZcbiAqIEBwYXJhbSAge251bWJlcn0gIHkgICBUb3AgY29vcmRpbmF0ZSBvZiB0aGUgbmV3IHNoZWxmXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB3ICAgV2lkdGggb2YgdGhlIG5ldyBzaGVsZlxuICogQHBhcmFtICB7bnVtYmVyfSAgaCAgIEhlaWdodCBvZiB0aGUgbmV3IHNoZWxmXG4gKiBAZXhhbXBsZVxuICogdmFyIHNoZWxmID0gbmV3IFNoZWxmKDY0LCA1MTIsIDI0KTtcbiAqL1xuZnVuY3Rpb24gU2hlbGYoeSwgdywgaCkge1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLncgPSB0aGlzLmZyZWUgPSB3O1xuICAgIHRoaXMuaCA9IGg7XG59XG5cbi8qKlxuICogQWxsb2NhdGUgYSBzaW5nbGUgYmluIGludG8gdGhlIHNoZWxmLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gICB7bnVtYmVyfSAgdyAgIFdpZHRoIG9mIHRoZSBiaW4gdG8gYWxsb2NhdGVcbiAqIEBwYXJhbSAgIHtudW1iZXJ9ICBoICAgSGVpZ2h0IG9mIHRoZSBiaW4gdG8gYWxsb2NhdGVcbiAqIEByZXR1cm5zIHtPYmplY3R9ICBBbGxvY2F0ZWQgYmluIG9iamVjdCB3aXRoIGB4YCwgYHlgLCBgd2AsIGBoYCBwcm9wZXJ0aWVzLCBvciBgbnVsbGAgaWYgYWxsb2NhdGlvbiBmYWlsZWRcbiAqIEBleGFtcGxlXG4gKiBzaGVsZi5hbGxvYygxMiwgMTYpO1xuICovXG5TaGVsZi5wcm90b3R5cGUuYWxsb2MgPSBmdW5jdGlvbih3LCBoKSB7XG4gICAgaWYgKHcgPiB0aGlzLmZyZWUgfHwgaCA+IHRoaXMuaCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdGhpcy54ICs9IHc7XG4gICAgdGhpcy5mcmVlIC09IHc7XG4gICAgcmV0dXJuIHsgeDogeCwgeTogdGhpcy55LCB3OiB3LCBoOiBoLCB3aWR0aDogdywgaGVpZ2h0OiBoIH07XG59O1xuXG4vKipcbiAqIFJlc2l6ZSB0aGUgc2hlbGYuXG4gKiBUaGUgcmVzaXplIHdpbGwgZmFpbCBpZiB0aGUgcmVxdWVzdGVkIHdpZHRoIGlzIHNtYWxsZXIgdGhhbiB0aGUgY3VycmVudCBzaGVsZiB3aWR0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICAge251bWJlcn0gIHcgIFJlcXVlc3RlZCBuZXcgd2lkdGggb2YgdGhlIHNoZWxmXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiByZXNpemUgc3VjY2VlZGVkLCBmYWxzZSBpZiBmYWlsZWRcbiAqIEBleGFtcGxlXG4gKiBzaGVsZi5yZXNpemUoNTEyKTtcbiAqL1xuU2hlbGYucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHcpIHtcbiAgICBpZiAodyA8IHRoaXMudykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuZnJlZSArPSAodyAtIHRoaXMudyk7XG4gICAgdGhpcy53ID0gdztcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBrZGJ1c2ggPSByZXF1aXJlKCdrZGJ1c2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdXBlcmNsdXN0ZXI7XG5cbmZ1bmN0aW9uIHN1cGVyY2x1c3RlcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdXBlckNsdXN0ZXIob3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIFN1cGVyQ2x1c3RlcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKE9iamVjdC5jcmVhdGUodGhpcy5vcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgdGhpcy50cmVlcyA9IG5ldyBBcnJheSh0aGlzLm9wdGlvbnMubWF4Wm9vbSArIDEpO1xufVxuXG5TdXBlckNsdXN0ZXIucHJvdG90eXBlID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgbWluWm9vbTogMCwgICAvLyBtaW4gem9vbSB0byBnZW5lcmF0ZSBjbHVzdGVycyBvblxuICAgICAgICBtYXhab29tOiAxNiwgIC8vIG1heCB6b29tIGxldmVsIHRvIGNsdXN0ZXIgdGhlIHBvaW50cyBvblxuICAgICAgICByYWRpdXM6IDQwLCAgIC8vIGNsdXN0ZXIgcmFkaXVzIGluIHBpeGVsc1xuICAgICAgICBleHRlbnQ6IDUxMiwgIC8vIHRpbGUgZXh0ZW50IChyYWRpdXMgaXMgY2FsY3VsYXRlZCByZWxhdGl2ZSB0byBpdClcbiAgICAgICAgbm9kZVNpemU6IDY0LCAvLyBzaXplIG9mIHRoZSBLRC10cmVlIGxlYWYgbm9kZSwgYWZmZWN0cyBwZXJmb3JtYW5jZVxuICAgICAgICBsb2c6IGZhbHNlICAgIC8vIHdoZXRoZXIgdG8gbG9nIHRpbWluZyBpbmZvXG4gICAgfSxcblxuICAgIGxvYWQ6IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAgICAgdmFyIGxvZyA9IHRoaXMub3B0aW9ucy5sb2c7XG5cbiAgICAgICAgaWYgKGxvZykgY29uc29sZS50aW1lKCd0b3RhbCB0aW1lJyk7XG5cbiAgICAgICAgdmFyIHRpbWVySWQgPSAncHJlcGFyZSAnICsgcG9pbnRzLmxlbmd0aCArICcgcG9pbnRzJztcbiAgICAgICAgaWYgKGxvZykgY29uc29sZS50aW1lKHRpbWVySWQpO1xuXG4gICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuXG4gICAgICAgIC8vIGdlbmVyYXRlIGEgY2x1c3RlciBvYmplY3QgZm9yIGVhY2ggcG9pbnRcbiAgICAgICAgdmFyIGNsdXN0ZXJzID0gcG9pbnRzLm1hcChjcmVhdGVQb2ludENsdXN0ZXIpO1xuICAgICAgICBpZiAobG9nKSBjb25zb2xlLnRpbWVFbmQodGltZXJJZCk7XG5cbiAgICAgICAgLy8gY2x1c3RlciBwb2ludHMgb24gbWF4IHpvb20sIHRoZW4gY2x1c3RlciB0aGUgcmVzdWx0cyBvbiBwcmV2aW91cyB6b29tLCBldGMuO1xuICAgICAgICAvLyByZXN1bHRzIGluIGEgY2x1c3RlciBoaWVyYXJjaHkgYWNyb3NzIHpvb20gbGV2ZWxzXG4gICAgICAgIGZvciAodmFyIHogPSB0aGlzLm9wdGlvbnMubWF4Wm9vbTsgeiA+PSB0aGlzLm9wdGlvbnMubWluWm9vbTsgei0tKSB7XG4gICAgICAgICAgICB2YXIgbm93ID0gK0RhdGUubm93KCk7XG5cbiAgICAgICAgICAgIC8vIGluZGV4IGlucHV0IHBvaW50cyBpbnRvIGEgS0QtdHJlZVxuICAgICAgICAgICAgdGhpcy50cmVlc1t6ICsgMV0gPSBrZGJ1c2goY2x1c3RlcnMsIGdldFgsIGdldFksIHRoaXMub3B0aW9ucy5ub2RlU2l6ZSwgRmxvYXQzMkFycmF5KTtcblxuICAgICAgICAgICAgY2x1c3RlcnMgPSB0aGlzLl9jbHVzdGVyKGNsdXN0ZXJzLCB6KTsgLy8gY3JlYXRlIGEgbmV3IHNldCBvZiBjbHVzdGVycyBmb3IgdGhlIHpvb21cblxuICAgICAgICAgICAgaWYgKGxvZykgY29uc29sZS5sb2coJ3olZDogJWQgY2x1c3RlcnMgaW4gJWRtcycsIHosIGNsdXN0ZXJzLmxlbmd0aCwgK0RhdGUubm93KCkgLSBub3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5kZXggdG9wLWxldmVsIGNsdXN0ZXJzXG4gICAgICAgIHRoaXMudHJlZXNbdGhpcy5vcHRpb25zLm1pblpvb21dID0ga2RidXNoKGNsdXN0ZXJzLCBnZXRYLCBnZXRZLCB0aGlzLm9wdGlvbnMubm9kZVNpemUsIEZsb2F0MzJBcnJheSk7XG5cbiAgICAgICAgaWYgKGxvZykgY29uc29sZS50aW1lRW5kKCd0b3RhbCB0aW1lJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldENsdXN0ZXJzOiBmdW5jdGlvbiAoYmJveCwgem9vbSkge1xuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZXNbdGhpcy5fbGltaXRab29tKHpvb20pXTtcbiAgICAgICAgdmFyIGlkcyA9IHRyZWUucmFuZ2UobG5nWChiYm94WzBdKSwgbGF0WShiYm94WzNdKSwgbG5nWChiYm94WzJdKSwgbGF0WShiYm94WzFdKSk7XG4gICAgICAgIHZhciBjbHVzdGVycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGMgPSB0cmVlLnBvaW50c1tpZHNbaV1dO1xuICAgICAgICAgICAgY2x1c3RlcnMucHVzaChjLmlkICE9PSAtMSA/IHRoaXMucG9pbnRzW2MuaWRdIDogZ2V0Q2x1c3RlckpTT04oYykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbHVzdGVycztcbiAgICB9LFxuXG4gICAgZ2V0VGlsZTogZnVuY3Rpb24gKHosIHgsIHkpIHtcbiAgICAgICAgdmFyIHoyID0gTWF0aC5wb3coMiwgeik7XG4gICAgICAgIHZhciBleHRlbnQgPSB0aGlzLm9wdGlvbnMuZXh0ZW50O1xuICAgICAgICB2YXIgcCA9IHRoaXMub3B0aW9ucy5yYWRpdXMgLyBleHRlbnQ7XG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlc1t0aGlzLl9saW1pdFpvb20oeildO1xuICAgICAgICB2YXIgaWRzID0gdHJlZS5yYW5nZShcbiAgICAgICAgICAgICh4IC0gcCkgLyB6MixcbiAgICAgICAgICAgICh5IC0gcCkgLyB6MixcbiAgICAgICAgICAgICh4ICsgMSArIHApIC8gejIsXG4gICAgICAgICAgICAoeSArIDEgKyBwKSAvIHoyKTtcblxuICAgICAgICBpZiAoIWlkcy5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHZhciB0aWxlID0ge1xuICAgICAgICAgICAgZmVhdHVyZXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHRyZWUucG9pbnRzW2lkc1tpXV07XG4gICAgICAgICAgICB2YXIgZmVhdHVyZSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAxLFxuICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBbW1xuICAgICAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKGV4dGVudCAqIChjLnggKiB6MiAtIHgpKSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZChleHRlbnQgKiAoYy55ICogejIgLSB5KSlcbiAgICAgICAgICAgICAgICBdXSxcbiAgICAgICAgICAgICAgICB0YWdzOiBjLmlkICE9PSAtMSA/IHRoaXMucG9pbnRzW2MuaWRdLnByb3BlcnRpZXMgOiBnZXRDbHVzdGVyUHJvcGVydGllcyhjKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRpbGUuZmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGlsZTtcbiAgICB9LFxuXG4gICAgX2xpbWl0Wm9vbTogZnVuY3Rpb24gKHopIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMub3B0aW9ucy5taW5ab29tLCBNYXRoLm1pbih6LCB0aGlzLm9wdGlvbnMubWF4Wm9vbSArIDEpKTtcbiAgICB9LFxuXG4gICAgX2NsdXN0ZXI6IGZ1bmN0aW9uIChwb2ludHMsIHpvb20pIHtcbiAgICAgICAgdmFyIGNsdXN0ZXJzID0gW107XG4gICAgICAgIHZhciByID0gdGhpcy5vcHRpb25zLnJhZGl1cyAvICh0aGlzLm9wdGlvbnMuZXh0ZW50ICogTWF0aC5wb3coMiwgem9vbSkpO1xuXG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBlYWNoIHBvaW50XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIC8vIGlmIHdlJ3ZlIGFscmVhZHkgdmlzaXRlZCB0aGUgcG9pbnQgYXQgdGhpcyB6b29tIGxldmVsLCBza2lwIGl0XG4gICAgICAgICAgICBpZiAocC56b29tIDw9IHpvb20pIGNvbnRpbnVlO1xuICAgICAgICAgICAgcC56b29tID0gem9vbTtcblxuICAgICAgICAgICAgLy8gZmluZCBhbGwgbmVhcmJ5IHBvaW50c1xuICAgICAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWVzW3pvb20gKyAxXTtcbiAgICAgICAgICAgIHZhciBuZWlnaGJvcklkcyA9IHRyZWUud2l0aGluKHAueCwgcC55LCByKTtcblxuICAgICAgICAgICAgdmFyIGZvdW5kTmVpZ2hib3JzID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbnVtUG9pbnRzID0gcC5udW1Qb2ludHM7XG4gICAgICAgICAgICB2YXIgd3ggPSBwLnggKiBudW1Qb2ludHM7XG4gICAgICAgICAgICB2YXIgd3kgPSBwLnkgKiBudW1Qb2ludHM7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmVpZ2hib3JJZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHRyZWUucG9pbnRzW25laWdoYm9ySWRzW2pdXTtcbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IG5laWdoYm9ycyB0aGF0IGFyZSB0b28gZmFyIG9yIGFscmVhZHkgcHJvY2Vzc2VkXG4gICAgICAgICAgICAgICAgaWYgKHpvb20gPCBiLnpvb20pIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmROZWlnaGJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBiLnpvb20gPSB6b29tOyAvLyBzYXZlIHRoZSB6b29tIChzbyBpdCBkb2Vzbid0IGdldCBwcm9jZXNzZWQgdHdpY2UpXG4gICAgICAgICAgICAgICAgICAgIHd4ICs9IGIueCAqIGIubnVtUG9pbnRzOyAvLyBhY2N1bXVsYXRlIGNvb3JkaW5hdGVzIGZvciBjYWxjdWxhdGluZyB3ZWlnaHRlZCBjZW50ZXJcbiAgICAgICAgICAgICAgICAgICAgd3kgKz0gYi55ICogYi5udW1Qb2ludHM7XG4gICAgICAgICAgICAgICAgICAgIG51bVBvaW50cyArPSBiLm51bVBvaW50cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goZm91bmROZWlnaGJvcnMgPyBjcmVhdGVDbHVzdGVyKHd4IC8gbnVtUG9pbnRzLCB3eSAvIG51bVBvaW50cywgbnVtUG9pbnRzLCAtMSkgOiBwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbHVzdGVycztcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVDbHVzdGVyKHgsIHksIG51bVBvaW50cywgaWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LCAvLyB3ZWlnaHRlZCBjbHVzdGVyIGNlbnRlclxuICAgICAgICB5OiB5LFxuICAgICAgICB6b29tOiBJbmZpbml0eSwgLy8gdGhlIGxhc3Qgem9vbSB0aGUgY2x1c3RlciB3YXMgcHJvY2Vzc2VkIGF0XG4gICAgICAgIGlkOiBpZCwgLy8gaW5kZXggb2YgdGhlIHNvdXJjZSBmZWF0dXJlIGluIHRoZSBvcmlnaW5hbCBpbnB1dCBhcnJheVxuICAgICAgICBudW1Qb2ludHM6IG51bVBvaW50c1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50Q2x1c3RlcihwLCBpKSB7XG4gICAgdmFyIGNvb3JkcyA9IHAuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgcmV0dXJuIGNyZWF0ZUNsdXN0ZXIobG5nWChjb29yZHNbMF0pLCBsYXRZKGNvb3Jkc1sxXSksIDEsIGkpO1xufVxuXG5mdW5jdGlvbiBnZXRDbHVzdGVySlNPTihjbHVzdGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICBwcm9wZXJ0aWVzOiBnZXRDbHVzdGVyUHJvcGVydGllcyhjbHVzdGVyKSxcbiAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgIHR5cGU6ICdQb2ludCcsXG4gICAgICAgICAgICBjb29yZGluYXRlczogW3hMbmcoY2x1c3Rlci54KSwgeUxhdChjbHVzdGVyLnkpXVxuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2x1c3RlclByb3BlcnRpZXMoY2x1c3Rlcikge1xuICAgIHZhciBjb3VudCA9IGNsdXN0ZXIubnVtUG9pbnRzO1xuICAgIHZhciBhYmJyZXYgPSBjb3VudCA+PSAxMDAwMCA/IE1hdGgucm91bmQoY291bnQgLyAxMDAwKSArICdrJyA6XG4gICAgICAgICAgICAgICAgIGNvdW50ID49IDEwMDAgPyAoTWF0aC5yb3VuZChjb3VudCAvIDEwMCkgLyAxMCkgKyAnaycgOiBjb3VudDtcbiAgICByZXR1cm4ge1xuICAgICAgICBjbHVzdGVyOiB0cnVlLFxuICAgICAgICBwb2ludF9jb3VudDogY291bnQsXG4gICAgICAgIHBvaW50X2NvdW50X2FiYnJldmlhdGVkOiBhYmJyZXZcbiAgICB9O1xufVxuXG4vLyBsb25naXR1ZGUvbGF0aXR1ZGUgdG8gc3BoZXJpY2FsIG1lcmNhdG9yIGluIFswLi4xXSByYW5nZVxuZnVuY3Rpb24gbG5nWChsbmcpIHtcbiAgICByZXR1cm4gbG5nIC8gMzYwICsgMC41O1xufVxuZnVuY3Rpb24gbGF0WShsYXQpIHtcbiAgICB2YXIgc2luID0gTWF0aC5zaW4obGF0ICogTWF0aC5QSSAvIDE4MCksXG4gICAgICAgIHkgPSAoMC41IC0gMC4yNSAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyBNYXRoLlBJKTtcbiAgICByZXR1cm4geSA8IDAgPyAwIDpcbiAgICAgICAgICAgeSA+IDEgPyAxIDogeTtcbn1cblxuLy8gc3BoZXJpY2FsIG1lcmNhdG9yIHRvIGxvbmdpdHVkZS9sYXRpdHVkZVxuZnVuY3Rpb24geExuZyh4KSB7XG4gICAgcmV0dXJuICh4IC0gMC41KSAqIDM2MDtcbn1cbmZ1bmN0aW9uIHlMYXQoeSkge1xuICAgIHZhciB5MiA9ICgxODAgLSB5ICogMzYwKSAqIE1hdGguUEkgLyAxODA7XG4gICAgcmV0dXJuIDM2MCAqIE1hdGguYXRhbihNYXRoLmV4cCh5MikpIC8gTWF0aC5QSSAtIDkwO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjKSB7XG4gICAgZm9yICh2YXIgaWQgaW4gc3JjKSBkZXN0W2lkXSA9IHNyY1tpZF07XG4gICAgcmV0dXJuIGRlc3Q7XG59XG5cbmZ1bmN0aW9uIGdldFgocCkge1xuICAgIHJldHVybiBwLng7XG59XG5mdW5jdGlvbiBnZXRZKHApIHtcbiAgICByZXR1cm4gcC55O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc29ydCA9IHJlcXVpcmUoJy4vc29ydCcpO1xudmFyIHJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZScpO1xudmFyIHdpdGhpbiA9IHJlcXVpcmUoJy4vd2l0aGluJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ga2RidXNoO1xuXG5mdW5jdGlvbiBrZGJ1c2gocG9pbnRzLCBnZXRYLCBnZXRZLCBub2RlU2l6ZSwgQXJyYXlUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBLREJ1c2gocG9pbnRzLCBnZXRYLCBnZXRZLCBub2RlU2l6ZSwgQXJyYXlUeXBlKTtcbn1cblxuZnVuY3Rpb24gS0RCdXNoKHBvaW50cywgZ2V0WCwgZ2V0WSwgbm9kZVNpemUsIEFycmF5VHlwZSkge1xuICAgIGdldFggPSBnZXRYIHx8IGRlZmF1bHRHZXRYO1xuICAgIGdldFkgPSBnZXRZIHx8IGRlZmF1bHRHZXRZO1xuICAgIEFycmF5VHlwZSA9IEFycmF5VHlwZSB8fCBBcnJheTtcblxuICAgIHRoaXMubm9kZVNpemUgPSBub2RlU2l6ZSB8fCA2NDtcbiAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcblxuICAgIHRoaXMuaWRzID0gbmV3IEFycmF5VHlwZShwb2ludHMubGVuZ3RoKTtcbiAgICB0aGlzLmNvb3JkcyA9IG5ldyBBcnJheVR5cGUocG9pbnRzLmxlbmd0aCAqIDIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5pZHNbaV0gPSBpO1xuICAgICAgICB0aGlzLmNvb3Jkc1syICogaV0gPSBnZXRYKHBvaW50c1tpXSk7XG4gICAgICAgIHRoaXMuY29vcmRzWzIgKiBpICsgMV0gPSBnZXRZKHBvaW50c1tpXSk7XG4gICAgfVxuXG4gICAgc29ydCh0aGlzLmlkcywgdGhpcy5jb29yZHMsIHRoaXMubm9kZVNpemUsIDAsIHRoaXMuaWRzLmxlbmd0aCAtIDEsIDApO1xufVxuXG5LREJ1c2gucHJvdG90eXBlID0ge1xuICAgIHJhbmdlOiBmdW5jdGlvbiAobWluWCwgbWluWSwgbWF4WCwgbWF4WSkge1xuICAgICAgICByZXR1cm4gcmFuZ2UodGhpcy5pZHMsIHRoaXMuY29vcmRzLCBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCB0aGlzLm5vZGVTaXplKTtcbiAgICB9LFxuXG4gICAgd2l0aGluOiBmdW5jdGlvbiAoeCwgeSwgcikge1xuICAgICAgICByZXR1cm4gd2l0aGluKHRoaXMuaWRzLCB0aGlzLmNvb3JkcywgeCwgeSwgciwgdGhpcy5ub2RlU2l6ZSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZGVmYXVsdEdldFgocCkgeyByZXR1cm4gcFswXTsgfVxuZnVuY3Rpb24gZGVmYXVsdEdldFkocCkgeyByZXR1cm4gcFsxXTsgfVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJhbmdlO1xuXG5mdW5jdGlvbiByYW5nZShpZHMsIGNvb3JkcywgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgbm9kZVNpemUpIHtcbiAgICB2YXIgc3RhY2sgPSBbMCwgaWRzLmxlbmd0aCAtIDEsIDBdO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgeCwgeTtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGF4aXMgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciBsZWZ0ID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA8PSBub2RlU2l6ZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxlZnQ7IGkgPD0gcmlnaHQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHggPSBjb29yZHNbMiAqIGldO1xuICAgICAgICAgICAgICAgIHkgPSBjb29yZHNbMiAqIGkgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoeCA+PSBtaW5YICYmIHggPD0gbWF4WCAmJiB5ID49IG1pblkgJiYgeSA8PSBtYXhZKSByZXN1bHQucHVzaChpZHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbSA9IE1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKTtcblxuICAgICAgICB4ID0gY29vcmRzWzIgKiBtXTtcbiAgICAgICAgeSA9IGNvb3Jkc1syICogbSArIDFdO1xuXG4gICAgICAgIGlmICh4ID49IG1pblggJiYgeCA8PSBtYXhYICYmIHkgPj0gbWluWSAmJiB5IDw9IG1heFkpIHJlc3VsdC5wdXNoKGlkc1ttXSk7XG5cbiAgICAgICAgdmFyIG5leHRBeGlzID0gKGF4aXMgKyAxKSAlIDI7XG5cbiAgICAgICAgaWYgKGF4aXMgPT09IDAgPyBtaW5YIDw9IHggOiBtaW5ZIDw9IHkpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gobGVmdCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKG0gLSAxKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gobmV4dEF4aXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChheGlzID09PSAwID8gbWF4WCA+PSB4IDogbWF4WSA+PSB5KSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKG0gKyAxKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gocmlnaHQpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChuZXh0QXhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRLRDtcblxuZnVuY3Rpb24gc29ydEtEKGlkcywgY29vcmRzLCBub2RlU2l6ZSwgbGVmdCwgcmlnaHQsIGRlcHRoKSB7XG4gICAgaWYgKHJpZ2h0IC0gbGVmdCA8PSBub2RlU2l6ZSkgcmV0dXJuO1xuXG4gICAgdmFyIG0gPSBNYXRoLmZsb29yKChsZWZ0ICsgcmlnaHQpIC8gMik7XG5cbiAgICBzZWxlY3QoaWRzLCBjb29yZHMsIG0sIGxlZnQsIHJpZ2h0LCBkZXB0aCAlIDIpO1xuXG4gICAgc29ydEtEKGlkcywgY29vcmRzLCBub2RlU2l6ZSwgbGVmdCwgbSAtIDEsIGRlcHRoICsgMSk7XG4gICAgc29ydEtEKGlkcywgY29vcmRzLCBub2RlU2l6ZSwgbSArIDEsIHJpZ2h0LCBkZXB0aCArIDEpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3QoaWRzLCBjb29yZHMsIGssIGxlZnQsIHJpZ2h0LCBpbmMpIHtcblxuICAgIHdoaWxlIChyaWdodCA+IGxlZnQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA+IDYwMCkge1xuICAgICAgICAgICAgdmFyIG4gPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgdmFyIG0gPSBrIC0gbGVmdCArIDE7XG4gICAgICAgICAgICB2YXIgeiA9IE1hdGgubG9nKG4pO1xuICAgICAgICAgICAgdmFyIHMgPSAwLjUgKiBNYXRoLmV4cCgyICogeiAvIDMpO1xuICAgICAgICAgICAgdmFyIHNkID0gMC41ICogTWF0aC5zcXJ0KHogKiBzICogKG4gLSBzKSAvIG4pICogKG0gLSBuIC8gMiA8IDAgPyAtMSA6IDEpO1xuICAgICAgICAgICAgdmFyIG5ld0xlZnQgPSBNYXRoLm1heChsZWZ0LCBNYXRoLmZsb29yKGsgLSBtICogcyAvIG4gKyBzZCkpO1xuICAgICAgICAgICAgdmFyIG5ld1JpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIE1hdGguZmxvb3IoayArIChuIC0gbSkgKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICBzZWxlY3QoaWRzLCBjb29yZHMsIGssIG5ld0xlZnQsIG5ld1JpZ2h0LCBpbmMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQgPSBjb29yZHNbMiAqIGsgKyBpbmNdO1xuICAgICAgICB2YXIgaSA9IGxlZnQ7XG4gICAgICAgIHZhciBqID0gcmlnaHQ7XG5cbiAgICAgICAgc3dhcEl0ZW0oaWRzLCBjb29yZHMsIGxlZnQsIGspO1xuICAgICAgICBpZiAoY29vcmRzWzIgKiByaWdodCArIGluY10gPiB0KSBzd2FwSXRlbShpZHMsIGNvb3JkcywgbGVmdCwgcmlnaHQpO1xuXG4gICAgICAgIHdoaWxlIChpIDwgaikge1xuICAgICAgICAgICAgc3dhcEl0ZW0oaWRzLCBjb29yZHMsIGksIGopO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgd2hpbGUgKGNvb3Jkc1syICogaSArIGluY10gPCB0KSBpKys7XG4gICAgICAgICAgICB3aGlsZSAoY29vcmRzWzIgKiBqICsgaW5jXSA+IHQpIGotLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb29yZHNbMiAqIGxlZnQgKyBpbmNdID09PSB0KSBzd2FwSXRlbShpZHMsIGNvb3JkcywgbGVmdCwgaik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgc3dhcEl0ZW0oaWRzLCBjb29yZHMsIGosIHJpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqIDw9IGspIGxlZnQgPSBqICsgMTtcbiAgICAgICAgaWYgKGsgPD0gaikgcmlnaHQgPSBqIC0gMTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN3YXBJdGVtKGlkcywgY29vcmRzLCBpLCBqKSB7XG4gICAgc3dhcChpZHMsIGksIGopO1xuICAgIHN3YXAoY29vcmRzLCAyICogaSwgMiAqIGopO1xuICAgIHN3YXAoY29vcmRzLCAyICogaSArIDEsIDIgKiBqICsgMSk7XG59XG5cbmZ1bmN0aW9uIHN3YXAoYXJyLCBpLCBqKSB7XG4gICAgdmFyIHRtcCA9IGFycltpXTtcbiAgICBhcnJbaV0gPSBhcnJbal07XG4gICAgYXJyW2pdID0gdG1wO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHdpdGhpbjtcblxuZnVuY3Rpb24gd2l0aGluKGlkcywgY29vcmRzLCBxeCwgcXksIHIsIG5vZGVTaXplKSB7XG4gICAgdmFyIHN0YWNrID0gWzAsIGlkcy5sZW5ndGggLSAxLCAwXTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHIyID0gciAqIHI7XG5cbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHZhciBheGlzID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciByaWdodCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgbGVmdCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbm9kZVNpemUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsZWZ0OyBpIDw9IHJpZ2h0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc3FEaXN0KGNvb3Jkc1syICogaV0sIGNvb3Jkc1syICogaSArIDFdLCBxeCwgcXkpIDw9IHIyKSByZXN1bHQucHVzaChpZHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbSA9IE1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKTtcblxuICAgICAgICB2YXIgeCA9IGNvb3Jkc1syICogbV07XG4gICAgICAgIHZhciB5ID0gY29vcmRzWzIgKiBtICsgMV07XG5cbiAgICAgICAgaWYgKHNxRGlzdCh4LCB5LCBxeCwgcXkpIDw9IHIyKSByZXN1bHQucHVzaChpZHNbbV0pO1xuXG4gICAgICAgIHZhciBuZXh0QXhpcyA9IChheGlzICsgMSkgJSAyO1xuXG4gICAgICAgIGlmIChheGlzID09PSAwID8gcXggLSByIDw9IHggOiBxeSAtIHIgPD0geSkge1xuICAgICAgICAgICAgc3RhY2sucHVzaChsZWZ0KTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gobSAtIDEpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChuZXh0QXhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF4aXMgPT09IDAgPyBxeCArIHIgPj0geCA6IHF5ICsgciA+PSB5KSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKG0gKyAxKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gocmlnaHQpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChuZXh0QXhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBzcURpc3QoYXgsIGF5LCBieCwgYnkpIHtcbiAgICB2YXIgZHggPSBheCAtIGJ4O1xuICAgIHZhciBkeSA9IGF5IC0gYnk7XG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbnlRdWV1ZTtcblxuZnVuY3Rpb24gVGlueVF1ZXVlKGRhdGEsIGNvbXBhcmUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGlueVF1ZXVlKSkgcmV0dXJuIG5ldyBUaW55UXVldWUoZGF0YSwgY29tcGFyZSk7XG5cbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IFtdO1xuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICB0aGlzLmNvbXBhcmUgPSBjb21wYXJlIHx8IGRlZmF1bHRDb21wYXJlO1xuXG4gICAgaWYgKGRhdGEpIGZvciAodmFyIGkgPSBNYXRoLmZsb29yKHRoaXMubGVuZ3RoIC8gMik7IGkgPj0gMDsgaS0tKSB0aGlzLl9kb3duKGkpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xufVxuXG5UaW55UXVldWUucHJvdG90eXBlID0ge1xuXG4gICAgcHVzaDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5kYXRhLnB1c2goaXRlbSk7XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgIHRoaXMuX3VwKHRoaXMubGVuZ3RoIC0gMSk7XG4gICAgfSxcblxuICAgIHBvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9wID0gdGhpcy5kYXRhWzBdO1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB0aGlzLmRhdGFbdGhpcy5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgdGhpcy5kYXRhLnBvcCgpO1xuICAgICAgICB0aGlzLl9kb3duKDApO1xuICAgICAgICByZXR1cm4gdG9wO1xuICAgIH0sXG5cbiAgICBwZWVrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbMF07XG4gICAgfSxcblxuICAgIF91cDogZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGNvbXBhcmUgPSB0aGlzLmNvbXBhcmU7XG5cbiAgICAgICAgd2hpbGUgKHBvcyA+IDApIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBNYXRoLmZsb29yKChwb3MgLSAxKSAvIDIpO1xuICAgICAgICAgICAgaWYgKGNvbXBhcmUoZGF0YVtwb3NdLCBkYXRhW3BhcmVudF0pIDwgMCkge1xuICAgICAgICAgICAgICAgIHN3YXAoZGF0YSwgcGFyZW50LCBwb3MpO1xuICAgICAgICAgICAgICAgIHBvcyA9IHBhcmVudDtcblxuICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9kb3duOiBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgY29tcGFyZSA9IHRoaXMuY29tcGFyZSxcbiAgICAgICAgICAgIGxlbiA9IHRoaXMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IDIgKiBwb3MgKyAxLFxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gbGVmdCArIDEsXG4gICAgICAgICAgICAgICAgbWluID0gcG9zO1xuXG4gICAgICAgICAgICBpZiAobGVmdCA8IGxlbiAmJiBjb21wYXJlKGRhdGFbbGVmdF0sIGRhdGFbbWluXSkgPCAwKSBtaW4gPSBsZWZ0O1xuICAgICAgICAgICAgaWYgKHJpZ2h0IDwgbGVuICYmIGNvbXBhcmUoZGF0YVtyaWdodF0sIGRhdGFbbWluXSkgPCAwKSBtaW4gPSByaWdodDtcblxuICAgICAgICAgICAgaWYgKG1pbiA9PT0gcG9zKSByZXR1cm47XG5cbiAgICAgICAgICAgIHN3YXAoZGF0YSwgbWluLCBwb3MpO1xuICAgICAgICAgICAgcG9zID0gbWluO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZnVuY3Rpb24gc3dhcChkYXRhLCBpLCBqKSB7XG4gICAgdmFyIHRtcCA9IGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGRhdGFbal07XG4gICAgZGF0YVtqXSA9IHRtcDtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDggQXBwbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gKiBhcmUgbWV0OlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgQVBQTEUgSU5DLiBgYEFTIElTJycgQU5EIEFOWVxuICogRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuICogUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIEFQUExFIElOQy4gT1JcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxuICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZXG4gKiBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKiBQb3J0ZWQgZnJvbSBXZWJraXRcbiAqIGh0dHA6Ly9zdm4ud2Via2l0Lm9yZy9yZXBvc2l0b3J5L3dlYmtpdC90cnVuay9Tb3VyY2UvV2ViQ29yZS9wbGF0Zm9ybS9ncmFwaGljcy9Vbml0QmV6aWVyLmhcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVuaXRCZXppZXI7XG5cbmZ1bmN0aW9uIFVuaXRCZXppZXIocDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwb2x5bm9taWFsIGNvZWZmaWNpZW50cywgaW1wbGljaXQgZmlyc3QgYW5kIGxhc3QgY29udHJvbCBwb2ludHMgYXJlICgwLDApIGFuZCAoMSwxKS5cbiAgICB0aGlzLmN4ID0gMy4wICogcDF4O1xuICAgIHRoaXMuYnggPSAzLjAgKiAocDJ4IC0gcDF4KSAtIHRoaXMuY3g7XG4gICAgdGhpcy5heCA9IDEuMCAtIHRoaXMuY3ggLSB0aGlzLmJ4O1xuXG4gICAgdGhpcy5jeSA9IDMuMCAqIHAxeTtcbiAgICB0aGlzLmJ5ID0gMy4wICogKHAyeSAtIHAxeSkgLSB0aGlzLmN5O1xuICAgIHRoaXMuYXkgPSAxLjAgLSB0aGlzLmN5IC0gdGhpcy5ieTtcblxuICAgIHRoaXMucDF4ID0gcDF4O1xuICAgIHRoaXMucDF5ID0gcDJ5O1xuICAgIHRoaXMucDJ4ID0gcDJ4O1xuICAgIHRoaXMucDJ5ID0gcDJ5O1xufVxuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZVggPSBmdW5jdGlvbih0KSB7XG4gICAgLy8gYGF4IHReMyArIGJ4IHReMiArIGN4IHQnIGV4cGFuZGVkIHVzaW5nIEhvcm5lcidzIHJ1bGUuXG4gICAgcmV0dXJuICgodGhpcy5heCAqIHQgKyB0aGlzLmJ4KSAqIHQgKyB0aGlzLmN4KSAqIHQ7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZVkgPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuICgodGhpcy5heSAqIHQgKyB0aGlzLmJ5KSAqIHQgKyB0aGlzLmN5KSAqIHQ7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZURlcml2YXRpdmVYID0gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiAoMy4wICogdGhpcy5heCAqIHQgKyAyLjAgKiB0aGlzLmJ4KSAqIHQgKyB0aGlzLmN4O1xufTtcblxuVW5pdEJlemllci5wcm90b3R5cGUuc29sdmVDdXJ2ZVggPSBmdW5jdGlvbih4LCBlcHNpbG9uKSB7XG4gICAgaWYgKHR5cGVvZiBlcHNpbG9uID09PSAndW5kZWZpbmVkJykgZXBzaWxvbiA9IDFlLTY7XG5cbiAgICB2YXIgdDAsIHQxLCB0MiwgeDIsIGk7XG5cbiAgICAvLyBGaXJzdCB0cnkgYSBmZXcgaXRlcmF0aW9ucyBvZiBOZXd0b24ncyBtZXRob2QgLS0gbm9ybWFsbHkgdmVyeSBmYXN0LlxuICAgIGZvciAodDIgPSB4LCBpID0gMDsgaSA8IDg7IGkrKykge1xuXG4gICAgICAgIHgyID0gdGhpcy5zYW1wbGVDdXJ2ZVgodDIpIC0geDtcbiAgICAgICAgaWYgKE1hdGguYWJzKHgyKSA8IGVwc2lsb24pIHJldHVybiB0MjtcblxuICAgICAgICB2YXIgZDIgPSB0aGlzLnNhbXBsZUN1cnZlRGVyaXZhdGl2ZVgodDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoZDIpIDwgMWUtNikgYnJlYWs7XG5cbiAgICAgICAgdDIgPSB0MiAtIHgyIC8gZDI7XG4gICAgfVxuXG4gICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBiaXNlY3Rpb24gbWV0aG9kIGZvciByZWxpYWJpbGl0eS5cbiAgICB0MCA9IDAuMDtcbiAgICB0MSA9IDEuMDtcbiAgICB0MiA9IHg7XG5cbiAgICBpZiAodDIgPCB0MCkgcmV0dXJuIHQwO1xuICAgIGlmICh0MiA+IHQxKSByZXR1cm4gdDE7XG5cbiAgICB3aGlsZSAodDAgPCB0MSkge1xuXG4gICAgICAgIHgyID0gdGhpcy5zYW1wbGVDdXJ2ZVgodDIpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoeDIgLSB4KSA8IGVwc2lsb24pIHJldHVybiB0MjtcblxuICAgICAgICBpZiAoeCA+IHgyKSB7XG4gICAgICAgICAgICB0MCA9IHQyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdDEgPSB0MjtcbiAgICAgICAgfVxuXG4gICAgICAgIHQyID0gKHQxIC0gdDApICogMC41ICsgdDA7XG4gICAgfVxuXG4gICAgLy8gRmFpbHVyZS5cbiAgICByZXR1cm4gdDI7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uKHgsIGVwc2lsb24pIHtcbiAgICByZXR1cm4gdGhpcy5zYW1wbGVDdXJ2ZVkodGhpcy5zb2x2ZUN1cnZlWCh4LCBlcHNpbG9uKSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMuVmVjdG9yVGlsZSA9IHJlcXVpcmUoJy4vbGliL3ZlY3RvcnRpbGUuanMnKTtcbm1vZHVsZS5leHBvcnRzLlZlY3RvclRpbGVGZWF0dXJlID0gcmVxdWlyZSgnLi9saWIvdmVjdG9ydGlsZWZlYXR1cmUuanMnKTtcbm1vZHVsZS5leHBvcnRzLlZlY3RvclRpbGVMYXllciA9IHJlcXVpcmUoJy4vbGliL3ZlY3RvcnRpbGVsYXllci5qcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmVjdG9yVGlsZUxheWVyID0gcmVxdWlyZSgnLi92ZWN0b3J0aWxlbGF5ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWZWN0b3JUaWxlO1xuXG5mdW5jdGlvbiBWZWN0b3JUaWxlKHBiZiwgZW5kKSB7XG4gICAgdGhpcy5sYXllcnMgPSBwYmYucmVhZEZpZWxkcyhyZWFkVGlsZSwge30sIGVuZCk7XG59XG5cbmZ1bmN0aW9uIHJlYWRUaWxlKHRhZywgbGF5ZXJzLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAzKSB7XG4gICAgICAgIHZhciBsYXllciA9IG5ldyBWZWN0b3JUaWxlTGF5ZXIocGJmLCBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcyk7XG4gICAgICAgIGlmIChsYXllci5sZW5ndGgpIGxheWVyc1tsYXllci5uYW1lXSA9IGxheWVyO1xuICAgIH1cbn1cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvclRpbGVGZWF0dXJlO1xuXG5mdW5jdGlvbiBWZWN0b3JUaWxlRmVhdHVyZShwYmYsIGVuZCwgZXh0ZW50LCBrZXlzLCB2YWx1ZXMpIHtcbiAgICAvLyBQdWJsaWNcbiAgICB0aGlzLnByb3BlcnRpZXMgPSB7fTtcbiAgICB0aGlzLmV4dGVudCA9IGV4dGVudDtcbiAgICB0aGlzLnR5cGUgPSAwO1xuXG4gICAgLy8gUHJpdmF0ZVxuICAgIHRoaXMuX3BiZiA9IHBiZjtcbiAgICB0aGlzLl9nZW9tZXRyeSA9IC0xO1xuICAgIHRoaXMuX2tleXMgPSBrZXlzO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcblxuICAgIHBiZi5yZWFkRmllbGRzKHJlYWRGZWF0dXJlLCB0aGlzLCBlbmQpO1xufVxuXG5mdW5jdGlvbiByZWFkRmVhdHVyZSh0YWcsIGZlYXR1cmUsIHBiZikge1xuICAgIGlmICh0YWcgPT0gMSkgZmVhdHVyZS5faWQgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PSAyKSByZWFkVGFnKHBiZiwgZmVhdHVyZSk7XG4gICAgZWxzZSBpZiAodGFnID09IDMpIGZlYXR1cmUudHlwZSA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09IDQpIGZlYXR1cmUuX2dlb21ldHJ5ID0gcGJmLnBvcztcbn1cblxuZnVuY3Rpb24gcmVhZFRhZyhwYmYsIGZlYXR1cmUpIHtcbiAgICB2YXIgZW5kID0gcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3M7XG5cbiAgICB3aGlsZSAocGJmLnBvcyA8IGVuZCkge1xuICAgICAgICB2YXIga2V5ID0gZmVhdHVyZS5fa2V5c1twYmYucmVhZFZhcmludCgpXSxcbiAgICAgICAgICAgIHZhbHVlID0gZmVhdHVyZS5fdmFsdWVzW3BiZi5yZWFkVmFyaW50KCldO1xuICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbn1cblxuVmVjdG9yVGlsZUZlYXR1cmUudHlwZXMgPSBbJ1Vua25vd24nLCAnUG9pbnQnLCAnTGluZVN0cmluZycsICdQb2x5Z29uJ107XG5cblZlY3RvclRpbGVGZWF0dXJlLnByb3RvdHlwZS5sb2FkR2VvbWV0cnkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGJmID0gdGhpcy5fcGJmO1xuICAgIHBiZi5wb3MgPSB0aGlzLl9nZW9tZXRyeTtcblxuICAgIHZhciBlbmQgPSBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcyxcbiAgICAgICAgY21kID0gMSxcbiAgICAgICAgbGVuZ3RoID0gMCxcbiAgICAgICAgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICBsaW5lcyA9IFtdLFxuICAgICAgICBsaW5lO1xuXG4gICAgd2hpbGUgKHBiZi5wb3MgPCBlbmQpIHtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjbWRMZW4gPSBwYmYucmVhZFZhcmludCgpO1xuICAgICAgICAgICAgY21kID0gY21kTGVuICYgMHg3O1xuICAgICAgICAgICAgbGVuZ3RoID0gY21kTGVuID4+IDM7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGgtLTtcblxuICAgICAgICBpZiAoY21kID09PSAxIHx8IGNtZCA9PT0gMikge1xuICAgICAgICAgICAgeCArPSBwYmYucmVhZFNWYXJpbnQoKTtcbiAgICAgICAgICAgIHkgKz0gcGJmLnJlYWRTVmFyaW50KCk7XG5cbiAgICAgICAgICAgIGlmIChjbWQgPT09IDEpIHsgLy8gbW92ZVRvXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUpIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICAgICAgbGluZSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaW5lLnB1c2gobmV3IFBvaW50KHgsIHkpKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNtZCA9PT0gNykge1xuXG4gICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcG5pay12ZWN0b3ItdGlsZS9pc3N1ZXMvOTBcbiAgICAgICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgbGluZS5wdXNoKGxpbmVbMF0uY2xvbmUoKSk7IC8vIGNsb3NlUG9seWdvblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gY29tbWFuZCAnICsgY21kKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsaW5lKSBsaW5lcy5wdXNoKGxpbmUpO1xuXG4gICAgcmV0dXJuIGxpbmVzO1xufTtcblxuVmVjdG9yVGlsZUZlYXR1cmUucHJvdG90eXBlLmJib3ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGJmID0gdGhpcy5fcGJmO1xuICAgIHBiZi5wb3MgPSB0aGlzLl9nZW9tZXRyeTtcblxuICAgIHZhciBlbmQgPSBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcyxcbiAgICAgICAgY21kID0gMSxcbiAgICAgICAgbGVuZ3RoID0gMCxcbiAgICAgICAgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICB4MSA9IEluZmluaXR5LFxuICAgICAgICB4MiA9IC1JbmZpbml0eSxcbiAgICAgICAgeTEgPSBJbmZpbml0eSxcbiAgICAgICAgeTIgPSAtSW5maW5pdHk7XG5cbiAgICB3aGlsZSAocGJmLnBvcyA8IGVuZCkge1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNtZExlbiA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgICAgICAgICBjbWQgPSBjbWRMZW4gJiAweDc7XG4gICAgICAgICAgICBsZW5ndGggPSBjbWRMZW4gPj4gMztcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aC0tO1xuXG4gICAgICAgIGlmIChjbWQgPT09IDEgfHwgY21kID09PSAyKSB7XG4gICAgICAgICAgICB4ICs9IHBiZi5yZWFkU1ZhcmludCgpO1xuICAgICAgICAgICAgeSArPSBwYmYucmVhZFNWYXJpbnQoKTtcbiAgICAgICAgICAgIGlmICh4IDwgeDEpIHgxID0geDtcbiAgICAgICAgICAgIGlmICh4ID4geDIpIHgyID0geDtcbiAgICAgICAgICAgIGlmICh5IDwgeTEpIHkxID0geTtcbiAgICAgICAgICAgIGlmICh5ID4geTIpIHkyID0geTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNtZCAhPT0gNykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGNvbW1hbmQgJyArIGNtZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3gxLCB5MSwgeDIsIHkyXTtcbn07XG5cblZlY3RvclRpbGVGZWF0dXJlLnByb3RvdHlwZS50b0dlb0pTT04gPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLmV4dGVudCAqIE1hdGgucG93KDIsIHopLFxuICAgICAgICB4MCA9IHRoaXMuZXh0ZW50ICogeCxcbiAgICAgICAgeTAgPSB0aGlzLmV4dGVudCAqIHksXG4gICAgICAgIGNvb3JkcyA9IHRoaXMubG9hZEdlb21ldHJ5KCksXG4gICAgICAgIHR5cGUgPSBWZWN0b3JUaWxlRmVhdHVyZS50eXBlc1t0aGlzLnR5cGVdLFxuICAgICAgICBpLCBqO1xuXG4gICAgZnVuY3Rpb24gcHJvamVjdChsaW5lKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHAgPSBsaW5lW2pdLCB5MiA9IDE4MCAtIChwLnkgKyB5MCkgKiAzNjAgLyBzaXplO1xuICAgICAgICAgICAgbGluZVtqXSA9IFtcbiAgICAgICAgICAgICAgICAocC54ICsgeDApICogMzYwIC8gc2l6ZSAtIDE4MCxcbiAgICAgICAgICAgICAgICAzNjAgLyBNYXRoLlBJICogTWF0aC5hdGFuKE1hdGguZXhwKHkyICogTWF0aC5QSSAvIDE4MCkpIC0gOTBcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgMTpcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwb2ludHNbaV0gPSBjb29yZHNbaV1bMF07XG4gICAgICAgIH1cbiAgICAgICAgY29vcmRzID0gcG9pbnRzO1xuICAgICAgICBwcm9qZWN0KGNvb3Jkcyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAyOlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwcm9qZWN0KGNvb3Jkc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDM6XG4gICAgICAgIGNvb3JkcyA9IGNsYXNzaWZ5UmluZ3MoY29vcmRzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHByb2plY3QoY29vcmRzW2ldW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoY29vcmRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb29yZHMgPSBjb29yZHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9ICdNdWx0aScgKyB0eXBlO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZHNcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcGVydGllczogdGhpcy5wcm9wZXJ0aWVzXG4gICAgfTtcblxuICAgIGlmICgnX2lkJyBpbiB0aGlzKSB7XG4gICAgICAgIHJlc3VsdC5pZCA9IHRoaXMuX2lkO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBjbGFzc2lmaWVzIGFuIGFycmF5IG9mIHJpbmdzIGludG8gcG9seWdvbnMgd2l0aCBvdXRlciByaW5ncyBhbmQgaG9sZXNcblxuZnVuY3Rpb24gY2xhc3NpZnlSaW5ncyhyaW5ncykge1xuICAgIHZhciBsZW4gPSByaW5ncy5sZW5ndGg7XG5cbiAgICBpZiAobGVuIDw9IDEpIHJldHVybiBbcmluZ3NdO1xuXG4gICAgdmFyIHBvbHlnb25zID0gW10sXG4gICAgICAgIHBvbHlnb24sXG4gICAgICAgIGNjdztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGFyZWEgPSBzaWduZWRBcmVhKHJpbmdzW2ldKTtcbiAgICAgICAgaWYgKGFyZWEgPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmIChjY3cgPT09IHVuZGVmaW5lZCkgY2N3ID0gYXJlYSA8IDA7XG5cbiAgICAgICAgaWYgKGNjdyA9PT0gYXJlYSA8IDApIHtcbiAgICAgICAgICAgIGlmIChwb2x5Z29uKSBwb2x5Z29ucy5wdXNoKHBvbHlnb24pO1xuICAgICAgICAgICAgcG9seWdvbiA9IFtyaW5nc1tpXV07XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvbHlnb24ucHVzaChyaW5nc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBvbHlnb24pIHBvbHlnb25zLnB1c2gocG9seWdvbik7XG5cbiAgICByZXR1cm4gcG9seWdvbnM7XG59XG5cbmZ1bmN0aW9uIHNpZ25lZEFyZWEocmluZykge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByaW5nLmxlbmd0aCwgaiA9IGxlbiAtIDEsIHAxLCBwMjsgaSA8IGxlbjsgaiA9IGkrKykge1xuICAgICAgICBwMSA9IHJpbmdbaV07XG4gICAgICAgIHAyID0gcmluZ1tqXTtcbiAgICAgICAgc3VtICs9IChwMi54IC0gcDEueCkgKiAocDEueSArIHAyLnkpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmVjdG9yVGlsZUZlYXR1cmUgPSByZXF1aXJlKCcuL3ZlY3RvcnRpbGVmZWF0dXJlLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmVjdG9yVGlsZUxheWVyO1xuXG5mdW5jdGlvbiBWZWN0b3JUaWxlTGF5ZXIocGJmLCBlbmQpIHtcbiAgICAvLyBQdWJsaWNcbiAgICB0aGlzLnZlcnNpb24gPSAxO1xuICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgdGhpcy5leHRlbnQgPSA0MDk2O1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIC8vIFByaXZhdGVcbiAgICB0aGlzLl9wYmYgPSBwYmY7XG4gICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgIHRoaXMuX2ZlYXR1cmVzID0gW107XG5cbiAgICBwYmYucmVhZEZpZWxkcyhyZWFkTGF5ZXIsIHRoaXMsIGVuZCk7XG5cbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMuX2ZlYXR1cmVzLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gcmVhZExheWVyKHRhZywgbGF5ZXIsIHBiZikge1xuICAgIGlmICh0YWcgPT09IDE1KSBsYXllci52ZXJzaW9uID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDEpIGxheWVyLm5hbWUgPSBwYmYucmVhZFN0cmluZygpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNSkgbGF5ZXIuZXh0ZW50ID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDIpIGxheWVyLl9mZWF0dXJlcy5wdXNoKHBiZi5wb3MpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMykgbGF5ZXIuX2tleXMucHVzaChwYmYucmVhZFN0cmluZygpKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDQpIGxheWVyLl92YWx1ZXMucHVzaChyZWFkVmFsdWVNZXNzYWdlKHBiZikpO1xufVxuXG5mdW5jdGlvbiByZWFkVmFsdWVNZXNzYWdlKHBiZikge1xuICAgIHZhciB2YWx1ZSA9IG51bGwsXG4gICAgICAgIGVuZCA9IHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zO1xuXG4gICAgd2hpbGUgKHBiZi5wb3MgPCBlbmQpIHtcbiAgICAgICAgdmFyIHRhZyA9IHBiZi5yZWFkVmFyaW50KCkgPj4gMztcblxuICAgICAgICB2YWx1ZSA9IHRhZyA9PT0gMSA/IHBiZi5yZWFkU3RyaW5nKCkgOlxuICAgICAgICAgICAgdGFnID09PSAyID8gcGJmLnJlYWRGbG9hdCgpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gMyA/IHBiZi5yZWFkRG91YmxlKCkgOlxuICAgICAgICAgICAgdGFnID09PSA0ID8gcGJmLnJlYWRWYXJpbnQ2NCgpIDpcbiAgICAgICAgICAgIHRhZyA9PT0gNSA/IHBiZi5yZWFkVmFyaW50KCkgOlxuICAgICAgICAgICAgdGFnID09PSA2ID8gcGJmLnJlYWRTVmFyaW50KCkgOlxuICAgICAgICAgICAgdGFnID09PSA3ID8gcGJmLnJlYWRCb29sZWFuKCkgOiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gcmV0dXJuIGZlYXR1cmUgYGlgIGZyb20gdGhpcyBsYXllciBhcyBhIGBWZWN0b3JUaWxlRmVhdHVyZWBcblZlY3RvclRpbGVMYXllci5wcm90b3R5cGUuZmVhdHVyZSA9IGZ1bmN0aW9uKGkpIHtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLl9mZWF0dXJlcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignZmVhdHVyZSBpbmRleCBvdXQgb2YgYm91bmRzJyk7XG5cbiAgICB0aGlzLl9wYmYucG9zID0gdGhpcy5fZmVhdHVyZXNbaV07XG5cbiAgICB2YXIgZW5kID0gdGhpcy5fcGJmLnJlYWRWYXJpbnQoKSArIHRoaXMuX3BiZi5wb3M7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3JUaWxlRmVhdHVyZSh0aGlzLl9wYmYsIGVuZCwgdGhpcy5leHRlbnQsIHRoaXMuX2tleXMsIHRoaXMuX3ZhbHVlcyk7XG59O1xuIiwidmFyIFBiZiA9IHJlcXVpcmUoJ3BiZicpXG52YXIgdnRwYiA9IHJlcXVpcmUoJy4vdmVjdG9yLXRpbGUtcGInKVxudmFyIEdlb0pTT05XcmFwcGVyID0gcmVxdWlyZSgnLi9saWIvZ2VvanNvbl93cmFwcGVyJylcblxubW9kdWxlLmV4cG9ydHMgPSBmcm9tVmVjdG9yVGlsZUpzXG5tb2R1bGUuZXhwb3J0cy5mcm9tVmVjdG9yVGlsZUpzID0gZnJvbVZlY3RvclRpbGVKc1xubW9kdWxlLmV4cG9ydHMuZnJvbUdlb2pzb25WdCA9IGZyb21HZW9qc29uVnRcbm1vZHVsZS5leHBvcnRzLkdlb0pTT05XcmFwcGVyID0gR2VvSlNPTldyYXBwZXJcblxuLyoqXG4gKiBTZXJpYWxpemUgYSB2ZWN0b3ItdGlsZS1qcy1jcmVhdGVkIHRpbGUgdG8gcGJmXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRpbGVcbiAqIEByZXR1cm4ge0J1ZmZlcn0gdW5jb21wcmVzc2VkLCBwYmYtc2VyaWFsaXplZCB0aWxlIGRhdGFcbiAqL1xuZnVuY3Rpb24gZnJvbVZlY3RvclRpbGVKcyAodGlsZSkge1xuICB2YXIgbGF5ZXJzID0gW11cbiAgZm9yICh2YXIgbCBpbiB0aWxlLmxheWVycykge1xuICAgIGxheWVycy5wdXNoKHByZXBhcmVMYXllcih0aWxlLmxheWVyc1tsXSkpXG4gIH1cblxuICB2YXIgb3V0ID0gbmV3IFBiZigpXG4gIHZ0cGIudGlsZS53cml0ZSh7IGxheWVyczogbGF5ZXJzIH0sIG91dClcbiAgcmV0dXJuIG91dC5maW5pc2goKVxufVxuXG4vKipcbiAqIFNlcmlhbGl6ZWQgYSBnZW9qc29uLXZ0LWNyZWF0ZWQgdGlsZSB0byBwYmYuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGxheWVycyAtIEFuIG9iamVjdCBtYXBwaW5nIGxheWVyIG5hbWVzIHRvIGdlb2pzb24tdnQtY3JlYXRlZCB2ZWN0b3IgdGlsZSBvYmplY3RzXG4gKiBAcmV0dXJuIHtCdWZmZXJ9IHVuY29tcHJlc3NlZCwgcGJmLXNlcmlhbGl6ZWQgdGlsZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIGZyb21HZW9qc29uVnQgKGxheWVycykge1xuICB2YXIgbCA9IHt9XG4gIGZvciAodmFyIGsgaW4gbGF5ZXJzKSB7XG4gICAgbFtrXSA9IG5ldyBHZW9KU09OV3JhcHBlcihsYXllcnNba10uZmVhdHVyZXMpXG4gICAgbFtrXS5uYW1lID0ga1xuICB9XG4gIHJldHVybiBmcm9tVmVjdG9yVGlsZUpzKHtsYXllcnM6IGx9KVxufVxuXG4vKipcbiAqIFByZXBhcmUgdGhlIGdpdmVuIGxheWVyIHRvIGJlIHNlcmlhbGl6ZWQgYnkgdGhlIGF1dG8tZ2VuZXJhdGVkIHBiZlxuICogc2VyaWFsaXplciBieSBlbmNvZGluZyB0aGUgZmVhdHVyZSBnZW9tZXRyeSBhbmQgcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gcHJlcGFyZUxheWVyIChsYXllcikge1xuICB2YXIgcHJlcGFyZWRMYXllciA9IHtcbiAgICBuYW1lOiBsYXllci5uYW1lIHx8ICcnLFxuICAgIHZlcnNpb246IGxheWVyLnZlcnNpb24gfHwgMSxcbiAgICBleHRlbnQ6IGxheWVyLmV4dGVudCB8fCA0MDk2LFxuICAgIGtleXM6IFtdLFxuICAgIHZhbHVlczogW10sXG4gICAgZmVhdHVyZXM6IFtdXG4gIH1cblxuICB2YXIga2V5Y2FjaGUgPSB7fVxuICB2YXIgdmFsdWVjYWNoZSA9IHt9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmZWF0dXJlID0gbGF5ZXIuZmVhdHVyZShpKVxuICAgIGZlYXR1cmUuZ2VvbWV0cnkgPSBlbmNvZGVHZW9tZXRyeShmZWF0dXJlLmxvYWRHZW9tZXRyeSgpKVxuXG4gICAgdmFyIHRhZ3MgPSBbXVxuICAgIGZvciAodmFyIGtleSBpbiBmZWF0dXJlLnByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBrZXlJbmRleCA9IGtleWNhY2hlW2tleV1cbiAgICAgIGlmICh0eXBlb2Yga2V5SW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHByZXBhcmVkTGF5ZXIua2V5cy5wdXNoKGtleSlcbiAgICAgICAga2V5SW5kZXggPSBwcmVwYXJlZExheWVyLmtleXMubGVuZ3RoIC0gMVxuICAgICAgICBrZXljYWNoZVtrZXldID0ga2V5SW5kZXhcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IHdyYXBWYWx1ZShmZWF0dXJlLnByb3BlcnRpZXNba2V5XSlcbiAgICAgIHZhciB2YWx1ZUluZGV4ID0gdmFsdWVjYWNoZVt2YWx1ZS5rZXldXG4gICAgICBpZiAodHlwZW9mIHZhbHVlSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHByZXBhcmVkTGF5ZXIudmFsdWVzLnB1c2godmFsdWUpXG4gICAgICAgIHZhbHVlSW5kZXggPSBwcmVwYXJlZExheWVyLnZhbHVlcy5sZW5ndGggLSAxXG4gICAgICAgIHZhbHVlY2FjaGVbdmFsdWUua2V5XSA9IHZhbHVlSW5kZXhcbiAgICAgIH1cbiAgICAgIHRhZ3MucHVzaChrZXlJbmRleClcbiAgICAgIHRhZ3MucHVzaCh2YWx1ZUluZGV4KVxuICAgIH1cblxuICAgIGZlYXR1cmUudGFncyA9IHRhZ3NcbiAgICBwcmVwYXJlZExheWVyLmZlYXR1cmVzLnB1c2goZmVhdHVyZSlcbiAgfVxuXG4gIHJldHVybiBwcmVwYXJlZExheWVyXG59XG5cbmZ1bmN0aW9uIGNvbW1hbmQgKGNtZCwgbGVuZ3RoKSB7XG4gIHJldHVybiAobGVuZ3RoIDw8IDMpICsgKGNtZCAmIDB4Nylcbn1cblxuZnVuY3Rpb24gemlnemFnIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMSkgXiAobnVtID4+IDMxKVxufVxuXG4vKipcbiAqIEVuY29kZSBhIHBvbHlnb24ncyBnZW9tZXRyeSBpbnRvIGFuIGFycmF5IHJlYWR5IHRvIGJlIHNlcmlhbGl6ZWRcbiAqIHRvIG1hcGJveCB2ZWN0b3IgdGlsZSBzcGVjaWZpZWQgZ2VvbWV0cnkgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBSaW5ncywgZWFjaCBiZWluZyBhbiBhcnJheSBvZiBbeCwgeV0gdGlsZS1zcGFjZSBjb29yZGluYXRlc1xuICogQHJldHVybiB7QXJyYXl9IGVuY29kZWQgZ2VvbWV0cnlcbiAqL1xuZnVuY3Rpb24gZW5jb2RlR2VvbWV0cnkgKGdlb21ldHJ5KSB7XG4gIHZhciBlbmNvZGVkID0gW11cbiAgdmFyIHggPSAwXG4gIHZhciB5ID0gMFxuICB2YXIgcmluZ3MgPSBnZW9tZXRyeS5sZW5ndGhcbiAgZm9yICh2YXIgciA9IDA7IHIgPCByaW5nczsgcisrKSB7XG4gICAgdmFyIHJpbmcgPSBnZW9tZXRyeVtyXVxuICAgIGVuY29kZWQucHVzaChjb21tYW5kKDEsIDEpKSAvLyBtb3ZldG9cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpID09PSAxKSB7XG4gICAgICAgIGVuY29kZWQucHVzaChjb21tYW5kKDIsIHJpbmcubGVuZ3RoIC0gMSkpIC8vIGxpbmV0b1xuICAgICAgfVxuICAgICAgdmFyIGR4ID0gcmluZ1tpXS54IC0geFxuICAgICAgdmFyIGR5ID0gcmluZ1tpXS55IC0geVxuICAgICAgZW5jb2RlZC5wdXNoKHppZ3phZyhkeCksIHppZ3phZyhkeSkpXG4gICAgICB4ICs9IGR4XG4gICAgICB5ICs9IGR5XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVuY29kZWRcbn1cblxuLyoqXG4gKiBXcmFwIGEgcHJvcGVydHkgdmFsdWUgYWNjb3JkaW5nIHRvIGl0cyB0eXBlLiBUaGUgcmV0dXJuZWQgb2JqZWN0XG4gKiBpcyBvZiB0aGUgZm9ybSB7IHh4eHhfdmFsdWU6IHByaW1pdGl2ZVZhbHVlIH0sIHdoaWNoIGlzIHdoYXQgdGhlIGdlbmVyYXRlZFxuICogcHJvdG9idWYgc2VyaWFsaXplciBleHBlY3RzLlxuICovXG5mdW5jdGlvbiB3cmFwVmFsdWUgKHZhbHVlKSB7XG4gIHZhciByZXN1bHRcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWVcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0geyBzdHJpbmdfdmFsdWU6IHZhbHVlIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICByZXN1bHQgPSB7IGJvb2xfdmFsdWU6IHZhbHVlIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgIGlmICh2YWx1ZSAhPT0gKHZhbHVlIHwgMCkpIHtcbiAgICAgIHJlc3VsdCA9IHsgZmxvYXRfdmFsdWU6IHZhbHVlIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgcmVzdWx0ID0geyBzaW50X3ZhbHVlOiB2YWx1ZSB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHsgdWludF92YWx1ZTogdmFsdWUgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB7IHN0cmluZ192YWx1ZTogJycgKyB2YWx1ZSB9XG4gIH1cblxuICByZXN1bHQua2V5ID0gdHlwZSArICc6JyArIHZhbHVlXG4gIHJldHVybiByZXN1bHRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgUG9pbnQgPSByZXF1aXJlKCdwb2ludC1nZW9tZXRyeScpXG52YXIgVmVjdG9yVGlsZUZlYXR1cmUgPSByZXF1aXJlKCd2ZWN0b3ItdGlsZScpLlZlY3RvclRpbGVGZWF0dXJlXG5cbm1vZHVsZS5leHBvcnRzID0gR2VvSlNPTldyYXBwZXJcblxuLy8gY29uZm9ybSB0byB2ZWN0b3J0aWxlIGFwaVxuZnVuY3Rpb24gR2VvSlNPTldyYXBwZXIgKGZlYXR1cmVzKSB7XG4gIHRoaXMuZmVhdHVyZXMgPSBmZWF0dXJlc1xuICB0aGlzLmxlbmd0aCA9IGZlYXR1cmVzLmxlbmd0aFxufVxuXG5HZW9KU09OV3JhcHBlci5wcm90b3R5cGUuZmVhdHVyZSA9IGZ1bmN0aW9uIChpKSB7XG4gIHJldHVybiBuZXcgRmVhdHVyZVdyYXBwZXIodGhpcy5mZWF0dXJlc1tpXSlcbn1cblxuZnVuY3Rpb24gRmVhdHVyZVdyYXBwZXIgKGZlYXR1cmUpIHtcbiAgdGhpcy50eXBlID0gZmVhdHVyZS50eXBlXG4gIHRoaXMucmF3R2VvbWV0cnkgPSBmZWF0dXJlLnR5cGUgPT09IDEgPyBbZmVhdHVyZS5nZW9tZXRyeV0gOiBmZWF0dXJlLmdlb21ldHJ5XG4gIHRoaXMucHJvcGVydGllcyA9IGZlYXR1cmUudGFnc1xuICB0aGlzLmV4dGVudCA9IDQwOTZcbn1cblxuRmVhdHVyZVdyYXBwZXIucHJvdG90eXBlLmxvYWRHZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJpbmdzID0gdGhpcy5yYXdHZW9tZXRyeVxuICB0aGlzLmdlb21ldHJ5ID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJpbmcgPSByaW5nc1tpXVxuICAgIHZhciBuZXdSaW5nID0gW11cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpbmcubGVuZ3RoOyBqKyspIHtcbiAgICAgIG5ld1JpbmcucHVzaChuZXcgUG9pbnQocmluZ1tqXVswXSwgcmluZ1tqXVsxXSkpXG4gICAgfVxuICAgIHRoaXMuZ2VvbWV0cnkucHVzaChuZXdSaW5nKVxuICB9XG4gIHJldHVybiB0aGlzLmdlb21ldHJ5XG59XG5cbkZlYXR1cmVXcmFwcGVyLnByb3RvdHlwZS5iYm94ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuZ2VvbWV0cnkpIHRoaXMubG9hZEdlb21ldHJ5KClcblxuICB2YXIgcmluZ3MgPSB0aGlzLmdlb21ldHJ5XG4gIHZhciB4MSA9IEluZmluaXR5XG4gIHZhciB4MiA9IC1JbmZpbml0eVxuICB2YXIgeTEgPSBJbmZpbml0eVxuICB2YXIgeTIgPSAtSW5maW5pdHlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJpbmcgPSByaW5nc1tpXVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCByaW5nLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgY29vcmQgPSByaW5nW2pdXG5cbiAgICAgIHgxID0gTWF0aC5taW4oeDEsIGNvb3JkLngpXG4gICAgICB4MiA9IE1hdGgubWF4KHgyLCBjb29yZC54KVxuICAgICAgeTEgPSBNYXRoLm1pbih5MSwgY29vcmQueSlcbiAgICAgIHkyID0gTWF0aC5tYXgoeTIsIGNvb3JkLnkpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5Ml1cbn1cblxuRmVhdHVyZVdyYXBwZXIucHJvdG90eXBlLnRvR2VvSlNPTiA9IFZlY3RvclRpbGVGZWF0dXJlLnByb3RvdHlwZS50b0dlb0pTT05cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gdGlsZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbnZhciB0aWxlID0gZXhwb3J0cy50aWxlID0ge3JlYWQ6IHJlYWRUaWxlLCB3cml0ZTogd3JpdGVUaWxlfTtcblxudGlsZS5HZW9tVHlwZSA9IHtcbiAgICBcIlVua25vd25cIjogMCxcbiAgICBcIlBvaW50XCI6IDEsXG4gICAgXCJMaW5lU3RyaW5nXCI6IDIsXG4gICAgXCJQb2x5Z29uXCI6IDNcbn07XG5cbmZ1bmN0aW9uIHJlYWRUaWxlKHBiZiwgZW5kKSB7XG4gICAgcmV0dXJuIHBiZi5yZWFkRmllbGRzKHJlYWRUaWxlRmllbGQsIHtcImxheWVyc1wiOiBbXX0sIGVuZCk7XG59XG5cbmZ1bmN0aW9uIHJlYWRUaWxlRmllbGQodGFnLCB0aWxlLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAzKSB0aWxlLmxheWVycy5wdXNoKHJlYWRMYXllcihwYmYsIHBiZi5yZWFkVmFyaW50KCkgKyBwYmYucG9zKSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlVGlsZSh0aWxlLCBwYmYpIHtcbiAgICB2YXIgaTtcbiAgICBpZiAodGlsZS5sYXllcnMgIT09IHVuZGVmaW5lZCkgZm9yIChpID0gMDsgaSA8IHRpbGUubGF5ZXJzLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVNZXNzYWdlKDMsIHdyaXRlTGF5ZXIsIHRpbGUubGF5ZXJzW2ldKTtcbn1cblxuLy8gdmFsdWUgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG50aWxlLnZhbHVlID0ge3JlYWQ6IHJlYWRWYWx1ZSwgd3JpdGU6IHdyaXRlVmFsdWV9O1xuXG5mdW5jdGlvbiByZWFkVmFsdWUocGJmLCBlbmQpIHtcbiAgICByZXR1cm4gcGJmLnJlYWRGaWVsZHMocmVhZFZhbHVlRmllbGQsIHt9LCBlbmQpO1xufVxuXG5mdW5jdGlvbiByZWFkVmFsdWVGaWVsZCh0YWcsIHZhbHVlLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAxKSB2YWx1ZS5zdHJpbmdfdmFsdWUgPSBwYmYucmVhZFN0cmluZygpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMikgdmFsdWUuZmxvYXRfdmFsdWUgPSBwYmYucmVhZEZsb2F0KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAzKSB2YWx1ZS5kb3VibGVfdmFsdWUgPSBwYmYucmVhZERvdWJsZSgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNCkgdmFsdWUuaW50X3ZhbHVlID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDUpIHZhbHVlLnVpbnRfdmFsdWUgPSBwYmYucmVhZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNikgdmFsdWUuc2ludF92YWx1ZSA9IHBiZi5yZWFkU1ZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNykgdmFsdWUuYm9vbF92YWx1ZSA9IHBiZi5yZWFkQm9vbGVhbigpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVZhbHVlKHZhbHVlLCBwYmYpIHtcbiAgICBpZiAodmFsdWUuc3RyaW5nX3ZhbHVlICE9PSB1bmRlZmluZWQpIHBiZi53cml0ZVN0cmluZ0ZpZWxkKDEsIHZhbHVlLnN0cmluZ192YWx1ZSk7XG4gICAgaWYgKHZhbHVlLmZsb2F0X3ZhbHVlICE9PSB1bmRlZmluZWQpIHBiZi53cml0ZUZsb2F0RmllbGQoMiwgdmFsdWUuZmxvYXRfdmFsdWUpO1xuICAgIGlmICh2YWx1ZS5kb3VibGVfdmFsdWUgIT09IHVuZGVmaW5lZCkgcGJmLndyaXRlRG91YmxlRmllbGQoMywgdmFsdWUuZG91YmxlX3ZhbHVlKTtcbiAgICBpZiAodmFsdWUuaW50X3ZhbHVlICE9PSB1bmRlZmluZWQpIHBiZi53cml0ZVZhcmludEZpZWxkKDQsIHZhbHVlLmludF92YWx1ZSk7XG4gICAgaWYgKHZhbHVlLnVpbnRfdmFsdWUgIT09IHVuZGVmaW5lZCkgcGJmLndyaXRlVmFyaW50RmllbGQoNSwgdmFsdWUudWludF92YWx1ZSk7XG4gICAgaWYgKHZhbHVlLnNpbnRfdmFsdWUgIT09IHVuZGVmaW5lZCkgcGJmLndyaXRlU1ZhcmludEZpZWxkKDYsIHZhbHVlLnNpbnRfdmFsdWUpO1xuICAgIGlmICh2YWx1ZS5ib29sX3ZhbHVlICE9PSB1bmRlZmluZWQpIHBiZi53cml0ZUJvb2xlYW5GaWVsZCg3LCB2YWx1ZS5ib29sX3ZhbHVlKTtcbn1cblxuLy8gZmVhdHVyZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbnRpbGUuZmVhdHVyZSA9IHtyZWFkOiByZWFkRmVhdHVyZSwgd3JpdGU6IHdyaXRlRmVhdHVyZX07XG5cbmZ1bmN0aW9uIHJlYWRGZWF0dXJlKHBiZiwgZW5kKSB7XG4gICAgdmFyIGZlYXR1cmUgPSBwYmYucmVhZEZpZWxkcyhyZWFkRmVhdHVyZUZpZWxkLCB7fSwgZW5kKTtcbiAgICBpZiAoZmVhdHVyZS50eXBlID09PSB1bmRlZmluZWQpIGZlYXR1cmUudHlwZSA9IFwiVW5rbm93blwiO1xuICAgIHJldHVybiBmZWF0dXJlO1xufVxuXG5mdW5jdGlvbiByZWFkRmVhdHVyZUZpZWxkKHRhZywgZmVhdHVyZSwgcGJmKSB7XG4gICAgaWYgKHRhZyA9PT0gMSkgZmVhdHVyZS5pZCA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAyKSBmZWF0dXJlLnRhZ3MgPSBwYmYucmVhZFBhY2tlZFZhcmludCgpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMykgZmVhdHVyZS50eXBlID0gcGJmLnJlYWRWYXJpbnQoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDQpIGZlYXR1cmUuZ2VvbWV0cnkgPSBwYmYucmVhZFBhY2tlZFZhcmludCgpO1xufVxuXG5mdW5jdGlvbiB3cml0ZUZlYXR1cmUoZmVhdHVyZSwgcGJmKSB7XG4gICAgaWYgKGZlYXR1cmUuaWQgIT09IHVuZGVmaW5lZCkgcGJmLndyaXRlVmFyaW50RmllbGQoMSwgZmVhdHVyZS5pZCk7XG4gICAgaWYgKGZlYXR1cmUudGFncyAhPT0gdW5kZWZpbmVkKSBwYmYud3JpdGVQYWNrZWRWYXJpbnQoMiwgZmVhdHVyZS50YWdzKTtcbiAgICBpZiAoZmVhdHVyZS50eXBlICE9PSB1bmRlZmluZWQpIHBiZi53cml0ZVZhcmludEZpZWxkKDMsIGZlYXR1cmUudHlwZSk7XG4gICAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCkgcGJmLndyaXRlUGFja2VkVmFyaW50KDQsIGZlYXR1cmUuZ2VvbWV0cnkpO1xufVxuXG4vLyBsYXllciA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbnRpbGUubGF5ZXIgPSB7cmVhZDogcmVhZExheWVyLCB3cml0ZTogd3JpdGVMYXllcn07XG5cbmZ1bmN0aW9uIHJlYWRMYXllcihwYmYsIGVuZCkge1xuICAgIHJldHVybiBwYmYucmVhZEZpZWxkcyhyZWFkTGF5ZXJGaWVsZCwge1wiZmVhdHVyZXNcIjogW10sIFwia2V5c1wiOiBbXSwgXCJ2YWx1ZXNcIjogW119LCBlbmQpO1xufVxuXG5mdW5jdGlvbiByZWFkTGF5ZXJGaWVsZCh0YWcsIGxheWVyLCBwYmYpIHtcbiAgICBpZiAodGFnID09PSAxNSkgbGF5ZXIudmVyc2lvbiA9IHBiZi5yZWFkVmFyaW50KCk7XG4gICAgZWxzZSBpZiAodGFnID09PSAxKSBsYXllci5uYW1lID0gcGJmLnJlYWRTdHJpbmcoKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDIpIGxheWVyLmZlYXR1cmVzLnB1c2gocmVhZEZlYXR1cmUocGJmLCBwYmYucmVhZFZhcmludCgpICsgcGJmLnBvcykpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gMykgbGF5ZXIua2V5cy5wdXNoKHBiZi5yZWFkU3RyaW5nKCkpO1xuICAgIGVsc2UgaWYgKHRhZyA9PT0gNCkgbGF5ZXIudmFsdWVzLnB1c2gocmVhZFZhbHVlKHBiZiwgcGJmLnJlYWRWYXJpbnQoKSArIHBiZi5wb3MpKTtcbiAgICBlbHNlIGlmICh0YWcgPT09IDUpIGxheWVyLmV4dGVudCA9IHBiZi5yZWFkVmFyaW50KCk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlTGF5ZXIobGF5ZXIsIHBiZikge1xuICAgIGlmIChsYXllci52ZXJzaW9uICE9PSB1bmRlZmluZWQpIHBiZi53cml0ZVZhcmludEZpZWxkKDE1LCBsYXllci52ZXJzaW9uKTtcbiAgICBpZiAobGF5ZXIubmFtZSAhPT0gdW5kZWZpbmVkKSBwYmYud3JpdGVTdHJpbmdGaWVsZCgxLCBsYXllci5uYW1lKTtcbiAgICB2YXIgaTtcbiAgICBpZiAobGF5ZXIuZmVhdHVyZXMgIT09IHVuZGVmaW5lZCkgZm9yIChpID0gMDsgaSA8IGxheWVyLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVNZXNzYWdlKDIsIHdyaXRlRmVhdHVyZSwgbGF5ZXIuZmVhdHVyZXNbaV0pO1xuICAgIGlmIChsYXllci5rZXlzICE9PSB1bmRlZmluZWQpIGZvciAoaSA9IDA7IGkgPCBsYXllci5rZXlzLmxlbmd0aDsgaSsrKSBwYmYud3JpdGVTdHJpbmdGaWVsZCgzLCBsYXllci5rZXlzW2ldKTtcbiAgICBpZiAobGF5ZXIudmFsdWVzICE9PSB1bmRlZmluZWQpIGZvciAoaSA9IDA7IGkgPCBsYXllci52YWx1ZXMubGVuZ3RoOyBpKyspIHBiZi53cml0ZU1lc3NhZ2UoNCwgd3JpdGVWYWx1ZSwgbGF5ZXIudmFsdWVzW2ldKTtcbiAgICBpZiAobGF5ZXIuZXh0ZW50ICE9PSB1bmRlZmluZWQpIHBiZi53cml0ZVZhcmludEZpZWxkKDUsIGxheWVyLmV4dGVudCk7XG59XG4iLCJ2YXIgYnVuZGxlRm4gPSBhcmd1bWVudHNbM107XG52YXIgc291cmNlcyA9IGFyZ3VtZW50c1s0XTtcbnZhciBjYWNoZSA9IGFyZ3VtZW50c1s1XTtcblxudmFyIHN0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgb3B0aW9ucykge1xuICAgIHZhciB3a2V5O1xuICAgIHZhciBjYWNoZUtleXMgPSBPYmplY3Qua2V5cyhjYWNoZSk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNhY2hlS2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGNhY2hlS2V5c1tpXTtcbiAgICAgICAgdmFyIGV4cCA9IGNhY2hlW2tleV0uZXhwb3J0cztcbiAgICAgICAgLy8gVXNpbmcgYmFiZWwgYXMgYSB0cmFuc3BpbGVyIHRvIHVzZSBlc21vZHVsZSwgdGhlIGV4cG9ydCB3aWxsIGFsd2F5c1xuICAgICAgICAvLyBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgZGVmYXVsdCBleHBvcnQgYXMgYSBwcm9wZXJ0eSBvZiBpdC4gVG8gZW5zdXJlXG4gICAgICAgIC8vIHRoZSBleGlzdGluZyBhcGkgYW5kIGJhYmVsIGVzbW9kdWxlIGV4cG9ydHMgYXJlIGJvdGggc3VwcG9ydGVkIHdlXG4gICAgICAgIC8vIGNoZWNrIGZvciBib3RoXG4gICAgICAgIGlmIChleHAgPT09IGZuIHx8IGV4cCAmJiBleHAuZGVmYXVsdCA9PT0gZm4pIHtcbiAgICAgICAgICAgIHdrZXkgPSBrZXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghd2tleSkge1xuICAgICAgICB3a2V5ID0gTWF0aC5mbG9vcihNYXRoLnBvdygxNiwgOCkgKiBNYXRoLnJhbmRvbSgpKS50b1N0cmluZygxNik7XG4gICAgICAgIHZhciB3Y2FjaGUgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYWNoZUtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gY2FjaGVLZXlzW2ldO1xuICAgICAgICAgICAgd2NhY2hlW2tleV0gPSBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlc1t3a2V5XSA9IFtcbiAgICAgICAgICAgIEZ1bmN0aW9uKFsncmVxdWlyZScsJ21vZHVsZScsJ2V4cG9ydHMnXSwgJygnICsgZm4gKyAnKShzZWxmKScpLFxuICAgICAgICAgICAgd2NhY2hlXG4gICAgICAgIF07XG4gICAgfVxuICAgIHZhciBza2V5ID0gTWF0aC5mbG9vcihNYXRoLnBvdygxNiwgOCkgKiBNYXRoLnJhbmRvbSgpKS50b1N0cmluZygxNik7XG5cbiAgICB2YXIgc2NhY2hlID0ge307IHNjYWNoZVt3a2V5XSA9IHdrZXk7XG4gICAgc291cmNlc1tza2V5XSA9IFtcbiAgICAgICAgRnVuY3Rpb24oWydyZXF1aXJlJ10sIChcbiAgICAgICAgICAgIC8vIHRyeSB0byBjYWxsIGRlZmF1bHQgaWYgZGVmaW5lZCB0byBhbHNvIHN1cHBvcnQgYmFiZWwgZXNtb2R1bGVcbiAgICAgICAgICAgIC8vIGV4cG9ydHNcbiAgICAgICAgICAgICd2YXIgZiA9IHJlcXVpcmUoJyArIHN0cmluZ2lmeSh3a2V5KSArICcpOycgK1xuICAgICAgICAgICAgJyhmLmRlZmF1bHQgPyBmLmRlZmF1bHQgOiBmKShzZWxmKTsnXG4gICAgICAgICkpLFxuICAgICAgICBzY2FjaGVcbiAgICBdO1xuXG4gICAgdmFyIHNyYyA9ICcoJyArIGJ1bmRsZUZuICsgJykoeydcbiAgICAgICAgKyBPYmplY3Qua2V5cyhzb3VyY2VzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShrZXkpICsgJzpbJ1xuICAgICAgICAgICAgICAgICsgc291cmNlc1trZXldWzBdXG4gICAgICAgICAgICAgICAgKyAnLCcgKyBzdHJpbmdpZnkoc291cmNlc1trZXldWzFdKSArICddJ1xuICAgICAgICAgICAgO1xuICAgICAgICB9KS5qb2luKCcsJylcbiAgICAgICAgKyAnfSx7fSxbJyArIHN0cmluZ2lmeShza2V5KSArICddKSdcbiAgICA7XG5cbiAgICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMIHx8IHdpbmRvdy5tb3pVUkwgfHwgd2luZG93Lm1zVVJMO1xuXG4gICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbc3JjXSwgeyB0eXBlOiAndGV4dC9qYXZhc2NyaXB0JyB9KTtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmJhcmUpIHsgcmV0dXJuIGJsb2I7IH1cbiAgICB2YXIgd29ya2VyVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJVcmwpO1xuICAgIGlmICh0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwod29ya2VyVXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmtlcjtcbn07XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAgIChmYWN0b3J5KChnbG9iYWwuV2hvb1RTID0gZ2xvYmFsLldob29UUyB8fCB7fSkpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuLyoqXG4gKiBnZXRVUkxcbiAqXG4gKiBAcGFyYW0gICAge1N0cmluZ30gIGJhc2VVcmwgIEJhc2UgdXJsIG9mIHRoZSBXTVMgc2VydmVyXG4gKiBAcGFyYW0gICAge1N0cmluZ30gIGxheWVyICAgIExheWVyIG5hbWVcbiAqIEBwYXJhbSAgICB7TnVtYmVyfSAgeCAgICAgICAgVGlsZSBjb29yZGluYXRlIHhcbiAqIEBwYXJhbSAgICB7TnVtYmVyfSAgeSAgICAgICAgVGlsZSBjb29yZGluYXRlIHlcbiAqIEBwYXJhbSAgICB7TnVtYmVyfSAgeiAgICAgICAgVGlsZSB6b29tXG4gKiBAcGFyYW0gICAge09iamVjdH0gIFtvcHRpb25zXVxuICogQHBhcmFtICAgIHtTdHJpbmd9ICBbb3B0aW9ucy5mb3JtYXQ9J2ltYWdlL3BuZyddXG4gKiBAcGFyYW0gICAge1N0cmluZ30gIFtvcHRpb25zLnNlcnZpY2U9J1dNUyddXG4gKiBAcGFyYW0gICAge1N0cmluZ30gIFtvcHRpb25zLnZlcnNpb249JzEuMS4xJ11cbiAqIEBwYXJhbSAgICB7U3RyaW5nfSAgW29wdGlvbnMucmVxdWVzdD0nR2V0TWFwJ11cbiAqIEBwYXJhbSAgICB7U3RyaW5nfSAgW29wdGlvbnMuc3JzPSdFUFNHOjM4NTcnXVxuICogQHBhcmFtICAgIHtOdW1iZXJ9ICBbb3B0aW9ucy53aWR0aD0nMjU2J11cbiAqIEBwYXJhbSAgICB7TnVtYmVyfSAgW29wdGlvbnMuaGVpZ2h0PScyNTYnXVxuICogQHJldHVybnMgIHtTdHJpbmd9ICB1cmxcbiAqIEBleGFtcGxlXG4gKiB2YXIgYmFzZVVybCA9ICdodHRwOi8vZ2VvZGF0YS5zdGF0ZS5uai51cy9pbWFnZXJ5d21zL05hdHVyYWwyMDE1JztcbiAqIHZhciBsYXllciA9ICdOYXR1cmFsMjAxNSc7XG4gKiB2YXIgdXJsID0gd2hvb3RzLmdldFVSTChiYXNlVXJsLCBsYXllciwgMTU0MzA4LCAxOTcxNjcsIDE5KTtcbiAqL1xuZnVuY3Rpb24gZ2V0VVJMKGJhc2VVcmwsIGxheWVyLCB4LCB5LCB6LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgdXJsID0gYmFzZVVybCArICc/JyArIFtcbiAgICAgICAgJ2Jib3g9JyAgICArIGdldFRpbGVCQm94KHgsIHksIHopLFxuICAgICAgICAnZm9ybWF0PScgICsgKG9wdGlvbnMuZm9ybWF0IHx8ICdpbWFnZS9wbmcnKSxcbiAgICAgICAgJ3NlcnZpY2U9JyArIChvcHRpb25zLnNlcnZpY2UgfHwgJ1dNUycpLFxuICAgICAgICAndmVyc2lvbj0nICsgKG9wdGlvbnMudmVyc2lvbiB8fCAnMS4xLjEnKSxcbiAgICAgICAgJ3JlcXVlc3Q9JyArIChvcHRpb25zLnJlcXVlc3QgfHwgJ0dldE1hcCcpLFxuICAgICAgICAnc3JzPScgICAgICsgKG9wdGlvbnMuc3JzIHx8ICdFUFNHOjM4NTcnKSxcbiAgICAgICAgJ3dpZHRoPScgICArIChvcHRpb25zLndpZHRoIHx8IDI1NiksXG4gICAgICAgICdoZWlnaHQ9JyAgKyAob3B0aW9ucy5oZWlnaHQgfHwgMjU2KSxcbiAgICAgICAgJ2xheWVycz0nICArIGxheWVyXG4gICAgXS5qb2luKCcmJyk7XG5cbiAgICByZXR1cm4gdXJsO1xufVxuXG5cbi8qKlxuICogZ2V0VGlsZUJCb3hcbiAqXG4gKiBAcGFyYW0gICAge051bWJlcn0gIHggIFRpbGUgY29vcmRpbmF0ZSB4XG4gKiBAcGFyYW0gICAge051bWJlcn0gIHkgIFRpbGUgY29vcmRpbmF0ZSB5XG4gKiBAcGFyYW0gICAge051bWJlcn0gIHogIFRpbGUgem9vbVxuICogQHJldHVybnMgIHtTdHJpbmd9ICBTdHJpbmcgb2YgdGhlIGJvdW5kaW5nIGJveFxuICovXG5mdW5jdGlvbiBnZXRUaWxlQkJveCh4LCB5LCB6KSB7XG4gICAgLy8gZm9yIEdvb2dsZS9PU00gdGlsZSBzY2hlbWUgd2UgbmVlZCB0byBhbHRlciB0aGUgeVxuICAgIHkgPSAoTWF0aC5wb3coMiwgeikgLSB5IC0gMSk7XG5cbiAgICB2YXIgbWluID0gZ2V0TWVyY0Nvb3Jkcyh4ICogMjU2LCB5ICogMjU2LCB6KSxcbiAgICAgICAgbWF4ID0gZ2V0TWVyY0Nvb3JkcygoeCArIDEpICogMjU2LCAoeSArIDEpICogMjU2LCB6KTtcblxuICAgIHJldHVybiBtaW5bMF0gKyAnLCcgKyBtaW5bMV0gKyAnLCcgKyBtYXhbMF0gKyAnLCcgKyBtYXhbMV07XG59XG5cblxuLyoqXG4gKiBnZXRNZXJjQ29vcmRzXG4gKlxuICogQHBhcmFtICAgIHtOdW1iZXJ9ICB4ICBQaXhlbCBjb29yZGluYXRlIHhcbiAqIEBwYXJhbSAgICB7TnVtYmVyfSAgeSAgUGl4ZWwgY29vcmRpbmF0ZSB5XG4gKiBAcGFyYW0gICAge051bWJlcn0gIHogIFRpbGUgem9vbVxuICogQHJldHVybnMgIHtBcnJheX0gICBbeCwgeV1cbiAqL1xuZnVuY3Rpb24gZ2V0TWVyY0Nvb3Jkcyh4LCB5LCB6KSB7XG4gICAgdmFyIHJlc29sdXRpb24gPSAoMiAqIE1hdGguUEkgKiA2Mzc4MTM3IC8gMjU2KSAvIE1hdGgucG93KDIsIHopLFxuICAgICAgICBtZXJjX3ggPSAoeCAqIHJlc29sdXRpb24gLSAyICogTWF0aC5QSSAgKiA2Mzc4MTM3IC8gMi4wKSxcbiAgICAgICAgbWVyY195ID0gKHkgKiByZXNvbHV0aW9uIC0gMiAqIE1hdGguUEkgICogNjM3ODEzNyAvIDIuMCk7XG5cbiAgICByZXR1cm4gW21lcmNfeCwgbWVyY195XTtcbn1cblxuZXhwb3J0cy5nZXRVUkwgPSBnZXRVUkw7XG5leHBvcnRzLmdldFRpbGVCQm94ID0gZ2V0VGlsZUJCb3g7XG5leHBvcnRzLmdldE1lcmNDb29yZHMgPSBnZXRNZXJjQ29vcmRzO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7IiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJtYXBib3gtZ2xcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkEgV2ViR0wgaW50ZXJhY3RpdmUgbWFwcyBsaWJyYXJ5XCIsXG4gIFwidmVyc2lvblwiOiBcIjAuMjIuMVwiLFxuICBcIm1haW5cIjogXCJqcy9tYXBib3gtZ2wuanNcIixcbiAgXCJsaWNlbnNlXCI6IFwiQlNELTMtQ2xhdXNlXCIsXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQ6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanMuZ2l0XCJcbiAgfSxcbiAgXCJlbmdpbmVzXCI6IHtcbiAgICBcIm5vZGVcIjogXCI+PTQuMC4wXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiY3NzY29sb3JwYXJzZXJcIjogXCJeMS4wLjJcIixcbiAgICBcImVhcmN1dFwiOiBcIl4yLjAuM1wiLFxuICAgIFwiZmVhdHVyZS1maWx0ZXJcIjogXCJeMi4yLjBcIixcbiAgICBcImdlb2pzb24tcmV3aW5kXCI6IFwiXjAuMS4wXCIsXG4gICAgXCJnZW9qc29uLXZ0XCI6IFwiXjIuNC4wXCIsXG4gICAgXCJnbC1tYXRyaXhcIjogXCJeMi4zLjFcIixcbiAgICBcImdyaWQtaW5kZXhcIjogXCJeMS4wLjBcIixcbiAgICBcIm1hcGJveC1nbC1mdW5jdGlvblwiOiBcIl4xLjIuMVwiLFxuICAgIFwibWFwYm94LWdsLXNoYWRlcnNcIjogXCJtYXBib3gvbWFwYm94LWdsLXNoYWRlcnMjZGYxNjI0NzY5ODBkOWVlMmFiNmY4ZDBjZjVhMDZlMjdhYWM2MDQ3MlwiLFxuICAgIFwibWFwYm94LWdsLXN0eWxlLXNwZWNcIjogXCJtYXBib3gvbWFwYm94LWdsLXN0eWxlLXNwZWMjODNiMWEzZTU4MzdkNzg1YWY1ODJlZmQ1ZWQxYTIxMmYyZGY2YTRhZVwiLFxuICAgIFwibWFwYm94LWdsLXN1cHBvcnRlZFwiOiBcIl4xLjIuMFwiLFxuICAgIFwicGJmXCI6IFwiXjEuMy4yXCIsXG4gICAgXCJwbmdqc1wiOiBcIl4yLjIuMFwiLFxuICAgIFwicG9pbnQtZ2VvbWV0cnlcIjogXCJeMC4wLjBcIixcbiAgICBcInF1aWNrc2VsZWN0XCI6IFwiXjEuMC4wXCIsXG4gICAgXCJyZXF1ZXN0XCI6IFwiXjIuMzkuMFwiLFxuICAgIFwicmVzb2x2ZS11cmxcIjogXCJeMC4yLjFcIixcbiAgICBcInNoZWxmLXBhY2tcIjogXCJeMS4wLjBcIixcbiAgICBcInN1cGVyY2x1c3RlclwiOiBcIl4yLjAuMVwiLFxuICAgIFwidGlueXF1ZXVlXCI6IFwiXjEuMS4wXCIsXG4gICAgXCJ1bmFzc2VydGlmeVwiOiBcIl4yLjAuMFwiLFxuICAgIFwidW5pdGJlemllclwiOiBcIl4wLjAuMFwiLFxuICAgIFwidmVjdG9yLXRpbGVcIjogXCJeMS4zLjBcIixcbiAgICBcInZ0LXBiZlwiOiBcIl4yLjAuMlwiLFxuICAgIFwid2Vid29ya2lmeVwiOiBcIl4xLjMuMFwiLFxuICAgIFwid2hvb3RzLWpzXCI6IFwiXjIuMC4wXCJcbiAgfSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYmFiZWwtcHJlc2V0LXJlYWN0XCI6IFwiXjYuMTEuMVwiLFxuICAgIFwiYmFiZWxpZnlcIjogXCJeNy4zLjBcIixcbiAgICBcImJlbmNobWFya1wiOiBcIn4yLjEuMFwiLFxuICAgIFwiYnJvd3NlcmlmeVwiOiBcIl4xMy4wLjBcIixcbiAgICBcImNsaXBib2FyZFwiOiBcIl4xLjUuMTJcIixcbiAgICBcImNvbmNhdC1zdHJlYW1cIjogXCIxLjUuMVwiLFxuICAgIFwiY292ZXJhbGxzXCI6IFwiXjIuMTEuOFwiLFxuICAgIFwiZG9jdHJpbmVcIjogXCJeMS4yLjFcIixcbiAgICBcImRvY3VtZW50YXRpb25cIjogXCJodHRwczovL2dpdGh1Yi5jb20vZG9jdW1lbnRhdGlvbmpzL2RvY3VtZW50YXRpb24vYXJjaGl2ZS9iYjQxNjE5YzczNGU1OWVmM2ZiYzM2NDg2MTAwMzJlZmNmZGFhYWNlLnRhci5nelwiLFxuICAgIFwiZG9jdW1lbnRhdGlvbi10aGVtZS11dGlsc1wiOiBcIjMuMC4wXCIsXG4gICAgXCJlbnZpZnlcIjogXCJeMy40LjBcIixcbiAgICBcImVzbGludFwiOiBcIl4zLjMuMVwiLFxuICAgIFwiZXNsaW50LWNvbmZpZy1tb3VybmVyXCI6IFwiXjIuMC4wXCIsXG4gICAgXCJlc2xpbnQtcGx1Z2luLWh0bWxcIjogXCJeMS41LjFcIixcbiAgICBcImdsXCI6IFwiXjQuMC4xXCIsXG4gICAgXCJoYW5kbGViYXJzXCI6IFwiNC4wLjVcIixcbiAgICBcImhpZ2hsaWdodC5qc1wiOiBcIjkuMy4wXCIsXG4gICAgXCJpc3RhbmJ1bFwiOiBcIl4wLjQuMlwiLFxuICAgIFwianNvbi1sb2FkZXJcIjogXCJeMC41LjRcIixcbiAgICBcImxvZGFzaFwiOiBcIl40LjEzLjFcIixcbiAgICBcIm1hcGJveC1nbC10ZXN0LXN1aXRlXCI6IFwibWFwYm94L21hcGJveC1nbC10ZXN0LXN1aXRlIzNlMzZiMTkzYTBjNDQyYTNmZDg2MzExOWYxMDFhZmE2ZGI5N2IzMmRcIixcbiAgICBcIm1lbW9yeS1mc1wiOiBcIl4wLjMuMFwiLFxuICAgIFwibWluaWZ5aWZ5XCI6IFwiXjcuMC4xXCIsXG4gICAgXCJucG0tcnVuLWFsbFwiOiBcIl4zLjAuMFwiLFxuICAgIFwibnljXCI6IFwiNi40LjBcIixcbiAgICBcInByb3h5cXVpcmVcIjogXCJeMS43LjlcIixcbiAgICBcInJlbWFya1wiOiBcIjQuMi4yXCIsXG4gICAgXCJyZW1hcmstaHRtbFwiOiBcIjMuMC4wXCIsXG4gICAgXCJzaW5vblwiOiBcIl4xLjE1LjRcIixcbiAgICBcInN0XCI6IFwiXjEuMi4wXCIsXG4gICAgXCJ0YXBcIjogXCJeNS43LjBcIixcbiAgICBcInRyYW5zZm9ybS1sb2FkZXJcIjogXCJeMC4yLjNcIixcbiAgICBcInVuaXN0LXV0aWwtdmlzaXRcIjogXCIxLjEuMFwiLFxuICAgIFwidmlueWxcIjogXCIxLjEuMVwiLFxuICAgIFwidmlueWwtZnNcIjogXCIyLjQuM1wiLFxuICAgIFwid2F0Y2hpZnlcIjogXCJeMy43LjBcIixcbiAgICBcIndlYnBhY2tcIjogXCJeMS4xMy4xXCIsXG4gICAgXCJ3ZWJ3b3JraWZ5LXdlYnBhY2tcIjogXCJeMS4xLjNcIlxuICB9LFxuICBcImJyb3dzZXJcIjoge1xuICAgIFwiLi9qcy91dGlsL2FqYXguanNcIjogXCIuL2pzL3V0aWwvYnJvd3Nlci9hamF4LmpzXCIsXG4gICAgXCIuL2pzL3V0aWwvYnJvd3Nlci5qc1wiOiBcIi4vanMvdXRpbC9icm93c2VyL2Jyb3dzZXIuanNcIixcbiAgICBcIi4vanMvdXRpbC9jYW52YXMuanNcIjogXCIuL2pzL3V0aWwvYnJvd3Nlci9jYW52YXMuanNcIixcbiAgICBcIi4vanMvdXRpbC9kb20uanNcIjogXCIuL2pzL3V0aWwvYnJvd3Nlci9kb20uanNcIixcbiAgICBcIi4vanMvdXRpbC93ZWJfd29ya2VyLmpzXCI6IFwiLi9qcy91dGlsL2Jyb3dzZXIvd2ViX3dvcmtlci5qc1wiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJidWlsZC1kZXZcIjogXCJicm93c2VyaWZ5IGpzL21hcGJveC1nbC5qcyAtLWRlYnVnIC0tc3RhbmRhbG9uZSBtYXBib3hnbCA+IGRpc3QvbWFwYm94LWdsLWRldi5qcyAmJiB0YXAgLS1uby1jb3ZlcmFnZSB0ZXN0L2J1aWxkL2Rldi50ZXN0LmpzXCIsXG4gICAgXCJ3YXRjaC1kZXZcIjogXCJ3YXRjaGlmeSBqcy9tYXBib3gtZ2wuanMgLS1kZWJ1ZyAtLXN0YW5kYWxvbmUgbWFwYm94Z2wgLS1vdXRmaWxlIGRpc3QvbWFwYm94LWdsLWRldi5qcyAtLXZlcmJvc2VcIixcbiAgICBcImJ1aWxkLW1pblwiOiBcImJyb3dzZXJpZnkganMvbWFwYm94LWdsLmpzIC0tZGVidWcgLS10cmFuc2Zvcm0gdW5hc3NlcnRpZnkgLS1wbHVnaW4gW21pbmlmeWlmeSAtLW1hcCBtYXBib3gtZ2wuanMubWFwIC0tb3V0cHV0IGRpc3QvbWFwYm94LWdsLmpzLm1hcF0gLS1zdGFuZGFsb25lIG1hcGJveGdsID4gZGlzdC9tYXBib3gtZ2wuanMgJiYgdGFwIC0tbm8tY292ZXJhZ2UgdGVzdC9idWlsZC9taW4udGVzdC5qc1wiLFxuICAgIFwiYnVpbGQtdG9rZW5cIjogXCJicm93c2VyaWZ5IGRlYnVnL2FjY2Vzcy10b2tlbi5qcyAtLWRlYnVnIC0tdHJhbnNmb3JtIGVudmlmeSA+IGRlYnVnL2FjY2Vzcy10b2tlbi1nZW5lcmF0ZWQuanNcIixcbiAgICBcIndhdGNoLWJlbmNoXCI6IFwibm9kZSBiZW5jaC9kb3dubG9hZC1kYXRhLmpzICYmIHdhdGNoaWZ5IGJlbmNoL2luZGV4LmpzIC0tcGx1Z2luIFttaW5pZnlpZnkgLS1uby1tYXBdIC0tdHJhbnNmb3JtIFtiYWJlbGlmeSAtLXByZXNldHMgcmVhY3RdIC0tdHJhbnNmb3JtIHVuYXNzZXJ0aWZ5IC0tdHJhbnNmb3JtIGVudmlmeSAtLW91dGZpbGUgYmVuY2gvaW5kZXgtZ2VuZXJhdGVkLmpzIC0tdmVyYm9zZVwiLFxuICAgIFwic3RhcnQtc2VydmVyXCI6IFwic3QgLS1uby1jYWNoZSAtLWxvY2FsaG9zdCAtLXBvcnQgOTk2NiAtLWluZGV4IGluZGV4Lmh0bWwgLlwiLFxuXG4gICAgXCJzdGFydFwiOiBcInJ1bi1wIGJ1aWxkLXRva2VuIHdhdGNoLWRldiB3YXRjaC1iZW5jaCBzdGFydC1zZXJ2ZXJcIixcbiAgICBcInN0YXJ0LWRlYnVnXCI6IFwicnVuLXAgYnVpbGQtdG9rZW4gd2F0Y2gtZGV2IHN0YXJ0LXNlcnZlclwiLFxuICAgIFwic3RhcnQtYmVuY2hcIjogXCJydW4tcCBidWlsZC10b2tlbiB3YXRjaC1iZW5jaCBzdGFydC1zZXJ2ZXJcIixcblxuICAgIFwiYnVpbGQtZG9jc1wiOiBcImRvY3VtZW50YXRpb24gYnVpbGQgLS1naXRodWIgLS1mb3JtYXQgaHRtbCAtLWNvbmZpZyBkb2N1bWVudGF0aW9uLnltbCAtLXRoZW1lIC4vZG9jcy9fdGhlbWUgLS1vdXRwdXQgZG9jcy9hcGkvXCIsXG4gICAgXCJidWlsZFwiOiBcIm5wbSBydW4gYnVpbGQtZG9jcyAjIGludm9rZWQgYnkgcHVibGlzaGVyIHdoZW4gcHVibGlzaGluZyBkb2NzIG9uIHRoZSBtYi1wYWdlcyBicmFuY2hcIixcbiAgICBcInN0YXJ0LWRvY3NcIjogXCJucG0gcnVuIGJ1aWxkLW1pbiAmJiBucG0gcnVuIGJ1aWxkLWRvY3MgJiYgamVreWxsIHNlcnZlIC0td2F0Y2hcIixcblxuICAgIFwibGludFwiOiBcImVzbGludCAgLS1pZ25vcmUtcGF0aCAuZ2l0aWdub3JlIGpzIHRlc3QgYmVuY2ggZG9jcy9fcG9zdHMvZXhhbXBsZXMvKi5odG1sXCIsXG4gICAgXCJvcGVuLWNoYW5nZWQtZXhhbXBsZXNcIjogXCJnaXQgZGlmZiAtLW5hbWUtb25seSBtYi1wYWdlcyBIRUFEIC0tIGRvY3MvX3Bvc3RzL2V4YW1wbGVzLyouaHRtbCB8IGF3ayAne3ByaW50IFxcXCJodHRwOi8vMTI3LjAuMC4xOjQwMDAvbWFwYm94LWdsLWpzL2V4YW1wbGUvXFxcIiBzdWJzdHIoJDAsMzMsbGVuZ3RoKCQwKS0zNyl9JyB8IHhhcmdzIG9wZW5cIixcbiAgICBcInRlc3Qtc3VpdGVcIjogXCJub2RlIHRlc3QvcmVuZGVyLnRlc3QuanMgJiYgbm9kZSB0ZXN0L3F1ZXJ5LnRlc3QuanNcIixcbiAgICBcInRlc3RcIjogXCJucG0gcnVuIGxpbnQgJiYgdGFwIC0tcmVwb3J0ZXIgZG90IHRlc3QvanMvKi8qLmpzIHRlc3QvYnVpbGQvd2VicGFjay50ZXN0LmpzXCJcbiAgfVxufVxuIl19
